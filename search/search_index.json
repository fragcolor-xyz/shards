{"config":{"lang":["en"],"separator":"[\\s\\-\\.\\`]","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#welcome-to-fragcolor-documentation","title":"Welcome to Fragcolor documentation!","text":"<p>Here at Fragcolor, we're passionate about the potential of technology to change the way we interact with the world around us.</p> <p>We believe that we're on the brink of a major revolution, where traditional interfaces will be replaced by more flexible and intuitive virtual interfaces that can be seamlessly integrated into the user's environment.</p> <p>To make this vision a reality, we're dedicated to creating programming tools that will empower developers to build the future.</p> <p></p> <p> Ready to step into the world of Fragcolor? </p> <p>Download</p> <p></p> Getting Started Shards Rare Engine <p> </p> <p>Built on Oct 24, 2024 at 21:08:41 from commit 9f51be4.</p>"},{"location":"contribute/","title":"Index","text":""},{"location":"contribute/#contribute","title":"Contribute","text":"<p>Fragcolor is a community-driven organization that thrives on collaboration and innovation. We have a bunch of exciting projects that are open to community contributions, and we would love for you to get involved!</p> <p>If you're interested in contributing to our projects, we've put together a guide that will help you get started. The guide will walk you through the process of setting up your development environment, which is the software and tools you'll need to work on our projects.</p> <p>Once you're set up, the guide will take you through your first contribution. This could be code or documentation \u2013 whatever you're most comfortable with. We'll explain the process and show you how to make your contribution, so you can get a feel for how things work.</p> <p>Contributing to open source projects like ours is a great way to learn new skills, build your portfolio, and connect with other developers. Plus, you'll be making a meaningful contribution to a project that could revolutionize the game development scene.</p> <p>If you're ready to get started, check out our guide and dive in!</p> <p> </p>"},{"location":"contribute/contributing-changes/","title":"Contributing changes","text":"<p>Fragcolor documentation exists under the /docs folder of the Shards repository.</p> <p>This guide will get you started with contributing documentation changes to Fragcolor projects. We'll use the GitHub Desktop (GD) to deal with git as GD is easier to use than the git command line.</p> <p>Also, all these steps are valid for code contributions too.</p> <p>For comprehensive coverage of git/ GitHub workflow, check out GitHub's excellent Quickstart Tutorial.</p>"},{"location":"contribute/contributing-changes/#cloning-the-repository","title":"Cloning the Repository","text":"<p>To begin, you'll need a copy of the project's repository on your local machine.</p> <p>Go to the repository's GitHub page. Click the 'Code' button on the right, select HTTPS (under the heading 'Clone'), and copy the git repository path.</p> <p></p> <p>Open GD and choose the option 'Clone a repository from the Internet...'</p> <p></p> <p>Choose the 3rd tab (URL) on the window that opens, and paste the copied git repository URL in the first input box.</p> <p>The second input box is the local path where git will clone your repository. You can change this as desired.</p> <p></p> <p>Cloning might take a couple of minutes (depending on the size of the repository). After it completes, you'll be able to view the repository files on your local system.</p> <p></p>"},{"location":"contribute/contributing-changes/#create-a-branch","title":"Create a branch","text":"<p>You will need to create a new branch from the main/ default branch to hold your changes.</p> <p>Never work on the main branch of the repository; always create a new branch for your changes.</p> <p>You can create a new branch using GD. Click the 'Current Branch' dropdown to show the available branches for this repository. Now click on 'New Branch' button on the right-hand side.</p> <p></p> <p>A modal will pop up asking for the new branch's name. This modal also explains on what branch is this new branch based. Ensure that the source branch is the default branch of the repository. In this case, it's 'develop'.</p> <p>Click on 'Create Branch'.</p> <p></p> <p>Publish this local branch to the project's remote (from where we cloned the repository).</p> <p></p> <p>If you don't have write access to a project repository, you can't push your changes to it. So, GD will ask you to fork (create a copy of) the target repository instead. Forking will put a copy of the original repository in your GitHub account. You can now push your local branch/ changes to this fork repository in your GitHub account. Fork the repository.</p> <p></p> <p>After forking, choose 'To contribute to the parent project' option.</p> <p></p> <p>Publish the new branch to your fork repository.</p> <p></p> <p>On GD, you will now be able to see uncommitted changes (if any) in your local branch.</p> <p></p>"},{"location":"contribute/contributing-changes/#make-test-changes","title":"Make &amp; test changes","text":"<p>Run all terminal commands from the project folder that contains <code>MkDocs.yml</code>. For the Shards repository, this folder is <code>...shards/docs</code>).</p> <p>MkDocs can build and serve the documentation website locally while you're making changes. The served pages reflect your documentation changes in real-time (also called hot reloading).</p> <p>Before starting the MkDocs live-preview server, we need to install the required plugins.</p> <p>MkDocs plugins get registered in the <code>MkDocs.yml</code> file against the keyword 'plugins'. Here, we have only one plugin: awesome-pages.</p> <p></p> <p>Install MkDocs plugins using the <code>pip install mkdocs-awesome-pages-plugin</code> command from the terminal.</p> Command <p></p> <p>Start the MkDocs live-preview server with the <code>mkdocs serve</code> command. Once the server is running, the terminal will display the locally served website's URL path.</p> CommandResult <p></p> <p></p> <p>Navigate to this path in your local browser to access the served site.</p> <p></p> <p>Now we're ready to make some changes!</p> <p>As an exercise, let's change the case of the header's title text. Change 'Fragcolor documentation' (sentence case) to 'Fragcolor Documentation' (title case). Save the edit.</p> <p>Before the change: </p> <p>After the change: </p> <p>And now, let's go to our local URL to preview this change.</p> <p></p>"},{"location":"contribute/contributing-changes/#commit-push-changes","title":"Commit &amp; push changes","text":"<p>GD will now show a summary of changes in this new local branch.</p> <p>Pink color highlights (marked with <code>-</code>) denote deleted lines. Blue color highlights (marked with <code>+</code>) denote added lines.</p> <p></p> <p>Commit (save) your changes to the local repository branch.</p> <p>To commit, click the 'Commit to LOCAL-REPO-NAME' in the bottom left-hand corner of GD.</p> <p></p> <p>GD will ask you to add a summary (commit message) and a description of the changes.</p> <p>Add the commit message summary/ description and click on the 'Commit to ...' button below these fields. This commit saves the changes to your new branch locally (in your fork).</p> <p>Now, click on the 'Push origin' button on the right-hand side. This action pushes your branch's local commits to your fork on GitHub (i.e., the origin remote).</p> <p></p> <p>At this point, GD will show that no local changes exist. This is because there are no outstanding changes on our local that need to be pushed to remote origin.</p> <p>GD will now prompt you to raise a Pull Request.</p> <p></p> <p>You'll see the same message/ prompt on the GitHub page of your (forked) remote origin repository.</p> <p></p> <p>You can start the process of raising a PR from either GD or GitHub website. In either case, you'll end up on the GitHub website's PR page, as explained in the next section.</p>"},{"location":"contribute/contributing-changes/#raise-a-pull-request","title":"Raise a pull request","text":"<p>A Pull Request (or PR) merges/ combines the changes of the PR branch into the target (main) branch.</p> <p>PRs may be raised between branches of the same repository from a fork to the original repository. Here we are dealing with the latter.</p> <p>Raise a PR by clicking 'Create Pull Request' in GD. Or, you can click 'Compare &amp; pull request' on your branch/ repository's GitHub page. In both cases, you'll end up on the 'Open a pull request' page on GitHub.</p> <p>Fill in the PR title and message. Then click the 'Create pull request' button on the bottom right-hand corner. This action will create a Pull Request and route it to a reviewer.</p> <p></p> <p>Every PR gets a unique URL. This URL tracks the review discussion between the contributor and the reviewer(s). It also has details like files changed, commit messages, etc.</p> <p></p> <p>Every PR gets routed to a reviewer or a maintainer (of that repository) for a review. If the reviewer agrees with the changes, they'll approve and merge the PR into the target branch. If they need further changes, they will discuss via the comments section in the PR.</p> <p>It's a good practice to delete your branches for merged/ closed PRs.</p> <p> </p>"},{"location":"contribute/getting-started/","title":"Getting Started","text":"<p>Note</p> <p>This guide assists in setting up the development environment for our projects.</p> <p>For an overview, click here.</p>"},{"location":"contribute/getting-started/#setting-up-the-cc-compiler","title":"Setting up the C/C++ Compiler","text":""},{"location":"contribute/getting-started/#macos","title":"macOS","text":"<ol> <li>Install Xcode from the Mac App Store. This includes the Xcode IDE, Git, and necessary compilers.</li> <li>Open Terminal and install the necessary command line tools with:     <pre><code>xcode-select --install\n</code></pre></li> <li>Install Homebrew, a package manager for macOS, with the following command:     <pre><code>/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n</code></pre></li> <li>Use Homebrew to install additional tools:     <pre><code>brew install cmake ninja llvm\n</code></pre></li> <li>Verify the installation of each tool by running <code>cmake --version</code>, <code>ninja --version</code>, and <code>llvm-config --version</code>.</li> </ol>"},{"location":"contribute/getting-started/#windows","title":"Windows","text":"<ol> <li>Open Command Prompt.</li> <li>Install Chocolatey by following the instructions at Chocolatey Installation.</li> <li> <p>Install the compiler and build tools:     <pre><code>choco install -y cmake --installargs '\"ADD_CMAKE_TO_PATH=System\"'\nchoco install -y ninja\nchoco install -y llvm\nrefreshenv\n</code></pre></p> <p>To install <code>cmake</code> for the current user only, replace <code>System</code> with <code>User</code>.</p> </li> <li> <p>Verify the installation:</p> <ul> <li>For <code>cmake</code>, <code>ninja</code>, and <code>clang</code>, run:     <pre><code>cmake --version\nninja --version\nclang --version\n</code></pre></li> <li>If any command returns an error, check the <code>PATH</code> environment variable.</li> </ul> </li> </ol>"},{"location":"contribute/getting-started/#linux","title":"Linux","text":"<p>Install <code>cmake</code>, <code>ninja</code>, <code>clang</code>, and other development dependencies using your distribution's package manager. For Ubuntu: <pre><code>sudo apt install build-essential cmake ninja-build clang xorg-dev libdbus-1-dev libssl-dev mesa-utils\n</code></pre></p>"},{"location":"contribute/getting-started/#rust","title":"Rust","text":"<p>Install Rust from Rust Installation.</p>"},{"location":"contribute/getting-started/#common-instructions-for-windows-linux-and-macos","title":"Common Instructions for Windows, Linux, and macOS","text":"<ol> <li>Verify the Rust installation with <code>cargo --version</code>.</li> <li>Install the nightly version of Rust if required by your project:     <pre><code>rustup toolchain install nightly\nrustup +nightly target add &lt;target-architecture&gt;\n</code></pre>     Replace <code>&lt;target-architecture&gt;</code> with your system's architecture (e.g., <code>x86_64-pc-windows-msvc</code> for Windows, <code>x86_64-unknown-linux-gnu</code> for Linux).</li> <li>For web browser support, run:     <pre><code>rustup +nightly target add wasm32-unknown-unknown\n</code></pre></li> <li>Regularly update Rust using <code>rustup update</code>.</li> </ol>"},{"location":"contribute/getting-started/#using-a-specific-nightly-version-if-needed","title":"Using a specific nightly version if needed","text":"<p>Before building the project, ensure that you are using the correct version of the Rust toolchain as specified in the project's <code>rust.version</code> file. This file is located in the root directory of the project if a specific version is required.</p> <ol> <li>Navigate to the project's root directory.</li> <li>Install the specific Rust toolchain version required by the project:     <pre><code>cat rust.version | xargs rustup toolchain install\n</code></pre></li> <li>Set the installed toolchain as the default for the current project:     <pre><code>cat rust.version | xargs rustup override set\n</code></pre></li> </ol> <p>Now, proceed with the project-specific build instructions.</p>"},{"location":"contribute/getting-started/#git-github","title":"Git &amp; GitHub","text":"<p>Git is a distributed version control system essential for managing project codebases.</p>"},{"location":"contribute/getting-started/#macos_1","title":"macOS","text":"<p>If not already installed with Xcode, install Git using Homebrew: <pre><code>brew install git\n</code></pre></p>"},{"location":"contribute/getting-started/#windows_1","title":"Windows","text":"<p>Use Chocolatey for installation: <pre><code>choco install -y git\n</code></pre></p>"},{"location":"contribute/getting-started/#linux_1","title":"Linux","text":"<p>Install Git using: <pre><code>sudo apt install git\n</code></pre></p>"},{"location":"contribute/getting-started/#code-editor","title":"Code Editor","text":"<p>We recommend Visual Studio Code (VS Code) for this tutorial.</p> <p>Download and install VS Code from VS Code Download</p>"},{"location":"contribute/getting-started/#vs-code-extensions","title":"VS Code Extensions","text":"<p>Install the following extensions to enhance your development experience:</p> <ol> <li>C/C++</li> <li>rust-analyzer</li> <li>CodeLLDB</li> <li>Better TOML</li> <li>CMake Tools</li> <li>YAML</li> <li>Fragcolor Shards - Direct link to the Fragcolor Shards extension on the VS Code Marketplace.</li> </ol>"},{"location":"contribute/getting-started/#overview","title":"Overview","text":"<p>Here is a quick overview of the setup process for Windows and Linux. Refer to the respective sections above for detailed instructions.</p>"},{"location":"contribute/getting-started/#macos_2","title":"macOS","text":"<ol> <li>Install Xcode and command line tools.</li> <li>Install Homebrew.</li> <li>Install <code>cmake</code>, <code>ninja</code>, and <code>llvm</code> using Homebrew.</li> <li>Install Rust and set up the nightly build.</li> <li>Install the Rust Web Assembly toolchain.</li> <li>Regularly update Rust.</li> <li>Install Git using Homebrew.</li> <li>Install VS Code and the recommended extensions.</li> </ol>"},{"location":"contribute/getting-started/#windows_2","title":"Windows","text":"<ol> <li>Install Chocolatey.</li> <li>Install <code>cmake</code>, <code>ninja</code>, and <code>llvm</code> with Chocolatey.</li> <li>Install Rust and set up the nightly build.</li> <li>Install the Rust Web Assembly toolchain.</li> <li>Regularly update Rust.</li> <li>Install Git and a Git GUI Client.</li> <li>Install VS Code and the recommended extensions.</li> </ol>"},{"location":"contribute/getting-started/#linux_2","title":"Linux","text":"<ol> <li>Install development dependencies including <code>cmake</code>, <code>ninja</code>, and <code>clang</code>.</li> <li>Install Rust and set up the nightly build.</li> <li>Install the Rust Web Assembly toolchain.</li> <li>Regularly update Rust.</li> <li>Install Git.</li> <li>Install VS Code and the recommended extensions.</li> </ol>"},{"location":"contribute/code/","title":"Projects","text":"<p>The Fragcolor ecosystem has a few primary components.</p> <ul> <li>Shards Shards programming language</li> </ul> <p>To contribute code to any of the above projects, you will need to ready your development environment.</p> <p>Once done, you can check out the guides on how to build and run Shards.</p> <p> </p>"},{"location":"contribute/code/build-shards/","title":"Build Shards","text":"<p>Note</p> <p>This guide is for new users unfamiliar with the Shards building process. </p> <p>Click here to skip the tutorial and jump to the overview.</p> <p>Curious about the inner workings of Shards? Build Shards to unlock its hidden magics, and gain access to infinite creative possibilities! \u2728 </p> <p>Do ensure that you have your development environment readied before embarking on the quest to build Shards!</p>"},{"location":"contribute/code/build-shards/#cloning-the-shards-repository","title":"Cloning the Shards Repository","text":"<p>Go to the Shard\u2019s repository on Github. If you have GitHub for Desktop installed, select the \u201cCode\u201d button, and \u201cOpen with GitHub Desktop\u201d to clone the repository. </p> <p></p> \"Open with GitHub Desktop\" Error <p>If \u201cOpen with GitHub Desktop\u201d does not work, you can instead copy the HTTPS link. </p> <p></p> <p>In GitHub Desktop, select the option to \u201cClone a Repository\u201d (Ctrl+Shift+O). </p> <p>Click on the \u201cURL\u201d tab, paste the HTTPS link and select \u201cClone\u201d. </p> <p></p> <p>The repository is now cloned to your computer! Take note of where it has been cloned to, as we will be using it in the following step\u2026</p>"},{"location":"contribute/code/build-shards/#navigating-to-the-shards-repository","title":"Navigating to the Shards Repository","text":"<p>Open up Git Bash.</p> Tip <p>You can use the Windows Search Bar to find the Git Bash application.</p> <p>Navigate to where your Shards repository is located using the command <code>cd $(cygpath -u '(X)')</code>, where (X) is the directory of your folder.</p> cd <p>The <code>cd</code> command is used for navigating to different directories within the terminal.</p> cygpath <p>The Git Bash terminal requires you to convert the backslashes(\\) in your directory address to forward slashes(/). You will also have to remove the colon(:) after the drive alphabet. </p> <p>This is the Unix form of an address and can be done automatically by using the cygpath program.</p> <p>e.g. <code>cygpath -u 'C:\\Projects\\Shards'</code> will output <code>/c/Projects/Shards</code></p> <p>If your Shards repository is located at <code>C:\\Projects\\Shards</code>, the command used in the terminal would be <code>cd $(cygpath -u 'C:\\Projects\\Shards')</code>.</p> <p>Tip</p> <p>A simple way to obtain a folder\u2019s directory is to copy the address as text. </p> <p>Navigate into the folder, right-click the folder in the navigation bar, and select \u201cCopy address as text\u201d.</p> <p></p>"},{"location":"contribute/code/build-shards/#single-command-to-build-shards","title":"Single command to build Shards","text":"<p>To build shards using a single command, execute the following command in the root of the repository: <pre><code>./build.sh\n</code></pre></p> <p>Note</p> <p>If you're unable to construct Shards using the <code>build.sh</code> script, continue reading for a step-by-step approach to building Shards.</p>"},{"location":"contribute/code/build-shards/#updating-the-repository-and-submodules","title":"Updating the Repository and Submodules","text":"<p>When new changes are made to the Shards repository, you will want to Pull these changes into your local copy of it. </p> <p>To do so with Github Desktop, first, select the \u201cFetch origin\u201d button.</p> <p></p> <p>If there are changes to pull, the button will change to \u201cPull origin\u201d. Select it to update your local repository.</p> <p></p> <p>The Shards repository contains repositories of other projects, known as submodules. When updating your Shards repository, these submodules are left alone and must be manually updated. You can update them with the following command: <pre><code>git submodule update --init --recursive\n</code></pre></p> not a git repository <p>This occurs when you are attempting to run the command outside of a git repository. Navigate to your Shards repository before attempting to update the submodules.</p>"},{"location":"contribute/code/build-shards/#bootstrapping-the-project","title":"Bootstrapping the Project","text":"<p>If this is your first time pulling the Shards repository, you will have to run the bootstrap file to set up and build the project.</p> <p>Enter the command <code>./bootstrap</code>.</p> <pre><code>./bootstrap\n</code></pre>"},{"location":"contribute/code/build-shards/#creating-build-folders","title":"Creating Build Folders","text":"<p>We will next create build folders in the Shards repository - one for the Debug version of Shards, and another for the Release version.</p> Debug or Release? <p>Debug builds are used when your code is still being tested and you wish to see detailed logs of what happens when your code is run. Release builds are used when you simply want the finished product without excessive logs.</p> <p>Debug Build:</p> <p></p> <p>Release Build:</p> <p></p> <p>First input <code>mkdir build</code> in the terminal to create a folder named \u201cbuild\u201d. </p> <pre><code>mkdir build\n</code></pre> mkdir <p>The <code>mkdir</code> command is used to create new folders.</p> <p>Next, input <code>cd build</code> to navigate into the newly created folder.</p> <pre><code>cd build\n</code></pre> <p>Input <code>mkdir Debug</code> to create a folder named \u201cDebug\u201d.</p> <pre><code>mkdir Debug\n</code></pre> <p>Input <code>mkdir Release</code> to create a folder named \u201cRelease\u201d.</p> <pre><code>mkdir Release\n</code></pre> What happened? <p>Look into your Shards repository, you should see the new folders created with the command line!</p> <p></p>"},{"location":"contribute/code/build-shards/#building-the-shards-executable","title":"Building the Shards Executable","text":"<p>We will first build the Debug version of Shards. </p> <p>Input the following command to generate the build files:</p> CommandOutput <pre><code>cmake -G Ninja -DCMAKE_BUILD_TYPE=Debug -B./Debug ..\n</code></pre> <pre><code>-- SHARDS_DIR = C:/Projects/Shards\n-- clang-format found:  C:/Program Files/LLVM/bin/clang-format.exe\n.\n.\n.\n-- Configuring done\n-- Generating done\n-- Build files have been written to: C:/Projects/Shards/build/Debug\n</code></pre> .. <p><code>..</code> represents the parent directory and can be used in the command line to navigate one level up.</p> <p>In the command <code>cmake -G Ninja -DCMAKE_BUILD_TYPE=Debug -B./Debug ..</code>, cmake is looking for the file <code>CMakeLists.txt</code> which exists one folder above the \"build\" folder where we are running the command from.</p> cmake: command not found <p>This error occurs when the terminal is unable to find where cargo.exe is. We will have to manually add the path of the folder containing it to the environment. </p> <p>The default location is at <code>C:\\Users\\username\\.cargo\\bin</code>.</p> <p>Use the command <code>export PATH=$PATH:$(cygpath -u '(X)')</code> whereby (X) is the folder directory for cargo.exe.</p> <pre><code>export PATH=$PATH:$(cygpath -u '(X)')\n</code></pre> <p>For the user \u2018john\u2019, the command used would be <code>export PATH=$PATH:$(cygpath -u 'C:\\Users\\john\\.cargo\\bin')</code>.</p> <p>You can check if the path has been set correctly by using the command <code>cargo</code> in the terminal. If done correctly, a wall of text starting with \u201cRust\u2019s package manager\u201d will appear. Otherwise, you will get the error \u201ccargo: command not found\u201d.</p> Unable to Build Shards <pre><code>rustup update\n</code></pre> <p>Next, input the <code>ninja</code> command below to build the .exe file. This might take a few minutes, so feel free to take a coffee break while waiting!</p> CommandOutput <pre><code>ninja -C Debug shards\n</code></pre> <pre><code>ninja: Entering directory `Debug'\n[0/2] Re-checking globbed directories...\n[1/876] Creating directories for 'sdl_a'\n.\n.\n.\n[874/876] Linking CXX static library lib\\libshards-extra.a\n[875/876] Linking CXX static library lib\\libshards-core-static.a\n[876/876] Linking CXX executable shards.exe\n</code></pre> <p>The debug version of shards.exe has been built! \ud83e\udd73</p> <p></p> <p>We will now repeat the process to create a Release version of Shards. Input the following cmake command:</p> CommandOutput <pre><code>cmake -G Ninja -DCMAKE_BUILD_TYPE=Release -B./Release ..\n</code></pre> <pre><code>-- The C compiler identification is Clang 15.0.7 with GNU-like command-line\n-- The CXX compiler identification is Clang 15.0.7 with GNU-like command-line\n.\n.\n.\n-- Configuring done\n-- Generating done\n-- Build files have been written to: C:/Projects/Shards/build/Release\n</code></pre> <p>Once again, build the .exe file with the <code>ninja</code> command below. Why not watch a few cat videos while waiting this time?</p> CommandOutput <pre><code>ninja -C Release shards\n</code></pre> <pre><code>ninja: Entering directory `Release'\n[0/2] Re-checking globbed directories...\n[1/876] Creating directories for 'sdl_a'\n.\n.\n.\n[874/876] Linking CXX static library lib\\libshards-extra.a\n[875/876] Linking CXX static library lib\\libshards-core-static.a\n[876/876] Linking CXX executable shards.exe\n</code></pre> <p>The release version of shards.exe has been built! \ud83d\ude0a</p> <p></p>"},{"location":"contribute/code/build-shards/#overview","title":"Overview","text":"<ol> <li> <p>Bootstrap the project if freshly pulled from the repository. <pre><code>./bootstrap\n</code></pre></p> </li> <li> <p>Create a \u201cbuild\u201d folder with nested \u201cDebug\u201d and \u201cRelease\u201d folders.</p> </li> <li> <p>Use <code>cmake</code> commands to generate build files for the Debug and Release versions. <pre><code>cmake -G Ninja -DCMAKE_BUILD_TYPE=Debug -B./Debug ..\n</code></pre> <pre><code>cmake -G Ninja -DCMAKE_BUILD_TYPE=Release -B./Release ..\n</code></pre></p> </li> <li> <p>Build the executables with the <code>ninja</code> commands. <pre><code>ninja -C Debug shards\n</code></pre> <pre><code>ninja -C Release shards\n</code></pre></p> </li> </ol> <p> </p>"},{"location":"contribute/code/run-shards/","title":"Run Shards","text":"<p>Note</p> <p>This guide is for new users unfamiliar with Visual Studio Code and the creation of new code files. </p> <p>Click here to skip the tutorial and jump to the overview.</p> <p>Learn how to employ Shards to execute code and bring your works to fruition!</p> <p>Ensure that you have Shards built before attempting to run it.</p>"},{"location":"contribute/code/run-shards/#preparing-the-script","title":"Preparing the Script","text":"<p>In VS Code, select \u201cFile \u2192 Open Folder\u2026\u201d (Ctrl+K+O) and select the Shards repository.</p> <p>Select the New Folder button  near the top of your Explorer window and name the folder \u201cscripts\u201d.</p> <p></p> <p>Right-click the \u201cscripts\u201d folder and select \u201cNew File\u2026\u201d. Name the file \u201chelloworld.edn\u201d.</p> <p></p> .edn <p>EDN is a file format used by other programming languages such as Clojure.</p> <p>Paste the following code into your new file and save it. <pre><code>(defmesh main)\n(defwire helloworld\n  (Msg \"Hello World\"))\n(schedule main helloworld)\n(run main)\n</code></pre></p> What does the code mean? <p>Even without in-depth knowledge, the Shards language is visual enough for you to make a guess at what it does. You define a mesh called \u201cmain\u201d and create a wire called \u201chelloworld\u201d that sends out a \u201cHello World\u201d message. We then schedule the wire on the mesh and run it. The code is therefore about sending out a \u201cHello World\u201d message.</p> <p>To better understand the intricacies of the code used, do give the Shards primer a read!</p> <p>Now that we have created a .edn file, the final step is to use shards.exe to execute the code in it.</p>"},{"location":"contribute/code/run-shards/#running-the-script","title":"Running the Script","text":"<p>Open the Git Bash terminal and navigate to your Shards repository with the command <code>cd $(cygpath -u '(X)')</code>, where (X) is the directory of your folder. For example, <code>cd $(cygpath -u 'C:\\Projects\\Shards')</code>.</p> <pre><code>cd $(cygpath -u '(X)')\n</code></pre> <p>To run the Debug version of Shards, use the command <code>./build/Debug/shards ./scripts/(X).edn</code>, whereby (X) is the name of your .edn file.</p> <pre><code>./build/Debug/shards ./scripts/(X).edn\n</code></pre> <p>To run the Release version of Shards, use the command <code>./build/Release/shards ./scripts/(X).edn</code>, whereby (X) is the name of your .edn file.</p> <pre><code>./build/Release/shards ./scripts/(X).edn\n</code></pre> <p>To run our \u201chelloworld.edn\u201d script, we run the command <code>./build/Debug/shards ./scripts/helloworld.edn</code>.</p> CommandOutput <pre><code>./build/Debug/shards ./scripts/helloworld.edn\n</code></pre> <pre><code>[debug] [2022-09-19 11:47:36.873] [T-19628] [SHCore.cpp::163] Exe path: C:\\Projects\\Shards\\build\\Debug\n[debug] [2022-09-19 11:47:36.873] [T-19628] [SHCore.cpp::164] Script path: C:\\Projects\\Shards\\scripts\n.\n.\n.\n[info] [2022-09-19 11:47:36.893] [T-19628] [logging.cpp::98] [helloworld] Hello World\n[debug] [2022-09-19 11:47:36.893] [T-19628] [runtime.cpp::2712] Running cleanup on wire: helloworld users count: 0\n[debug] [2022-09-19 11:47:36.893] [T-19628] [runtime.cpp::2752] Ran cleanup on wire: helloworld\n[trace] [2022-09-19 11:47:36.893] [T-19628] [runtime.cpp::2031] wire helloworld ended\n[trace] [2022-09-19 11:47:36.893] [T-19628] [runtime.hpp::294] stopping wire: helloworld\n</code></pre> <p>Congratulations! You have printed out your first \u201cHello World\u201d message to the terminal with Shards! \u2b50</p>"},{"location":"contribute/code/run-shards/#overview","title":"Overview","text":"<ol> <li> <p>Use <code>./build/Debug/shards ./scripts/fileName.edn</code> to run scripts with the Debug version of Shards. <pre><code>./build/Debug/shards ./scripts/fileName.edn\n</code></pre></p> </li> <li> <p>Use <code>./build/Release/shards ./scripts/fileName.edn</code> to run scripts with the Release version of Shards. <pre><code>./build/Release/shards ./scripts/fileName.edn\n</code></pre></p> </li> </ol> <p> </p>"},{"location":"contribute/docs/","title":"Documenting the API","text":"<p>Note that as of 2021/10/25, the API Documentation for the shards is extracted from the shards binary using the generate.edn script.</p> <pre><code>./src/build/shards docs/generate.edn\n</code></pre> <p>If you wish to contribute, you can check out our guide on how to start documenting.</p> <p> </p>"},{"location":"contribute/docs/start-documenting/","title":"Start Documenting","text":"<p>Note</p> <p>This guide is for new users unfamiliar with the installation process.</p> <p>Click here to skip the tutorial and jump to the overview.</p> <p>Pre-requisites:</p> <ul> <li>Readied the development environment</li> </ul> <p>Eager to help contribute to our ever-growing library of documentation? In this chapter, we will set up the documentation site generator so that you can start writing documentation.</p>"},{"location":"contribute/docs/start-documenting/#python","title":"Python","text":"<p>Python needs to be installed for the site generator to work. Download Python here and follow the instructions given by the installer. Remember to add Python to PATH during the installation!</p> <p></p> <p>By adding Python to PATH, it allows your terminals to be able to find and use Python. Try typing <code>Python</code> in any terminal to check if the installation process is successful.</p> CommandResult <pre><code>Python\n</code></pre> <p></p>"},{"location":"contribute/docs/start-documenting/#mkdocs","title":"MkDocs","text":"<p>MkDocs is a static site generator that allows you to write documentation in markdown.</p> What is Markdown? <p>It is a formatting language used to stylize plain text. Take a look at how this segment is written in markdown!</p> <p></p> <p>Install MkDocs using the Package Installer for Python (pip). Run the following command in your terminal:</p> Command <pre><code>pip install mkdocs\n</code></pre> <p>Once done, you can check if your installation is successful with the command:</p> CommandResult <pre><code>mkdocs\n</code></pre> <p></p> <p>Finally, install the following by running the given commands:</p> <ol> <li> <p>Material for MkDoc - A theme for MkDocs</p> <pre><code>pip install mkdocs-material\n</code></pre> </li> <li> <p>Awesome Pages Plugin - Adds navigation customization</p> <pre><code>pip install mkdocs-awesome-pages-plugin\n</code></pre> </li> <li> <p>mkdocs-macros - Allows for custom macros and variables</p> <pre><code>pip install mkdocs-macros-plugin\n</code></pre> </li> </ol> <p>You are now ready to start writing documentation! We will learn how Fragcolor's documentation is written in the next chapter.</p>"},{"location":"contribute/docs/start-documenting/#overview","title":"Overview","text":"<ol> <li> <p>Download Python and add it to PATH.</p> </li> <li> <p>Install MkDocs. <pre><code>pip install mkdocs\n</code></pre></p> </li> <li> <p>Install Material for MkDocs. <pre><code>pip install mkdocs-material\n</code></pre></p> </li> <li> <p>Install the Awesome Pages Plugin. <pre><code>pip install mkdocs-awesome-pages-plugin\n</code></pre></p> </li> <li> <p>Install mkdocs-macros. <pre><code>pip install mkdocs-macros-plugin\n</code></pre></p> </li> </ol> <p> </p>"},{"location":"contribute/docs/write-documentation/","title":"Write Documentation","text":"<p>Note</p> <p>Our documentation follows the Microsoft Style Guide. Do refer to it if you are unsure of the documentation style!</p> <p>In this chapter, you will be learning how to write documentation for Fragcolor.</p> <p>Pre-requisites:</p> <ul> <li> <p>Ready the Development Environment</p> </li> <li> <p>Build Shards</p> </li> <li> <p>Install MkDocs</p> </li> </ul>"},{"location":"contribute/docs/write-documentation/#navigating-the-docs","title":"Navigating the Docs","text":"<p>Documentation exists under the <code>/docs</code> folder of the Shards repository. We will list down notable folders that you will want to take note of.</p> <p>For Shards API Documentation:</p> <ul> <li> <p><code>/docs/docs/reference</code>: contains the pages for the \"Reference\" category of the site.</p> </li> <li> <p><code>/docs/details</code>: holds the files containing the details of each shard.</p> </li> <li> <p><code>/docs/samples</code>: contains the code and output of the examples for each shard.</p> </li> </ul> <p>Content from the three folders above is combined to make up each API documentation page.</p> <p></p> <p>For the other documentation pages:</p> <ul> <li> <p><code>/docs/docs/contribute</code>: contains the pages for the \"Contribute\" category of the site.</p> </li> <li> <p><code>/docs/docs/learn</code>: contains the pages for the \"Learn\" category of the site.</p> </li> </ul>"},{"location":"contribute/docs/write-documentation/#previewing-the-docs","title":"Previewing the Docs","text":"<ol> <li> <p>Open your MinGW terminal.</p> </li> <li> <p>Navigate to where your docs folder is located using the command <code>cd $(cygpath -u '(X)')</code>, where (X) is the directory of your folder.</p> <pre><code>cd $(cygpath -u '(X)')\n</code></pre> <p>If your docs folder is located at <code>C:\\Fragcolor\\Shards\\docs</code>, the command used in the MinGW terminal would be <code>cd $(cygpath -u 'C:\\Fragcolor\\Shards\\docs')</code>.</p> </li> <li> <p>Run the following command to start the server:</p> <pre><code>mkdocs serve\n</code></pre> </li> <li> <p>Enter the following in your browser to preview the site:</p> <pre><code>http://127.0.0.1:8000/\n</code></pre> </li> </ol>"},{"location":"contribute/docs/write-documentation/#pages-and-levels","title":"Pages and Levels","text":"<p>The root directory for our site is located at <code>/docs/docs</code>, with <code>index.md</code> as the file for our homepage. Subsequent directories are placed within folders.</p> <p></p> <p>Each level contains:</p> <ul> <li> <p>An <code>index.md</code> file as the landing page</p> </li> <li> <p>An (optional) <code>assets</code> folder to hold media used in that level</p> </li> <li> <p>A <code>.pages</code> file to organize the order of our pages</p> <p></p> <p>Note</p> <p>If <code>...</code> is used within <code>.pages</code>, files in the same hierarchy, that have not been mentioned in <code>.pages</code> will be arranged in alphabetical order.</p> <p></p> </li> </ul>"},{"location":"contribute/docs/write-documentation/#generating-documentation-for-the-shards-api","title":"Generating Documentation for the Shards API","text":"<p>You might have observed that the <code>/docs/docs/reference/shards</code> folder is conspicuously empty. This is to allow for the faster previewing of your static site without having to load all the pages for the Shards API.</p> <p>To generate the documentation for the Shards API:</p> <ol> <li> <p>Launch your MinGW terminal.</p> </li> <li> <p>Navigate to where your Shards repository is located using the command <code>cd $(cygpath -u '(X)')</code>, where (X) is the directory of your folder.</p> <pre><code>cd $(cygpath -u '(X)')\n</code></pre> <p>If your repository is located at <code>C:\\Fragcolor\\Shards</code>, the command used in the MinGW terminal would be <code>cd $(cygpath -u 'C:\\Fragcolor\\Shards')</code>.</p> </li> <li> <p>Input the following command:</p> <pre><code>./build/Debug/shards ./docs/generate.edn\n</code></pre> </li> </ol> <p>Note</p> <p>The Debug version of Shards should be used for the generating of the Shards API pages.</p> <p>Once done, you will notice that the directory is now filled with folders and Markdown files of various shards.</p>"},{"location":"contribute/docs/write-documentation/#generating-log-files-for-examples","title":"Generating Log Files for Examples","text":"<p>Did you realize that the \"Output\" segments for your code examples are empty too? This is due to how a <code>.log</code> file is required for each example to show its output.</p> <p>To generate the <code>.log</code> files for your code examples:</p> <ol> <li> <p>Launch your MinGW terminal.</p> </li> <li> <p>Navigate to where your Shards repository is located using the command <code>cd $(cygpath -u '(X)')</code>, where (X) is the directory of your folder.</p> <pre><code>cd $(cygpath -u '(X)')\n</code></pre> <p>If your repository is located at <code>C:\\Fragcolor\\Shards</code>, the command used in the MinGW terminal would be <code>cd $(cygpath -u 'C:\\Fragcolor\\Shards')</code>.</p> </li> <li> <p>Input the following command:</p> <pre><code>./run-samples.sh\n</code></pre> </li> </ol> <p>When the script is done, you will notice new <code>.log</code> files within your \"Samples\" folder. These will be shown in your documentation as the \"Output\" of your code examples.</p> <p></p> <p></p>"},{"location":"contribute/docs/write-documentation/#updating-the-shards-api-docs","title":"Updating the Shards API Docs","text":"<p>As you have seen from the segment on navigating the docs, a shard's API documentation is generated from three different locations:</p> <ol> <li> <p><code>/docs/details</code> folder</p> </li> <li> <p><code>/docs/samples</code> folder</p> </li> <li> <p><code>/docs/docs/reference</code> folder</p> </li> </ol> <p>Each segment will require a different approach to making changes. The following are the steps required to work with each segment:</p>"},{"location":"contribute/docs/write-documentation/#details","title":"Details","text":"<ol> <li> <p>Navigate to the <code>/docs/details</code> folder.</p> </li> <li> <p>Search for the <code>.md</code> file with the shard's name. We will be using the <code>Msg</code> shard in this example.</p> <p>Note</p> <p>If the file does not exist, create a new <code>.md</code> file with the shard's name (e.g. <code>Msg.md</code>).</p> <p></p> </li> <li> <p>Amend the text within the <code>.md</code> file.</p> <p></p> </li> <li> <p>The changes will be reflected on the site.</p> <p></p> </li> </ol>"},{"location":"contribute/docs/write-documentation/#examples","title":"Examples","text":"<ol> <li> <p>Navigate to the <code>/docs/samples</code> folder and locate the folder with the shard's name.</p> </li> <li> <p>The examples are <code>.edn</code> files named in numerical order, starting from 1.</p> <p></p> </li> <li> <p>Amend the code within the <code>.edn</code> file, or add a new <code>.edn</code> file to create a new example.</p> <p></p> </li> <li> <p>Amend the code within the <code>.edn.log</code> file of the same number to reflect the results of the example.</p> <p></p> </li> <li> <p>The changes to the <code>.edn</code> file will be reflected in the \"Code\" portion of the \"Examples\" segment on the site.</p> <p></p> </li> <li> <p>The changes to the <code>.edn.log</code> file will be reflected in the \"Output\" portion of the \"Examples\" segment on the site.</p> <p></p> </li> </ol>"},{"location":"contribute/docs/write-documentation/#reference","title":"Reference","text":"<p>Since the files within the <code>/docs/docs/reference</code> folder were generated by running a script, the editing of the description text in it will require additional steps.</p> <p>In this segment, we will learn how to edit the following:</p> <ul> <li> <p>The basic description of a shard</p> </li> <li> <p>The description text for the input and output</p> </li> <li> <p>The description text for the shard's parameters</p> </li> </ul> <p></p> <p>Editing these description texts will require looking at the source .cpp and .hpp files.</p>"},{"location":"contribute/docs/write-documentation/#basic-description","title":"Basic Description","text":"<p>Firstly, locate the struct of the shard you wish to amend. For this tutorial, we will be using the <code>String.Join</code> shard as an example.</p> <ol> <li> <p>Navigate to the <code>/src/core/shards</code> folder and select the file that most likely contains the target shard. For this example, we will select the <code>strings.cpp</code> file.</p> <p></p> </li> <li> <p>Search for where the shards are being registered and check the struct of the shard. In this example, <code>String.Join</code> has a struct named <code>Join</code>.</p> <p></p> <p>Note</p> <p>There might be instances whereby the struct is named differently from the shard. It is therefore important to check the struct's name first before proceeding.</p> </li> <li> <p>Navigate to the struct in the same file to access the <code>help()</code> function. The basic description of the shard is located in the return statement and can be edited from there.</p> <p></p> </li> </ol>"},{"location":"contribute/docs/write-documentation/#input-and-output","title":"Input and Output","text":"<p>Within the same struct, you can find the description text for the input and output within the <code>inputHelp()</code> and <code>outputHelp()</code> functions.</p> <p></p>"},{"location":"contribute/docs/write-documentation/#parameters","title":"Parameters","text":"<p>For the description of the parameters, look for the <code>parameters()</code> function within the struct.</p> <p>You will see either:</p> <ul> <li> <p>The parameter description within the function,</p> </li> <li> <p>OR a variable being returned.</p> </li> </ul> <p>In the case of <code>String.Join</code>, a variable <code>params</code> is returned. Search for the variable used to find the description text of the parameters.</p> <p></p> <p></p>"},{"location":"contribute/docs/write-documentation/#formatting-the-docs","title":"Formatting the Docs","text":"<p>Our documentation is formatted with Markdown. Do check out the cheatsheet if you are new to Markdown or need a refresher.</p> <p>Material for MkDocs allows you to add fancier stuff to your documentation, such as admonitions and annotated code blocks. For more information on what you can achieve, do check out the reference page here.</p> <p>Note</p> <p>This is an admonition created with Material for MkDocs!</p> <p>Great job reaching the end of the tutorial! We hope this has been useful in helping you start your documentation writing endeavors.</p>"},{"location":"contribute/docs/write-documentation/#overview","title":"Overview","text":"<ol> <li> <p><code>/docs/docs/contribute</code>: \"Contribute\" pages</p> </li> <li> <p><code>/docs/docs/learn</code>: \"Learn\" pages</p> </li> <li> <p><code>/docs/docs/reference</code>: API \"Reference\" pages</p> </li> <li> <p><code>/docs/details</code>: API Details</p> </li> <li> <p><code>/docs/samples</code>: API Examples</p> </li> <li> <p><code>/src/core/shards</code>: API Basic/Input/Output/Parameters Description</p> </li> </ol> <p> </p>"},{"location":"contribute/wiki/","title":"Contributing to the wiki","text":"<p>A wiki houses community-contributed knowledge, such as code recipes, etc.</p> <p>You can access a project's wiki by suffixing '/wiki' to the URL of that project's code repository.</p> <p>For example, the Shards wiki is at <code>https://github.com/fragcolor-xyz/shards/wiki</code>.</p>"},{"location":"contribute/wiki/#request-collaborator-access","title":"Request collaborator access","text":"<p>To edit a project's wiki, you'll need collaborator access to that project's repository. Open an issue in the repository and tag the project maintainer to request this access.</p> <p>Once you have access, you'll see the Edit and New Page buttons on the upper right-hand side of the wiki page.</p> <p></p>"},{"location":"contribute/wiki/#edit-page","title":"Edit page","text":"<p>Use the right-hand side Table Of Contents to select a page you want to edit.</p> <p>Click the Edit button to start editing the page. You can change the Edit mode by clicking the Markdown dropdown.</p> <p></p> <p>The Preview tab shows you what your formatted document would look like.</p> <p>Under the Edit message field, there's an option to add a commit-message (something that explains your changes).</p> <p></p>"},{"location":"contribute/wiki/#new-page","title":"New page","text":"<p>Click the New Page button to add your content.</p> <p></p> <p>Editing and saving changes work just as they do for an existing page.</p> <p> </p>"},{"location":"download/","title":"Index","text":""},{"location":"download/#download","title":"Download","text":"<p>Select the project you wish to download:</p> <ul> <li> <p>Download Shards</p> </li> <li> <p>Download Rare Engine (Coming Soon!)</p> </li> </ul> <p>Unsure of where to go from here? Why not learn more about our projects with our primers and tutorials here!</p> <p> </p>"},{"location":"learn/","title":"Index","text":""},{"location":"learn/#learn","title":"Learn","text":"<p>Ready to learn more about our organization's various projects and initiatives? Check out our primers and tutorials! They're a valuable resource for anyone who wants to get involved and make a difference with our projects.</p> <p>Our primers are comprehensive guides that provide a detailed introduction to our projects. They cover everything you need to know to get started and are a great way to get up to speed quickly.</p> <p>Our tutorials, on the other hand, are more focused on practical application and techniques. If you're more interested in getting your hands dirty and learning practical skills, then our tutorials are what you need. They take you step-by-step through specific tasks or projects, with easy-to-follow instructions and examples.</p> <p>Begin by navigating to the project you wish to learn more about:</p> <ul> <li> <p>Shards</p> </li> <li> <p>Rare Engine (Coming Soon!)</p> </li> </ul> <p> </p>"},{"location":"learn/shards/","title":"Index","text":""},{"location":"learn/shards/#learn-shards","title":"Learn Shards","text":"<p>Shards is a programming language that helps developers create apps more efficiently. It does this by breaking down the app into smaller functional units called shards. These shards can then be easily connected to create more complex workflows. By using Shards, developers can create a variety of workflows that can be customized to fit specific needs, while improving the performance and scalability of a system.</p> <p>If you're new to the world of Shards, our primer is an excellent place to start. It covers the basics of Shards and you'll get a solid foundation which will allow you to tackle more advanced concepts.</p> <p>However, learning the basics is only the first step. To truly understand Shards and use them effectively in your projects, you need to reinforce the concepts learned with hands-on experience. That's where our tutorials come in. Our step-by-step tutorials provide practical examples and exercises that allow you to apply what you've learned to create playable games. With our tutorials, you'll gain the confidence and skills you need to start developing with Shards.</p> <p>Begin your learning journey here!</p> <ul> <li> <p>Primer - Shards basics.</p> </li> <li> <p>Tutorials - Practical examples.</p> </li> </ul> <p> </p>"},{"location":"learn/shards/primer/","title":"Shards","text":"<p>Looking to step into the world of Shards? Look no further! In this primer, you will learn the basics of Shards and why you should use it.</p> <p>Shards has a very visual syntax which makes it intuitive and easy to learn, even for those new to programming.</p> <p>It is also designed to be highly performant and promotes the creation of sharable and reusable code.</p> <p> </p>"},{"location":"learn/shards/primer/coding-with-shards/","title":"Coding with Shards","text":"<p>In this chapter, we will be learning how to code with Shards so that you can write your very own program!</p>"},{"location":"learn/shards/primer/coding-with-shards/#the-shard","title":"The shard","text":"<p>A shard in its most basic code form consists of its name surrounded by parentheses.</p> <p></p> <p>The above example consists of 3 different predefined shards.</p> <p>Shards are named to make their purpose rather intuitive. <code>(Msg)</code> is the Message shard that prints a message to the console, while <code>Math.Add</code> is a Mathematics shard that adds numbers together.</p> <p>Note</p> <p>It is a good practice to name your code based on its purpose. This allows others to easily understand what your code achieves without getting too technical.</p> <p>For example, the code <code>(Msg \"Hello World!\")</code> can be easily understood to be sending the message \"Hello World\" to the console. You do not need to delve into how <code>(Msg)</code> was coded to understand what it can do.</p> <p>A shard can take in an input, process that input, and produce an output. Shards also have parameters that behave as user-defined settings.</p> <p>For example, <code>Math.Add</code> has the parameter <code>Operand</code> which is defined by the user. It determines the value that will be added to the input. The final result is then produced as the output.</p> <p></p> <p>In code form, parameters are defined by the user within the parentheses of the shard itself, after the shard's name. The above examples will appear as <code>5 (Math.Add 1)</code> and <code>5 (Math.Add 3)</code> in code. </p> <p>Some shards have multiple parameters. When specifying values for multiple parameters, you will have to prepend your values with the parameter they are for if some parameters are skipped.</p> <p>Let us take a look at the <code>Repeat</code> shard which has four parameters: <code>Action</code>, <code>Times</code>, <code>Forever</code>, <code>Until</code>.</p> <p>We can utilize the <code>Repeat</code> shard with its different parameters as shown:</p> 1 Parameter (Implicit)2 Parameters (Explicit)2 Parameters (Implicit)2 Parameters (Implicit 1st)(INCORRECT) 2 Parameters (Implicit 2nd)3 Parameters (Explicit) <pre><code>(Repeat\n    (-&gt; (Msg \"Hello World!\"))) ;; (1)(2)\n</code></pre> <ol> <li>When no parameters are specified, parameters are treated as implicit and are resolved in order. In this case, <code>Action</code> is the implicit parameter for <code>Repeat</code> and we set <code>(Msg \"Hello World\")</code> to it.</li> <li>Since the other parameters are not defined, they will assume their default values. In this case, the <code>Repeat</code> shard will not run at all as <code>Times</code> has a default value of 0.</li> </ol> <pre><code>(Repeat \n    :Action (-&gt; (Msg \"Hello World!\")) ;; (1)\n    :Times 2) ;; (2)\n</code></pre> <ol> <li>The parameters are explicitly declared for clarity.</li> <li>Repeats the <code>Action</code> twice.</li> </ol> <pre><code>(Repeat ;; (1)\n    (-&gt; (Msg \"Hello World!\"))\n    2)\n</code></pre> <ol> <li>Both parameters can be implicit since they are resolved in order. In this case, <code>Action</code> is the first implicit parameter, and <code>Times</code> is the second implicit parameter.</li> </ol> <pre><code>(Repeat \n    (-&gt; (Msg \"Hello World!\")) ;; (1)\n    :Times 2)\n</code></pre> <ol> <li>You can still implicitly declare the first parameter, while fully declaring the other parameters. Note that it does not work vice versa. You cannot implicitly declare parameters if a parameter before it has been explicitly declared.</li> </ol> <pre><code>(Repeat \n    :Action (-&gt; (Msg \"Hello World!\")) \n    2) ;; (1)\n</code></pre> <ol> <li>This will not work as you cannot implicitly declare the second parameter if the first has been fully declared.</li> </ol> <pre><code>(Repeat\n   :Action (-&gt; (Msg \"Hello World!\"))\n   :Forever true ;; (1)\n   :Until ( ;; some condition )\n   ) ;; (2)\n</code></pre> <ol> <li>The <code>Times</code> parameter is skipped and <code>Forever</code> is declared instead. Since we are skipping a parameter, we must fully declare the parameters that come after it.</li> <li><code>Until</code> takes a shard that returns <code>true</code> or <code>false</code>. <code>Repeat</code> will loop forever until the shard specified in <code>Until</code> evaluates to <code>true</code>.</li> </ol> <p><code>-&gt;</code></p> <p>When using shards for a parameter (e.g., <code>Action</code>), you must always place <code>-&gt;</code> before the first shard.</p> <p><code>-&gt;</code> is a shard container used to group multiple shards together. We will see how to eliminate the use of <code>-&gt;</code> later in the segment for <code>defshards</code>.</p> <p>To find out more about the input/output/parameter of a shard, you can search for the shard in the search bar above and check out its documentation page.</p> <p>Give it a try!</p> <p>Type \"Msg\" in the search bar above and select the first result that appears. It should lead you to the page for <code>Msg</code> here.</p> <p>From there, you can learn more about:</p> <ul> <li> <p>The purpose of the shard</p> </li> <li> <p>Its parameters</p> </li> <li> <p>The input type it can receive</p> </li> <li> <p>The output it will produce</p> </li> <li> <p>How to utilize the shard by looking at the examples given</p> </li> </ul>"},{"location":"learn/shards/primer/coding-with-shards/#data-types","title":"Data Types","text":"<p>A shard can take in data, process it, and output the results.</p> <p></p> <p>There are many different types of data in the Shards language, and each shard will have specific data types that it can work with. </p> <p>For example, the <code>Math.Add</code> shard can only work with numeric data types, while the <code>Log</code> shard that prints information to the console can work with <code>Any</code> data type.</p> <p>Here are some of the data types found in Shards:</p> Data Type Description Example <code>Any</code> Any data type. <code>None</code> No data type. <code>Bool</code> Evaluates to either <code>true</code> or <code>false</code>. <code>true</code>, <code>false</code> <code>Float</code> A numerical value with a decimal point. <code>2.53</code>, <code>-9.124</code> <code>Int</code> A numerical value with no decimals. Read as \"integer\". <code>2</code>, <code>-9</code> <code>Sequence</code> A collection of values. <code>[2.5, -9.1, 9.7]</code> <code>String</code> Characters enclosed by double quotes. \"A string!\" <code>Wire</code> A sequence of shards. <p>Note</p> <p>A shard can have multiple data types as its input and output. For example, the shard <code>Math.Add</code> can have its input and output as an <code>Int</code>, or it can have its input and output as a <code>Float</code>.</p> <p>For the full list of data types and more in-depth reading, check out the <code>Types</code> documentation page here.</p>"},{"location":"learn/shards/primer/coding-with-shards/#variables","title":"Variables","text":"<p>To better work with data across your code, we can assign them to data containers known as variables.</p> <p>Imagine a scenario where you have a float <code>3.141592653589793</code> that you need to reuse in code multiple times. Instead of typing out the entire float each time, you could assign it to a variable called <code>.pi-value</code> and simply use that variable whenever it is needed.</p> Without VariablesWith Variables <pre><code>3.141592653589793 (Math.Add 3.141592653589793) (Math.Multiply 3.141592653589793) (Math.Subtract 3.141592653589793)\n</code></pre> <pre><code>3.141592653589793 = .pi-value ;; (1)\n.pi-value (Math.Add .pi-value) (Math.Multiply .pi-value) (Math.Subtract .pi-value)\n</code></pre> <ol> <li>3.141592653589793 is assigned to the variable <code>.pi-value</code>. We'll learn more about assigning variables in a bit!</li> </ol> <p>Variable names always start with a <code>.</code> period.</p> <p>Some example of variable names:</p> <ul> <li> <p><code>.x</code></p> </li> <li> <p><code>.number-of-apples</code></p> </li> <li> <p><code>.is-verified</code> </p> </li> </ul> <p>How you assign data to variables depends on the variable type. The main differences between variables are as follows:</p> <ul> <li> <p>Constant vs Mutable</p> <ul> <li> <p>Constant: The variable's value cannot be changed once defined.</p> </li> <li> <p>Mutable: The variable's value can be changed.</p> </li> </ul> </li> <li> <p>Local vs Global</p> <ul> <li> <p>Local: The variable is only known within the Wire it originated from.</p> </li> <li> <p>Global: The variable is known throughout the entire Mesh.</p> </li> </ul> </li> </ul> <p>Local vs Global</p> <p>We will learn more about this later in the section about Scope in Shards.</p> <p>Here are the variable types and the symbols used to create and assign to them:</p> Variable Type Shard Alias Description Local, Constant <code>Ref</code> <code>=</code> Creates a local constant variable. Local, Mutable <code>Set</code> <code>&gt;=</code> Creates a local mutable variable. Global, Mutable <code>Set</code> <code>&gt;==</code> Creates a global mutable variable. Mutable <code>Update</code> <code>&gt;</code> Updates a mutable variable. <p>In summary:</p> <ul> <li> <p>Use <code>=</code> to create constant variables.</p> </li> <li> <p>Otherwise, use <code>&gt;=</code> to create local variables, or <code>&gt;==</code> to make them global.</p> </li> <li> <p>Use <code>&gt;</code> to update variable values.</p> </li> </ul> <p>When defining variables in your program, you can use <code>Setup</code> to ensure that variables defined within it will only ever be defined once within a program.</p> Defining Variables in Setup <pre><code>(Setup\n 10 &gt;= .timer\n 100 &gt;= max-points) ;; (1)\n</code></pre> <ol> <li>Code within a <code>Setup</code> will only be run once. As such, you can prevent variables defined in a loop from being reset each time.</li> </ol> <p><code>Setup</code> is an alias of the shard <code>Once</code>, with its <code>Every</code> parameter set to 1 to ensure that code defined in its <code>Action</code> parameter will only be run once.</p>"},{"location":"learn/shards/primer/coding-with-shards/#grouping-shards","title":"Grouping shards","text":"<p><code>defshards</code> allows you to group multiple shards to form a new shard, thereby eliminating the use of <code>-&gt;</code>. It is useful for organizing your code and improving readability.</p> <p><code>defshards</code> has a syntax as such:</p> Code <pre><code>(defshards shard-name []\n    ;; your shards here\n)\n</code></pre> <p>The square brackets <code>[]</code> are where you can define parameters. For example:</p> Code <pre><code>(defshards send-message [message]\n    (Msg \"Message Incoming...\")\n    (Msg message))\n</code></pre> <p>When used in code:</p> CodeResult <pre><code>(send-message \"Hello World!\")\n</code></pre> <pre><code>Message Incoming...\nHello World!\n</code></pre> <p>Let us now take a look at how we can utilize <code>defshards</code> in a code snippet that counts from 1 to 5 multiple times.</p> Code <pre><code>(Repeat\n :Action\n (-&gt; (Msg \"1\")\n     (Msg \"2\")\n     (Msg \"3\")\n     (Msg \"4\")\n     (Msg \"5\"))\n :Times 5)\n</code></pre> <p>We can replace the use of <code>-&gt;</code> above with <code>defshards</code> to make the count from 1 to 5 code reusable and factor it out under a new shard called <code>msg-one-to-five</code>.</p> Code <pre><code>(defshards msg-one-to-five []\n  (Msg \"1\")\n  (Msg \"2\")\n  (Msg \"3\")\n  (Msg \"4\")\n  (Msg \"5\"))\n\n(Repeat\n :Action (msg-one-to-five)\n :Times 5)\n</code></pre> <p>Note</p> <p>The parameter will still require a <code>-&gt;</code> if it contains multiple shards.</p> Code <pre><code>(Repeat\n :Action\n (-&gt; (msg-one-to-five)\n     (Msg \"6\"))\n :Times 5)\n</code></pre>"},{"location":"learn/shards/primer/coding-with-shards/#the-wire","title":"The Wire","text":"<p>A Wire is made up of a sequence of shards, queued for execution from left to right, top to bottom.</p> <p></p> <p>To create a Wire, we use <code>defwire</code>.</p> Creating a Wire <pre><code>(defwire wire-name \n  ;; shards here\n)\n</code></pre> <p>Note</p> <p>The syntax for <code>defwire</code> is different from <code>defshards</code> as you cannot define parameters. Square brackets <code>[]</code> are not used. Instead, <code>defwire</code> inherits variables from the parent wire unless the variables are pure.</p> <p>Note</p> <p>Unlike <code>defshards</code> which group shards up for organization, <code>defwire</code> groups shards up to fulfill a purpose. As Wires are created with a purpose in mind, they should be appropriately named to reflect it.</p> <p>A Wire's lifetime ends once the final shard within it has been executed. To keep a Wire alive even after it has reached its end, we can set it to be loopable. This is called a Looped Wire.</p> <p></p> <p>A Looped Wire will continue running until its exit conditions have been met.</p> <p>Note</p> <p>You will learn more about the entering and exiting of Looped Wires in the next chapter!</p> <p>To create a Looped Wire, we use <code>defloop</code>.</p> Creating a Looped Wire <pre><code>(defloop loop-name \n  ;; shards here\n)\n</code></pre>"},{"location":"learn/shards/primer/coding-with-shards/#the-mesh","title":"The Mesh","text":"<p>Wires are queued for execution within a Mesh, from left to right, top to bottom.</p> <p></p> <p>To queue a Wire on a Mesh, we use <code>schedule</code>.</p> Scheduling a Wire <pre><code>(schedule mesh-name wire-name)\n</code></pre> <p>Note</p> <p>We will learn more about controlling the flow of Shards with Wires and Meshes in the following chapter.</p>"},{"location":"learn/shards/primer/coding-with-shards/#running-shards","title":"Running Shards","text":"<p>To get Shards running, a specific hierarchy and sequence must be followed. Your shards are first queued into Wires, which are then queued onto a Mesh.</p> <p></p> <p>When the Mesh is run, the Wires are executed in sequence and your program is started. This is done using the aptly named command <code>run</code>.</p> Running a Mesh <pre><code>(run mesh-name)\n</code></pre> <p><code>run</code> can take in two optional values:</p> <ul> <li> <p>The interval between each iteration of the Mesh.</p> </li> <li> <p>The maximum number of iterations, which is typically used for debugging purposes.</p> </li> </ul> <p>Note</p> <p>If your program has animations, we recommend that you set the first value to <code>(/ 1.0 60.0)</code> which emulates 60 frames per second (60 FPS).</p> Running a Mesh at 60 FPS <pre><code>(run mesh-name (/ 1.0 60.0))\n</code></pre> <p>Let us now take a look at what a basic Shards program will look like!</p>"},{"location":"learn/shards/primer/coding-with-shards/#writing-a-sample-program","title":"Writing a sample program","text":"<p>Do you recall the <code>hungry-cat</code> loop from the previous chapter? Let us try to implement a simpler modified version of it using the concepts learned in this chapter.</p> <p></p> <p>In this example, the \"cat\" starts off with 0 hunger. At the end of each loop, we increase the hunger by 1. Once the value of hunger is greater than 0, the cat starts to make cat noises.</p>"},{"location":"learn/shards/primer/coding-with-shards/#defshards-and-defwire","title":"defshards and defwire","text":"<p>Let us first define the <code>make-cat-noises</code> Wire.</p> make-cat-noises <pre><code>(defwire make-cat-noises\n  (Msg \"Meow\") (Msg \"Meow\") (Msg \"Meow\")\n  (Msg \"Mew\") (Msg \"Mew\") (Msg \"Mew\")\n  (Msg \"Meow\") (Msg \"Meow\") (Msg \"Meow\")\n  (Msg \"Mew\") (Msg \"Mew\") (Msg \"Mew\"))\n</code></pre> <p>We can employ the <code>Repeat</code> shard we saw earlier to make our code more efficient. </p> make-cat-noises <pre><code>(defwire make-cat-noises\n  (Repeat\n   :Action (-&gt; (Msg \"Meow\"))\n   :Times 3)\n  (Repeat\n   :Action (-&gt; (Msg \"Mew\"))\n   :Times 3)\n  (Repeat\n   :Action (-&gt; (Msg \"Meow\"))\n   :Times 3)\n  (Repeat\n   :Action (-&gt; (Msg \"Mew\"))\n   :Times 3))\n</code></pre> <p>Going a step further, we can better organize our code by creating new shards with <code>defshards</code>. Look at how much neater it is now!</p> make-cat-noises <pre><code>(defshards meows []\n  (Repeat\n   :Action (-&gt; (Msg \"Meow\"))\n   :Times 3))\n\n(defshards mews []\n  (Repeat\n   :Action (-&gt; (Msg \"Mew\"))\n   :Times 3))\n\n(defwire make-cat-noises\n  (meows) (mews) (meows) (mews))\n</code></pre>"},{"location":"learn/shards/primer/coding-with-shards/#the-loop","title":"The Loop","text":"<p>With the <code>make-cat-noises</code> Wire done, let us now look at creating the full <code>hungry-cat</code> program loop.</p> hungry-cat <pre><code>(defloop hungry-cat)\n</code></pre> <p>We want to first create a variable to track the cat's hunger level. Create the <code>.hunger</code> variable and assign the value of 0 to it. Remember to create the variable within <code>Setup</code> to prevent it from being reassigned at each iteration of the loop.</p> hungry-cat <pre><code>(defloop hungry-cat\n  (Setup\n   0 &gt;= .hunger)) ;; (1)\n</code></pre> <ol> <li>Code within a <code>Setup</code> will only be run once in a program.</li> </ol> <p>Next, use the <code>Math.Inc</code> shard to increase the value of <code>.hunger</code> every time the Wire loops.</p> hungry-cat <pre><code>(defloop hungry-cat\n  (Setup\n   0 &gt;= .hunger)\n  (Math.Inc .hunger))\n</code></pre>"},{"location":"learn/shards/primer/coding-with-shards/#conditionals","title":"Conditionals","text":"<p>A conditional can be used to check if <code>.hunger</code> is greater than 0. When the cat's hunger level has risen above 0, we want the cat to start making cat noises. Some conditional shards that you can use are:</p> <ul> <li><code>When</code></li> <li><code>If</code></li> </ul> <p><code>When</code> allows you to specify what happens if a condition is met. The syntax reads as such: <code>When</code> a condition is met, <code>Then</code> a specified action happens.</p> <p><code>If</code> is similar to <code>When</code>, but it has an additional parameter <code>Else</code> that allows it to have a syntax that reads as such: <code>If</code> a condition is met, <code>Then</code> a specified action occurs, <code>Else</code> another action is executed instead.</p> <p>For this example, using <code>When</code> would suffice as we only need <code>make-cat-noises</code> to run <code>When</code> hunger <code>IsMore</code> than 0.</p> hungry-cat <pre><code>(defloop hungry-cat\n  (Setup\n   0 &gt;= .hunger)\n  (When\n   :Predicate (IsMore 0) ;; (1)\n   :Action (-&gt; (Detach make-cat-noises))) ;; (2)\n  (Math.Inc .hunger))\n</code></pre> <ol> <li><code>IsMore</code> compares the input to its parameter and outputs <code>true</code> if the input has a greater value. In this case, it is comparing the value of <code>.hunger</code> to 0.</li> <li><code>Detach</code> is used to schedule a Wire on the Mesh. You will learn more about using <code>Detach</code> in the following chapter!</li> </ol>"},{"location":"learn/shards/primer/coding-with-shards/#debugging","title":"Debugging","text":"<p>What if you wanted to check the value of <code>.hunger</code> in each loop iteration?  We can employ a shard that is useful when you wish to debug your code - the <code>Log</code> shard.</p> <p>Debugging</p> <p>Debugging is the process of attempting to find the cause of an error or undesirable behavior in your program. When attempting to debug your code, functions or tools that allow you to check the value of variables at various points in your code can be useful in helping you narrow down where the errors could be originating from.</p> <p><code>Log</code> is useful as it can be placed at any point of your code to check the value passing through it. In this example, we will use <code>Log</code> to verify the value of <code>.hunger</code> before the conditional check with <code>When</code> occurs. Upon running the code, you will see that when the value of <code>.hunger</code> becomes 1, the cat starts to make noises.</p>"},{"location":"learn/shards/primer/coding-with-shards/#readying-the-mesh","title":"Readying the Mesh","text":"<p>Before our program can run, do not forget to:</p> <ul> <li> <p>Define the Mesh.</p> </li> <li> <p><code>schedule</code> the Wire on the Mesh.</p> </li> <li> <p><code>run</code> the Mesh.</p> </li> </ul> hungry-catResults <pre><code>(defmesh main)\n\n(defshards meows []\n  (Repeat\n   :Action (-&gt; (Msg \"Meow\"))\n   :Times 3))\n\n(defshards mews []\n  (Repeat\n   :Action (-&gt; (Msg \"Mew\"))\n   :Times 3))\n\n(defwire make-cat-noises\n  (meows) (mews) (meows) (mews))\n\n(defloop hungry-cat\n  (Setup\n   0 &gt;= .hunger)\n  .hunger (Log \"Hunger Level\")\n  (When\n   :Predicate (IsMore 0)\n   :Action (-&gt; (Detach make-cat-noises)))\n  (Math.Inc .hunger))\n\n(schedule main hungry-cat)\n(run main 1 3) ;; (1)\n</code></pre> <ol> <li>We set the Mesh to only run 3 iterations. This means that the <code>hungry-cat</code> loop will only occur 3 times.</li> </ol> <pre><code>[hungry-cat] Hunger Level: 0\n[hungry-cat] Hunger Level: 1\n[make-cat-noises] Meow\n[make-cat-noises] Meow\n[make-cat-noises] Meow\n[make-cat-noises] Mew\n[make-cat-noises] Mew\n[make-cat-noises] Mew\n[make-cat-noises] Meow\n[make-cat-noises] Meow\n[make-cat-noises] Meow\n[make-cat-noises] Mew\n[make-cat-noises] Mew\n[make-cat-noises] Mew\n[hungry-cat] Hunger Level: 2\n[make-cat-noises] Meow\n[make-cat-noises] Meow\n[make-cat-noises] Meow\n[make-cat-noises] Mew\n[make-cat-noises] Mew\n[make-cat-noises] Mew\n[make-cat-noises] Meow\n[make-cat-noises] Meow\n[make-cat-noises] Meow\n[make-cat-noises] Mew\n[make-cat-noises] Mew\n[make-cat-noises] Mew\n</code></pre> <p>Congratulations! You have now learned the fundamentals of writing a Shards program.</p> <p>We will next look at how you can manipulate the flow of Shards to give you better control of how your program utilizes different Wires.</p> <p> </p>"},{"location":"learn/shards/primer/the-flow/","title":"Shards Flow","text":"<p>A Shards program flows from left to right, top to bottom. Wires are scheduled on the Mesh, and they are run in the order they are scheduled in.</p> <p>To gain better control of the flow in your Shards program, you can employ some of the methods described here.</p>"},{"location":"learn/shards/primer/the-flow/#do","title":"Do","text":"<p><code>Do</code> allows you to run a Wire without having to schedule it on a Mesh. This is useful when you wish to reuse a Wire multiple times, similar to a function. <code>Do</code> takes an input, passes it into the Wire being called, and returns the output from it.</p> <p>In the example below, John and Lucy are taking apples in turn. The Looped Wires are scheduled on the Mesh. When they are run, they each call the unscheduled Wire <code>take-an-apple</code>.</p> <p>Note</p> <p>Wires scheduled on the Mesh are automatically run in order when the program starts. Unscheduled Wires however will only run when called by methods such as <code>Do</code>.</p> CommandOutput <pre><code>(defmesh main)\n\n(defwire take-an-apple\n  = .name (Log \"Actor\") ;; (1)\n  (Setup 10 &gt;= .apples) ;; (2)\n  (Math.Dec .apples)\n  .apples (Log \"Apples Remaining\"))\n\n(defloop john\n  (Msg \"Taking an apple!\")\n  \"John\" (Do take-an-apple))\n\n(defloop lucy\n  (Msg \"Taking an apple!\")\n  \"Lucy\" (Do take-an-apple))\n\n(schedule main john)\n(schedule main lucy)\n(run main 1 3)\n</code></pre> <ol> <li> <p>The value passed into the Wire is saved into a variable. In this case, the string \"John\" or \"Lucy\" is passed into the Wire and saved into the variable <code>.name</code>.</p> </li> <li> <p>The program starts with 10 apples. This value decreases each time the Wire <code>take-an-apple</code> is called.</p> </li> </ol> <pre><code>[john] Taking an apple!\n[take-an-apple] Actor: John\n[take-an-apple] Apples Remaining: 9\n[lucy] Taking an apple!\n[take-an-apple] Actor: Lucy\n[take-an-apple] Apples Remaining: 8\n[john] Taking an apple!\n[take-an-apple] Actor: John\n[take-an-apple] Apples Remaining: 7\n[lucy] Taking an apple!\n[take-an-apple] Actor: Lucy\n[take-an-apple] Apples Remaining: 6\n[john] Taking an apple!\n[take-an-apple] Actor: John\n[take-an-apple] Apples Remaining: 5\n[lucy] Taking an apple!\n[take-an-apple] Actor: Lucy\n[take-an-apple] Apples Remaining: 4\n</code></pre> <p></p>"},{"location":"learn/shards/primer/the-flow/#detach-spawn","title":"Detach / Spawn","text":"<p><code>Detach</code> and <code>Spawn</code> schedules a Wire to run on the same Mesh.</p> <p>The difference between <code>Detach</code> and <code>Spawn</code> is that:</p> <ul> <li> <p><code>Detach</code> schedules the original Wire itself.</p> </li> <li> <p><code>Spawn</code> schedules a clone of the Wire.</p> </li> </ul> <p>This means that there can only be one instance of the detached Wire running, while you can have many instances of the spawned Wire.</p> <p></p> <p></p>"},{"location":"learn/shards/primer/the-flow/#wait","title":"Wait","text":"<p><code>Detach</code> allows you to pause the original Wire to run the detached Wire by calling the <code>Wait</code> shard. It is useful when you have to pause a Wire's execution to wait for something. Use cases would include pausing a program to wait for a file to upload, or waiting for an online transaction to go through.</p> <p></p> <p>Back to our previous example with apples, if John now requires some time to juice each apple before taking another, we could use <code>Detach</code> and <code>Wait</code> to implement this. Note how Lucy continues to take apples while John is still making apple juice.</p> CommandOutput <pre><code>(defmesh main)\n\n(defwire take-an-apple\n  = .name (Log \"Actor\")\n  (Setup 10 &gt;= .apples (Log \"Setup\"))\n  (Math.Dec .apples)\n  .apples (Log \"Apples Remaining\"))\n\n(defwire juice-apple\n  = .name (Log \"Actor\")\n  (Msg \"Juicing Apple...\") (Pause 1) ;; (1)\n  (Msg \"Made some Apple Juice!\"))\n\n(defloop john\n  (Msg \"Taking an apple!\")\n  \"John\" (Do take-an-apple)\n  \"John\" (Detach juice-apple)\n  (Wait \"juice-apple\"))\n\n(defloop lucy\n  (Msg \"Taking an apple!\")\n  \"Lucy\" (Do take-an-apple))\n\n(schedule main john)\n(schedule main lucy)\n(run main 1 4)\n</code></pre> <ol> <li><code>Pause</code> pauses the Wire by the specified amount of seconds.</li> </ol> <pre><code>[john] Taking an apple!\n[take-an-apple] Actor: John\n[take-an-apple] Setup: 10\n[take-an-apple] Apples Remaining: 9\n[lucy] Taking an apple!\n[take-an-apple] Actor: Lucy\n[take-an-apple] Apples Remaining: 8\n[juice-apple] Actor: John\n[juice-apple] Juicing Apple...\n[lucy] Taking an apple!\n[take-an-apple] Actor: Lucy\n[take-an-apple] Apples Remaining: 7\n[juice-apple] Made some Apple Juice!\n[lucy] Taking an apple!\n[take-an-apple] Actor: Lucy\n[take-an-apple] Apples Remaining: 6\n[john] Taking an apple!\n[take-an-apple] Actor: John\n[take-an-apple] Apples Remaining: 5\n[lucy] Taking an apple!\n[take-an-apple] Actor: Lucy\n[take-an-apple] Apples Remaining: 4\n[juice-apple] Actor: John\n[juice-apple] Juicing Apple...\n</code></pre> <p>If you tried <code>(Detach juice-apple)</code> for Lucy too, you would notice that the juicing does not happen on Lucy's end. This is due to how <code>Detach</code> is scheduling the original Wire, and only one instance of it can be scheduled at any time. When John is using the juicer to make apple juice, Lucy cannot use it.</p> <p>Now say we have a large oven that bakes multiple apples concurrently. We can use <code>Spawn</code> to make clones of a <code>bake-apple</code> Wire that can be scheduled to run together.</p> CommandOutput <pre><code>(defmesh main)\n\n(defwire take-an-apple\n  = .name (Log \"Actor\")\n  (Setup 10 &gt;= .apples)\n  (Math.Dec .apples)\n  .apples (Log \"Apples Remaining\"))\n\n(defwire bake-apple\n  = .name (Log \"Actor\")\n  (Msg \"Baking Apple...\") (Pause 1)\n  (Msg \"Made a Baked Apple!\"))\n\n(defloop john\n  (Msg \"Taking an apple!\")\n  \"John\" (Do take-an-apple)\n  \"John\" (Spawn bake-apple))\n\n(defloop lucy\n  (Msg \"Taking an apple!\")\n  \"Lucy\" (Do take-an-apple))\n\n(schedule main john)\n(schedule main lucy)\n(run main 1 4)\n</code></pre> <pre><code>[john] Taking an apple!\n[take-an-apple] Actor: John\n[take-an-apple] Apples Remaining: 9\n[lucy] Taking an apple!\n[take-an-apple] Apples Remaining: 8\n[bake-apple-1] Actor: John\n[bake-apple-1] Baking Apple...\n[john] Taking an apple!\n[take-an-apple] Actor: John\n[take-an-apple] Apples Remaining: 7\n[lucy] Taking an apple!\n[take-an-apple] Actor: Lucy\n[take-an-apple] Apples Remaining: 6\n[bake-apple-2] Actor: John\n[bake-apple-2] Baking Apple...\n[john] Taking an apple!\n[take-an-apple] Actor: John\n[take-an-apple] Apples Remaining: 5\n[lucy] Taking an apple!\n[take-an-apple] Actor: Lucy\n[take-an-apple] Apples Remaining: 4\n[bake-apple-1] Made a Baked Apple!\n[bake-apple-2] Made a Baked Apple!\n[bake-apple-3] Actor: John\n[bake-apple-3] Baking Apple...\n[john] Taking an apple!\n[take-an-apple] Actor: John\n[take-an-apple] Apples Remaining: 3\n[lucy] Taking an apple!\n[take-an-apple] Actor: Lucy\n[take-an-apple] Apples Remaining: 2\n[bake-apple-2] Actor: John\n[bake-apple-2] Baking Apple...\n</code></pre> <p>If you added <code>(Spawn bake-apple)</code> for Lucy, you will notice that Lucy starts to bake apples along with John! Unlike <code>Detach</code>, you can have multiple instances of a spawned Wire running.</p> <p>Use cases for <code>Spawn</code> would include spawning the same projectile (such as bullets fired from a gun) or spawning monster mobs with many instances of one monster type.</p>"},{"location":"learn/shards/primer/the-flow/#start-resume","title":"Start / Resume","text":""},{"location":"learn/shards/primer/the-flow/#start","title":"Start","text":"<p><code>Start</code> scheduling a Wire to run on the same Mesh, in place of the current Wire.</p> <p>Start vs Detach</p> <p>Even though they both schedule a Wire onto the Mesh, <code>Start</code> will stop the current Wire to run the scheduled Wire. With <code>Detach</code>, the scheduled Wire will only run when its turn on the Mesh is up.</p> <p></p>"},{"location":"learn/shards/primer/the-flow/#resume","title":"Resume","text":"<p><code>Resume</code> will resume a suspended Wire from where it was last paused at.</p> <p>Note</p> <p>If <code>Resume</code> is used on a Wire that has not been scheduled yet, it will behave as <code>Start</code> would and schedule the Wire on the Mesh before starting it.</p> <p></p> <p><code>Start</code> and <code>Resume</code> are useful when managing different states.</p> <p>For example:</p> <ul> <li> <p>Your game <code>Start</code>s the player in Zone 1.</p> </li> <li> <p>When the player moves to Zone 2, you <code>Start</code> Zone 2's Wire.</p> </li> <li> <p>When the player returns to Zone 1, you <code>Resume</code> Zone 1's Wire.</p> </li> <li> <p>Any previous changes made by the player in Zone 1 would still persist.</p> </li> </ul> <p>In the example below, we use <code>Start</code> and <code>Resume</code> to toggle between John's and Lucy's turns. Note how <code>Resume</code> redirects the flow back to exactly where <code>john</code> was paused at.</p> CommandOutput <pre><code>(defmesh main)\n\n(defwire take-an-apple\n  (Setup 10 &gt;= .apples)\n  (Math.Dec .apples)\n  .apples (Log \"Apples Remaining\"))\n\n(defloop lucy\n  (Setup 0 &gt;= .apple-count)\n  (Msg \"Taking an apple!\")\n  (Do take-an-apple)\n  (Math.Inc .apple-count)\n\n  (When\n   :Predicate (-&gt; .apple-count (IsMore 2))\n   :Action\n   (-&gt; (Msg \"I have enough, you can have the rest.\")\n       (Resume)))) ;; (1)\n\n(defloop john\n  (Setup\n   (-&gt; (Msg \"Lucy, you can take as much as you want first.\")\n       (Start lucy) ;; (2)\n       (Msg \"It's my turn now!\")))\n  (Msg \"Taking an apple!\")\n  (Do take-an-apple))\n\n(schedule main john)\n(run main (/ 1 60) 6) ;; (3)\n</code></pre> <ol> <li>Returns the flow to the Wire that started it, which is <code>john</code> in this case.</li> <li>Starts the <code>lucy</code> Wire and redirects the program's flow to it.</li> <li><code>(/ 1 60)</code> is read as \"1 divided by 60\". It is used to get the program to run at 60 FPS (Frames Per Second).</li> </ol> <pre><code>[john] Lucy, you can take as much as you want first.\n[lucy] Taking an apple!\n[take-an-apple] Apples Remaining: 9\n[lucy] Taking an apple!\n[take-an-apple] Apples Remaining: 8\n[lucy] Taking an apple!\n[take-an-apple] Apples Remaining: 7\n[lucy] I have enough, you can have the rest.\n[john] It's my turn now!\n[john] Taking an apple!\n[take-an-apple] Apples Remaining: 6\n[john] Taking an apple!\n[take-an-apple] Apples Remaining: 5\n</code></pre>"},{"location":"learn/shards/primer/the-flow/#stop","title":"Stop","text":"<p><code>Stop</code> is used to end Wires. It is very useful for managing Wires created with <code>Detach</code> or <code>Spawn</code>. For example, if you have spawned multiple monsters, you could set them to <code>Stop</code> running once their health reaches 0.</p> <p>Note</p> <p>If <code>Stop</code> is used on a Wire that is running from <code>Start</code> or <code>Resume</code>, the Wire itself is stopped and the entire program will end.</p> <p></p> <p>For our example, we use <code>Stop</code> to end <code>bake-apple</code> looped Wires after they iterate twice.</p> CommandOutput <pre><code>(defmesh main)\n\n(defloop bake-apple\n  (Setup\n   (-&gt; (Msg \"Started Baking\")\n       0 &gt;= .timer))\n  (Math.Inc .timer)\n  .timer (Log \"Time Baked\")\n\n  (When\n   :Predicate (-&gt; .timer (Is 2))\n   :Action (-&gt;\n            (Msg \"Apple is Baked!\")\n            (Stop))))\n\n(defloop john\n  (Msg \"Baking Apple...\")\n  (Spawn bake-apple))\n\n(schedule main john)\n(run main 1 3)\n</code></pre> <pre><code>[john] Baking Apple...\n[bake-apple-1] Started Baking\n[bake-apple-1] Time Baked: 1\n[john] Baking Apple...\n[bake-apple-1] Time Baked: 2\n[bake-apple-1] Apple is Baked!\n[bake-apple-2] Started Baking\n[bake-apple-2] Time Baked: 1\n[john] Baking Apple...\n[bake-apple-2] Time Baked: 2\n[bake-apple-2] Apple is Baked!\n[bake-apple-1] Started Baking\n[bake-apple-1] Time Baked: 1\n</code></pre>"},{"location":"learn/shards/primer/the-flow/#step","title":"Step","text":"<p><code>Step</code> schedules and runs another Wire on the Wire calling <code>Step</code> itself. That is, if <code>X Step Y</code>, Y  is scheduled to run on X itself.</p> <p>Being scheduled on a Wire (instead of the Mesh) has a few implications:</p> <ol> <li> <p>The flow is different.</p> </li> <li> <p>It shares the same environment and scope as the Wire which stepped it.</p> </li> <li> <p>It can affect variables on the Wire which stepped it.</p> </li> </ol>"},{"location":"learn/shards/primer/the-flow/#flow-difference","title":"Flow Difference","text":"<p>The stepped Wire runs similarly to how <code>Do</code> does as the flow shifts into the stepped Wire immediately. It may seem like it is running inline too, but the difference is obvious when calling <code>Pause</code> on the stepped Wire.</p> <p>For <code>Do</code>, the flow is paused and resumed only after the pause is resolved. For <code>Step</code>, even though the stepped Wire is paused, the original Wire continues to run.</p> <p></p>"},{"location":"learn/shards/primer/the-flow/#shared-environment","title":"Shared Environment","text":"<p>Being scheduled on a Wire allows the stepped Wire to share the same scope and environment as the Wire which stepped it. This is especially useful when working with <code>UI</code> shards that can only exist within a single <code>GFX</code> window. The topic of <code>UI</code> and <code>GFX</code> is beyond the scope of this tutorial, but the general idea is that when implementing <code>UI</code> elements, they can only be stepped from the Wire that holds the <code>GFX.MainWindow</code> shard in your program.</p>"},{"location":"learn/shards/primer/the-flow/#shared-variables","title":"Shared Variables","text":"<p>Most of the methods described in this chapter will \"snapshot\" the variables of the Wire that called it. That is:</p> <ul> <li> <p>Variables existing in the caller Wire will be copied and made available to the callee Wire.</p> </li> <li> <p>Changes made to variable copies will not be reflected on the original variables.</p> </li> </ul> <p><code>Step</code> is unique in the sense that it has access to the original variables. Changes made to variables from the Wire that called it will persist.</p>"},{"location":"learn/shards/primer/the-flow/#example","title":"Example","text":"<p>In the example below, we demonstrate how the main Looped Wired <code>john</code> continues to run even when the Wire <code>bake-apple</code> is paused after stepping into it. <code>bake-apple</code> cannot be stepped into again when it is paused due to how it is still running.</p> <p>The example also showcases how variables defined in <code>john</code> are affected by changes made to it by the stepped Wires.</p> CommandOutput <pre><code>(defmesh main)\n\n(defwire take-an-apple ;; (1)\n  (Math.Inc .fresh-apples)\n  (Msg \"Taking an apple...\")\n  .fresh-apples (Log \"Fresh Apple (+1)\"))\n\n(defwire bake-apple ;; (2)\n  (Math.Dec .fresh-apples)\n  (Msg \"Baking apple...\")\n  .fresh-apples (Log \"Fresh Apple (-1)\")\n  (Pause 1)\n  (Math.Inc .baked-apples)\n  (Msg \"Baking complete!\")\n  .baked-apples (Log \"Baked Apple (+1)\"))\n\n(defloop john\n  (Setup\n   5 &gt;= .fresh-apples\n   0 &gt;= .baked-apples)\n\n  (Step take-an-apple)\n  (Step bake-apple))\n\n(schedule main john)\n(run main 1 5)\n</code></pre> <ol> <li>This Wire increases the value of <code>.fresh-apples</code> every time it is stepped into.</li> <li>This Wire decreases the value of <code>.fresh-apples</code>, pauses the Wire for 1 second, and increases the value of <code>.baked-apples</code> every time it is stepped into.</li> </ol> <pre><code>[take-an-apple] Taking an apple...\n[take-an-apple] Fresh Apple (+1): 6\n[bake-apple] Baking apple...\n[bake-apple] Fresh Apple (-1): 5\n[take-an-apple] Taking an apple...\n[take-an-apple] Fresh Apple (+1): 6\n[bake-apple] Baking complete!\n[bake-apple] Baked Apple (+1): 1\n[take-an-apple] Taking an apple...\n[take-an-apple] Fresh Apple (+1): 7\n[bake-apple] Baking apple...\n[bake-apple] Fresh Apple (-1): 6\n[take-an-apple] Taking an apple...\n[take-an-apple] Fresh Apple (+1): 7\n[take-an-apple] Taking an apple...\n[take-an-apple] Fresh Apple (+1): 8\n[bake-apple] Baking complete!\n[bake-apple] Baked Apple (+1): 2\n</code></pre>"},{"location":"learn/shards/primer/the-flow/#branch","title":"Branch","text":"<p><code>Branch</code> is used when you wish to create a Submesh on the current Mesh. You can schedule Wires on the Submesh by placing Wires in its <code>Wires</code> parameter. These Wires will behave as if they were run with <code>Step</code>.</p> Syntax <pre><code>(Branch [wire-x wire-y wire-z]) ;; (1)\n</code></pre> <ol> <li>You can schedule as many Wires as you wish within the square brackets here. In this example, three Wires are scheduled on the Submesh.</li> </ol>"},{"location":"learn/shards/primer/the-flow/#expand","title":"Expand","text":"<ul> <li> <p>Creates and schedules copies of a Wire.</p> </li> <li> <p>Returns an array of the output from all the copies.</p> </li> </ul> <p><code>Expand</code> is useful when you need to run code in bulk. The results produced can then be evaluated, which is useful in Machine Learning for example.</p> Multithreading with <code>Expand</code> <p>Simple programs are usually run on a single thread. You can think of a thread as a thought process. For a Computer to be able to \"multitask\", they require multiple threads.</p> <p><code>Expand</code> has the parameter <code>Threads</code> which allows you to specify the number of threads to use. Multithreading can improve performance when attempting to <code>Expand</code> a Wire to a large size.</p> <p>In our example below, we will be using <code>Expand</code> to teach John about multiplication with zeros.</p> CommandOutput <pre><code>(defmesh main)\n\n(defwire learn-zero-multiplication\n  (Expand\n   :Size 100 ;; (1)\n   :Wire (defwire zero-multiplication\n           (RandomInt :Max 100)(Math.Multiply 0))) ;; (2)\n  (ForEach (-&gt; (Is 0)(Log)))) ;; (3)\n\n(defwire john\n  (Do learn-zero-multiplication))\n\n(schedule main john)\n(run main)\n</code></pre> <ol> <li>Creates and runs 100 copies of the Wire <code>zero-multiplication</code>.</li> <li>Generates a random number from 0 to 99 and multiplies it with 0.</li> <li><code>Expand</code> outputs an array of the results. We use <code>ForEach</code> to check if each result <code>Is</code> 0.</li> </ol> <pre><code>[learn-zero-multiplication] true\n[learn-zero-multiplication] true\n[learn-zero-multiplication] true\n[learn-zero-multiplication] true\n...\n</code></pre>"},{"location":"learn/shards/primer/the-flow/#trymany","title":"TryMany","text":"<ul> <li> <p>Takes a sequence as input.</p> </li> <li> <p>Creates a clone of a Wire for each entry in the sequence.</p> </li> </ul> <p><code>TryMany</code> can be used to check for values that would achieve the result desired. This is useful in Machine Learning for example, as it teaches your program how it can achieve a result by using specific values.</p> <p><code>TryMany</code> has a <code>Policy</code> parameter that takes a value of <code>WaitUntil</code>. The value used determines the output <code>TryMany</code> produces.</p> <p>There are three variations of <code>WaitUntil</code>:</p> <ol> <li> <p><code>WaitUntil.FirstSuccess</code> - Will output the result of the first successful Wire copy and ignores the rest.</p> </li> <li> <p><code>WaitUntil.AllSuccess</code> - Will only output all the results if all Wire copies are successful. If one Wire fails, no output is produced.</p> </li> <li> <p><code>WaitUntil.SomeSuccess</code> - Will wait for all Wire copies to run, but will only output the successful results.</p> </li> </ol> <p>In the following examples, John attempts to hit a moving target by firing arrows at it. He can only land a hit if the <code>.distance-shot</code> is an odd number. Note how the results vary based on the <code>Policy</code> used.</p> FirstSuccessOutputAllSuccessOutputSomeSuccessOutput <pre><code>(defmesh main)\n\n(defwire fire-arrow\n  [1, 2, 3]\n  (TryMany\n   :Wire (defwire check-for-hit\n           &gt;= .distance-shot\n           (Math.Mod 2) ;; (2)\n           (Assert.Is 1 false)\n           .distance-shot)\n   :Policy WaitUntil.FirstSuccess) ;; (1)\n  (Log \"Hits the mark\"))\n\n(defwire john\n  (Do fire-arrow))\n\n(schedule main john)\n(run main)\n</code></pre> <ol> <li>Only the first successful result will be used as output. Once a Wire is successful, the rest are ignored.</li> <li>Odd numbers will have a remainder of 1 when divided by 2. We use <code>Math.Mod</code> to get the remainder from the division.</li> </ol> <pre><code>[fire-arrow] Hits the mark: 1\n</code></pre> <pre><code>(defmesh main)\n\n(defwire fire-arrow\n  [1, 2, 3]\n  (TryMany\n   :Wire (defwire check-for-hit\n           &gt;= .distance-shot\n           (Math.Mod 2)\n           (Assert.Is 1 false)\n           .distance-shot)\n   :Policy WaitUntil.AllSuccess) ;; (1)\n  (Log \"Hits the mark\"))\n\n(defwire john\n  (Do fire-arrow))\n\n(schedule main john)\n(run main)\n</code></pre> <ol> <li>All results will be produced in the output, but only if all Wires are successful.</li> </ol> <pre><code>;; No result is obtained as the condition for WaitUntil.AllSuccess was not achieved.\n;; The Wire with a .distance-shot of 2 would fail the Assert checks.\n</code></pre> <pre><code>(defmesh main)\n\n(defwire fire-arrow\n  [1, 2, 3]\n  (TryMany\n   :Wire (defwire check-for-hit\n           &gt;= .distance-shot\n           (Math.Mod 2) ;; (2)\n           (Assert.Is 1 false)\n           .distance-shot)\n   :Policy WaitUntil.SomeSuccess) ;; (1)\n  (Log \"Hits the mark\"))\n\n(defwire john\n  (Do fire-arrow))\n\n(schedule main john)\n(run main)\n</code></pre> <ol> <li>Only the successful results will be produced as output after all Wires have been executed.</li> </ol> <pre><code>[fire-arrow] Hits the mark: [1, 3]\n</code></pre> Multithreading with <code>TryMany</code> <p><code>TryMany</code> has the additional parameters of <code>Threads</code> and <code>Coroutines</code> which allow it to work better with a very large input. A large input means that it has a large number of Wire copies to run.</p> <p><code>Threads</code> will determine the number of Wires that <code>TryMany</code> can run at the same time, while <code>Coroutines</code> determines the maximum number of Wires running together on each thread at any point in time.</p> <p>Using <code>Threads</code> and <code>Coroutines</code> helps to split the work and makes your program runs more efficiently.</p> <p>Congratulations! You have now learned new methods of executing and scheduling Wires, which gives you better control of the Flow of Shards. The possibilities of what you can create with Shards just got much wider with this newfound knowledge!</p> <p>In the next chapter, we will take a look at what working with data in Shards is like.</p>"},{"location":"learn/shards/primer/the-flow/#summary","title":"Summary","text":"Shard Uses Original Variables? Restarts Wire? Continues Loop? 1 Instance per run? Do Yes No Yes Yes Detach No Yes Yes Yes Spawn No Yes Yes No Start No Yes No No Resume No Yes Yes Yes Step Yes Yes Yes Yes StepMany Yes Yes Yes No Branch Yes No Yes Yes Expand Yes Yes Yes No TryMany Yes Yes Yes No"},{"location":"learn/shards/primer/what-is-shards/","title":"What is Shards","text":"<p>Before we delve into the intricacies of Shards, let's familiarize ourselves with its fundamental concepts.</p>"},{"location":"learn/shards/primer/what-is-shards/#the-shard","title":"The shard","text":"<p>The basic building block of the Shards programming language is called a shard (with a lowercase \u2018s\u2019).</p> <p>A shard can receive an input, do work on that input, and produce an output.</p> <p></p> <p>Every shard has a role and is usually named after it. For example, the shard <code>Math.Add</code> takes a number as an input, adds a specified value to it and outputs the result.</p> <p></p> <p>Shards can be grouped up to form another shard. </p> <p>For example, you might have a <code>meow</code> shard that prints a \"meow\" to the user's screen, and a <code>mew</code> shard that prints a \"mew\" instead. </p> <p></p> <p>If you wanted your program to be able to make cat noises, you might have a bunch of <code>meow</code> and <code>mew</code> shards... which could end up being rather cluttered:</p> <p></p> <p>To keep our work organized, we can group shards up to form a new shard. In our example, we can create a new <code>meows</code> shard that is made up of a few <code>meow</code> shards, and create a <code>mews</code> shard for our <code>mew</code> shards.</p> <p></p> <p>When our shards are grouped up into logical segments, our program becomes more readable and orderly.</p> <p></p>"},{"location":"learn/shards/primer/what-is-shards/#the-wire","title":"The Wire","text":"<p>In the flow of a Shards program, each shard is queued for execution and will be run in the order they are presented in. The order goes from left to right, top to bottom.</p> <p>When shards are queued, they form a sequence know as a Wire.</p> <p></p> <p>Wires can be set to be loopable. This is called a Looped Wire.</p> <p></p> <p>You may look at this and wonder - is this the same as grouping shards together? When shards are grouped up to form a new shard, they are still executed from left to right, top to bottom after all.</p> <p>The answer is... no! A Wire is not the same as a shard containing shards. </p> <p>A Wire queues shards for a purpose, while grouping shards up are for organization. In the earlier example, we were trying to create a program that makes cat noises. We can achieve that by queueing our shards in a Wire named <code>make-cat-noises</code>.</p> <p></p> <p>Whenever we want our program to produce cat noises, we would call the <code>make-cat-noises</code> Wire. A Wire is similar to what we call a function in traditional programming languages.</p> What is a function? <p>It is a block of code that can be reused over and over again.</p> <p>It allows you to reuse code without writing out the same block of code each time by calling the function's name instead.</p> <p>Think of shards as the different components of your program, while Wires are the lifeblood connecting the many different shards in your program, creating a Flow.</p> <p>By mastering the usage of Wires, the possibilities of what you can achieve are endless!</p> <p></p>"},{"location":"learn/shards/primer/what-is-shards/#the-mesh","title":"The Mesh","text":"<p>In order to actually run shards, we have to schedule Wires on a Mesh. Multiple Wires can be scheduled, and they will be run in the order that they are scheduled in.</p> <p>After scheduling our Wires, we can finally run the Mesh... and that is when Shards comes to life!</p> <p></p> <p>Note</p> <p>If the scheduling of Wires seems rigid to you, fret not! We will be learning more about manipulating the flow of Shards later.</p> <p>Now that you have a basic understanding of what Shards is, let us take a look at how coding with Shards work.</p> <p> </p>"},{"location":"learn/shards/primer/working-with-data/","title":"Working with Data","text":"<p>Now that you have learned to code with Shards and mastered the program flow, let us round off this series of primers by taking a look at how data works in Shards.</p>"},{"location":"learn/shards/primer/working-with-data/#scope","title":"Scope","text":""},{"location":"learn/shards/primer/working-with-data/#local-and-global","title":"Local and Global","text":"<p>Scope determines the visibility of data at different points in your program. When data is assigned to variables, these variables will either have a local or global scope.</p> <ul> <li> <p>Local: The variable is only known within the Wire it originated from.</p> </li> <li> <p>Global: The variable is known throughout the entire Mesh.</p> </li> </ul> <p>In the example below, the Wire <code>get-x</code> attempts to retrieve the value of <code>.x</code> defined in the Wire <code>define-x</code>. Note how it can retrieve the value of 1 even though it was defined in a separate Wire. This is due to how <code>.x</code> has been defined as a global variable, making its value available to all Wires on the Mesh.</p> CommandOutput <pre><code>(defmesh main)\n\n(defwire get-x\n  (Get .x :Default 0) (Log \"x\"))\n\n(defwire define-x\n  1 &gt;== .x) ;; (1)\n\n(schedule main define-x)\n(schedule main get-x)\n(run main)\n</code></pre> <ol> <li><code>&gt;==</code> is the alias for the <code>Set</code> shard, with the parameter <code>Global</code> set to true. This makes <code>.x</code> a global variable.</li> </ol> <pre><code>[get-x] x: 1\n</code></pre> <p>For the following example, <code>get-x</code> fails to retrieve the value of <code>.x</code> defined in <code>define-x</code> and returns the default value of 0. This is due to how <code>.x</code> was locally defined within the Wire <code>define-x</code> and cannot be accessed by other Wires separate from it.</p> CommandOutput <pre><code>(defmesh main)\n\n(defwire get-x\n  (Get .x :Default 0) (Log \"x\"))\n\n(defwire define-x\n  1 &gt;= .x) ;; (1)\n\n(schedule main define-x)\n(schedule main get-x)\n(run main)\n</code></pre> <ol> <li><code>&gt;=</code> is the alias for the <code>Set</code> shard, with the parameter <code>Global</code> set to false. This makes <code>.x</code> a local variable.</li> </ol> <pre><code>[get-x] x: 0\n</code></pre>"},{"location":"learn/shards/primer/working-with-data/#flow-methods","title":"Flow Methods","text":"<p>If Wire Y is run from a separate Wire X using methods such as <code>Detach</code>, the variables on Wire X will be copied such that Y has access to its value at the moment it was called.</p> <p>However, this does not mean that Wire Y is in the same scope as X. Wire Y holds only a copy of the value - it does not have access to the actual variable.</p> <p>If a method such as <code>Step</code> is used instead, Wire Y would be scheduled on Wire X itself, giving it the same scope and access to X's actual variables.</p> DetachOutputStepOutput <pre><code>(defmesh main)\n\n(defwire wire-y\n  12 &gt; .x (Log)) ;; (1)\n\n(defloop wire-x\n  (Setup 0 &gt;= .x)\n  .x (Log)\n  (Detach wire-y))\n\n(schedule main wire-x)\n(run main 1 2)\n</code></pre> <ol> <li><code>.x</code> here is a copy of the original variable in <code>wire-x</code>. It was snapshotted when <code>Detach wire-y</code> was called.</li> </ol> <pre><code>[wire-x] 0\n[wire-y] 12\n[wire-x] 0\n[wire-y] 12\n</code></pre> <pre><code>(defmesh main)\n\n(defwire wire-y\n  12 &gt; .x (Log)) ;; (1)\n\n(defloop wire-x\n  (Setup 0 &gt;= .x)\n  .x (Log)\n  (Step wire-y))\n\n(schedule main wire-x)\n(run main 1 2)\n</code></pre> <ol> <li><code>.x</code> here is the original variable from <code>wire-x</code>. This is due to how <code>Step</code> results in <code>wire-y</code> existing in the same scope as <code>wire-x</code>.</li> </ol> <pre><code>[wire-x] 0\n[wire-y] 12\n[wire-x] 12\n[wire-y] 12\n</code></pre> <p></p>"},{"location":"learn/shards/primer/working-with-data/#pure-wires","title":"Pure Wires","text":"<p>Pure Wires are Wires that exist in their scope. When run from another Wire, they do not copy that Wire's variables.</p> <p>To create a Pure Wire, we use <code>defpure</code>.</p> Syntax <pre><code>(defpure wire-name\n  ;; your shards here\n  )\n</code></pre> <p>In the example below, you can see how using <code>Step</code> on a Pure Wire still does not give it access to the parent Wire's variables.</p> CommandOutput <pre><code>(defmesh main)\n\n(defwire unpure-wire\n  (Get .x :Default 0) (Log))\n\n(defpure pure-wire\n  (Get .x :Default 0) (Log))\n\n(defwire main-wire\n  5 &gt;= .x\n  (Step unpure-wire)\n  (Step pure-wire))\n\n(schedule main main-wire)\n(run main)\n</code></pre> <pre><code>[unpure-wire] 5\n[pure-wire] 0\n</code></pre>"},{"location":"learn/shards/primer/working-with-data/#defined-constants","title":"Defined Constants","text":"<p>If you define a constant in your program, it will have a global scope and can be accessed by any Wire in your program.</p> CommandOutput <pre><code>(defmesh main)\n\n(def x 1)\n\n(defwire get-x\n  x (Log \"x\"))\n\n(schedule main get-x)\n(run main)\n</code></pre> <pre><code>[get-x] x: 1\n</code></pre> <p>Note</p> <p>Note that the constant <code>x</code> defined in the example above is named differently from variables, which would have been <code>.x</code> in this case.</p>"},{"location":"learn/shards/primer/working-with-data/#passthrough","title":"Passthrough","text":"<p>Passthrough determines if data can pass through shards unaltered. It allows you to better control the state of the data moving through your program.</p> <p>Most shards take in data, process the data, and output the results. To allow data to emerge from these shards unaltered, we can employ the shard <code>SubFlow</code>. <code>SubFlow</code> saves the initial value passed in, and outputs the saved value at the end. Any shards passed into the <code>Shards</code> parameter of <code>SubFlow</code> will run as per usual, except that the final output will be replaced with the initial input passed into <code>SubFlow</code>, thereby creating a passthrough effect.</p> <p><code>SubFlow</code> has an alias <code>|</code> which eliminates the need for <code>-&gt;</code> to group shards when passed into its <code>Shards</code> parameter.</p> SubFlow ExampleSubFlow Example with |Output <pre><code>(defmesh main)\n\n(defwire sub-test\n  1 &gt;= .x (Log \"Before SubFlow\")\n  (SubFlow\n   :Shards\n   (-&gt; (Math.Add 2) &gt; .x\n       .x (Log \"In SubFlow\")))\n  (Log \"After SubFlow\"))\n\n(schedule main sub-test)\n(run main)\n</code></pre> <pre><code>(defmesh main)\n\n(defwire sub-test\n  1 &gt;= .x (Log \"Before SubFlow\")\n  (|(Math.Add 2) &gt; .x\n    .x (Log \"In SubFlow\"))\n  (Log \"After SubFlow\"))\n\n(schedule main sub-test)\n(run main)\n</code></pre> <pre><code>[sub-test] Before SubFlow: 1\n[sub-test] In SubFlow: 3\n[sub-test] After SubFlow: 1\n</code></pre> <p>In the example below, John wishes to check the price of an apple in different currencies. The base price of 1 USD is passed into a Wire and goes through a series of shards that each performs mathematical operations on it to obtain its foreign value.</p> <p>To keep the initial value unchanged as it passes through the different shards, a passthrough is required.</p> <p></p> <p>Without passthrough, the data passed in at the start of the Wire gets altered each time it passes through a shard that transforms its value.</p> <p></p>"},{"location":"learn/shards/primer/working-with-data/#specific-data-types","title":"Specific Data Types","text":"<p>Some shards can only accept specific data types and will require you to either:</p> <ul> <li> <p>Explicitly declare the types of dynamic output types,</p> </li> <li> <p>Or convert data to the required data type.</p> </li> </ul>"},{"location":"learn/shards/primer/working-with-data/#dynamic-output-types","title":"Dynamic Output Types","text":"<p>You do not have to declare the data types of most data in Shards. Shards can smartly infer and determine the data types when it is run, thereby removing the hassle of having to explicitly specify data types.</p> <p>However, when data is output dynamically, you are still required to declare its data type as it cannot be determined easily. Examples would include data output from the shards <code>FromBytes</code> and <code>FromJson</code>.</p> <p>You will also have to declare data types when trying to <code>Take</code> from a mixed type Sequence.</p> <p>To declare a data type, you can use \"Expect\" shards to indicate the type of incoming data. Examples of \"Expect\" shards are ExpectInt and ExpectString.</p>"},{"location":"learn/shards/primer/working-with-data/#converting-types","title":"Converting Types","text":"<p>When you have to convert data's type to allow for it to be used by shards, you can employ type conversion shards such as <code>ToString</code> and <code>ToInt</code>.</p> <p>In the example below, <code>String.Join</code> retrieves elements in a sequence and combines them. It only accepts strings and will throw an error if the sequence passed into it contains non-strings. To get <code>String.Join</code> to use integer values to form a sentence, the integer will have to be converted to a string first.</p> ToStringOutput <pre><code>(defmesh main)\n\n(defwire wire\n  2 (ToString) &gt;= .num-of-apples\n  [\"John has \" .num-of-apples \" apples.\"](String.Join)(Log))\n\n(schedule main wire)\n(run main)\n</code></pre> <pre><code>[wire] John has 2 apples.\n</code></pre> <p>Congratulations on making it to the end of the primer series! You are now equipped with the fundamentals that will allow you to start creating amazing things with Shards.</p> <p>If you are still lost and unsure of where to go from here, why not take a look at our tutorials to have a taste of what you could potentially create with Shards?</p>"},{"location":"learn/shards/tutorials/","title":"Index","text":""},{"location":"learn/shards/tutorials/#tutorials","title":"Tutorials","text":"<p>These tutorials will help you to get familiar with programming in Shards and give you a glimpse of what you can create with it. Note that these are simplified examples to better convey basic concepts and ideas - you can definitely achieve much more beyond what these tutorials provide! </p>"},{"location":"learn/shards/tutorials/#prerequisites","title":"Prerequisites","text":"<p>Ensure that your development environment is set up and that you have Shards downloaded before attempting these tutorials.</p> Snake Game Yes-No Game Glod Game <p>More to come. Stay tuned!</p> <p> </p> <p>Built on Oct 24, 2024 at 21:08:41 from commit 9f51be4.</p>"},{"location":"learn/shards/tutorials/glod-game/","title":"Glod Game Tutorial","text":"<p>Hello there! In this tutorial, we will be making a 2D point collection game using Shards.</p> <p>This tutorial assumes that you have a basic understanding of Shards. In order to run the code examples used here, you are required to have Shards installed. </p> <p>For more information, check out the following links:</p> <ol> <li> <p>The Basics of Shards</p> </li> <li> <p>Install Shards</p> </li> </ol>"},{"location":"learn/shards/tutorials/glod-game/#key-concepts","title":"Key Concepts","text":"<p>Here are the key concepts that we will be covering in this tutorial:</p> <ol> <li> <p>How to draw a character image on the screen</p> </li> <li> <p>How to animate a character using an image array</p> </li> <li> <p>How to move a character using button inputs</p> </li> <li> <p>Controlling flow, using Step</p> </li> <li> <p>Setting up a scoring system</p> </li> </ol> <p>You can either follow the step-by-step guide or jump directly to the full game.</p> <ul> <li> <p>Introduction</p> </li> <li> <p>Step by step</p> </li> <li> <p>Full game</p> </li> </ul> <p> </p>"},{"location":"learn/shards/tutorials/glod-game/introduction/","title":"Introduction","text":""},{"location":"learn/shards/tutorials/glod-game/introduction/#gameplay","title":"Gameplay","text":"<p>In this game, players will enter the world of Glod - a charming and lovable character with a passion for collecting coins. Players have 60 seconds to collect as many coins as they can while dodging spiked balls that fall from the sky.</p> <p> </p>"},{"location":"learn/shards/tutorials/glod-game/full-game/","title":"Full game","text":"EDN glodgame.edn<pre><code>(defshards LoadTexture [name]\n  (LoadImage name)\n  (GFX.Texture))\n\n(defshards initialize-character []\n  (LoadTexture \"GlodImages/Character1_Jumping_Left.png\") = .character-jumping-left\n  (LoadTexture \"GlodImages/Character1_Jumping_Right.png\") = .character-jumping-right\n\n  0 &gt;= .character-state\n  0 &gt;= .character-direction\n  true &gt;= .can-jump\n\n  0.0 &gt;= .X\n  620.0 &gt;= .Y\n  (float2 .X .Y) &gt;= .character-position\n  0.0 &gt;= .character-x-velocity\n  0.0 &gt;= .character-y-velocity\n  0.0 &gt;= .character-y-acceleration\n\n  ;; ---------- Character Idle Array (Facing Left) ----------\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png\") &gt;&gt; .idle-left-image-array\n\n  ;; ---------- Character Idle Array (Facing Right) ----------------\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_1.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_2.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_3.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_4.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_5.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_6.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_7.png\") &gt;&gt; .idle-right-image-array\n\n  0 &gt;= .idle-image-index\n  (Count .idle-left-image-array) = .idle-image-index-max\n  0.08 = .idle-animation-speed\n\n  ;; -------------- Walking Array (Facing Left) -----------------\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_1.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_2.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_3.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_4.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_5.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_6.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_7.png\") &gt;&gt; .walking-left-image-array\n\n  ;; ----------- Walking Array (Facing Right) ---------------\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_1.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_2.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_3.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_4.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_5.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_6.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_7.png\") &gt;&gt; .walking-right-image-array\n\n  (Count .walking-left-image-array) = .walking-image-index-max\n  0 &gt;= .walking-image-index\n  0.08 = .walking-animation-speed) ;; Reduce number to increase animation speed\n\n;; --------- Idle Animation Loop ---------\n(defloop idle-animation\n  .idle-image-index (Math.Add 1)\n  &gt; .idle-image-index\n  (When :Predicate (IsMoreEqual .idle-image-index-max)\n        :Action (-&gt; 0 &gt; .idle-image-index))\n  (Pause .idle-animation-speed))\n\n;; -------- Walking Animation Loop --------\n(defloop walking-animation\n  .walking-image-index (Math.Add 1)\n  &gt; .walking-image-index\n  (When :Predicate (IsMoreEqual .walking-image-index-max)\n        :Action (-&gt; 0 &gt; .walking-image-index))\n  (Pause .walking-animation-speed))\n\n;; ---------- character-boundary ------------\n\n(defshards clamp [var min max]\n  var (Max min) (Min max) &gt; var)\n\n;; ------------ Character Run Logic ----------------\n(defshards run-logic []\n  .X (Math.Add .character-x-velocity)\n  &gt; .X\n\n  (float2 .X .Y) &gt; .character-position\n\n  (clamp .X -600.0 600.0))\n\n;; ------------ Character gravity-logic ---------------\n(defshards gravity-logic []\n  .Y (Math.Add .character-y-velocity)\n  &gt; .Y\n\n  .character-y-velocity (Math.Add .character-y-acceleration)\n  &gt; .character-y-velocity\n\n  (float2 .X .Y) &gt; .character-position\n\n  (clamp .Y -620.0 620.0)\n  .Y\n  (When :Predicate (IsMoreEqual 620.0)\n        :Action (-&gt;\n                 0.0 &gt; .character-y-velocity\n                 0.0 &gt; .character-y-acceleration\n                 true &gt; .can-jump\n                 .character-state\n                 (When :Predicate (Is 3)\n                       :Action (-&gt;\n                                0 &gt; .character-state)))))\n\n;; ------- Button Inputs ----------\n(defshards button-inputs []\n  (Inputs.KeyDown\n   :Key \"left\"\n   :Action (-&gt;\n            (Msg \"left\")\n\n            .character-state\n            (When :Predicate (Is 0)\n                  :Action (-&gt; 1 &gt; .character-state))\n\n            0 &gt; .character-direction\n            -5.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyDown\n   :Key \"right\"\n   :Action (-&gt;\n            (Msg \"right\")\n\n            .character-state\n            (When :Predicate (Is 0)\n                  :Action (-&gt; 2 &gt; .character-state))\n            1 &gt; .character-direction\n            5.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyDown\n   :Key \"up\"\n   :Action (-&gt;\n            (Msg \"up\")\n            3 &gt; .character-state\n            .can-jump\n            (When :Predicate (Is true)\n                  :Action (-&gt;\n                           -20.0 &gt; .character-y-velocity\n                           1.0 &gt;  .character-y-acceleration\n                           false &gt;= .can-jump))))\n\n  (Inputs.KeyUp\n   :Key \"left\"\n   :Action (-&gt;\n            0 &gt; .character-state\n            0.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyUp\n   :Key \"right\"\n   :Action (-&gt;\n            0 &gt; .character-state\n            0.0 &gt; .character-x-velocity)))\n\n;; -------------- Initialize Coin ----------\n(defshards initialize-coin []\n  (LoadTexture \"GlodImages/Coin/Coin_1.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_2.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_3.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_4.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_5.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_6.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_7.png\") &gt;&gt; .coin-image-array\n  (Count .coin-image-array) = .coin-image-index-max\n  0 &gt;= .coin-image-index\n  0.1 = .coin-animation-speed\n\n  ;; ----- Coin 1 ------\n  0.0 &gt;= .coinx-1\n  0.0 &gt;= .coiny-1\n  (float2 .coinx-1 .coiny-1) &gt;= .coin-position-1\n  0.0 &gt;= .coin-velocity-1\n  0.5 &gt;= .coin-acceleration\n\n  ;; ----- Coin 2 ----\n  0.0 &gt;= .coinx-2\n  0.0 &gt;= .coiny-2\n  (float2 .coinx-2 .coiny-2) &gt;= .coin-position-2\n  0.0 &gt;= .coin-velocity-2)\n\n;; -------------- Coin Animation ------------------\n(defloop coin-animation\n  .coin-image-index (Math.Add 1)\n  &gt; .coin-image-index\n  (When :Predicate (IsMoreEqual .coin-image-index-max)\n        :Action (-&gt; 0 &gt; .coin-image-index))\n\n  (Pause .coin-animation-speed))\n\n;; ------------- Coin Gravity ------------------\n(defshards coin-gravity-logic [coiny coinx coin-velocity coin-position]\n\n  coiny (Math.Add coin-velocity)\n  &gt; coiny\n\n  coin-velocity (Math.Add .coin-acceleration)\n  &gt; coin-velocity\n\n  (float2 coinx coiny) &gt; coin-position)\n\n;; ------------- Random Coin ------------------\n(defshards random-coin [coinx coiny coin-velocity coin-position pause-length]\n  coinx\n  (RandomFloat :Max 1200.0)\n  &gt; coinx\n  (Math.Subtract 600.0)\n  &gt; coinx\n\n  0.0 &gt; coiny\n  0.0 &gt; coin-velocity\n  (float2 coinx coiny) &gt; coin-position\n  (Pause pause-length))\n\n(defloop random-coin-1\n  (random-coin .coinx-1 .coiny-1 .coin-velocity-1 .coin-position-1 1.5))\n\n(defloop random-coin-2\n  (random-coin .coinx-2 .coiny-2 .coin-velocity-2 .coin-position-2 2.5))\n\n;; ------------ Initialize Spiked CanonBalls ---------------\n(defshards initialize-spiked-canonballs []\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall1.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall2.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall3.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall4.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall5.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall6.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall7.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall8.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall9.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall10.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall11.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall12.png\") &gt;&gt; .spikeball-array\n\n  (Count .spikeball-array) = .spikeball-array-index-max\n  0 &gt;= .spikeball-index\n  0.06 = .spikeball-animation-speed\n\n  ;; ---------- spikball-1 -------------\n  1.0 &gt;= .spikeball-velocity-1\n  0.0 &gt;= .spikeball-y-1\n  0.0 &gt;= .spikeball-x-1\n  (float2 .spikeball-x-1 .spikeball-y-1) &gt;= .spikeball-position-1\n\n  ;; ---------- spikeball-2 -------------\n  1.0 &gt;= .spikeball-velocity-2\n  0.0 &gt;= .spikeball-y-2\n  0.0 &gt;= .spikeball-x-2\n  (float2 .spikeball-x-2 .spikeball-y-2) &gt;= .spikeball-position-2\n\n;; ---------- SpikeBall_3 -------------\n  1.0 &gt;= .spikeball-velocity-3\n  0.0 &gt;= .spikeball-y-3\n  0.0 &gt;= .spikeball-x-3\n  (float2 .spikeball-x-3 .spikeball-y-3) &gt;= .spikeball-position-3\n\n  0.5 &gt;= .spikeball-acceleration)\n\n;;------------- Spiked CanonBall Animation -------------\n(defloop spiked-canonball-animation\n  .spikeball-index (Math.Add 1)\n  &gt; .spikeball-index\n  (When :Predicate (IsMoreEqual .spikeball-array-index-max)\n        :Action (-&gt; 0 &gt; .spikeball-index))\n\n  (Pause .spikeball-animation-speed))\n\n;; ------------- SpikeBall_Gravity_Logic -------------\n(defshards spikeball-gravity-logic [spikeball-y spikeball-velocity spikeball-position spikeball-x]\n  spikeball-y (Math.Add spikeball-velocity)\n  &gt; spikeball-y\n  spikeball-velocity (Math.Add .spikeball-acceleration)\n  &gt; spikeball-velocity\n  (float2 spikeball-x spikeball-y) &gt; spikeball-position)\n\n;; ------------- Randomise Spikeball ----------------\n(defshards randomise-spikeball [spikeball-x spikeball-y spikeball-velocity spikeball-position pausefloat]\n  spikeball-x\n  (RandomFloat :Max 1200.0)\n  &gt; spikeball-x\n  (Math.Subtract 600.0)\n  &gt; spikeball-x\n\n  0.0 &gt; spikeball-y\n  0.0 &gt; spikeball-velocity\n  (float2 spikeball-x spikeball-y) &gt; spikeball-position\n  .spikeball-x-1\n  (Pause pausefloat))\n\n(defloop spikeball-1\n  (randomise-spikeball .spikeball-x-1 .spikeball-y-1 .spikeball-velocity-1 .spikeball-position-1 2))\n(defloop spikeball-2\n  (randomise-spikeball .spikeball-x-2 .spikeball-y-2 .spikeball-velocity-2 .spikeball-position-2 3))\n(defloop spikeball-3\n  (randomise-spikeball .spikeball-x-3 .spikeball-y-3 .spikeball-velocity-3 .spikeball-position-3 4))\n\n;; --------- Game Elements ------------\n(defshards initialize-game-elements []\n  ;;------------ Scoring Limits ----------\n  0 &gt;= .score\n  false &gt;= .scored\n\n  .X (Math.Add 50.0)\n  &gt;= .scoringUpper-x-limit\n  .X (Math.Subtract 50.0)\n  &gt;= .scoringLower-x-limit\n\n  .Y (Math.Add 10.0)\n  &gt;= .scoringUpper-y-limit\n  .Y (Math.Subtract 10.0)\n  &gt;= .scoringLower-y-limit\n\n  ;; ---------- Damage Limits ------------\n  .X (Math.Add 50.0)\n  &gt;= .damageUpper-x-limit\n  .X (Math.Subtract 50.0)\n  &gt;= .damageLower-x-limit\n\n  .Y (Math.Add 5.0)\n  &gt;= .damageUpper-y-limit\n  .Y (Math.Subtract 5.0)\n  &gt;= .damageLower-y-limit\n\n  false &gt;= .damaged\n\n  60 &gt;= .timer\n  0 &gt;= .gameOver)\n\n;; --------- Scoring ----------\n(defshards score-collision [coinx coiny]\n  coinx\n  (When :Predicate (-&gt;\n                    (IsLess .scoringUpper-x-limit)\n                    (And)\n                    coinx (IsMore .scoringLower-x-limit)\n                    (And)\n                    coiny (IsLess .scoringUpper-y-limit)\n                    (And)\n                    coiny (IsMore .scoringLower-y-limit)\n                    (And)\n                    .scored (Is false))\n        :Action (-&gt;\n                 true &gt; .scored\n                 (Log \"Score: \"))))\n\n(defshards scoring []\n  .X (Math.Add 50.0)\n  &gt; .scoringUpper-x-limit\n  .X (Math.Subtract 50.0)\n  &gt; .scoringLower-x-limit\n\n  .Y (Math.Add 10.0)\n  &gt; .scoringUpper-y-limit\n  .Y (Math.Subtract 10.0)\n  &gt; .scoringLower-y-limit\n\n  (score-collision .coinx-1 .coiny-1)\n  (score-collision .coinx-2 .coiny-2)\n\n  .scored\n  (When :Predicate (Is true)\n        :Action (-&gt;\n                 .score (Math.Add 1)\n                 &gt; .score\n                 true &gt; .score-effect-play\n                 false &gt; .scored)))\n\n;; ------------- spikeBall-collision-logic --------------\n(defshards spikeBall-collision-logic [spikeBall-x spikeBall-y]\n\n  spikeBall-x\n  (If :Predicate (-&gt; (IsLess .damageUpper-x-limit)\n                     (And)\n                     spikeBall-x (IsMore .damageLower-x-limit)\n                     (And)\n                     spikeBall-y (IsLess .damageUpper-y-limit)\n                     (And)\n                     spikeBall-y (IsMore .damageLower-y-limit))\n\n      :Then (-&gt; .damaged\n                (When :Predicate (Is false)\n                      :Action (-&gt;\n                               true &gt; .damaged\n                               (Log \"damaged: \"))))))\n\n;; -------------- Damaging --------------\n(defshards damaging []\n\n  .X (Math.Add 120.0)\n  &gt; .damageUpper-x-limit\n  .X (Math.Subtract 120.0)\n  &gt; .damageLower-x-limit\n\n  .Y (Math.Add 15.0)\n  &gt; .damageUpper-y-limit\n  .Y (Math.Subtract 15.0)\n  &gt; .damageLower-y-limit\n\n  (spikeBall-collision-logic .spikeball-x-1 .spikeball-y-1)\n  (spikeBall-collision-logic .spikeball-x-2 .spikeball-y-2)\n  (spikeBall-collision-logic .spikeball-x-3 .spikeball-y-3)\n\n  .damaged\n  (When :Predicate (Is true)\n        :Action (-&gt;\n                 .score (Math.Subtract 1)\n                 &gt; .score\n                 true &gt; .damage-effect-play\n                 false &gt; .damaged)))\n\n;; ------------- initialize effects -------------\n(defshards initialize-effects []\n  (LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_1.png\") &gt;&gt; .score-effect-array\n  (LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_2.png\") &gt;&gt; .score-effect-array\n  (LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_3.png\") &gt;&gt; .score-effect-array\n  (LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_4.png\") &gt;&gt; .score-effect-array\n  (LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_5.png\") &gt;&gt; .score-effect-array\n  (LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_6.png\") &gt;&gt; .score-effect-array\n  (LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_7.png\") &gt;&gt; .score-effect-array\n  (LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_8.png\") &gt;&gt; .score-effect-array\n  (Count .score-effect-array) (Math.Subtract 1) &gt;= .score-effect-array-index-max\n  0 &gt;= .score-effect-array-index\n  0.05 &gt;=  .score-effect-animation-speed ;; Reduce number to increase animation speed\n  false &gt;= .score-effect-play\n\n  0.0 &gt;= .score-effect-position-x\n  0.0 &gt;= .score-effect-position-y\n  (float2 .score-effect-position-x .score-effect-position-y) &gt;= .score-effect-position\n\n  ;; --------------- Damaged Effect ----------------\n  (LoadTexture \"GlodImages/Damage_Effect/Damaged_Effect_1.png\") &gt;&gt; .damage-effect-array\n  (LoadTexture \"GlodImages/Damage_Effect/Damaged_Effect_2.png\") &gt;&gt; .damage-effect-array\n  (LoadTexture \"GlodImages/Damage_Effect/Damaged_Effect_3.png\") &gt;&gt; .damage-effect-array\n  (LoadTexture \"GlodImages/Damage_Effect/Damaged_Effect_4.png\") &gt;&gt; .damage-effect-array\n  (LoadTexture \"GlodImages/Damage_Effect/Damaged_Effect_5.png\") &gt;&gt; .damage-effect-array\n  (LoadTexture \"GlodImages/Damage_Effect/Damaged_Effect_6.png\") &gt;&gt; .damage-effect-array\n  (LoadTexture \"GlodImages/Damage_Effect/Damaged_Effect_7.png\") &gt;&gt; .damage-effect-array\n  (LoadTexture \"GlodImages/Damage_Effect/Damaged_Effect_8.png\") &gt;&gt; .damage-effect-array\n  (Count .damage-effect-array) (Math.Subtract 1) &gt;= .damage-effect-array-index-max\n  0 &gt;= .damage-effect-array-index\n  0.02 &gt;=  .damage-effect-animation-speed ;; Reduce number to increase animation speed\n  false &gt;= .damage-effect-play\n\n  (LoadTexture \"GlodImages/BG.png\") = .bg-image)\n\n;; ------------ DamageEffect Animation ------------\n(defloop damage-effect-animation-logic\n\n  .damage-effect-play\n  (When :Predicate (Is true)\n        :Action (-&gt;\n                 .damage-effect-array-index (Math.Add 1)\n                 &gt; .damage-effect-array-index\n                 (When :Predicate (IsMore .damage-effect-array-index-max)\n                       :Action (-&gt;\n                                0 &gt; .damage-effect-array-index\n                                false &gt; .damage-effect-play))))\n\n  (Pause .damage-effect-animation-speed))\n\n;; ------------ ScoreEffect_Animation_Position ------------\n(defshards scoreEffect-animation-position []\n  .Y (Math.Add -15.0)\n  &gt; .score-effect-position-y\n\n  .X\n  &gt; .score-effect-position-x\n\n  (float2 .score-effect-position-x .score-effect-position-y)\n  &gt; .score-effect-position)\n\n;; ------------ ScoreEffect Animation ------------\n(defloop scoreEffect-animation-logic\n\n  .score-effect-play\n  (When :Predicate (Is true)\n        :Action (-&gt;\n                 .score-effect-array-index (Math.Add 1)\n                 &gt; .score-effect-array-index\n                 (When :Predicate (IsMore .score-effect-array-index-max)\n                       :Action (-&gt;\n                                0 &gt; .score-effect-array-index\n                                false &gt; .score-effect-play))))\n\n\n  (Pause .score-effect-animation-speed))\n\n;; -------- Timer -----------\n(defloop timer-countdown\n  .gameOver\n  (When :Predicate (-&gt;\n                    (Is 0)\n                    (And)\n                    .timer (IsMore 0))\n        :Action (-&gt;\n                 .timer (Math.Subtract 1)\n                 &gt; .timer))\n\n  (Pause 1.0))\n\n;; ---------- GameOver Logic ------------\n(defshards gameOver-logic []\n  .timer\n  (When :Predicate (Is 0)\n        :Action (-&gt;\n                 1 &gt; .gameOver)))\n\n;; ------ UI Style --------\n(def style\n  {:override_text_style \"MyStyle\"\n   :text_styles\n   [{:name \"MyStyle\"\n     :size (float 46)\n     :family \"Monospace\"}]\n   :visuals\n   {:override_text_color (color 250 250 250)}})\n\n;; -------- Game_Over_UI -------------\n(defloop gameOver-ui\n  (UI.Area :Position (float2 -40 20)\n           :Anchor Anchor.Center\n           :Contents (-&gt;\n                      style (UI.Style)\n                      \"Score\" (UI.Label)\n                      .score (ToString) (UI.Label)\n                      (UI.Button :Label \"Restart\"\n                                 :Action (-&gt;\n                                          0 &gt; .gameOver\n                                          60 &gt; .timer\n                                          0 &gt; .score\n                                          (float2 0 0) &gt; .character-position)))))\n\n(defloop mainGame-ui\n  (UI.Area :Position (float2 0 0)\n           :Anchor Anchor.TopLeft\n           :Contents (-&gt;\n                      .bg-image (UI.Image :Scale (float2 0.7))))\n\n  (UI.Area :Position .character-position\n           :Anchor Anchor.Top\n           :Contents (-&gt;\n                      .character-state\n                      (Match [0 (-&gt; .character-direction\n                                    (Match [0 (-&gt; .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n                                            1 (-&gt; .idle-right-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))]\n                                           :Passthrough false))\n                              1 (-&gt; .walking-left-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n                              2 (-&gt; .walking-right-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n                              3 (-&gt;  .character-direction\n                                     (Match [0 (-&gt; .character-jumping-left (UI.Image :Scale (float2 0.2)))\n                                             1 (-&gt; .character-jumping-right (UI.Image :Scale (float2 0.2)))]\n                                            :Passthrough false))]\n                             :Passthrough false)))\n\n         ;; ---------- Coins -----------\n\n  (UI.Area :Position .coin-position-1\n           :Anchor Anchor.Top\n           :Contents (-&gt;\n                      .coin-image-array (Take .coin-image-index) (UI.Image :Scale (float2 0.2))))\n\n  (UI.Area :Position .coin-position-2\n           :Anchor Anchor.Top\n           :Contents (-&gt;\n                      .coin-image-array (Take .coin-image-index) (UI.Image :Scale (float2 0.2))))\n\n         ;; ------------SpikeBalls ------------\n\n  (UI.Area :Position .spikeball-position-1\n           :Anchor Anchor.Top\n           :Contents (-&gt;\n                      .spikeball-array (Take .spikeball-index) (UI.Image :Scale (float2 0.15))))\n\n  (UI.Area :Position .spikeball-position-2\n           :Anchor Anchor.Top\n           :Contents (-&gt;\n                      .spikeball-array (Take .spikeball-index) (UI.Image :Scale (float2 0.15))))\n\n  (UI.Area :Position .spikeball-position-3\n           :Anchor Anchor.Top\n           :Contents (-&gt;\n                      .spikeball-array (Take .spikeball-index) (UI.Image :Scale (float2 0.15))))\n\n         ;; ----------------- Visual Effects  -------------------\n  (UI.Area :Position .score-effect-position\n           :Anchor Anchor.Top\n           :Contents (-&gt;\n                      .score-effect-array (Take .score-effect-array-index) (UI.Image :Scale (float2 0.15))))\n\n  (UI.Area :Position (float2 0 0)\n           :Anchor Anchor.TopLeft\n           :Contents (-&gt;\n                      .damage-effect-array (Take .damage-effect-array-index) (UI.Image :Scale (float2 10))))\n\n         ;; --------------- UI Score --------------\n\n  (UI.Area :Position (float2 -40 20)\n           :Anchor Anchor.TopRight\n           :Contents (-&gt;\n                      style (UI.Style)\n                      .score (ToString) (UI.Label)))\n\n         ;; --------------- UI Timer --------------\n  (UI.Area :Position (float2 40 20)\n           :Anchor Anchor.TopLeft\n           :Contents (-&gt;\n                      style (UI.Style)\n                      .timer (ToString) (UI.Label))))\n\n;;---------- main-wire ------------\n(defloop main-wire\n  (Setup\n   (initialize-character)\n   (initialize-coin)\n   (initialize-game-elements)\n   (initialize-spiked-canonballs)\n   (initialize-effects))\n\n  (coin-gravity-logic .coiny-1 .coinx-1 .coin-velocity-1 .coin-position-1)\n  (coin-gravity-logic .coiny-2 .coinx-2 .coin-velocity-2 .coin-position-2)\n\n  (run-logic)\n  (gravity-logic)\n  (scoring)\n  (damaging)\n\n  (Step idle-animation)\n  (Step walking-animation)\n\n  (Step coin-animation)\n  (Step random-coin-1)\n  (Step random-coin-2)\n\n  (Step spiked-canonball-animation)\n  (spikeball-gravity-logic .spikeball-y-1 .spikeball-velocity-1 .spikeball-position-1 .spikeball-x-1)\n  (spikeball-gravity-logic .spikeball-y-2 .spikeball-velocity-2 .spikeball-position-2 .spikeball-x-2)\n  (spikeball-gravity-logic .spikeball-y-3 .spikeball-velocity-3 .spikeball-position-3 .spikeball-x-3)\n  (Step  spikeball-1)\n  (Step  spikeball-2)\n  (Step  spikeball-3)\n\n  (scoreEffect-animation-position)\n  (Step scoreEffect-animation-logic)\n  (Step damage-effect-animation-logic)\n\n  (Step timer-countdown)\n  (gameOver-logic)\n\n  (GFX.MainWindow\n   :Title \"MainWindow\" :Width 1920 :Height 1080\n   :Contents\n   (-&gt; (Setup\n        (GFX.DrawQueue) &gt;= .ui-draw-queue\n        (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n       .ui-draw-queue (GFX.ClearQueue)\n\n       (UI\n        .ui-draw-queue\n        (-&gt;\n         .gameOver\n         (Match [0 (-&gt; (Step mainGame-ui))\n                 1 (-&gt; (Step gameOver-ui))]\n                :Passthrough false)))\n\n       (button-inputs)\n\n       (GFX.Render :Steps .render-steps))))\n\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre>"},{"location":"learn/shards/tutorials/glod-game/steps/","title":"Steps","text":"<ul> <li>Step 1 - Drawing Glod's Image with UI</li> <li>Step 2 - Changing Glod's Image with Button Inputs</li> <li>Step 3 - Animating Glod with Image Arrays</li> <li>Step 4 - Moving Glod with Button Inputs</li> <li>Step 5 - Dropping Coins and Scoring Points</li> <li>Step 6 - Making the Game Harder</li> <li>Step 7 - Polishing the Game</li> </ul>"},{"location":"learn/shards/tutorials/glod-game/steps/step-1/","title":"Step 1","text":""},{"location":"learn/shards/tutorials/glod-game/steps/step-1/#drawing-a-character-image-using-ui-overview","title":"Drawing a Character Image using UI - Overview","text":"<p>Let's start things off nice and easy. In this step, we will simply be:</p> <ol> <li> <p>Creating the <code>GFX.Window</code>.</p> </li> <li> <p>Drawing our Character Image in the <code>GFX.Window</code>.</p> </li> <li> <p>Scheduling our Wire on the Mesh and running it.</p> </li> </ol>"},{"location":"learn/shards/tutorials/glod-game/steps/step-1/#step-11-readying-the-image","title":"Step 1.1: Readying the Image","text":"<p>Before we can draw our character on the screen, we will need the image file. Any image file will do. If you don't have one, say hello to Glod! Right-click and save the image of Glod below. </p> <p></p> <ol> <li>Create a folder named \"GlodImages\" in the same location as where your script will be located.</li> <li>Add your image into the newly created folder.</li> <li>Name your image \"Character1.png\".</li> </ol> <p>With our image file readied, we can start!</p>"},{"location":"learn/shards/tutorials/glod-game/steps/step-1/#step-12-initializing-our-variables","title":"Step 1.2: Initializing our Variables","text":"<p>First, create the variable <code>.character-image</code> to assign our Image file to. Use the shard <code>LoadImage</code> to load the image into the variable. Set your image's location as its parameter.</p> <p>We will wrap this line of code in a <code>defshards</code> shard. This shard will be called at the start of our code, where we will be initializing all our variables. </p> What is Initializing? <p>Initializing is the assigning of an initial value to a variable when it is declared.</p> Initialization Code <pre><code>(defshards initialize-character []\n    (LoadImage \"GlodImages/Character1.png\") = .character-image)\n</code></pre>"},{"location":"learn/shards/tutorials/glod-game/steps/step-1/#step-13-creating-the-main-looped-wire","title":"Step 1.3: Creating the main Looped Wire","text":"<p>Following that, we will create the main Looped Wire which will be scheduled on the Mesh. The <code>initialize-character</code> shard that we have just created will be called at the start of this Looped Wire. It will be wrapped in a <code>Setup</code> shard.</p> The Setup shard <p>The <code>Setup</code> shard ensures that every line of code called within it will only happen once. By placing the <code>initialize-character</code> shard within a <code>Setup</code> shard, we ensure that it is only called once despite being placed in a <code>defloop</code>.</p> <p>We want to initialize variables once only as we do not want our program to continuously create a new instance of the same variable every time the Wire loops. We only need one instance of our variables which will be reused.</p> Main Looped Wire <pre><code>(defshards initialize-character []\n  (LoadImage \"GlodImages/Character1.png\") = .character-image) ;; (1)\n\n(defloop main-wire\n  (Setup\n   (initialize-character)))\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre> <ol> <li><code>.character-image</code> is the variable that contains our image.</li> </ol>"},{"location":"learn/shards/tutorials/glod-game/steps/step-1/#step-14-creating-the-window","title":"Step 1.4: Creating the Window","text":"<p>Trying to run our program right now would result in... nothing. This is because all we are doing is simply initializing a variable. To draw our image on the screen however, we will have to create the window first.</p> Initialize Code <pre><code>(defshards initialize-character []\n  (LoadImage \"GlodImages/Character1.png\") = .character-image)\n\n(defloop main-wire\n  (Setup\n   (initialize-character))\n\n  (GFX.MainWindow\n   :Title \"MainWindow\" :Width 1920 :Height 1080\n   :Contents\n   (-&gt; (Setup\n        (GFX.DrawQueue) &gt;= .ui-draw-queue\n        (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n       .ui-draw-queue (GFX.ClearQueue)\n\n       (UI\n        .ui-draw-queue)\n\n       (GFX.Render :Steps .render-steps))))\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre> <p>Try running the program now. Something happens! The window that you see was created with the code above. Changing the values in the <code>:Width</code> and <code>:Height</code> parameters will change the size of this window accordingly.</p>"},{"location":"learn/shards/tutorials/glod-game/steps/step-1/#step-15-drawing-the-image-on-the-screen","title":"Step 1.5: Drawing the Image on the Screen","text":"<p>The last step is to draw the image on screen. To do this, we use the <code>UI.Area</code>, the <code>UI.Image</code>, and <code>GFX.Texture</code> shards.</p> <p>Create a <code>load-texture</code> shard to load our images as textures. This would make it easier for our computer to load the images and ensure that our program runs smoothly even if we use large images.</p> Code AddedFull Code So Far <pre><code>(defshards load-texture [name] ;; (1)\n    (LoadImage name)\n    (GFX.Texture))\n</code></pre> <ol> <li>The <code>load-texture</code> shard will allow our images to be loaded as textures.</li> </ol> <pre><code>  (UI.Area ;; (1)\n   :Position (float2 0 0)\n   :Anchor Anchor.Center\n   :Contents\n   (-&gt;\n    .character-image (UI.Image :Scale (float2 0.2))))\n</code></pre> <ol> <li><code>UI.Area</code> allows our image to be drawn on screen in the specified area.</li> </ol> <pre><code>(defshards load-texture [name] ;; (1)\n  (LoadImage name)\n  (GFX.Texture))\n\n(defshards initialize-character []\n  (load-texture \"GlodImages/Character1.png\") = .character-image)\n\n(defloop main-wire\n  (Setup\n   (initialize-character))\n\n  (GFX.MainWindow\n   :Title \"MainWindow\" :Width 1920 :Height 1080\n   :Contents\n   (-&gt;\n    (Setup\n     (GFX.DrawQueue) &gt;= .ui-draw-queue\n     (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n    .ui-draw-queue (GFX.ClearQueue)\n\n    (UI\n     .ui-draw-queue\n     (-&gt;\n      (UI.Area\n       :Position (float2 0 0)\n       :Anchor Anchor.Center\n       :Contents\n       (-&gt;\n        .character-image (UI.Image :Scale (float2 0.2))))))\n\n    (GFX.Render :Steps .render-steps))))\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre> <ol> <li>Adding <code>[name]</code> when creating a shard allows that shard to take in an input variable. Here <code>[name]</code> will be used as the input for <code>load-texture</code>.</li> </ol> <p>Try running the program now. You should see adorable little Glod in the center of your screen.</p> <p>Congratulations! You have successfully drawn an image on the screen.</p> <p></p>"},{"location":"learn/shards/tutorials/glod-game/steps/step-1/#recap","title":"Recap","text":"<p>In this step, we have successfully drawn an image on the screen by:</p> <ol> <li> <p>Initializing an image variable.</p> </li> <li> <p>Creating a window.</p> </li> <li> <p>Using <code>UI.Area</code> and <code>UI.Image</code> to draw our image within the window.</p> </li> </ol> <p>We would be very hard-pressed however to make a game out of a single static unchanging image. In the next step, we will learn how to dynamically change adorable Glod's image by pressing buttons.</p> <p>Good job so far and see you in the next step! \ud83d\udc4b</p>"},{"location":"learn/shards/tutorials/glod-game/steps/step-2/","title":"Step 2","text":""},{"location":"learn/shards/tutorials/glod-game/steps/step-2/#changing-character-images-with-button-inputs-overview","title":"Changing Character Images with Button Inputs - Overview","text":"<p>In the previous step, we successfully drew our character in a window. Eventually, we want this image to be animated.</p> <p>But slow down now!</p> <p>Before we reach that stage, let's first start with having our image change to another.</p> <p>In this step, we will learn how to have our character image change on button input.</p>"},{"location":"learn/shards/tutorials/glod-game/steps/step-2/#step-21","title":"Step 2.1","text":"<p>For a start, let's have our program create a message when we press a button. To do this, create another <code>defshards</code> named <code>button-inputs</code>.</p> <p>We will use the shards <code>Inputs.KeyDown</code> and <code>Msg</code> to have our program show a message output in the terminal when we press directional buttons.</p> Code AddedFull Code So Far <pre><code>(defshards button-inputs []\n  (Inputs.KeyDown\n   :Key \"left\"\n   :Action (Msg \"left\"))\n\n  (Inputs.KeyDown\n   :Key \"right\"\n   :Action (Msg \"right\"))\n\n  (Inputs.KeyDown\n   :Key \"up\"\n   :Action (Msg \"up\"))) ;; (1)\n</code></pre> <ol> <li>The code above is added to lines 8 - 19.</li> </ol> <pre><code>(button-inputs) ;; (1)\n</code></pre> <ol> <li>Added to line 44.</li> </ol> <pre><code>(defshards LoadTexture [name]\n  (LoadImage name)\n  (GFX.Texture))\n\n(defshards initialize-character []\n  (LoadTexture \"GlodImages/Character1.png\") = .character-image)\n\n(defshards button-inputs []\n  (Inputs.KeyDown\n   :Key \"left\"\n   :Action (Msg \"left\"))\n\n  (Inputs.KeyDown\n   :Key \"right\"\n   :Action (Msg \"right\"))\n\n  (Inputs.KeyDown\n   :Key \"up\"\n   :Action (Msg \"up\")))\n\n(defloop main-wire\n  (Setup\n   (initialize-character))\n\n  (GFX.MainWindow\n   :Title \"MainWindow\" :Width 1920 :Height 1080\n   :Contents\n   (-&gt;\n    (Setup\n     (GFX.DrawQueue) &gt;= .ui-draw-queue\n     (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n    .ui-draw-queue (GFX.ClearQueue)\n\n    (UI\n     .ui-draw-queue\n     (-&gt;\n      (UI.Area\n       :Position (float2 0 0)\n       :Anchor Anchor.Center\n       :Contents\n       (-&gt;\n        LoadTexture .character-image (UI.Image :Scale (float2 0.2))))))\n\n    (GFX.Render :Steps .render-steps)\n\n    (button-inputs))))\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre> <p>Why don't you try running the program now? Do you see the messages in the terminal?</p> <p>Great job if you did! We are off to a good start.</p> <p></p>"},{"location":"learn/shards/tutorials/glod-game/steps/step-2/#step-22","title":"Step 2.2","text":"<p>Next, instead of just having messages appear on the terminal, let's start trying to get the image to change. Similar to step 1, we first load the images into variables. Add these images into the GlodImages folder and name them appropriately.</p> <ul> <li>Download the Images here.</li> </ul> Code AddedFull Code So Far <pre><code>(defshards initialize-character []\n    (LoadTexture \"GlodImages/Character1.png\") = .character-image\n    (LoadTexture \"GlodImages/Character1_Left.png\") = .character-left\n    (LoadTexture \"GlodImages/Character1_Right.png\") = .character-right\n    (LoadTexture \"GlodImages/Character1_Jumping.png\") = .character-jumping) ;; (1)      \n</code></pre> <ol> <li><code>.character-left</code>, <code>.character-right</code>, and <code>.character-jumping</code> are added to lines 5 - 9.</li> </ol> <pre><code>(defshards load-texture [name]\n  (LoadImage name)\n  (GFX.Texture))\n\n(defshards initialize-character []\n  (LoadTexture \"GlodImages/Character1.png\") = .character-image\n  (LoadTexture \"GlodImages/Character1_Left.png\") = .character-left\n  (LoadTexture \"GlodImages/Character1_Right.png\") = .character-right\n  (LoadTexture \"GlodImages/Character1_Jumping.png\") = .character-jumping)\n\n(defshards button-inputs []\n  (Inputs.KeyDown\n   :Key \"left\"\n   :Action (Msg \"left\"))\n\n  (Inputs.KeyDown\n   :Key \"right\"\n   :Action (Msg \"right\"))\n\n  (Inputs.KeyDown\n   :Key \"up\"\n   :Action (Msg \"up\")))\n\n(defloop main-wire\n  (Setup\n   (initialize-character))\n\n  (GFX.MainWindow\n   :Title \"MainWindow\" :Width 1920 :Height 1080\n   :Contents\n   (-&gt;\n    (Setup\n     (GFX.DrawQueue) &gt;= .ui-draw-queue\n     (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n    .ui-draw-queue (GFX.ClearQueue)\n\n    (UI\n     .ui-draw-queue\n     (-&gt;\n      (UI.Area\n       :Position (float2 0 0)\n       :Anchor Anchor.Center\n       :Contents\n       (-&gt;\n        .character-image (UI.Image :Scale (float2 0.2))))))\n\n    (GFX.Render :Steps .render-steps)\n\n    (button-inputs))))\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre> <p>Now, let's draw the new images onto the screen. Place them under the same <code>UI.Area</code>.</p> Code AddedFull Code So Far <pre><code>(defshards initialize-character []\n    .character-left (UI.Image :Scale (float2 0.2))\n    .character-right (UI.Image :Scale (float2 0.2))\n    .character-jumping (UI.Image :Scale (float2 0.2))) ;; (1)      \n</code></pre> <ol> <li><code>.character-left (UI.Image)</code>, <code>.character-right (UI.Image)</code>, <code>.character-jumping (UI.Image)</code> are added to <code>UI.Area</code>'s <code>Contents</code> at line 44, 45, and 46.</li> </ol> <pre><code>(defshards load-texture [name]\n  (LoadImage name)\n  (GFX.Texture))\n\n(defshards initialize-character []\n  (LoadTexture \"GlodImages/Character1.png\") = .character-image\n  (LoadTexture \"GlodImages/Character1_Left.png\") = .character-left\n  (LoadTexture \"GlodImages/Character1_Right.png\") = .character-right\n  (LoadTexture \"GlodImages/Character1_Jumping.png\") = .character-jumping)\n\n(defshards button-inputs []\n  (Inputs.KeyDown\n   :Key \"left\"\n   :Action (Msg \"left\"))\n\n  (Inputs.KeyDown\n   :Key \"right\"\n   :Action (Msg \"right\"))\n\n  (Inputs.KeyDown\n   :Key \"up\"\n   :Action (Msg \"up\")))\n\n(defloop main-wire\n  (Setup\n   (initialize-character))\n\n  (GFX.MainWindow\n   :Title \"MainWindow\" :Width 1920 :Height 1080\n   :Contents\n   (-&gt;\n    (Setup\n     (GFX.DrawQueue) &gt;= .ui-draw-queue\n     (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n    .ui-draw-queue (GFX.ClearQueue)\n\n    (UI\n     .ui-draw-queue\n     (-&gt;\n      (UI.Area\n       :Position (float2 0 0)\n       :Anchor Anchor.Center\n       :Contents\n       (-&gt;\n        .character-image (UI.Image :Scale (float2 0.2))\n        .character-left (UI.Image :Scale (float2 0.2))\n        .character-right (UI.Image :Scale (float2 0.2))\n        .character-jumping (UI.Image :Scale (float2 0.2))))))\n\n    (GFX.Render :Steps .render-steps)\n\n    (button-inputs))))\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre> <p>Try running the program. Don't panic! You are supposed to see four images stacked on top of each other.</p> <p></p> <p>The next step is to have the window draw only one image at a time.</p>"},{"location":"learn/shards/tutorials/glod-game/steps/step-2/#step-23","title":"Step 2.3","text":"<p>To have only one image drawn each time, we will:</p> <ol> <li> <p>Create a <code>.character-state</code> variable for Glod.</p> </li> <li> <p>Draw only one image based on the character state using the <code>Match</code> shard.</p> </li> </ol> States <p>Creating states is a way to have our characters and stages hold different modes, forms and levels.</p> <p>For example, a boss can have a normal mode and an enraged mode. We create the variables <code>.normal-mode</code> and <code>.enraged-mode</code>.</p> <p>When <code>.normal-mode</code> is <code>true</code> and <code>.enraged-mode</code> is <code>false</code>, the boss is in normal mode. Vice-versa, when <code>.enraged-mode</code> is <code>true</code> and <code>.normal-mode</code> is <code>false</code>, the boss will go into enraged mode.</p> <p>We will use the same logic to create states for our character and have the image shown on screen change when its state is changed.</p> <p>First, create the <code>.character-state</code> variable.</p> Code AddedFull Code So Far <pre><code>0 &gt;= .character-state ;; (1)      \n</code></pre> <ol> <li>Added under <code>initialize-character</code> at line 11.</li> </ol> <pre><code>.character-state\n(Match [0 (-&gt; .character-image (UI.Image :Scale (float2 0.2)))\n        1 (-&gt; .character-left (UI.Image :Scale (float2 0.2)))\n        2 (-&gt; .character-right (UI.Image :Scale (float2 0.2)))\n        3 (-&gt; .character-jumping (UI.Image :Scale (float2 0.2)))]\n        :Passthrough false) ;; (1)     \n</code></pre> <ol> <li>Added to the <code>UI.Area</code> at line 45 - 50.</li> </ol> <pre><code>(defshards load-texture [name]\n  (LoadImage name)\n  (GFX.Texture))\n\n(defshards initialize-character []\n  (LoadTexture \"GlodImages/Character1.png\") = .character-image\n  (LoadTexture \"GlodImages/Character1_Left.png\") = .character-left\n  (LoadTexture \"GlodImages/Character1_Right.png\") = .character-right\n  (LoadTexture \"GlodImages/Character1_Jumping.png\") = .character-jumping\n\n  0 &gt;= .character-state)\n\n(defshards button-inputs []\n  (Inputs.KeyDown\n   :Key \"left\"\n   :Action (Msg \"left\"))\n\n  (Inputs.KeyDown\n   :Key \"right\"\n   :Action (Msg \"right\"))\n\n  (Inputs.KeyDown\n   :Key \"up\"\n   :Action (Msg \"up\")))\n\n(defloop main-wire\n  (Setup\n   (initialize-character))\n\n  (GFX.MainWindow\n   :Title \"MainWindow\" :Width 1920 :Height 1080\n   :Contents\n   (-&gt;\n    (Setup\n     (GFX.DrawQueue) &gt;= .ui-draw-queue\n     (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n    .ui-draw-queue (GFX.ClearQueue)\n\n    (UI\n     .ui-draw-queue\n     (-&gt;\n      (UI.Area\n       :Position (float2 0 0)\n       :Anchor Anchor.Center\n       :Contents\n       (-&gt;\n        .character-state\n        (Match [0 (-&gt; .character-image (UI.Image :Scale (float2 0.2)))\n                1 (-&gt; .character-left (UI.Image :Scale (float2 0.2)))\n                2 (-&gt; .character-right (UI.Image :Scale (float2 0.2)))\n                3 (-&gt; .character-jumping (UI.Image :Scale (float2 0.2)))]\n               :Passthrough false)))))\n\n    (GFX.Render :Steps .render-steps)\n\n    (button-inputs))))\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre> <p>If you run the code now, you will see only one image this time.</p> <p>However, the image does not change.</p> <p>This is because our <code>.character-state</code> has a value of 0 and stays at 0. Our <code>Match</code> shard will only return the image that is shown when <code>.character-state</code> is 0.</p> <p>To change the image, we must first change the value of the <code>.character-state</code> variable.</p> <p>Update the <code>button-inputs</code> shard to let it modify the value of <code>.character-state</code>.</p> Code AddedFull Code So Far <pre><code>(defshards button-inputs []\n  (Inputs.KeyDown\n   :Key \"left\"\n   :Action\n   (-&gt;\n    (Msg \"left\")\n    1 &gt; .character-state))\n\n  (Inputs.KeyDown\n   :Key \"right\"\n   :Action\n   (-&gt;\n    (Msg \"right\")\n    2 &gt; .character-state))\n\n  (Inputs.KeyDown\n   :Key \"up\"\n   :Action\n   (-&gt;\n    (Msg \"up\")\n    3 &gt; .character-state)))  \n</code></pre> <pre><code>(defshards load-texture [name]\n  (LoadImage name)\n  (GFX.Texture))\n\n(defshards initialize-character []\n  (LoadTexture \"GlodImages/Character1.png\") = .character-image\n  (LoadTexture \"GlodImages/Character1_Left.png\") = .character-left\n  (LoadTexture \"GlodImages/Character1_Right.png\") = .character-right\n  (LoadTexture \"GlodImages/Character1_Jumping.png\") = .character-jumping\n\n  0 &gt;= .character-state)\n\n(defshards button-inputs []\n  (Inputs.KeyDown\n   :Key \"left\"\n   :Action\n   (-&gt;\n    (Msg \"left\")\n    1 &gt; .character-state))\n\n  (Inputs.KeyDown\n   :Key \"right\"\n   :Action\n   (-&gt;\n    (Msg \"right\")\n    2 &gt; .character-state))\n\n  (Inputs.KeyDown\n   :Key \"up\"\n   :Action\n   (-&gt;\n    (Msg \"up\")\n    3 &gt; .character-state)))\n\n(defloop main-wire\n  (Setup\n   (initialize-character))\n\n  (GFX.MainWindow\n   :Title \"MainWindow\" :Width 1920 :Height 1080\n   :Contents\n   (-&gt;\n    (Setup\n     (GFX.DrawQueue) &gt;= .ui-draw-queue\n     (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n    .ui-draw-queue (GFX.ClearQueue)\n\n    (UI\n     .ui-draw-queue\n     (-&gt;\n      (UI.Area\n       :Position (float2 0 0)\n       :Anchor Anchor.Center\n       :Contents\n       (-&gt;\n        .character-state\n        (Match [0 (-&gt; .character-image (UI.Image :Scale (float2 0.2)))\n                1 (-&gt; .character-left (UI.Image :Scale (float2 0.2)))\n                2 (-&gt; .character-right (UI.Image :Scale (float2 0.2)))\n                3 (-&gt; .character-jumping (UI.Image :Scale (float2 0.2)))]\n               :Passthrough false))))\n\n    (GFX.Render :Steps .render-steps)\n\n    (button-inputs))))\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre> <p>Now if you run the code and press the up, left and right directional buttons, you will see Glod's image change! Congratulations.</p>"},{"location":"learn/shards/tutorials/glod-game/steps/step-2/#recap","title":"Recap","text":"<p>Try running the code. Walah! You now have an image that changes based on the button pressed.</p> <p>We achieved this by:</p> <ol> <li> <p>Creating a <code>.character-state</code> variable.</p> </li> <li> <p>Using a <code>Match</code> shard to dictate which image is drawn in the window based on the value of <code>.character-state</code>.</p> </li> </ol> <p>In the next step we will breathe more life into adorable Glod by animating him!</p> <p>Looking forward to seeing you in the next step!\ud83d\ude42</p>"},{"location":"learn/shards/tutorials/glod-game/steps/step-3/","title":"Step 3","text":""},{"location":"learn/shards/tutorials/glod-game/steps/step-3/#animating-with-image-arrays-overview","title":"Animating with Image Arrays - Overview","text":"<p>In the last step, we managed to have Glod's image change based on directional key input.</p> <p>Now, let's breathe more life into him.</p> <p>Instead of having static images, we can have him animated. To do this we will:</p> <ol> <li> <p>Use an image array to house the different frames in an animation.</p> </li> <li> <p>Display a single frame in <code>UI.Area</code> using <code>UI.Image</code>.</p> </li> <li> <p>Cycle through the image shown by going through the image array with <code>Step</code> to create a looping animation.</p> </li> </ol> <p>Without further ado, let's get to it!</p>"},{"location":"learn/shards/tutorials/glod-game/steps/step-3/#step-31","title":"Step 3.1","text":"<p>Before we can create our animation, we have to download the images that will be used.</p> <p>Create a folder within \"GlodImages\" and name it \"Character_Idle\". Within the \"Character_Idle\" folder, create another folder named \"Idle_Left\" and save the images there.</p> <p></p> <ul> <li>Download Glod's adorable idle animation frames here.</li> </ul>"},{"location":"learn/shards/tutorials/glod-game/steps/step-3/#step-32","title":"Step 3.2","text":"<p>Once you have the images downloaded, the next step is to have an image array to house these images. </p> Code AddedFull Code So Far <pre><code>;; ---------- Character Idle Array ---------- ;; (1)\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png\") &gt;&gt; .idle-left-image-array  \n</code></pre> <ol> <li>Remember to use <code>;;</code> comments to help segment and organize your code for better readability!</li> </ol> <pre><code>(defshards load-texture [name]\n  (LoadImage name)\n  (GFX.Texture))\n\n(defshards initialize-character []\n  (LoadTexture \"GlodImages/Character1.png\") = .character-image\n  (LoadTexture \"GlodImages/Character1_Left.png\") = .character-left\n  (LoadTexture \"GlodImages/Character1_Right.png\") = .character-right\n  (LoadTexture \"GlodImages/Character1_Jumping.png\") = .character-jumping\n\n  0 &gt;= .character-state\n\n  ;; ---------- Character Idle Array ----------\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png\") &gt;&gt; .idle-left-image-array)\n\n(defshards button-inputs []\n  (Inputs.KeyDown\n   :Key \"left\"\n   :Action\n   (-&gt;\n    (Msg \"left\")\n    1 &gt; .character-state))\n\n  (Inputs.KeyDown\n   :Key \"right\"\n   :Action\n   (-&gt;\n    (Msg \"right\")\n    2 &gt; .character-state))\n\n  (Inputs.KeyDown\n   :Key \"up\"\n   :Action\n   (-&gt;\n    (Msg \"up\")\n    3 &gt; .character-state)))\n\n(defloop main-wire\n  (Setup\n   (initialize-character))\n\n  (GFX.MainWindow\n   :Title \"MainWindow\" :Width 1920 :Height 1080\n   :Contents\n   (-&gt;\n    (Setup\n     (GFX.DrawQueue) &gt;= .ui-draw-queue\n     (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n    .ui-draw-queue (GFX.ClearQueue)\n\n    (UI\n     .ui-draw-queue\n     (-&gt;\n      (UI.Area\n       :Position (float2 0 0)\n       :Anchor Anchor.Center\n       :Contents\n       (-&gt;\n        .character-state\n            (Match [0 (-&gt; .character-image (UI.Image :Scale (float2 0.2)))\n                    1 (-&gt; .character-left (UI.Image :Scale (float2 0.2)))\n                    2 (-&gt; .character-right (UI.Image :Scale (float2 0.2)))\n                    3 (-&gt; .character-jumping (UI.Image :Scale (float2 0.2)))]\n                    :Passthrough false)))))\n\n    (GFX.Render :Steps .render-steps)\n\n    (button-inputs))))\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre> &gt;&gt; <p><code>&gt;&gt;</code> is an alias for the shard <code>Push</code>. An alias is a short form of a shard to make coding much easier. Think of it like typing \"lol\" instead of \"laughing out loud\". The <code>Push</code> shard is used to add an element to the back of an array.</p>"},{"location":"learn/shards/tutorials/glod-game/steps/step-3/#step-33","title":"Step 3.3","text":"<p>Now that we have an array of images, we can take an element from this array and draw that specific image in the window. To do this:</p> <ol> <li> <p>Create a variable called <code>.idle-image-index</code>. This will determine the index of the image array that will be used.</p> </li> <li> <p>Use the <code>Take</code> shard to retrieve the image located in the specified index of the image array.</p> </li> <li> <p>Tell <code>UI.Area</code> to draw the image.</p> </li> </ol> Code AddedFull Code So Far <pre><code>0 &gt;= .idle-image-index ;; (1)\n</code></pre> <ol> <li>Added to line 22, within <code>initialize-character</code>.</li> </ol> <pre><code>.idle-left-image-array (Take .idle-image-index) ;; (1)\n</code></pre> <ol> <li><code>.character-image</code> is renamed to <code>.idle-left-image-array</code> to better reflect its idling state at line 68.</li> </ol> <pre><code>(defshards load-texture [name]\n  (LoadImage name)\n  (GFX.Texture))\n\n(defshards initialize-character []\n  (LoadTexture \"GlodImages/Character1.png\") = .character-image\n  (LoadTexture \"GlodImages/Character1_Left.png\") = .character-left\n  (LoadTexture \"GlodImages/Character1_Right.png\") = .character-right\n  (LoadTexture \"GlodImages/Character1_Jumping.png\") = .character-jumping\n\n  0 &gt;= .character-state\n\n  ;; ---------- Character Idle Array ----------\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png\") &gt;&gt; .idle-left-image-array\n\n  0 &gt;= .idle-image-index)\n\n(defshards button-inputs []\n  (Inputs.KeyDown\n   :Key \"left\"\n   :Action\n   (-&gt;\n    (Msg \"left\")\n    1 &gt; .character-state))\n\n  (Inputs.KeyDown\n   :Key \"right\"\n   :Action\n   (-&gt;\n    (Msg \"right\")\n    2 &gt; .character-state))\n\n  (Inputs.KeyDown\n   :Key \"up\"\n   :Action\n   (-&gt;\n    (Msg \"up\")\n    3 &gt; .character-state)))\n\n(defloop main-wire\n  (Setup\n   (initialize-character))\n\n  (GFX.MainWindow\n   :Title \"MainWindow\" :Width 1920 :Height 1080\n   :Contents\n   (-&gt;\n    (Setup\n     (GFX.DrawQueue) &gt;= .ui-draw-queue\n     (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n    .ui-draw-queue (GFX.ClearQueue)\n\n    (UI\n     .ui-draw-queue\n     (-&gt;\n      (UI.Area\n       :Position (float2 0 0)\n       :Anchor Anchor.Center\n       :Contents\n       (-&gt;\n        .character-state\n            (Match [0 (-&gt; .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n                    1 (-&gt; .character-left (UI.Image :Scale (float2 0.2)))\n                    2 (-&gt; .character-right (UI.Image :Scale (float2 0.2)))\n                    3 (-&gt; .character-jumping (UI.Image :Scale (float2 0.2)))]\n                    :Passthrough false)))))\n\n    (GFX.Render :Steps .render-steps)\n\n    (button-inputs))))\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre>"},{"location":"learn/shards/tutorials/glod-game/steps/step-3/#step-34","title":"Step 3.4","text":"<p>We're almost there!</p> <p>To have this image animated, we need to dynamically increase the value of <code>.idle-image-index</code> and make it loop. To do this, we will first create a Wire that increases <code>.idle_image_index.</code></p> Code Added <pre><code>(defloop idle-animation ;; (1)\n  .idle-image-index (Math.Add 1)\n  &gt; .idle-image-index)\n</code></pre> <ol> <li>Use <code>defloop</code> to create a looping Wire that will add 1 to <code>.idle-image-index</code> each time it is called. Added to lines 24 - 26.</li> </ol> <p>Updating Variables</p> <p>Whenever you make changes to a variable, remember to reassign it to the variable again at the end if you plan on using it in another segment of the code.</p> Full Code So Far <pre><code>(defshards load-texture [name]\n  (LoadImage name)\n  (GFX.Texture))\n\n(defshards initialize-character []\n  (LoadTexture \"GlodImages/Character1.png\") = .character-image\n  (LoadTexture \"GlodImages/Character1_Left.png\") = .character-left\n  (LoadTexture \"GlodImages/Character1_Right.png\") = .character-right\n  (LoadTexture \"GlodImages/Character1_Jumping.png\") = .character-jumping\n\n  0 &gt;= .character-state\n\n  ;; ---------- Character Idle Array ----------\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png\") &gt;&gt; .idle-left-image-array\n\n  0 &gt;= .idle-image-index)\n\n(defloop idle-animation\n  .idle-image-index (Math.Add 1)\n  &gt; .idle-image-index)\n\n(defshards button-inputs []\n  (Inputs.KeyDown\n   :Key \"left\"\n   :Action\n   (-&gt;\n    (Msg \"left\")\n    1 &gt; .character-state))\n\n  (Inputs.KeyDown\n   :Key \"right\"\n   :Action\n   (-&gt;\n    (Msg \"right\")\n    2 &gt; .character-state))\n\n  (Inputs.KeyDown\n   :Key \"up\"\n   :Action\n   (-&gt;\n    (Msg \"up\")\n    3 &gt; .character-state)))\n\n(defloop main-wire\n  (Setup\n   (initialize-character))\n\n  (GFX.MainWindow\n   :Title \"MainWindow\" :Width 1920 :Height 1080\n   :Contents\n   (-&gt;\n    (Setup\n     (GFX.DrawQueue) &gt;= .ui-draw-queue\n     (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n    .ui-draw-queue (GFX.ClearQueue)\n\n    (UI\n     .ui-draw-queue\n     (-&gt;\n      (UI.Area\n       :Position (float2 0 0)\n       :Anchor Anchor.Center\n       :Contents\n       (-&gt;\n        .character-state\n            (Match [0 (-&gt; .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n                    1 (-&gt; .character-left (UI.Image :Scale (float2 0.2)))\n                    2 (-&gt; .character-right (UI.Image :Scale (float2 0.2)))\n                    3 (-&gt; .character-jumping (UI.Image :Scale (float2 0.2)))]\n                    :Passthrough false)))))\n\n    (GFX.Render :Steps .render-steps)\n\n    (button-inputs))))\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre> <p>Before we can call this Wire, we have to create some variables to help us loop it properly.</p> <p>If we were to try to use this Wire as it is, <code>.idle-image-index</code> will increase in value indefinitely.</p> <p>To prevent this from happening, we will create some variables and a conditional statement to control how <code>.idle-image-index</code> increases.</p> Code AddedFull Code So Far <pre><code>(Count .idle-left-image-array) = .idle-image-index-max ;; (1)\n0.08 = .idle-animation-speed ;; (2)\n</code></pre> <ol> <li><code>.idle-image-index-max</code> will be used to ensure that <code>.idle-image-index</code>does not exceed this value. Added to line 23.</li> <li><code>idle-animation-speed</code> ensures how fast our idle animation will play. Added to line 24.</li> </ol> <pre><code>;; --------- Idle Animation Loop ---------\n(defloop idle-animation ;; (3)\n  .idle-image-index (Math.Add 1)\n  &gt; .idle-image-index\n  (When ;; (1)\n   :Predicate (IsMoreEqual .idle-image-index-max) \n   :Action (-&gt; 0 &gt; .idle-image-index))\n  (Pause .idle-animation-speed)) ;; (2)\n</code></pre> <ol> <li> <p>The <code>When</code> conditional statement ensures that <code>.idle-animation-index</code> will not exceed <code>.idle-image-index-max</code>. This ensures that we will not try to draw an image that is beyond what the array has as it will crash the program.</p> </li> <li> <p><code>Pause</code> is used as this <code>defloop</code> will eventually execute <code>Step</code>. This pause will cause the <code>defloop</code> to be called at the speed indicated by <code>.idle-animation-speed</code>.</p> </li> <li> <p>Added to lines 28 - 34.</p> </li> </ol> <pre><code>(defshards load-texture [name]\n  (LoadImage name)\n  (GFX.Texture))\n\n(defshards initialize-character []\n  (LoadTexture \"GlodImages/Character1.png\") = .character-image\n  (LoadTexture \"GlodImages/Character1_Left.png\") = .character-left\n  (LoadTexture \"GlodImages/Character1_Right.png\") = .character-right\n  (LoadTexture \"GlodImages/Character1_Jumping.png\") = .character-jumping\n\n  0 &gt;= .character-state\n\n  ;; ---------- Character Idle Array ----------\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png\") &gt;&gt; .idle-left-image-array\n\n  0 &gt;= .idle-image-index\n  (Count .idle-left-image-array) = .idle-image-index-max\n  0.08 = .idle-animation-speed)\n\n;; --------- Idle Animation Loop ---------\n(defloop idle-animation\n  .idle-image-index (Math.Add 1)\n  &gt; .idle-image-index\n  (When\n   :Predicate (IsMoreEqual .idle-image-index-max)\n   :Action (-&gt; 0 &gt; .idle-image-index))\n  (Pause .idle-animation-speed))\n\n;; ------- Button Inputs ----------\n(defshards button-inputs []\n  (Inputs.KeyDown\n   :Key \"left\"\n   :Action\n   (-&gt;\n    (Msg \"left\")\n    1 &gt; .character-state))\n\n  (Inputs.KeyDown\n   :Key \"right\"\n   :Action\n   (-&gt;\n    (Msg \"right\")\n    2 &gt; .character-state))\n\n  (Inputs.KeyDown\n   :Key \"up\"\n   :Action\n   (-&gt;\n    (Msg \"up\")\n    3 &gt; .character-state)))\n\n(defloop main-wire\n  (Setup\n   (initialize-character))\n\n  (GFX.MainWindow\n   :Title \"MainWindow\" :Width 1920 :Height 1080\n   :Contents\n   (-&gt;\n    (Setup\n     (GFX.DrawQueue) &gt;= .ui-draw-queue\n     (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n    .ui-draw-queue (GFX.ClearQueue)\n\n    (UI\n     .ui-draw-queue\n     (-&gt;\n      (UI.Area\n       :Position (float2 0 0)\n       :Anchor Anchor.Center\n       :Contents\n       (-&gt;\n        .character-state\n            (Match [0 (-&gt; .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n                    1 (-&gt; .character-left (UI.Image :Scale (float2 0.2)))\n                    2 (-&gt; .character-right (UI.Image :Scale (float2 0.2)))\n                    3 (-&gt; .character-jumping (UI.Image :Scale (float2 0.2)))]\n                    :Passthrough false)))))\n\n    (GFX.Render :Steps .render-steps)\n\n    (button-inputs))))\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre> <p>Now we just have to call this Wire in our main Wire with <code>Step</code>. </p> Step <p><code>Step</code> schedules and runs another Wire on the Wire calling <code>Step</code> itself.</p> Code AddedFull Code So Far <pre><code>(Step idle-animation) ;; (1)\n</code></pre> <ol> <li><code>Step</code> allows us to run a code in parallel to the main Wire. This line is added to line 62.</li> </ol> <pre><code>(defshards load-texture [name]\n  (LoadImage name)\n  (GFX.Texture))\n\n(defshards initialize-character []\n  (LoadTexture \"GlodImages/Character1.png\") = .character-image\n  (LoadTexture \"GlodImages/Character1_Left.png\") = .character-left\n  (LoadTexture \"GlodImages/Character1_Right.png\") = .character-right\n  (LoadTexture \"GlodImages/Character1_Jumping.png\") = .character-jumping\n\n  0 &gt;= .character-state\n\n  ;; ---------- Character Idle Array ----------\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png\") &gt;&gt; .idle-left-image-array\n\n  0 &gt;= .idle-image-index\n  (Count .idle-left-image-array) = .idle-image-index-max\n  0.08 = .idle-animation-speed)\n\n;; --------- Idle Animation Loop ---------\n(defloop idle-animation\n  .idle-image-index (Math.Add 1)\n  &gt; .idle-image-index\n  (When\n   :Predicate (IsMoreEqual .idle-image-index-max)\n   :Action (-&gt; 0 &gt; .idle-image-index))\n  (Pause .idle-animation-speed))\n\n;; ------- Button Inputs ----------\n(defshards button-inputs []\n  (Inputs.KeyDown\n   :Key \"left\"\n   :Action\n   (-&gt;\n    (Msg \"left\")\n    1 &gt; .character-state))\n\n  (Inputs.KeyDown\n   :Key \"right\"\n   :Action\n   (-&gt;\n    (Msg \"right\")\n    2 &gt; .character-state))\n\n  (Inputs.KeyDown\n   :Key \"up\"\n   :Action\n   (-&gt;\n    (Msg \"up\")\n    3 &gt; .character-state)))\n\n(defloop main-wire\n  (Setup\n   (initialize-character))\n\n  (Step idle-animation)\n\n  (GFX.MainWindow\n   :Title \"MainWindow\" :Width 1920 :Height 1080\n   :Contents\n   (-&gt;\n    (Setup\n     (GFX.DrawQueue) &gt;= .ui-draw-queue\n     (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n    .ui-draw-queue (GFX.ClearQueue)\n\n    (UI\n     .ui-draw-queue\n     (-&gt;\n      (UI.Area\n       :Position (float2 0 0)\n       :Anchor Anchor.Center\n       :Contents\n       (-&gt;\n        .character-state\n        (Match [0 (-&gt; .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n                1 (-&gt; .character-left (UI.Image :Scale (float2 0.2)))\n                2 (-&gt; .character-right (UI.Image :Scale (float2 0.2)))\n                3 (-&gt; .character-jumping (UI.Image :Scale (float2 0.2)))]\n               :Passthrough false)))))\n\n    (GFX.Render :Steps .render-steps)\n\n    (button-inputs))))\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre> <p>Phew, that was a pretty long step! \ud83d\ude2a But it was worth it! Try running the code now. Tadah! You now have an animated idle image.</p>"},{"location":"learn/shards/tutorials/glod-game/steps/step-3/#step-35","title":"Step 3.5","text":"<p>Before we proceed to the next chapter, let's give Glod more animations.</p> <p>We will be:</p> <ol> <li> <p>Using the same logic to give Glod his walk animation.</p> </li> <li> <p>Creating the logic to ensure that he faces the correct direction when the corresponding buttons are pressed. </p> </li> </ol> <p>Create the appropriate folders and save the images accordingly:</p> <ul> <li> <p>Download Glod's \"Walking Right\" animation here.</p> </li> <li> <p>Download Glod's \"Walking Left\" animation here.</p> </li> <li> <p>Download Glod's \"Idle Right\" animation here.</p> </li> </ul> Jumping Frame <p>There is no animation for jumping. Instead, it retains a single image while jumping.</p> <p>2D characters feel more responsive when they transit immediately between jumping and walking/idling. This is achieved by using only a single frame.</p> <p>Similar to how we created an image array for the idle animation when Glod is facing left, we will now create one for when Glod is facing right.</p> Code Added <pre><code>  ;; ---------- Character Idle Array (Facing Right) ----------------\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_1.png\") &gt;&gt; .idle-right-image-array ;; (1)\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_2.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_3.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_4.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_5.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_6.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_7.png\") &gt;&gt; .idle-right-image-array\n</code></pre> <ol> <li>Added to line 22.</li> </ol> <p>Create image arrays for when Glod is walking left and for when Glod is walking right. Since the walking animation is different from the idle animation, we will be making new variables for:</p> <ul> <li> <p>Animation speed</p> </li> <li> <p>Image index</p> </li> <li> <p>Max image index</p> <pre><code>  ;; -------------- Walking Array (Facing Left) -----------------\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_1.png\") &gt;&gt; .walking-left-image-array ;; (1)\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_2.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_3.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_4.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_5.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_6.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_7.png\") &gt;&gt; .walking-left-image-array\n\n  ;; ----------- Walking Array (Facing Right) ---------------\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_1.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_2.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_3.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_4.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_5.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_6.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_7.png\") &gt;&gt; .walking-right-image-array\n\n  (Count .walking-left-image-array) = .walking-image-index-max\n  0 &gt;= .walking-image-index\n  0.08 = .walking-animation-speed ;; Reduce number to increase animation speed\n</code></pre> <ol> <li>Added to line 35.</li> </ol> </li> </ul> <p><code>.character-left</code>, <code>.character-right</code> are updated to display an image from their respective arrays.</p> <pre><code>```{.clojure .annotate linenums=\"1\"}\n\n.walking-left-image-array (Take .walking-image-index) ;; (1)\n.walking-right-image-array (Take .walking-image-index)\n```\n\n1. Update lines 115 - 116.\n</code></pre> Full Code So Far <pre><code>(defshards load-texture [name]\n  (LoadImage name)\n  (GFX.Texture))\n\n(defshards initialize-character []\n  (LoadTexture \"GlodImages/Character1.png\") = .idle-left-image-array\n  (LoadTexture \"GlodImages/Character1_Left.png\") = .character-left\n  (LoadTexture \"GlodImages/Character1_Right.png\") = .character-right\n  (LoadTexture \"GlodImages/Character1_Jumping.png\") = .character-jumping\n\n  0 &gt;= .character-state\n\n  ;; ---------- Character Idle Array (Facing Left)----------\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png\") &gt;&gt; .idle-left-image-array\n\n  ;; ---------- Character Idle Array (Facing Right) ----------------\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_1.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_2.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_3.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_4.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_5.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_6.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_7.png\") &gt;&gt; .idle-right-image-array\n\n  0 &gt;= .idle-image-index\n  (Count .idle-left-image-array) = .idle-image-index-max\n  0.08 = .idle-animation-speed\n\n  ;; -------------- Walking Array (Facing Left) -----------------\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_1.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_2.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_3.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_4.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_5.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_6.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_7.png\") &gt;&gt; .walking-left-image-array\n\n  ;; ----------- Walking Array (Facing Right) ---------------\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_1.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_2.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_3.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_4.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_5.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_6.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_7.png\") &gt;&gt; .walking-right-image-array\n\n  (Count .walking-left-image-array) = .walking-image-index-max\n  0 &gt;= .walking-image-index\n  0.08 = .walking-animation-speed ;; Reduce number to increase animation speed\n  )\n\n;; --------- Idle Animation Loop ---------\n(defloop idle-animation\n  .idle-image-index (Math.Add 1)\n  &gt; .idle-image-index\n  (When\n   :Predicate (IsMoreEqual .idle-image-index-max)\n   :Action (-&gt; 0 &gt; .idle-image-index))\n  (Pause .idle-animation-speed))\n\n;; ------- Button Inputs ----------\n(defshards button-inputs []\n  (Inputs.KeyDown\n   :Key \"left\"\n   :Action\n   (-&gt;\n    (Msg \"left\")\n    1 &gt; .character-state))\n\n  (Inputs.KeyDown\n   :Key \"right\"\n   :Action\n   (-&gt;\n    (Msg \"right\")\n    2 &gt; .character-state))\n\n  (Inputs.KeyDown\n   :Key \"up\"\n   :Action\n   (-&gt;\n    (Msg \"up\")\n    3 &gt; .character-state)))\n\n(defloop main-wire\n  (Setup\n   (initialize-character))\n\n  (Step idle-animation)\n\n  (GFX.MainWindow\n   :Title \"MainWindow\" :Width 1920 :Height 1080\n   :Contents\n   (-&gt;\n    (Setup\n     (GFX.DrawQueue) &gt;= .ui-draw-queue\n     (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n    .ui-draw-queue (GFX.ClearQueue)\n\n    (UI\n     .ui-draw-queue\n     (-&gt;\n      (UI.Area\n       :Position (float2 0 0)\n       :Anchor Anchor.Center\n       :Contents\n       (-&gt;\n        .character-state\n        (Match [0 (-&gt; .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n                1 (-&gt; .walking-left-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n                2 (-&gt; .walking-right-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n                3 (-&gt; .character-jumping (UI.Image :Scale (float2 0.2)))]\n               :Passthrough false)))))\n\n    (GFX.Render :Steps .render-steps)\n\n    (button-inputs))))\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre> <p>Create a Wire for the walking animation and <code>Step</code> it.</p> Code AddedFull Code So Far <pre><code> ;; -------- Walking Animation Loop --------\n(defloop walking-animation ;; (1)\n  .walking-image-index (Math.Add 1)\n  &gt; .walking-image-index\n  (When\n   :Predicate (IsMoreEqual .walking-image-index-max) \n   :Action (-&gt; 0 &gt; .walking-image-index))\n  (Pause .walking-animation-speed))\n</code></pre> <ol> <li>Added to line 67.</li> </ol> <pre><code>  (Step walking-animation) ;; (1)\n</code></pre> <ol> <li>Added to line 104.</li> </ol> <pre><code>(defshards load-texture [name]\n  (LoadImage name)\n  (GFX.Texture))\n\n(defshards initialize-character []\n  (LoadTexture \"GlodImages/Character1.png\") = .idle-left-image-array\n  (LoadTexture \"GlodImages/Character1_Left.png\") = .character-left\n  (LoadTexture \"GlodImages/Character1_Right.png\") = .character-right\n  (LoadTexture \"GlodImages/Character1_Jumping.png\") = .character-jumping\n\n  0 &gt;= .character-state\n\n  ;; ---------- Character Idle Array (Facing Left)----------\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png\") &gt;&gt; .idle-left-image-array\n\n  ;; ---------- Character Idle Array (Facing Right) ----------------\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_1.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_2.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_3.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_4.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_5.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_6.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_7.png\") &gt;&gt; .idle-right-image-array\n\n  0 &gt;= .idle-image-index\n  (Count .idle-left-image-array) = .idle-image-index-max\n  0.08 = .idle-animation-speed\n\n  ;; -------------- Walking Array (Facing Left) -----------------\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_1.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_2.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_3.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_4.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_5.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_6.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_7.png\") &gt;&gt; .walking-left-image-array\n\n  ;; ----------- Walking Array (Facing Right) ---------------\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_1.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_2.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_3.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_4.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_5.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_6.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_7.png\") &gt;&gt; .walking-right-image-array\n\n  (Count .walking-left-image-array) = .walking-image-index-max\n  0 &gt;= .walking-image-index\n  0.08 = .walking-animation-speed ;; Reduce number to increase animation speed\n  )\n\n;; --------- Idle Animation Loop ---------\n(defloop idle-animation\n  .idle-image-index (Math.Add 1)\n  &gt; .idle-image-index\n  (When\n   :Predicate (IsMoreEqual .idle-image-index-max)\n   :Action (-&gt; 0 &gt; .idle-image-index))\n  (Pause .idle-animation-speed))\n\n;; -------- Walking Animation Loop --------\n(defloop walking-animation\n  .walking-image-index (Math.Add 1)\n  &gt; .walking-image-index\n  (When\n   :Predicate (IsMoreEqual .walking-image-index-max) \n   :Action (-&gt; 0 &gt; .walking-image-index))\n  (Pause .walking-animation-speed))\n\n;; ------- Button Inputs ----------\n(defshards button-inputs []\n  (Inputs.KeyDown\n   :Key \"left\"\n   :Action\n   (-&gt;\n    (Msg \"left\")\n    1 &gt; .character-state))\n\n  (Inputs.KeyDown\n   :Key \"right\"\n   :Action\n   (-&gt;\n    (Msg \"right\")\n    2 &gt; .character-state))\n\n  (Inputs.KeyDown\n   :Key \"up\"\n   :Action\n   (-&gt;\n    (Msg \"up\")\n    3 &gt; .character-state)))\n\n(defloop main-wire\n  (Setup\n   (initialize-character))\n\n  (Step idle-animation)\n  (Step walking-animation)\n\n  (GFX.MainWindow\n   :Title \"MainWindow\" :Width 1920 :Height 1080\n   :Contents\n   (-&gt;\n    (Setup\n     (GFX.DrawQueue) &gt;= .ui-draw-queue\n     (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n    .ui-draw-queue (GFX.ClearQueue)\n\n    (UI\n     .ui-draw-queue\n     (-&gt;\n      (UI.Area\n       :Position (float2 0 0)\n       :Anchor Anchor.Center\n       :Contents\n       (-&gt;\n        .character-state\n        (Match [0 (-&gt; .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n                1 (-&gt; .walking-left-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n                2 (-&gt; .walking-right-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n                3 (-&gt; .character-jumping (UI.Image :Scale (float2 0.2)))]\n               :Passthrough false)))))\n\n    (GFX.Render :Steps .render-steps)\n\n    (button-inputs))))\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre>"},{"location":"learn/shards/tutorials/glod-game/steps/step-3/#step-36","title":"Step 3.6","text":"<p>If you tried running the program, you might notice some problems.</p> <p>Namely:</p> <ol> <li>Glod does not return to his idle animation.</li> <li>Glod's jumping animation only faces right.</li> </ol> <p>Let's fix these problems.</p> <p>Why don't we start with the easier one first? Let's get Glod to return to his idle animation when we are not pressing any buttons.</p> <p>To do this we will:</p> <ol> <li> <p>Use <code>Inputs.KeyUp</code>.</p> </li> <li> <p>Create a variable that tracks which direction Glod is facing towards.</p> </li> </ol> Code Added <pre><code>0 &gt;= .character-direction ;; 0 = facing left, 1 = facing right ;; (1)\n</code></pre> <ol> <li>Added to line 12 under <code>initialize-character</code>.</li> </ol> <p>;; ------- Button Inputs ---------- (defshards button-inputs [] ;; (1)   (Inputs.KeyDown    :Key \"left\"    :Action    (-&gt;     (Msg \"left\")     1 &gt; .character-state     0 &gt; .character-direction))</p> <p>(Inputs.KeyDown ;; (3)    :Key \"right\"    :Action    (-&gt;     (Msg \"right\")     2 &gt; .character-state     1 &gt; .character-direction))</p> <p>(Inputs.KeyDown    :Key \"up\"    :Action    (-&gt;      (Msg \"up\")      3 &gt; .character-state))</p> <p>(Inputs.KeyUp ;; (2)    :Key \"left\"    :Action     (-&gt;     0 &gt; .character-state))</p> <p>(Inputs.KeyUp    :Key \"right\"    :Action    (-&gt;     0 &gt; .character-state))) ```</p> <ol> <li> <p>Added to line 78.</p> </li> <li> <p>When the left and right buttons are released, <code>.character-state</code> will revert back to 0.</p> </li> <li> <p>When the left and right buttons are pressed <code>.character-direction</code> will be 0 and 1 respectively.</p> </li> </ol> <p>Lastly, we will add another <code>Match</code> nested within <code>Match [0(-&gt;)]</code> so that Glod displays the correct image based on his direction.</p> <pre><code>```{.clojure .annotate linenums=\"1\"}\n  (Match [0 (-&gt; .character-direction\n                (Match [0 (-&gt; .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n                        1 (-&gt; .idle-right-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))]\n                        :Passthrough false))\n          1 (-&gt; .walking-left-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n          2 (-&gt; .walking-right-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n          3 (-&gt; .character-jumping (UI.Image :Scale (float2 0.2)))]\n          :Passthrough false)\n```\n</code></pre> Full Code So Far <pre><code>(defshards LoadTexture [name]\n  (LoadImage name)\n  (GFX.Texture))\n\n(defshards initialize-character []\n  (LoadTexture \"GlodImages/Character1.png\") = .character-image\n  (LoadTexture \"GlodImages/Character1_Left.png\") = .character-left\n  (LoadTexture \"GlodImages/Character1_Right.png\") = .character-right\n  (LoadTexture \"GlodImages/Character1_Jumping.png\") = .character-jumping\n\n  0 &gt;= .character-state\n  0 &gt;= .character-direction\n\n  ;; ---------- Character Idle Array (Facing Left) ----------\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png\") &gt;&gt; .idle-left-image-array\n\n  ;; ---------- Character Idle Array (Facing Right) ----------------\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_1.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_2.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_3.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_4.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_5.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_6.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_7.png\") &gt;&gt; .idle-right-image-array\n\n  0 &gt;= .idle-image-index\n  (Count .idle-left-image-array) = .idle-image-index-max\n  0.08 = .idle-animation-speed\n\n  ;; -------------- Walking Array (Facing Left) -----------------\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_1.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_2.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_3.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_4.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_5.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_6.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_7.png\") &gt;&gt; .walking-left-image-array\n\n  ;; ----------- Walking Array (Facing Right) ---------------\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_1.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_2.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_3.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_4.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_5.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_6.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_7.png\") &gt;&gt; .walking-right-image-array\n\n  (Count .walking-left-image-array) = .walking-image-index-max\n  0 &gt;= .walking-image-index\n  0.08 = .walking-animation-speed) ;; Reduce number to increase animation speed\n\n;; --------- Idle Animation Loop ---------\n(defloop idle-animation\n  .idle-image-index (Math.Add 1)\n  &gt; .idle-image-index\n  (When :Predicate (IsMoreEqual .idle-image-index-max)\n        :Action (-&gt; 0 &gt; .idle-image-index))\n  (Pause .idle-animation-speed))\n\n;; -------- Walking Animation Loop --------\n(defloop walking-animation\n  .walking-image-index (Math.Add 1)\n  &gt; .walking-image-index\n  (When :Predicate (IsMoreEqual .walking-image-index-max)\n        :Action (-&gt; 0 &gt; .walking-image-index))\n  (Pause .walking-animation-speed))\n\n;; ------- Button Inputs ----------\n(defshards button-inputs []\n  (Inputs.KeyDown\n  :Key \"left\"\n  :Action (-&gt;\n            (Msg \"left\")\n            1 &gt; .character-state\n            0 &gt; .character-direction))\n\n  (Inputs.KeyDown\n  :Key \"right\"\n  :Action (-&gt;\n            (Msg \"right\")\n            2 &gt; .character-state\n            1 &gt; .character-direction))\n\n  (Inputs.KeyDown\n  :Key \"up\"\n  :Action (-&gt;\n            (Msg \"up\")\n            3 &gt; .character-state))\n\n  (Inputs.KeyUp\n  :Key \"left\"\n  :Action (-&gt;\n            0 &gt; .character-state))\n\n  (Inputs.KeyUp\n  :Key \"right\"\n  :Action (-&gt;\n            0 &gt; .character-state)))\n\n;;---------- main-wire ------------\n(defloop main-wire\n  (Setup\n  (initialize-character))\n\n  (Step idle-animation)\n  (Step walking-animation)\n\n  (GFX.MainWindow\n  :Title \"MainWindow\" :Width 1920 :Height 1080\n  :Contents\n  (-&gt; (Setup\n        (GFX.DrawQueue) &gt;= .ui-draw-queue\n        (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n      .ui-draw-queue (GFX.ClearQueue)\n\n      (UI\n        .ui-draw-queue\n        (-&gt;\n        (UI.Area :Position (float2 0 0)\n                  :Anchor Anchor.Center\n                  :Contents\n                  (-&gt;\n                  .character-state\n                  (Match [0 (-&gt; .character-direction\n                                (Match [0 (-&gt; LoadTexture .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n                                        1 (-&gt; LoadTexture .idle-right-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))]\n                                        :Passthrough false))\n                          1 (-&gt; LoadTexture .walking-left-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n                          2 (-&gt; LoadTexture .walking-right-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n                          3 (-&gt; LoadTexture .character-jumping (UI.Image :Scale (float2 0.2)))]\n                          :Passthrough false)))))\n\n      (button-inputs)\n\n      (GFX.Render :Steps .render-steps))))\n\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre> <p>When you run the programme, Glod will  return to his idle animation whenever you stop pressing the left, right or up buttons and he should be facing the correct direction. Now we have to do the same thing for our jump animation</p> <ul> <li>Download Jumping Image here.</li> </ul> Code AddedFull Code So Far <pre><code>;; -------------- Character Jumping  ----------\n(LoadTexture \"GlodImages/Character1_Jumping_Left.png\") = .character-jumping-left\n(LoadTexture \"GlodImages/Character1_Jumping_Right.png\") = .character-jumping-right\n</code></pre> <p>Add in a jumping right image and rename our original .character-jumping to .character-jumping-left added to line 5 - 7.</p> <pre><code>(Match [0 (-&gt; .character-direction\n              (Match [0 (-&gt; .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n                      1 (-&gt; .idle-right-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))]\n                      :Passthrough false))\n        1 (-&gt; .walking-left-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n        2 (-&gt; .walking-right-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n        3 (-&gt;  .character-direction\n              (Match [0 (-&gt; .character-jumping-left (UI.Image :Scale (float2 0.2)))\n                      1 (-&gt; .character-jumping-right (UI.Image :Scale (float2 0.2)))]\n                      :Passthrough false))]\n        :Passthrough false)\n</code></pre> <p>Then add another Match to our original Match to show the corresponding jump image depending on Glod's direction.Code added to lines 127-137.</p> <pre><code>(defshards load-texture [name]\n  (LoadImage name)\n  (GFX.Texture))\n\n(defshards initialize-character []\n  (LoadTexture \"GlodImages/Character1.png\") = .idle-left-image-array\n  (LoadTexture \"GlodImages/Character1_Left.png\") = .character-left\n  (LoadTexture \"GlodImages/Character1_Right.png\") = .character-right\n  (LoadTexture \"GlodImages/Character1_Jumping.png\") = .character-jumping\n\n  0 &gt;= .character-state\n  0 &gt;= .character-direction ;; 0 = facing left, 1 = facing right\n\n  ;; ---------- Character Idle Array (Facing Left)----------\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png\") &gt;&gt; .idle-left-image-array\n\n  ;; ---------- Character Idle Array (Facing Right) ----------------\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_1.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_2.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_3.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_4.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_5.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_6.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_7.png\") &gt;&gt; .idle-right-image-array\n\n  0 &gt;= .idle-image-index\n  (Count .idle-left-image-array) = .idle-image-index-max\n  0.08 = .idle-animation-speed\n\n  ;; -------------- Walking Array (Facing Left) -----------------\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_1.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_2.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_3.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_4.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_5.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_6.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_7.png\") &gt;&gt; .walking-left-image-array\n\n  ;; ----------- Walking Array (Facing Right) ---------------\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_1.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_2.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_3.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_4.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_5.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_6.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_7.png\") &gt;&gt; .walking-right-image-array\n\n  (Count .walking-left-image-array) = .walking-image-index-max\n  0 &gt;= .walking-image-index\n  0.08 = .walking-animation-speed ;; Reduce number to increase animation speed\n  )\n\n;; --------- Idle Animation Loop ---------\n(defloop idle-animation\n  .idle-image-index (Math.Add 1)\n  &gt; .idle-image-index\n  (When\n   :Predicate (IsMoreEqual .idle-image-index-max)\n   :Action (-&gt; 0 &gt; .idle-image-index))\n  (Pause .idle-animation-speed))\n\n;; -------- Walking Animation Loop --------\n(defloop walking-animation\n  .walking-image-index (Math.Add 1)\n  &gt; .walking-image-index\n  (When\n   :Predicate (IsMoreEqual .walking-image-index-max) \n   :Action (-&gt; 0 &gt; .walking-image-index))\n  (Pause .walking-animation-speed))\n\n;; ------- Button Inputs ----------\n(defshards button-inputs []\n  (Inputs.KeyDown\n   :Key \"left\"\n   :Action\n   (-&gt;\n    (Msg \"left\")\n    1 &gt; .character-state\n    0 &gt; .character-direction))\n\n  (Inputs.KeyDown\n   :Key \"right\"\n   :Action\n   (-&gt;\n    (Msg \"right\")\n    2 &gt; .character-state\n    1 &gt; .character-direction))\n\n  (Inputs.KeyDown\n   :Key \"up\"\n   :Action\n   (-&gt; \n    (Msg \"up\") \n    3 &gt; .character-state))\n\n  (Inputs.KeyUp\n   :Key \"left\"\n   :Action \n   (-&gt;\n    0 &gt; .character-state))\n\n  (Inputs.KeyUp\n   :Key \"right\"\n   :Action\n   (-&gt;\n    0 &gt; .character-state)))\n\n(defloop main-wire\n  (Setup\n   (initialize-character))\n\n  (Step idle-animation)\n  (Step walking-animation)\n\n  (GFX.MainWindow\n   :Title \"MainWindow\" :Width 1920 :Height 1080\n   :Contents\n   (-&gt;\n    (Setup\n     (GFX.DrawQueue) &gt;= .ui-draw-queue\n     (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n    .ui-draw-queue (GFX.ClearQueue)\n\n    (UI\n     .ui-draw-queue\n     (-&gt;\n      (UI.Area\n       :Position (float2 0 0)\n       :Anchor Anchor.Center\n       :Contents\n       (-&gt;\n        .character-state\n        (Match [0 (-&gt; .character-direction\n                      (Match [0 (-&gt; .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n                              1 (-&gt; .idle-right-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))]\n                             :Passthrough false))\n                1 (-&gt; .walking-left-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n                2 (-&gt; .walking-right-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n                3 (-&gt; .character-jumping (UI.Image :Scale (float2 0.2)))]\n               :Passthrough false)))))\n\n    (GFX.Render :Steps .render-steps)\n\n    (button-inputs))))\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre>"},{"location":"learn/shards/tutorials/glod-game/steps/step-3/#recap","title":"Recap","text":"<p>Try running the code now! Your adorable Glod should be fully animated and will now face the correct directions.</p> <p>Congratulations on making your first animated character in Shards.</p> <p>To recap, in this step, we used arrays of images to animate Glod. Next, we will break the chains that bind Glod down and give him the power to move.</p> <p>See you in the next chapter! \ud83d\ude04</p>"},{"location":"learn/shards/tutorials/glod-game/steps/step-4/","title":"Step 4","text":""},{"location":"learn/shards/tutorials/glod-game/steps/step-4/#moving-the-character-with-button-inputs-overview","title":"Moving the Character with Button Inputs - Overview","text":"<p>In the previous chapter, we breathed some life into Glod and transformed him from a static image into a fully animated character.</p> <p>Amazing!</p> <p>However, we can take things further. Let's free Glod from his stationary curse and make him move! To do this we will:</p> <ol> <li>Place a variable in the <code>Position</code> tag of <code>UI.Area</code>.</li> <li>Change this variable to make Glod move.</li> <li>Use velocity and acceleration concepts to make Glod jump.</li> </ol>"},{"location":"learn/shards/tutorials/glod-game/steps/step-4/#step-41","title":"Step 4.1","text":"<p>First, let's edit our code a little. Currently, Glod is situated in the center of the screen. While this can work, we can instead change his current <code>Anchor.Center</code> to <code>Anchor.Top</code>, and bring him down to Earth by changing his position. We achieve this by creating some variables.</p> <p>While any anchor will work as long as we change the position accordingly, we will be using <code>Anchor.Top</code> to keep things consistent and manage the positions of the different game elements more effectively.</p> <p>Create the <code>.x</code> and <code>.y</code> variables which will be used to create the variable <code>.character-position</code>.</p> Code Added <pre><code>0.0 &gt;= .x ;; (1)\n310.0 &gt;= .y\n(float2 .x .y) &gt;= .character-position\n</code></pre> <ol> <li>Added under <code>initialize-character</code>, at line 14.</li> </ol> <p><code>.character-position</code> is then fed into the <code>Position</code> parameter of the <code>UI.Area</code> shard. When the <code>.x</code> and <code>.y</code> values are changed, the <code>UI.Area</code> will move and hence move our character.</p> <p>Remember to change the <code>Anchor</code> to <code>Anchor.Top</code>!</p> Code AddedFull Code So Far <pre><code>(UI.Area\n :Position .character-position ;; (1)\n :Anchor Anchor.Top\n :Contents\n</code></pre> <ol> <li>Code edited at line 138.</li> </ol> <pre><code>(defshards load-texture [name]\n  (LoadImage name)\n  (GFX.Texture))\n\n(defshards initialize-character []\n  (LoadTexture \"GlodImages/Character1.png\") = .idle-left-image-array\n  (LoadTexture \"GlodImages/Character1_Left.png\") = .character-left\n  (LoadTexture \"GlodImages/Character1_Right.png\") = .character-right\n  (LoadTexture \"GlodImages/Character1_Jumping.png\") = .character-jumping\n\n  0 &gt;= .character-state\n  0 &gt;= .character-direction ;; 0 = facing left, 1 = facing right\n\n  0.0 &gt;= .x\n  310.0 &gt;= .y\n  (float2 .x .y) &gt;= .character-position\n\n  ;; ---------- Character Idle Array (Facing Left)----------\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png\") &gt;&gt; .idle-left-image-array\n\n  ;; ---------- Character Idle Array (Facing Right) ----------------\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_1.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_2.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_3.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_4.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_5.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_6.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_7.png\") &gt;&gt; .idle-right-image-array\n\n  0 &gt;= .idle-image-index\n  (Count .idle-left-image-array) = .idle-image-index-max\n  0.08 = .idle-animation-speed\n\n  ;; -------------- Walking Array (Facing Left) -----------------\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_1.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_2.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_3.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_4.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_5.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_6.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_7.png\") &gt;&gt; .walking-left-image-array\n\n  ;; ----------- Walking Array (Facing Right) ---------------\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_1.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_2.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_3.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_4.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_5.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_6.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_7.png\") &gt;&gt; .walking-right-image-array\n\n  (Count .walking-left-image-array) = .walking-image-index-max\n  0 &gt;= .walking-image-index\n  0.08 = .walking-animation-speed ;; Reduce number to increase animation speed\n  )\n\n;; --------- Idle Animation Loop ---------\n(defloop idle-animation\n  .idle-image-index (Math.Add 1)\n  &gt; .idle-image-index\n  (When\n   :Predicate (IsMoreEqual .idle-image-index-max)\n   :Action (-&gt; 0 &gt; .idle-image-index))\n  (Pause .idle-animation-speed))\n\n;; -------- Walking Animation Loop --------\n(defloop walking-animation\n  .walking-image-index (Math.Add 1)\n  &gt; .walking-image-index\n  (When\n   :Predicate (IsMoreEqual .walking-image-index-max) \n   :Action (-&gt; 0 &gt; .walking-image-index))\n  (Pause .walking-animation-speed))\n\n;; ------- Button Inputs ----------\n(defshards button-inputs []\n  (Inputs.KeyDown\n   :Key \"left\"\n   :Action\n   (-&gt;\n    (Msg \"left\")\n    1 &gt; .character-state\n    0 &gt; .character-direction))\n\n  (Inputs.KeyDown\n   :Key \"right\"\n   :Action\n   (-&gt;\n    (Msg \"right\")\n    2 &gt; .character-state\n    1 &gt; .character-direction))\n\n  (Inputs.KeyDown\n   :Key \"up\"\n   :Action\n   (-&gt; \n    (Msg \"up\") \n    3 &gt; .character-state))\n\n  (Inputs.KeyUp\n   :Key \"left\"\n   :Action \n   (-&gt;\n    0 &gt; .character-state))\n\n  (Inputs.KeyUp\n   :Key \"right\"\n   :Action\n   (-&gt;\n    0 &gt; .character-state)))\n\n(defloop main-wire\n  (Setup\n   (initialize-character))\n\n  (Step idle-animation)\n  (Step walking-animation)\n\n  (GFX.MainWindow\n   :Title \"MainWindow\" :Width 1920 :Height 1080\n   :Contents\n   (-&gt;\n    (Setup\n     (GFX.DrawQueue) &gt;= .ui-draw-queue\n     (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n    .ui-draw-queue (GFX.ClearQueue)\n\n    (UI\n     .ui-draw-queue\n     (-&gt;\n      (UI.Area\n       :Position .character-position\n       :Anchor Anchor.Top\n       :Contents\n       (-&gt;\n        .character-state\n        (Match [0 (-&gt; .character-direction\n                      (Match [0 (-&gt; .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n                              1 (-&gt; .idle-right-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))]\n                             :Passthrough false))\n                1 (-&gt; .walking-left-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n                2 (-&gt; .walking-right-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n                3 (-&gt; .character-jumping (UI.Image :Scale (float2 0.2)))]\n               :Passthrough false)))))\n\n    (GFX.Render :Steps .render-steps)\n\n    (button-inputs))))\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre>"},{"location":"learn/shards/tutorials/glod-game/steps/step-4/#step-42","title":"Step 4.2","text":"<p>Now that our variables are set up, it's time to make Glod move! Let's start by moving him to the left and right.</p> <p>To do this, we simply have to change the <code>.x</code> value that we have just created whenever the left and right buttons are pressed.</p> <p>First, create a new variable named <code>.character-x-velocity</code>. We will change this value when the right and left directional buttons are pressed to make our character move.</p> Code Added <pre><code>0.0 &gt;= .character-x-velocity ;; (1)\n</code></pre> <ol> <li>Added to <code>initialize-character</code> at line 17.</li> </ol> <p>Create the <code>run-logic</code> shard. When <code>.character-x-velocity</code> is changed, it will be added to <code>.x</code> and <code>.character-position</code> will be updated accordingly.</p> Code Added <pre><code>;; ------------ Character Run Logic ----------------\n(defshards run-logic [] ;; (1)\n  .x (Math.Add .character-x-velocity)\n  &gt; .x\n\n  (float2 .x .y) &gt; .character-position)\n</code></pre> <ol> <li>Added to line 83.</li> </ol> <p>Update the value of <code>.character-x-velocity</code> whenever the left or right directional buttons are pressed. Remember to reset the value back to 0 when the buttons are released. If not, Glod will move to the left or right forever.</p> Code AddedFull Code So Far <pre><code>;; ------- Button Inputs ----------\n(defshards button-inputs [] ;; (1)\n  (Inputs.KeyDown\n   :Key \"left\"\n   :Action\n   (-&gt;\n    (Msg \"left\")\n    1 &gt; .character-state\n    0 &gt; .character-direction\n    -5.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyDown\n   :Key \"right\"\n   :Action\n   (-&gt;\n    (Msg \"right\")\n    2 &gt; .character-state\n    1 &gt; .character-direction\n    5.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyDown\n   :Key \"up\"\n   :Action\n   (-&gt; \n    (Msg \"up\") \n    3 &gt; .character-state))\n\n  (Inputs.KeyUp\n   :Key \"left\"\n   :Action \n   (-&gt;\n    0 &gt; .character-state\n    0.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyUp\n   :Key \"right\"\n   :Action\n   (-&gt;\n    0 &gt; .character-state\n    0.0 &gt; .character-x-velocity)))\n</code></pre> <ol> <li>Updated within the <code>button-inputs</code> shard at line 90.</li> </ol> <pre><code>(run-logic) ;; (1)\n</code></pre> <ol> <li><code>run-logic</code> is added to the <code>main-wire</code> at line 134.</li> </ol> <pre><code>(defshards load-texture [name]\n  (LoadImage name)\n  (GFX.Texture))\n\n(defshards initialize-character []\n  (LoadTexture \"GlodImages/Character1.png\") = .idle-left-image-array\n  (LoadTexture \"GlodImages/Character1_Left.png\") = .character-left\n  (LoadTexture \"GlodImages/Character1_Right.png\") = .character-right\n  (LoadTexture \"GlodImages/Character1_Jumping.png\") = .character-jumping\n\n  0 &gt;= .character-state\n  0 &gt;= .character-direction ;; 0 = facing left, 1 = facing right\n\n  0.0 &gt;= .x\n  310.0 &gt;= .y\n  (float2 .x .y) &gt;= .character-position\n  0.0 &gt;= .character-x-velocity\n\n  ;; ---------- Character Idle Array (Facing Left)----------\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png\") &gt;&gt; .idle-left-image-array\n\n  ;; ---------- Character Idle Array (Facing Right) ----------------\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_1.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_2.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_3.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_4.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_5.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_6.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_7.png\") &gt;&gt; .idle-right-image-array\n\n  0 &gt;= .idle-image-index\n  (Count .idle-left-image-array) = .idle-image-index-max\n  0.08 = .idle-animation-speed\n\n  ;; -------------- Walking Array (Facing Left) -----------------\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_1.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_2.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_3.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_4.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_5.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_6.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_7.png\") &gt;&gt; .walking-left-image-array\n\n  ;; ----------- Walking Array (Facing Right) ---------------\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_1.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_2.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_3.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_4.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_5.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_6.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_7.png\") &gt;&gt; .walking-right-image-array\n\n  (Count .walking-left-image-array) = .walking-image-index-max\n  0 &gt;= .walking-image-index\n  0.08 = .walking-animation-speed ;; Reduce number to increase animation speed\n  )\n\n;; --------- Idle Animation Loop ---------\n(defloop idle-animation\n  .idle-image-index (Math.Add 1)\n  &gt; .idle-image-index\n  (When\n   :Predicate (IsMoreEqual .idle-image-index-max)\n   :Action (-&gt; 0 &gt; .idle-image-index))\n  (Pause .idle-animation-speed))\n\n;; -------- Walking Animation Loop --------\n(defloop walking-animation\n  .walking-image-index (Math.Add 1)\n  &gt; .walking-image-index\n  (When\n   :Predicate (IsMoreEqual .walking-image-index-max) \n   :Action (-&gt; 0 &gt; .walking-image-index))\n  (Pause .walking-animation-speed))\n\n;; ------------ Character Run Logic ----------------\n(defshards run-logic []\n  .x (Math.Add .character-x-velocity)\n  &gt; .x\n\n  (float2 .x .y) &gt; .character-position)\n\n;; ------- Button Inputs ----------\n(defshards button-inputs []\n  (Inputs.KeyDown\n   :Key \"left\"\n   :Action\n   (-&gt;\n    (Msg \"left\")\n    1 &gt; .character-state\n    0 &gt; .character-direction\n    -5.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyDown\n   :Key \"right\"\n   :Action\n   (-&gt;\n    (Msg \"right\")\n    2 &gt; .character-state\n    1 &gt; .character-direction\n    5.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyDown\n   :Key \"up\"\n   :Action\n   (-&gt; \n    (Msg \"up\") \n    3 &gt; .character-state))\n\n  (Inputs.KeyUp\n   :Key \"left\"\n   :Action \n   (-&gt;\n    0 &gt; .character-state\n    0.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyUp\n   :Key \"right\"\n   :Action\n   (-&gt;\n    0 &gt; .character-state\n    0.0 &gt; .character-x-velocity)))\n\n(defloop main-wire\n  (Setup\n   (initialize-character))\n\n  (run-logic)\n\n  (Step idle-animation)\n  (Step walking-animation)\n\n  (GFX.MainWindow\n   :Title \"MainWindow\" :Width 1920 :Height 1080\n   :Contents\n   (-&gt;\n    (Setup\n     (GFX.DrawQueue) &gt;= .ui-draw-queue\n     (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n    .ui-draw-queue (GFX.ClearQueue)\n\n    (UI\n     .ui-draw-queue\n     (-&gt;\n      (UI.Area\n       :Position .character-position\n       :Anchor Anchor.Top\n       :Contents\n       (-&gt;\n        .character-state\n        (Match [0 (-&gt; .character-direction\n                      (Match [0 (-&gt; .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n                              1 (-&gt; .idle-right-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))]\n                             :Passthrough false))\n                1 (-&gt; .walking-left-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n                2 (-&gt; .walking-right-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n                3 (-&gt; .character-jumping (UI.Image :Scale (float2 0.2)))]\n               :Passthrough false)))))\n\n    (GFX.Render :Steps .render-steps)\n\n    (button-inputs))))\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre>"},{"location":"learn/shards/tutorials/glod-game/steps/step-4/#step-43","title":"Step 4.3","text":"<p>Oh no! We now have a problem. \ud83e\udd72</p> <p>If we continue moving Glod left or right, you might notice that he goes off-screen.</p> <p>Let's set up a boundary to ensure that Glod does not fall off the edge and into the abyss. To do this, create a clamp function that limits how far our x value can go.</p> Code Added <pre><code>;; ---------- Character Boundary ------------ ;; (1)\n(defshards clamp [var min max]\n  var (Max min) (Min max) &gt; var)\n</code></pre> <ol> <li>Added to line 82.</li> </ol> <p>This clamp function takes in a value and makes sure that it does not exceed the minimum and maximum values.</p> <p>Call our <code>clamp</code> function in <code>run-logic</code> and set the <code>var</code> parameter to be <code>.x</code>, the <code>min</code> parameter to be -600, and the <code>max</code> parameter to be 600. </p> <p>Note</p> <p>You can change the <code>min</code> and <code>max</code> parameters to fit your screen accordingly.</p> Code AddedFull Code So Far <pre><code>(clamp .x -600.0 600.0) ;; (1)\n</code></pre> <ol> <li>Added to line 93.</li> </ol> <pre><code>(defshards load-texture [name]\n  (LoadImage name)\n  (GFX.Texture))\n\n(defshards initialize-character []\n  (LoadTexture \"GlodImages/Character1.png\") = .idle-left-image-array\n  (LoadTexture \"GlodImages/Character1_Left.png\") = .character-left\n  (LoadTexture \"GlodImages/Character1_Right.png\") = .character-right\n  (LoadTexture \"GlodImages/Character1_Jumping.png\") = .character-jumping\n\n  0 &gt;= .character-state\n  0 &gt;= .character-direction ;; 0 = facing left, 1 = facing right\n\n  0.0 &gt;= .x\n  310.0 &gt;= .y\n  (float2 .x .y) &gt;= .character-position\n  0.0 &gt;= .character-x-velocity\n\n  ;; ---------- Character Idle Array (Facing Left)----------\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png\") &gt;&gt; .idle-left-image-array\n\n  ;; ---------- Character Idle Array (Facing Right) ----------------\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_1.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_2.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_3.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_4.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_5.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_6.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_7.png\") &gt;&gt; .idle-right-image-array\n\n  0 &gt;= .idle-image-index\n  (Count .idle-left-image-array) = .idle-image-index-max\n  0.08 = .idle-animation-speed\n\n  ;; -------------- Walking Array (Facing Left) -----------------\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_1.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_2.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_3.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_4.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_5.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_6.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_7.png\") &gt;&gt; .walking-left-image-array\n\n  ;; ----------- Walking Array (Facing Right) ---------------\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_1.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_2.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_3.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_4.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_5.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_6.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_7.png\") &gt;&gt; .walking-right-image-array\n\n  (Count .walking-left-image-array) = .walking-image-index-max\n  0 &gt;= .walking-image-index\n  0.08 = .walking-animation-speed ;; Reduce number to increase animation speed\n  )\n\n;; --------- Idle Animation Loop ---------\n(defloop idle-animation\n  .idle-image-index (Math.Add 1)\n  &gt; .idle-image-index\n  (When\n   :Predicate (IsMoreEqual .idle-image-index-max)\n   :Action (-&gt; 0 &gt; .idle-image-index))\n  (Pause .idle-animation-speed))\n\n;; -------- Walking Animation Loop --------\n(defloop walking-animation\n  .walking-image-index (Math.Add 1)\n  &gt; .walking-image-index\n  (When\n   :Predicate (IsMoreEqual .walking-image-index-max) \n   :Action (-&gt; 0 &gt; .walking-image-index))\n  (Pause .walking-animation-speed))\n\n;; ---------- Character Boundary ------------\n(defshards clamp [var min max]\n  var (Max min) (Min max) &gt; var)\n\n;; ------------ Character Run Logic ----------------\n(defshards run-logic []\n  .x (Math.Add .character-x-velocity)\n  &gt; .x\n\n  (float2 .x .y) &gt; .character-position\n\n  (clamp .X -600.0 600.0))\n\n;; ------- Button Inputs ----------\n(defshards button-inputs []\n  (Inputs.KeyDown\n   :Key \"left\"\n   :Action\n   (-&gt;\n    (Msg \"left\")\n    1 &gt; .character-state\n    0 &gt; .character-direction\n    -5.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyDown\n   :Key \"right\"\n   :Action\n   (-&gt;\n    (Msg \"right\")\n    2 &gt; .character-state\n    1 &gt; .character-direction\n    5.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyDown\n   :Key \"up\"\n   :Action\n   (-&gt; \n    (Msg \"up\") \n    3 &gt; .character-state))\n\n  (Inputs.KeyUp\n   :Key \"left\"\n   :Action \n   (-&gt;\n    0 &gt; .character-state\n    0.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyUp\n   :Key \"right\"\n   :Action\n   (-&gt;\n    0 &gt; .character-state\n    0.0 &gt; .character-x-velocity)))\n\n(defloop main-wire\n  (Setup\n   (initialize-character))\n\n  (run-logic)\n\n  (Step idle-animation)\n  (Step walking-animation)\n\n  (GFX.MainWindow\n   :Title \"MainWindow\" :Width 1920 :Height 1080\n   :Contents\n   (-&gt;\n    (Setup\n     (GFX.DrawQueue) &gt;= .ui-draw-queue\n     (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n    .ui-draw-queue (GFX.ClearQueue)\n\n    (UI\n     .ui-draw-queue\n     (-&gt;\n      (UI.Area\n       :Position .character-position\n       :Anchor Anchor.Top\n       :Contents\n       (-&gt;\n        .character-state\n        (Match [0 (-&gt; .character-direction\n                      (Match [0 (-&gt; .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n                              1 (-&gt; .idle-right-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))]\n                             :Passthrough false))\n                1 (-&gt; .walking-left-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n                2 (-&gt; .walking-right-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n                3 (-&gt; .character-jumping (UI.Image :Scale (float2 0.2)))]\n               :Passthrough false)))))\n\n    (GFX.Render :Steps .render-steps)\n\n    (button-inputs))))\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre> <p>Yay! Now Glod will not walk off into the void! \ud83d\ude19</p>"},{"location":"learn/shards/tutorials/glod-game/steps/step-4/#step-44","title":"Step 4.4","text":"<p>Now, let's make Glod jump!</p> <p>Instead of just using velocity, we can add acceleration into the mix. This will make Glod's jump feel more amazing.</p> Jumping using Velocity &amp; Acceleration <p>For smooth realistic jumping, we have to decrease velocity by acceleration whenever we jump. Decreasing velocity by acceleration decreases the rate of increase of <code>.y</code>.</p> <p>This simulates gravity, making our jump feel more realistic.</p> <p>First, create the variables that we will use.</p> Code Added <pre><code>0.0 &gt;= .character-y-velocity ;; (1)\n0.0 &gt;= .character-y-acceleration\n</code></pre> <ol> <li>Added to lines 18 and 19.</li> </ol> <p>Similar to <code>run-logic</code>, we will add <code>.character-y-velocity</code> to our <code>.y</code> variable. This time however, we will also add .<code>character-y-acceleration</code> to <code>.character-y-velocity</code>.</p> Code Added <pre><code>;; ------------ Character Gravity Logic ---------------\n(defshards gravity-logic [] ;; (1)\n  .y (Math.Add .character-y-velocity)\n  &gt; .y\n\n  .character-y-velocity (Math.Add .character-y-acceleration)\n  &gt; .character-y-velocity\n\n  (float2 .x .y) &gt; .character-position)\n</code></pre> <ol> <li>Added to line 98.</li> </ol> <pre><code>(gravity-logic) ;; (1)\n</code></pre> <ol> <li>Added to line 160 in <code>main-wire</code>.</li> </ol> <p>Lastly we modify the value of <code>.character-y-velocity</code> and <code>.character-y-acceleration</code> whenever the Up directional button is pressed.</p> Code AddedFull Code So Far <p><pre><code>(Inputs.KeyDown\n  :Key \"up\"\n  :Action (-&gt;\n            (Msg \"up\")\n            3 &gt; .character-state\n            -20.0 &gt; .character-y-velocity ;; (1)\n            1.0 &gt;  .character-y-acceleration))\n</code></pre> 1. Added to line 140 in <code>button-inputs</code>.</p> <pre><code>(defshards load-texture [name]\n  (LoadImage name)\n  (GFX.Texture))\n\n(defshards initialize-character []\n  (LoadTexture \"GlodImages/Character1.png\") = .idle-left-image-array\n  (LoadTexture \"GlodImages/Character1_Left.png\") = .character-left\n  (LoadTexture \"GlodImages/Character1_Right.png\") = .character-right\n  (LoadTexture \"GlodImages/Character1_Jumping.png\") = .character-jumping\n\n  0 &gt;= .character-state\n  0 &gt;= .character-direction ;; 0 = facing left, 1 = facing right\n\n  0.0 &gt;= .x\n  310.0 &gt;= .y\n  (float2 .x .y) &gt;= .character-position\n  0.0 &gt;= .character-x-velocity\n  0.0 &gt;= .character-y-velocity\n  0.0 &gt;= .character-y-acceleration\n\n  ;; ---------- Character Idle Array (Facing Left)----------\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png\") &gt;&gt; .idle-left-image-array\n\n  ;; ---------- Character Idle Array (Facing Right) ----------------\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_1.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_2.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_3.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_4.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_5.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_6.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_7.png\") &gt;&gt; .idle-right-image-array\n\n  0 &gt;= .idle-image-index\n  (Count .idle-left-image-array) = .idle-image-index-max\n  0.08 = .idle-animation-speed\n\n  ;; -------------- Walking Array (Facing Left) -----------------\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_1.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_2.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_3.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_4.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_5.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_6.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_7.png\") &gt;&gt; .walking-left-image-array\n\n  ;; ----------- Walking Array (Facing Right) ---------------\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_1.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_2.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_3.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_4.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_5.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_6.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_7.png\") &gt;&gt; .walking-right-image-array\n\n  (Count .walking-left-image-array) = .walking-image-index-max\n  0 &gt;= .walking-image-index\n  0.08 = .walking-animation-speed ;; Reduce number to increase animation speed\n  )\n\n;; --------- Idle Animation Loop ---------\n(defloop idle-animation\n  .idle-image-index (Math.Add 1)\n  &gt; .idle-image-index\n  (When\n   :Predicate (IsMoreEqual .idle-image-index-max)\n   :Action (-&gt; 0 &gt; .idle-image-index))\n  (Pause .idle-animation-speed))\n\n;; -------- Walking Animation Loop --------\n(defloop walking-animation\n  .walking-image-index (Math.Add 1)\n  &gt; .walking-image-index\n  (When\n   :Predicate (IsMoreEqual .walking-image-index-max) \n   :Action (-&gt; 0 &gt; .walking-image-index))\n  (Pause .walking-animation-speed))\n\n;; ---------- Character Boundary ------------\n(defshards clamp [var min max]\n  var (Max min) (Min max) &gt; var)\n\n;; ------------ Character Run Logic ----------------\n(defshards run-logic []\n  .x (Math.Add .character-x-velocity)\n  &gt; .x\n\n  (float2 .x .y) &gt; .character-position\n\n  (clamp .X -600.0 600.0))\n\n;; ------------ Character Gravity Logic ---------------\n(defshards gravity-logic []\n  .y (Math.Add .character-y-velocity)\n  &gt; .y\n\n  .character-y-velocity (Math.Add .character-y-acceleration)\n  &gt; .character-y-velocity\n\n  (float2 .x .y) &gt; .character-position)\n\n;; ------- Button Inputs ----------\n(defshards button-inputs []\n  (Inputs.KeyDown\n   :Key \"left\"\n   :Action\n   (-&gt;\n    (Msg \"left\")\n    1 &gt; .character-state\n    0 &gt; .character-direction\n    -5.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyDown\n   :Key \"right\"\n   :Action\n   (-&gt;\n    (Msg \"right\")\n    2 &gt; .character-state\n    1 &gt; .character-direction\n    5.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyDown\n   :Key \"up\"\n   :Action\n   (-&gt;\n    (Msg \"up\")\n    3 &gt; .character-state\n    -20.0 &gt; .character-y-velocity\n    1.0 &gt;  .character-y-acceleration))\n\n  (Inputs.KeyUp\n   :Key \"left\"\n   :Action \n   (-&gt;\n    0 &gt; .character-state\n    0.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyUp\n   :Key \"right\"\n   :Action\n   (-&gt;\n    0 &gt; .character-state\n    0.0 &gt; .character-x-velocity)))\n\n(defloop main-wire\n  (Setup\n   (initialize-character))\n\n  (run-logic)\n  (gravity-logic)\n\n  (Step idle-animation)\n  (Step walking-animation)\n\n  (GFX.MainWindow\n   :Title \"MainWindow\" :Width 1920 :Height 1080\n   :Contents\n   (-&gt;\n    (Setup\n     (GFX.DrawQueue) &gt;= .ui-draw-queue\n     (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n    .ui-draw-queue (GFX.ClearQueue)\n\n    (UI\n     .ui-draw-queue\n     (-&gt;\n      (UI.Area\n       :Position .character-position\n       :Anchor Anchor.Top\n       :Contents\n       (-&gt;\n        .character-state\n        (Match [0 (-&gt; .character-direction\n                      (Match [0 (-&gt; .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n                              1 (-&gt; .idle-right-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))]\n                             :Passthrough false))\n                1 (-&gt; .walking-left-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n                2 (-&gt; .walking-right-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n                3 (-&gt; .character-jumping (UI.Image :Scale (float2 0.2)))]\n               :Passthrough false)))))\n\n    (GFX.Render :Steps .render-steps)\n\n    (button-inputs))))\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre> <p>Since our <code>Anchor</code> is set to <code>Anchor.Top</code>, it places the <code>UI.Area</code> at the top and in the middle of the screen. This is now our origin at (0,0).</p> <p>In Shards, increasing the value of the y-axis pushes our <code>UI.Area</code> down while decreasing it pushes it up.</p> <p>This is why our velocity is a negative value. When added to our <code>.y</code> value, it decreases <code>.y</code> and makes our image move upwards.</p> <p>Similarly, our acceleration is a positive value so that when it gets added to our negative value velocity, it decreases it.</p>"},{"location":"learn/shards/tutorials/glod-game/steps/step-4/#step-45","title":"Step 4.5","text":"<p>Try running your code now! </p> <p>Oh no, we have a problem. Glod falls through the floor! \ud83d\ude28</p> <p>Don't worry, we can fix this!</p> <p>Similar to how we made a boundary to ensure that Glod does not walk off-screen, we can add a boundary to ensure he doesn't fall through the floor by reusing the same <code>clamp</code> function we made in the previous step.</p> <p>First, call our <code>clamp</code> function in <code>gravity-logic</code> with <code>.y</code> as our <code>var</code>, -620 as our <code>min</code>, and 620 as our <code>max</code>.</p> Code Added <pre><code>(clamp .y -620.0 620.0) ;; (1)\n</code></pre> <ol> <li>Added to lines 107.</li> </ol> <p>Next, add a conditional statement to ensure that our y velocity and acceleration reverts back to 0 when Glod is on the ground.</p> Code AddedFull Code So Far <pre><code>.y ;; (1)\n(When\n :Predicate (IsMoreEqual 620.0)\n :Action (-&gt;\n          0.0 &gt; .character-y-velocity\n          0.0 &gt; .character-y-acceleration))\n</code></pre> <ol> <li>Added to line 108.</li> </ol> <pre><code>(defshards load-texture [name]\n  (LoadImage name)\n  (GFX.Texture))\n\n(defshards initialize-character []\n  (LoadTexture \"GlodImages/Character1.png\") = .idle-left-image-array\n  (LoadTexture \"GlodImages/Character1_Left.png\") = .character-left\n  (LoadTexture \"GlodImages/Character1_Right.png\") = .character-right\n  (LoadTexture \"GlodImages/Character1_Jumping.png\") = .character-jumping\n\n  0 &gt;= .character-state\n  0 &gt;= .character-direction ;; 0 = facing left, 1 = facing right\n\n  0.0 &gt;= .x\n  310.0 &gt;= .y\n  (float2 .x .y) &gt;= .character-position\n  0.0 &gt;= .character-x-velocity\n  0.0 &gt;= .character-y-velocity\n  0.0 &gt;= .character-y-acceleration\n\n  ;; ---------- Character Idle Array (Facing Left)----------\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png\") &gt;&gt; .idle-left-image-array\n\n  ;; ---------- Character Idle Array (Facing Right) ----------------\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_1.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_2.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_3.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_4.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_5.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_6.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_7.png\") &gt;&gt; .idle-right-image-array\n\n  0 &gt;= .idle-image-index\n  (Count .idle-left-image-array) = .idle-image-index-max\n  0.08 = .idle-animation-speed\n\n  ;; -------------- Walking Array (Facing Left) -----------------\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_1.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_2.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_3.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_4.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_5.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_6.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_7.png\") &gt;&gt; .walking-left-image-array\n\n  ;; ----------- Walking Array (Facing Right) ---------------\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_1.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_2.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_3.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_4.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_5.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_6.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_7.png\") &gt;&gt; .walking-right-image-array\n\n  (Count .walking-left-image-array) = .walking-image-index-max\n  0 &gt;= .walking-image-index\n  0.08 = .walking-animation-speed ;; Reduce number to increase animation speed\n  )\n\n;; --------- Idle Animation Loop ---------\n(defloop idle-animation\n  .idle-image-index (Math.Add 1)\n  &gt; .idle-image-index\n  (When\n   :Predicate (IsMoreEqual .idle-image-index-max)\n   :Action (-&gt; 0 &gt; .idle-image-index))\n  (Pause .idle-animation-speed))\n\n;; -------- Walking Animation Loop --------\n(defloop walking-animation\n  .walking-image-index (Math.Add 1)\n  &gt; .walking-image-index\n  (When\n   :Predicate (IsMoreEqual .walking-image-index-max) \n   :Action (-&gt; 0 &gt; .walking-image-index))\n  (Pause .walking-animation-speed))\n\n;; ---------- Character Boundary ------------\n(defshards clamp [var min max]\n  var (Max min) (Min max) &gt; var)\n\n;; ------------ Character Run Logic ----------------\n(defshards run-logic []\n  .x (Math.Add .character-x-velocity)\n  &gt; .x\n\n  (float2 .x .y) &gt; .character-position\n\n  (clamp .X -600.0 600.0))\n\n;; ------------ Character Gravity Logic ---------------\n(defshards gravity-logic []\n  .y (Math.Add .character-y-velocity)\n  &gt; .y\n\n  .character-y-velocity (Math.Add .character-y-acceleration)\n  &gt; .character-y-velocity\n\n  (float2 .x .y) &gt; .character-position\n\n  (clamp .y -620.0 620.0)\n  .y\n  (When\n   :Predicate (IsMoreEqual 620.0)\n   :Action (-&gt;\n            0.0 &gt; .character-y-velocity\n            0.0 &gt; .character-y-acceleration)))\n\n;; ------- Button Inputs ----------\n(defshards button-inputs []\n  (Inputs.KeyDown\n   :Key \"left\"\n   :Action\n   (-&gt;\n    (Msg \"left\")\n    1 &gt; .character-state\n    0 &gt; .character-direction\n    -5.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyDown\n   :Key \"right\"\n   :Action\n   (-&gt;\n    (Msg \"right\")\n    2 &gt; .character-state\n    1 &gt; .character-direction\n    5.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyDown\n   :Key \"up\"\n   :Action\n   (-&gt;\n    (Msg \"up\")\n    3 &gt; .character-state\n    -20.0 &gt; .character-y-velocity\n    1.0 &gt;  .character-y-acceleration))\n\n  (Inputs.KeyUp\n   :Key \"left\"\n   :Action \n   (-&gt;\n    0 &gt; .character-state\n    0.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyUp\n   :Key \"right\"\n   :Action\n   (-&gt;\n    0 &gt; .character-state\n    0.0 &gt; .character-x-velocity)))\n\n(defloop main-wire\n  (Setup\n   (initialize-character))\n\n  (run-logic)\n  (gravity-logic)\n\n  (Step idle-animation)\n  (Step walking-animation)\n\n  (GFX.MainWindow\n   :Title \"MainWindow\" :Width 1920 :Height 1080\n   :Contents\n   (-&gt;\n    (Setup\n     (GFX.DrawQueue) &gt;= .ui-draw-queue\n     (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n    .ui-draw-queue (GFX.ClearQueue)\n\n    (UI\n     .ui-draw-queue\n     (-&gt;\n      (UI.Area\n       :Position .character-position\n       :Anchor Anchor.Top\n       :Contents\n       (-&gt;\n        .character-state\n        (Match [0 (-&gt; .character-direction\n                      (Match [0 (-&gt; .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n                              1 (-&gt; .idle-right-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))]\n                             :Passthrough false))\n                1 (-&gt; .walking-left-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n                2 (-&gt; .walking-right-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n                3 (-&gt; .character-jumping (UI.Image :Scale (float2 0.2)))]\n               :Passthrough false)))))\n\n    (GFX.Render :Steps .render-steps)\n\n    (button-inputs))))\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre> <p>Congratulations! Glod can now move and jump safely! \ud83d\ude0a</p>"},{"location":"learn/shards/tutorials/glod-game/steps/step-4/#step-46","title":"Step 4.6","text":"<p>Finally, let's polish up the code a little.</p> <p>You might have noticed other small problems: </p> <ol> <li>Glod does not go back to his idle animation when he lands on the floor.</li> <li>Glod changes to his running animation if we move left and right while jumping.</li> <li>Glod can continuously jump as long as you press the jump button.</li> </ol> <p>Let's fix these problems!</p> <p>For the first issue, we simply have to ensure that Glod goes back to his idle animation when he reaches the floor.</p> <p>In <code>gravity-logic</code>, revert <code>character-state</code> to 0 when the character is jumping.</p> Code AddedFull Code So Far <pre><code>  .y\n  (When\n   :Predicate (IsMoreEqual 620.0)\n   :Action (-&gt;\n            0.0 &gt; .character-y-velocity\n            0.0 &gt; .character-y-acceleration\n            .character-state ;; (1)\n            (When\n             :Predicate (Is 3)\n             :Action (-&gt;\n                      0 &gt; .character-state))))\n</code></pre> <ol> <li>Added to line 114, under <code>gravity-logic</code>.</li> </ol> <pre><code>(defshards load-texture [name]\n  (LoadImage name)\n  (GFX.Texture))\n\n(defshards initialize-character []\n  (LoadTexture \"GlodImages/Character1.png\") = .idle-left-image-array\n  (LoadTexture \"GlodImages/Character1_Left.png\") = .character-left\n  (LoadTexture \"GlodImages/Character1_Right.png\") = .character-right\n  (LoadTexture \"GlodImages/Character1_Jumping.png\") = .character-jumping\n\n  0 &gt;= .character-state\n  0 &gt;= .character-direction ;; 0 = facing left, 1 = facing right\n\n  0.0 &gt;= .x\n  310.0 &gt;= .y\n  (float2 .x .y) &gt;= .character-position\n  0.0 &gt;= .character-x-velocity\n  0.0 &gt;= .character-y-velocity\n  0.0 &gt;= .character-y-acceleration\n\n  ;; ---------- Character Idle Array (Facing Left)----------\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png\") &gt;&gt; .idle-left-image-array\n\n  ;; ---------- Character Idle Array (Facing Right) ----------------\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_1.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_2.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_3.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_4.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_5.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_6.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_7.png\") &gt;&gt; .idle-right-image-array\n\n  0 &gt;= .idle-image-index\n  (Count .idle-left-image-array) = .idle-image-index-max\n  0.08 = .idle-animation-speed\n\n  ;; -------------- Walking Array (Facing Left) -----------------\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_1.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_2.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_3.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_4.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_5.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_6.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_7.png\") &gt;&gt; .walking-left-image-array\n\n  ;; ----------- Walking Array (Facing Right) ---------------\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_1.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_2.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_3.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_4.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_5.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_6.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_7.png\") &gt;&gt; .walking-right-image-array\n\n  (Count .walking-left-image-array) = .walking-image-index-max\n  0 &gt;= .walking-image-index\n  0.08 = .walking-animation-speed ;; Reduce number to increase animation speed\n  )\n\n;; --------- Idle Animation Loop ---------\n(defloop idle-animation\n  .idle-image-index (Math.Add 1)\n  &gt; .idle-image-index\n  (When\n   :Predicate (IsMoreEqual .idle-image-index-max)\n   :Action (-&gt; 0 &gt; .idle-image-index))\n  (Pause .idle-animation-speed))\n\n;; -------- Walking Animation Loop --------\n(defloop walking-animation\n  .walking-image-index (Math.Add 1)\n  &gt; .walking-image-index\n  (When\n   :Predicate (IsMoreEqual .walking-image-index-max) \n   :Action (-&gt; 0 &gt; .walking-image-index))\n  (Pause .walking-animation-speed))\n\n;; ---------- Character Boundary ------------\n(defshards clamp [var min max]\n  var (Max min) (Min max) &gt; var)\n\n;; ------------ Character Run Logic ----------------\n(defshards run-logic []\n  .x (Math.Add .character-x-velocity)\n  &gt; .x\n\n  (float2 .x .y) &gt; .character-position\n\n  (clamp .X -600.0 600.0))\n\n;; ------------ Character Gravity Logic ---------------\n(defshards gravity-logic []\n  .y (Math.Add .character-y-velocity)\n  &gt; .y\n\n  .character-y-velocity (Math.Add .character-y-acceleration)\n  &gt; .character-y-velocity\n\n  (float2 .x .y) &gt; .character-position\n\n  (clamp .y -620.0 620.0)\n  .y\n  (When\n   :Predicate (IsMoreEqual 620.0)\n   :Action (-&gt;\n            0.0 &gt; .character-y-velocity\n            0.0 &gt; .character-y-acceleration\n            .character-state\n            (When\n             :Predicate (Is 3)\n             :Action (-&gt;\n                      0 &gt; .character-state)))))\n\n;; ------- Button Inputs ----------\n(defshards button-inputs []\n  (Inputs.KeyDown\n   :Key \"left\"\n   :Action\n   (-&gt;\n    (Msg \"left\")\n    1 &gt; .character-state\n    0 &gt; .character-direction\n    -5.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyDown\n   :Key \"right\"\n   :Action\n   (-&gt;\n    (Msg \"right\")\n    2 &gt; .character-state\n    1 &gt; .character-direction\n    5.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyDown\n   :Key \"up\"\n   :Action\n   (-&gt;\n    (Msg \"up\")\n    3 &gt; .character-state\n    -20.0 &gt; .character-y-velocity\n    1.0 &gt;  .character-y-acceleration))\n\n  (Inputs.KeyUp\n   :Key \"left\"\n   :Action \n   (-&gt;\n    0 &gt; .character-state\n    0.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyUp\n   :Key \"right\"\n   :Action\n   (-&gt;\n    0 &gt; .character-state\n    0.0 &gt; .character-x-velocity)))\n\n(defloop main-wire\n  (Setup\n   (initialize-character))\n\n  (run-logic)\n  (gravity-logic)\n\n  (Step idle-animation)\n  (Step walking-animation)\n\n  (GFX.MainWindow\n   :Title \"MainWindow\" :Width 1920 :Height 1080\n   :Contents\n   (-&gt;\n    (Setup\n     (GFX.DrawQueue) &gt;= .ui-draw-queue\n     (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n    .ui-draw-queue (GFX.ClearQueue)\n\n    (UI\n     .ui-draw-queue\n     (-&gt;\n      (UI.Area\n       :Position .character-position\n       :Anchor Anchor.Top\n       :Contents\n       (-&gt;\n        .character-state\n        (Match [0 (-&gt; .character-direction\n                      (Match [0 (-&gt; .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n                              1 (-&gt; .idle-right-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))]\n                             :Passthrough false))\n                1 (-&gt; .walking-left-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n                2 (-&gt; .walking-right-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n                3 (-&gt; .character-jumping (UI.Image :Scale (float2 0.2)))]\n               :Passthrough false)))))\n\n    (GFX.Render :Steps .render-steps)\n\n    (button-inputs))))\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre> <p>Here, we use a nested <code>When</code> conditional statement to ensure that Glod goes back to his idle animation only when he is jumping.</p> <p>Had we simply put <code>0 &gt;. character-state</code> without the nested <code>When</code>, this would revert Glod back to his idle animation but it would cause another problem. That is, Glod will forever be in his idle animation whenever he is on the ground. This means that he will never transit into his walking animation.</p> <p>This is why we use the nested <code>When</code> conditional statement instead.</p> <p>The second problem is also an easy fix. We simply put a <code>When</code> conditional statement to make Glod go into his walking animation when he is idling (<code>.character-state</code> is 0) and not jumping.</p> Code AddedFull Code So Far <pre><code>(Inputs.KeyDown\n :Key \"left\"\n :Action\n (-&gt;\n  (Msg \"left\")\n  .character-state ;; (1)\n  (When\n   :Predicate (Is 0)\n   :Action (-&gt; 1 &gt; .character-state))\n  0 &gt; .character-direction\n  -5.0 &gt; .character-x-velocity))\n\n(Inputs.KeyDown\n :Key \"right\"\n :Action\n (-&gt;\n  (Msg \"right\")\n  .character-state\n  (When\n   :Predicate (Is 0)\n   :Action (-&gt; 2 &gt; .character-state))\n  1 &gt; .character-direction\n  5.0 &gt; .character-x-velocity))\n</code></pre> <ol> <li>Edited from line 127 onwards.</li> </ol> <pre><code>(defshards load-texture [name]\n  (LoadImage name)\n  (GFX.Texture))\n\n(defshards initialize-character []\n  (LoadTexture \"GlodImages/Character1.png\") = .idle-left-image-array\n  (LoadTexture \"GlodImages/Character1_Left.png\") = .character-left\n  (LoadTexture \"GlodImages/Character1_Right.png\") = .character-right\n  (LoadTexture \"GlodImages/Character1_Jumping.png\") = .character-jumping\n\n  0 &gt;= .character-state\n  0 &gt;= .character-direction ;; 0 = facing left, 1 = facing right\n\n  0.0 &gt;= .x\n  310.0 &gt;= .y\n  (float2 .x .y) &gt;= .character-position\n  0.0 &gt;= .character-x-velocity\n  0.0 &gt;= .character-y-velocity\n  0.0 &gt;= .character-y-acceleration\n\n  ;; ---------- Character Idle Array (Facing Left)----------\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png\") &gt;&gt; .idle-left-image-array\n\n  ;; ---------- Character Idle Array (Facing Right) ----------------\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_1.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_2.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_3.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_4.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_5.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_6.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_7.png\") &gt;&gt; .idle-right-image-array\n\n  0 &gt;= .idle-image-index\n  (Count .idle-left-image-array) = .idle-image-index-max\n  0.08 = .idle-animation-speed\n\n  ;; -------------- Walking Array (Facing Left) -----------------\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_1.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_2.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_3.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_4.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_5.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_6.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_7.png\") &gt;&gt; .walking-left-image-array\n\n  ;; ----------- Walking Array (Facing Right) ---------------\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_1.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_2.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_3.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_4.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_5.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_6.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_7.png\") &gt;&gt; .walking-right-image-array\n\n  (Count .walking-left-image-array) = .walking-image-index-max\n  0 &gt;= .walking-image-index\n  0.08 = .walking-animation-speed ;; Reduce number to increase animation speed\n  )\n\n;; --------- Idle Animation Loop ---------\n(defloop idle-animation\n  .idle-image-index (Math.Add 1)\n  &gt; .idle-image-index\n  (When\n   :Predicate (IsMoreEqual .idle-image-index-max)\n   :Action (-&gt; 0 &gt; .idle-image-index))\n  (Pause .idle-animation-speed))\n\n;; -------- Walking Animation Loop --------\n(defloop walking-animation\n  .walking-image-index (Math.Add 1)\n  &gt; .walking-image-index\n  (When\n   :Predicate (IsMoreEqual .walking-image-index-max) \n   :Action (-&gt; 0 &gt; .walking-image-index))\n  (Pause .walking-animation-speed))\n\n;; ---------- Character Boundary ------------\n(defshards clamp [var min max]\n  var (Max min) (Min max) &gt; var)\n\n;; ------------ Character Run Logic ----------------\n(defshards run-logic []\n  .x (Math.Add .character-x-velocity)\n  &gt; .x\n\n  (float2 .x .y) &gt; .character-position\n\n  (clamp .X -600.0 600.0))\n\n;; ------------ Character Gravity Logic ---------------\n(defshards gravity-logic []\n  .y (Math.Add .character-y-velocity)\n  &gt; .y\n\n  .character-y-velocity (Math.Add .character-y-acceleration)\n  &gt; .character-y-velocity\n\n  (float2 .x .y) &gt; .character-position\n\n  (clamp .y -620.0 620.0)\n  .y\n  (When\n   :Predicate (IsMoreEqual 620.0)\n   :Action (-&gt;\n            0.0 &gt; .character-y-velocity\n            0.0 &gt; .character-y-acceleration\n            .character-state\n            (When\n             :Predicate (Is 3)\n             :Action (-&gt;\n                      0 &gt; .character-state)))))\n\n;; ------- Button Inputs ----------\n(defshards button-inputs []\n  (Inputs.KeyDown\n   :Key \"left\"\n   :Action\n   (-&gt;\n    (Msg \"left\")\n    .character-state\n    (When\n     :Predicate (Is 0)\n     :Action (-&gt; 1 &gt; .character-state))\n    0 &gt; .character-direction\n    -5.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyDown\n   :Key \"right\"\n   :Action\n   (-&gt;\n    (Msg \"right\")\n    .character-state\n    (When\n     :Predicate (Is 0)\n     :Action (-&gt; 2 &gt; .character-state))\n    1 &gt; .character-direction\n    5.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyDown\n   :Key \"up\"\n   :Action\n   (-&gt;\n    (Msg \"up\")\n    3 &gt; .character-state\n    -20.0 &gt; .character-y-velocity\n    1.0 &gt;  .character-y-acceleration))\n\n  (Inputs.KeyUp\n   :Key \"left\"\n   :Action \n   (-&gt;\n    0 &gt; .character-state\n    0.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyUp\n   :Key \"right\"\n   :Action\n   (-&gt;\n    0 &gt; .character-state\n    0.0 &gt; .character-x-velocity)))\n\n(defloop main-wire\n  (Setup\n   (initialize-character))\n\n  (run-logic)\n  (gravity-logic)\n\n  (Step idle-animation)\n  (Step walking-animation)\n\n  (GFX.MainWindow\n   :Title \"MainWindow\" :Width 1920 :Height 1080\n   :Contents\n   (-&gt;\n    (Setup\n     (GFX.DrawQueue) &gt;= .ui-draw-queue\n     (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n    .ui-draw-queue (GFX.ClearQueue)\n\n    (UI\n     .ui-draw-queue\n     (-&gt;\n      (UI.Area\n       :Position .character-position\n       :Anchor Anchor.Top\n       :Contents\n       (-&gt;\n        .character-state\n        (Match [0 (-&gt; .character-direction\n                      (Match [0 (-&gt; .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n                              1 (-&gt; .idle-right-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))]\n                             :Passthrough false))\n                1 (-&gt; .walking-left-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n                2 (-&gt; .walking-right-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n                3 (-&gt; .character-jumping (UI.Image :Scale (float2 0.2)))]\n               :Passthrough false)))))\n\n    (GFX.Render :Steps .render-steps)\n\n    (button-inputs))))\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre> <p>For the last problem, although slightly more complicated, we will employ the <code>When</code> conditional statement too to solve it.</p> <p>First, create a <code>.can-jump</code> variable under <code>initialize-character</code>.</p> Code Added <pre><code>true &gt;= .can-jump ;; (1)\n</code></pre> <ol> <li>Added to line 13.</li> </ol> <p>Set it such that Glod cannot jump again when he is jumping. When the jump button is pressed, <code>.can-jump</code> becomes false.</p> <p>The increase in velocity and acceleration to make Glod jump only happens when <code>.can-jump</code> is true.</p> Code Added <pre><code>(Inputs.KeyDown\n :Key \"up\"\n :Action\n (-&gt;\n  (Msg \"up\")\n  3 &gt; .character-state\n  .can-jump ;; (1)\n  (When\n   :Predicate (Is true)\n   :Action (-&gt;\n            -20.0 &gt; .character-y-velocity\n            1.0 &gt;  .character-y-acceleration\n            false &gt;= .can-jump))))\n</code></pre> <ol> <li>Edited from line 153 onwards.</li> </ol> <p>Lastly we reset <code>.can-jump</code> back to true when Glod touches the floor again.</p> Code AddedFull Code So Far <pre><code>.y\n(When\n :Predicate (IsMoreEqual 620.0)\n :Action (-&gt;\n          0.0 &gt; .character-y-velocity\n          0.0 &gt; .character-y-acceleration\n          true &gt; .can-jump ;; (1)\n          .character-state\n          (When\n           :Predicate (Is 3)\n           :Action (-&gt;\n                    0 &gt; .character-state))))\n</code></pre> <ol> <li>Edited from line 115 onwards.</li> </ol> <pre><code>(defshards load-texture [name]\n  (LoadImage name)\n  (GFX.Texture))\n\n(defshards initialize-character []\n  (LoadTexture \"GlodImages/Character1.png\") = .idle-left-image-array\n  (LoadTexture \"GlodImages/Character1_Left.png\") = .character-left\n  (LoadTexture \"GlodImages/Character1_Right.png\") = .character-right\n  (LoadTexture \"GlodImages/Character1_Jumping.png\") = .character-jumping\n\n  0 &gt;= .character-state\n  0 &gt;= .character-direction ;; 0 = facing left, 1 = facing right\n  true &gt;= .can-jump\n\n  0.0 &gt;= .x\n  310.0 &gt;= .y\n  (float2 .x .y) &gt;= .character-position\n  0.0 &gt;= .character-x-velocity\n  0.0 &gt;= .character-y-velocity\n  0.0 &gt;= .character-y-acceleration\n\n  ;; ---------- Character Idle Array (Facing Left)----------\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png\") &gt;&gt; .idle-left-image-array\n\n  ;; ---------- Character Idle Array (Facing Right) ----------------\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_1.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_2.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_3.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_4.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_5.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_6.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_7.png\") &gt;&gt; .idle-right-image-array\n\n  0 &gt;= .idle-image-index\n  (Count .idle-left-image-array) = .idle-image-index-max\n  0.08 = .idle-animation-speed\n\n  ;; -------------- Walking Array (Facing Left) -----------------\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_1.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_2.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_3.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_4.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_5.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_6.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_7.png\") &gt;&gt; .walking-left-image-array\n\n  ;; ----------- Walking Array (Facing Right) ---------------\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_1.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_2.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_3.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_4.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_5.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_6.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_7.png\") &gt;&gt; .walking-right-image-array\n\n  (Count .walking-left-image-array) = .walking-image-index-max\n  0 &gt;= .walking-image-index\n  0.08 = .walking-animation-speed ;; Reduce number to increase animation speed\n  )\n\n;; --------- Idle Animation Loop ---------\n(defloop idle-animation\n  .idle-image-index (Math.Add 1)\n  &gt; .idle-image-index\n  (When\n   :Predicate (IsMoreEqual .idle-image-index-max)\n   :Action (-&gt; 0 &gt; .idle-image-index))\n  (Pause .idle-animation-speed))\n\n;; -------- Walking Animation Loop --------\n(defloop walking-animation\n  .walking-image-index (Math.Add 1)\n  &gt; .walking-image-index\n  (When\n   :Predicate (IsMoreEqual .walking-image-index-max) \n   :Action (-&gt; 0 &gt; .walking-image-index))\n  (Pause .walking-animation-speed))\n\n;; ---------- Character Boundary ------------\n(defshards clamp [var min max]\n  var (Max min) (Min max) &gt; var)\n\n;; ------------ Character Run Logic ----------------\n(defshards run-logic []\n  .x (Math.Add .character-x-velocity)\n  &gt; .x\n\n  (float2 .x .y) &gt; .character-position\n\n  (clamp .X -600.0 600.0))\n\n;; ------------ Character Gravity Logic ---------------\n(defshards gravity-logic []\n  .y (Math.Add .character-y-velocity)\n  &gt; .y\n\n  .character-y-velocity (Math.Add .character-y-acceleration)\n  &gt; .character-y-velocity\n\n  (float2 .x .y) &gt; .character-position\n\n  (clamp .y -620.0 620.0)\n  .y\n  (When\n   :Predicate (IsMoreEqual 620.0)\n   :Action (-&gt;\n            0.0 &gt; .character-y-velocity\n            0.0 &gt; .character-y-acceleration\n            true &gt; .can-jump\n            .character-state\n            (When\n             :Predicate (Is 3)\n             :Action (-&gt;\n                      0 &gt; .character-state)))))\n\n;; ------- Button Inputs ----------\n(defshards button-inputs []\n  (Inputs.KeyDown\n   :Key \"left\"\n   :Action\n   (-&gt;\n    (Msg \"left\")\n    .character-state\n    (When\n     :Predicate (Is 0)\n     :Action (-&gt; 1 &gt; .character-state))\n    0 &gt; .character-direction\n    -5.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyDown\n   :Key \"right\"\n   :Action\n   (-&gt;\n    (Msg \"right\")\n    .character-state\n    (When\n     :Predicate (Is 0)\n     :Action (-&gt; 2 &gt; .character-state))\n    1 &gt; .character-direction\n    5.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyDown\n   :Key \"up\"\n   :Action\n   (-&gt;\n    (Msg \"up\")\n    3 &gt; .character-state\n    .can-jump\n    (When\n     :Predicate (Is true)\n     :Action (-&gt;\n              -20.0 &gt; .character-y-velocity\n              1.0 &gt;  .character-y-acceleration\n              false &gt;= .can-jump))))\n\n  (Inputs.KeyUp\n   :Key \"left\"\n   :Action \n   (-&gt;\n    0 &gt; .character-state\n    0.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyUp\n   :Key \"right\"\n   :Action\n   (-&gt;\n    0 &gt; .character-state\n    0.0 &gt; .character-x-velocity)))\n\n(defloop main-wire\n  (Setup\n   (initialize-character))\n\n  (run-logic)\n  (gravity-logic)\n\n  (Step idle-animation)\n  (Step walking-animation)\n\n  (GFX.MainWindow\n   :Title \"MainWindow\" :Width 1920 :Height 1080\n   :Contents\n   (-&gt;\n    (Setup\n     (GFX.DrawQueue) &gt;= .ui-draw-queue\n     (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n    .ui-draw-queue (GFX.ClearQueue)\n\n    (UI\n     .ui-draw-queue\n     (-&gt;\n      (UI.Area\n       :Position .character-position\n       :Anchor Anchor.Top\n       :Contents\n       (-&gt;\n        .character-state\n        (Match [0 (-&gt; .character-direction\n                      (Match [0 (-&gt; .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n                              1 (-&gt; .idle-right-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))]\n                             :Passthrough false))\n                1 (-&gt; .walking-left-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n                2 (-&gt; .walking-right-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n                3 (-&gt; .character-jumping (UI.Image :Scale (float2 0.2)))]\n               :Passthrough false)))))\n\n    (GFX.Render :Steps .render-steps)\n\n    (button-inputs))))\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre>"},{"location":"learn/shards/tutorials/glod-game/steps/step-4/#recap","title":"Recap","text":"<p>Try running your code now! Glod should be happily running and jumping without any glitches. \ud83d\ude01</p> <p>To recap:</p> <ol> <li> <p>We made Glod move by tying a variable to the <code>UI.Area</code> position and changing said variable.</p> </li> <li> <p>We ensured that Glod does not walk or fall into the void by creating boundaries.</p> </li> <li> <p>We created conditional statements to fix several problems.</p> </li> </ol> <p>And walah! We now have a fully functional moving character!</p> <p>In the next chapter, let's have Glod collect some coins! \ud83e\udd11</p>"},{"location":"learn/shards/tutorials/glod-game/steps/step-5/","title":"Step 5","text":""},{"location":"learn/shards/tutorials/glod-game/steps/step-5/#dropping-coins-and-scoring-points-overview","title":"Dropping Coins and Scoring Points - Overview","text":"<p>Good job on reaching this far!</p> <p>Now that we have a moving character, we can add more game elements.</p> <p>As mentioned in the intro, this will be a point collection game. We'll start by creating coins for Glod to collect.</p> <p>In this chapter we will be:</p> <ol> <li> <p>Drawing a coin image on screen.</p> </li> <li> <p>Having it move by using variables.</p> </li> <li> <p>Creating a spawning system to randomly spawn coins on the screen.</p> </li> <li> <p>Creating a collision system to have Glod be able to collect coins.</p> </li> <li> <p>Reusing code to create more coins by making shards accept arguments.</p> </li> </ol>"},{"location":"learn/shards/tutorials/glod-game/steps/step-5/#step-51","title":"Step 5.1","text":"<p>Drawing an image on screen and using variables to move them... Does that not sound familiar? \ud83e\udd14</p> <p>Yes! It is using the same logic to make Glod appear on the screen. Download the images that we will be using:</p> <ul> <li>Download Coin Images here.</li> </ul> <p>Let's start off nice and easy by first drawing the coin image on the screen.</p> <p>Create a new <code>initialize-coin</code> shard. We will separate the initializing of our coin and character variables to make our code neater.</p> Code Added <pre><code>;; -------------- Initialize Coin ----------\n(defshards initialize-coin [] ;; (1)\n  (LoadTexture \"GlodImages/Coin/Coin_1.png\") = .coin-1)\n</code></pre> <ol> <li>Added to line 177.</li> </ol> <p>Remember to call <code>initialize-coin</code> in the <code>Setup</code> of the <code>main-wire</code>to ensure that these variables are only created once.</p> Code Added <pre><code>(defloop main-wire\n  (Setup\n   (initialize-character)\n   (initialize-coin)) ;; (1)\n</code></pre> <ol> <li>Added to line 183.</li> </ol> <p>We then create a new <code>UI.Area</code> to draw the coin on the screen.</p> Code AddedFull Code So Far <pre><code>(UI.Area ;; (1)\n :Position (float2 0 0)\n :Anchor Anchor.Top\n :Contents (-&gt; .coin-1 (UI.Image :Scale (float2 0.2)))\n</code></pre> <ol> <li>Added to line 218.</li> </ol> <pre><code>(defshards load-texture [name]\n  (LoadImage name)\n  (GFX.Texture))\n\n(defshards initialize-character []\n  (LoadTexture \"GlodImages/Character1.png\") = .idle-left-image-array\n  (LoadTexture \"GlodImages/Character1_Left.png\") = .character-left\n  (LoadTexture \"GlodImages/Character1_Right.png\") = .character-right\n  (LoadTexture \"GlodImages/Character1_Jumping.png\") = .character-jumping\n\n  0 &gt;= .character-state\n  0 &gt;= .character-direction ;; 0 = facing left, 1 = facing right\n  true &gt;= .can-jump\n\n  0.0 &gt;= .x\n  310.0 &gt;= .y\n  (float2 .x .y) &gt;= .character-position\n  0.0 &gt;= .character-x-velocity\n  0.0 &gt;= .character-y-velocity\n  0.0 &gt;= .character-y-acceleration\n\n  ;; ---------- Character Idle Array (Facing Left)----------\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png\") &gt;&gt; .idle-left-image-array\n\n  ;; ---------- Character Idle Array (Facing Right) ----------------\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_1.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_2.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_3.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_4.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_5.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_6.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_7.png\") &gt;&gt; .idle-right-image-array\n\n  0 &gt;= .idle-image-index\n  (Count .idle-left-image-array) = .idle-image-index-max\n  0.08 = .idle-animation-speed\n\n  ;; -------------- Walking Array (Facing Left) -----------------\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_1.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_2.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_3.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_4.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_5.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_6.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_7.png\") &gt;&gt; .walking-left-image-array\n\n  ;; ----------- Walking Array (Facing Right) ---------------\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_1.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_2.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_3.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_4.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_5.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_6.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_7.png\") &gt;&gt; .walking-right-image-array\n\n  (Count .walking-left-image-array) = .walking-image-index-max\n  0 &gt;= .walking-image-index\n  0.08 = .walking-animation-speed ;; Reduce number to increase animation speed\n  )\n\n;; --------- Idle Animation Loop ---------\n(defloop idle-animation\n  .idle-image-index (Math.Add 1)\n  &gt; .idle-image-index\n  (When\n   :Predicate (IsMoreEqual .idle-image-index-max)\n   :Action (-&gt; 0 &gt; .idle-image-index))\n  (Pause .idle-animation-speed))\n\n;; -------- Walking Animation Loop --------\n(defloop walking-animation\n  .walking-image-index (Math.Add 1)\n  &gt; .walking-image-index\n  (When\n   :Predicate (IsMoreEqual .walking-image-index-max) \n   :Action (-&gt; 0 &gt; .walking-image-index))\n  (Pause .walking-animation-speed))\n\n;; ---------- Character Boundary ------------\n(defshards clamp [var min max]\n  var (Max min) (Min max) &gt; var)\n\n;; ------------ Character Run Logic ----------------\n(defshards run-logic []\n  .x (Math.Add .character-x-velocity)\n  &gt; .x\n\n  (float2 .x .y) &gt; .character-position\n\n  (clamp .X -600.0 600.0))\n\n;; ------------ Character Gravity Logic ---------------\n(defshards gravity-logic []\n  .y (Math.Add .character-y-velocity)\n  &gt; .y\n\n  .character-y-velocity (Math.Add .character-y-acceleration)\n  &gt; .character-y-velocity\n\n  (float2 .x .y) &gt; .character-position\n\n  (clamp .y -620.0 620.0)\n  .y\n  (When\n   :Predicate (IsMoreEqual 620.0)\n   :Action (-&gt;\n            0.0 &gt; .character-y-velocity\n            0.0 &gt; .character-y-acceleration\n            true &gt; .can-jump\n            .character-state\n            (When\n             :Predicate (Is 3)\n             :Action (-&gt;\n                      0 &gt; .character-state)))))\n\n;; ------- Button Inputs ----------\n(defshards button-inputs []\n  (Inputs.KeyDown\n   :Key \"left\"\n   :Action\n   (-&gt;\n    (Msg \"left\")\n    .character-state\n    (When\n     :Predicate (Is 0)\n     :Action (-&gt; 1 &gt; .character-state))\n    0 &gt; .character-direction\n    -5.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyDown\n   :Key \"right\"\n   :Action\n   (-&gt;\n    (Msg \"right\")\n    .character-state\n    (When\n     :Predicate (Is 0)\n     :Action (-&gt; 2 &gt; .character-state))\n    1 &gt; .character-direction\n    5.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyDown\n   :Key \"up\"\n   :Action\n   (-&gt;\n    (Msg \"up\")\n    3 &gt; .character-state\n    .can-jump\n    (When\n     :Predicate (Is true)\n     :Action (-&gt;\n              -20.0 &gt; .character-y-velocity\n              1.0 &gt;  .character-y-acceleration\n              false &gt;= .can-jump))))\n\n  (Inputs.KeyUp\n   :Key \"left\"\n   :Action \n   (-&gt;\n    0 &gt; .character-state\n    0.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyUp\n   :Key \"right\"\n   :Action\n   (-&gt;\n    0 &gt; .character-state\n    0.0 &gt; .character-x-velocity)))\n\n;; -------------- Initialize Coin ----------\n(defshards initialize-coin []\n  (LoadTexture \"GlodImages/Coin/Coin_1.png\") = .coin-1)\n\n(defloop main-wire\n  (Setup\n   (initialize-character)\n   (initialize-coin))\n\n  (run-logic)\n  (gravity-logic)\n\n  (Step idle-animation)\n  (Step walking-animation)\n\n  (GFX.MainWindow\n   :Title \"MainWindow\" :Width 1920 :Height 1080\n   :Contents\n   (-&gt;\n    (Setup\n     (GFX.DrawQueue) &gt;= .ui-draw-queue\n     (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n    .ui-draw-queue (GFX.ClearQueue)\n\n    (UI\n     .ui-draw-queue\n     (-&gt;\n      (UI.Area\n       :Position .character-position\n       :Anchor Anchor.Top\n       :Contents\n       (-&gt;\n        .character-state\n        (Match [0 (-&gt; .character-direction\n                      (Match [0 (-&gt; .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n                              1 (-&gt; .idle-right-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))]\n                             :Passthrough false))\n                1 (-&gt; .walking-left-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n                2 (-&gt; .walking-right-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n                3 (-&gt; .character-jumping (UI.Image :Scale (float2 0.2)))]\n               :Passthrough false)))\n\n      (UI.Area\n       :Position (float2 0 0)\n       :Anchor Anchor.Top\n       :Contents (-&gt; .coin-1 (UI.Image :Scale (float2 0.2))))))\n\n    (GFX.Render :Steps .render-steps)\n\n    (button-inputs))))\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre>"},{"location":"learn/shards/tutorials/glod-game/steps/step-5/#step-52","title":"Step 5.2","text":"<p>Try running your code now. You should see a coin being drawn on the top of the screen.</p> <p>Congrats!</p> <p>We are off to a good start. Now, let's animate this coin.</p> <p>The logic will be exactly the same as when we animated Glod. This will be much easier however as we won't need any conditional statements to control the coin.</p> <ul> <li>Download coin images here.</li> </ul> <p>Just like what we did to animate Glod, we replace the singular image with an array of images.</p> <p>We also create variables for controlling the Coin animation:</p> <ul> <li> <p><code>.coin-image-index</code></p> </li> <li> <p><code>.coin-image-index-max</code></p> </li> <li> <p><code>.coin-animation-speed</code></p> </li> </ul> Code Added <p>;; -------------- Initialize Coin ---------- (defshards initialize-coin [] ;; (1)   (LoadTexture \"GlodImages/Coin/Coin_1.png\") &gt;&gt; .coin-image-array   (LoadTexture \"GlodImages/Coin/Coin_2.png\") &gt;&gt; .coin-image-array   (LoadTexture \"GlodImages/Coin/Coin_3.png\") &gt;&gt; .coin-image-array   (LoadTexture \"GlodImages/Coin/Coin_4.png\") &gt;&gt; .coin-image-array   (LoadTexture \"GlodImages/Coin/Coin_5.png\") &gt;&gt; .coin-image-array   (LoadTexture \"GlodImages/Coin/Coin_6.png\") &gt;&gt; .coin-image-array   (LoadTexture \"GlodImages/Coin/Coin_7.png\") &gt;&gt; .coin-image-array   (Count .coin-image-array) (Math.Subtract 1) &gt;= .coin-image-index-max   0 &gt;= .coin-image-index   0.1 &gt;= .coin-animation-speed)</p> <ol> <li>Updated <code>initialize-coin</code> at line 177.</li> </ol> <p>Then we create a <code>coin-animation</code> loop that follows the same logic as Glod's animations.</p> Code Added <p>;; -------------- Coin Animation ------------------ (defloop coin-animation   .coin-image-index (Math.Add 1)</p> <p>.coin-image-index   (When    :Predicate (IsMore .coin-image-index-max)    :Action (-&gt; 0 &gt; .coin-image-index))</p> <p>(Pause .coin-animation-speed)) </p> <ol> <li>Added to line 190.</li> </ol> <p>Remember to <code>Step</code> into the Coin's animation in your <code>main-wire</code>!</p> Code Added <p>(Step coin-animation) ;; (1)</p> <ol> <li>Added to line 210.</li> </ol> <p>Lastly, update your coin's <code>UI.Area</code> to draw the image located in an index of <code>.coin-image-array</code>. The index used is determined by the value of <code>.coin-image-index</code>.</p> Code AddedFull Code So Far <p>(UI.Area  :Position (float2 0 0)  :Anchor Anchor.Top  :Contents  (-&gt; .coin-image-array      (Take .coin-image-index)      (UI.Image :Scale (float2 0.2))))</p> <ol> <li>Added to line 239.</li> </ol> <p>(defshards load-texture [name]   (LoadImage name)   (GFX.Texture))</p> <p>(defshards initialize-character []   (LoadTexture \"GlodImages/Character1.png\") = .idle-left-image-array   (LoadTexture \"GlodImages/Character1_Left.png\") = .character-left   (LoadTexture \"GlodImages/Character1_Right.png\") = .character-right   (LoadTexture \"GlodImages/Character1_Jumping.png\") = .character-jumping</p> <p>0 &gt;= .character-state   0 &gt;= .character-direction ;; 0 = facing left, 1 = facing right   true &gt;= .can-jump</p> <p>0.0 &gt;= .x   310.0 &gt;= .y   (float2 .x .y) &gt;= .character-position   0.0 &gt;= .character-x-velocity   0.0 &gt;= .character-y-velocity   0.0 &gt;= .character-y-acceleration</p> <p>;; ---------- Character Idle Array (Facing Left)----------   (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png\") &gt;&gt; .idle-left-image-array   (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png\") &gt;&gt; .idle-left-image-array   (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png\") &gt;&gt; .idle-left-image-array   (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png\") &gt;&gt; .idle-left-image-array   (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png\") &gt;&gt; .idle-left-image-array   (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png\") &gt;&gt; .idle-left-image-array   (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png\") &gt;&gt; .idle-left-image-array</p> <p>;; ---------- Character Idle Array (Facing Right) ----------------   (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_1.png\") &gt;&gt; .idle-right-image-array   (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_2.png\") &gt;&gt; .idle-right-image-array   (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_3.png\") &gt;&gt; .idle-right-image-array   (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_4.png\") &gt;&gt; .idle-right-image-array   (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_5.png\") &gt;&gt; .idle-right-image-array   (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_6.png\") &gt;&gt; .idle-right-image-array   (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_7.png\") &gt;&gt; .idle-right-image-array</p> <p>0 &gt;= .idle-image-index   (Count .idle-left-image-array) = .idle-image-index-max   0.08 = .idle-animation-speed</p> <p>;; -------------- Walking Array (Facing Left) -----------------   (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_1.png\") &gt;&gt; .walking-left-image-array   (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_2.png\") &gt;&gt; .walking-left-image-array   (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_3.png\") &gt;&gt; .walking-left-image-array   (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_4.png\") &gt;&gt; .walking-left-image-array   (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_5.png\") &gt;&gt; .walking-left-image-array   (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_6.png\") &gt;&gt; .walking-left-image-array   (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_7.png\") &gt;&gt; .walking-left-image-array</p> <p>;; ----------- Walking Array (Facing Right) ---------------   (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_1.png\") &gt;&gt; .walking-right-image-array   (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_2.png\") &gt;&gt; .walking-right-image-array   (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_3.png\") &gt;&gt; .walking-right-image-array   (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_4.png\") &gt;&gt; .walking-right-image-array   (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_5.png\") &gt;&gt; .walking-right-image-array   (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_6.png\") &gt;&gt; .walking-right-image-array   (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_7.png\") &gt;&gt; .walking-right-image-array</p> <p>(Count .walking-left-image-array) = .walking-image-index-max   0 &gt;= .walking-image-index   0.08 = .walking-animation-speed ;; Reduce number to increase animation speed   )</p> <p>;; --------- Idle Animation Loop --------- (defloop idle-animation   .idle-image-index (Math.Add 1)</p> <p>.idle-image-index   (When    :Predicate (IsMoreEqual .idle-image-index-max)    :Action (-&gt; 0 &gt; .idle-image-index))   (Pause .idle-animation-speed))</p> <p>;; -------- Walking Animation Loop -------- (defloop walking-animation   .walking-image-index (Math.Add 1)</p> <p>.walking-image-index   (When    :Predicate (IsMoreEqual .walking-image-index-max)     :Action (-&gt; 0 &gt; .walking-image-index))   (Pause .walking-animation-speed))</p> <p>;; ---------- Character Boundary ------------ (defshards clamp [var min max]   var (Max min) (Min max) &gt; var)</p> <p>;; ------------ Character Run Logic ---------------- (defshards run-logic []   .x (Math.Add .character-x-velocity)</p> <p>.x</p> <p>(float2 .x .y) &gt; .character-position</p> <p>(clamp .X -600.0 600.0))</p> <p>;; ------------ Character Gravity Logic --------------- (defshards gravity-logic []   .y (Math.Add .character-y-velocity)</p> <p>.y</p> <p>.character-y-velocity (Math.Add .character-y-acceleration)</p> <p>.character-y-velocity</p> <p>(float2 .x .y) &gt; .character-position</p> <p>(clamp .y -620.0 620.0)   .y   (When    :Predicate (IsMoreEqual 620.0)    :Action (-&gt;             0.0 &gt; .character-y-velocity             0.0 &gt; .character-y-acceleration             true &gt; .can-jump             .character-state             (When              :Predicate (Is 3)              :Action (-&gt;                       0 &gt; .character-state)))))</p> <p>;; ------- Button Inputs ---------- (defshards button-inputs []   (Inputs.KeyDown    :Key \"left\"    :Action    (-&gt;     (Msg \"left\")     .character-state     (When      :Predicate (Is 0)      :Action (-&gt; 1 &gt; .character-state))     0 &gt; .character-direction     -5.0 &gt; .character-x-velocity))</p> <p>(Inputs.KeyDown    :Key \"right\"    :Action    (-&gt;     (Msg \"right\")     .character-state     (When      :Predicate (Is 0)      :Action (-&gt; 2 &gt; .character-state))     1 &gt; .character-direction     5.0 &gt; .character-x-velocity))</p> <p>(Inputs.KeyDown    :Key \"up\"    :Action    (-&gt;     (Msg \"up\")     3 &gt; .character-state     .can-jump     (When      :Predicate (Is true)      :Action (-&gt;               -20.0 &gt; .character-y-velocity               1.0 &gt;  .character-y-acceleration               false &gt;= .can-jump))))</p> <p>(Inputs.KeyUp    :Key \"left\"    :Action     (-&gt;     0 &gt; .character-state     0.0 &gt; .character-x-velocity))</p> <p>(Inputs.KeyUp    :Key \"right\"    :Action    (-&gt;     0 &gt; .character-state     0.0 &gt; .character-x-velocity)))</p> <p>;; -------------- Initialize Coin ---------- (defshards initialize-coin []   (LoadTexture \"GlodImages/Coin/Coin_1.png\") &gt;&gt; .coin-image-array   (LoadTexture \"GlodImages/Coin/Coin_2.png\") &gt;&gt; .coin-image-array   (LoadTexture \"GlodImages/Coin/Coin_3.png\") &gt;&gt; .coin-image-array   (LoadTexture \"GlodImages/Coin/Coin_4.png\") &gt;&gt; .coin-image-array   (LoadTexture \"GlodImages/Coin/Coin_5.png\") &gt;&gt; .coin-image-array   (LoadTexture \"GlodImages/Coin/Coin_6.png\") &gt;&gt; .coin-image-array   (LoadTexture \"GlodImages/Coin/Coin_7.png\") &gt;&gt; .coin-image-array   (Count .coin-image-array) (Math.Subtract 1) &gt;= .coin-image-index-max   0 &gt;= .coin-image-index   0.1 &gt;= .coin-animation-speed)</p> <p>;; -------------- Coin Animation ------------------ (defloop coin-animation   .coin-image-index (Math.Add 1)</p> <p>.coin-image-index   (When    :Predicate (IsMore .coin-image-index-max)    :Action (-&gt; 0 &gt; .coin-image-index))</p> <p>(Pause .coin-animation-speed))   </p> <p>(defloop main-wire   (Setup    (initialize-character)    (initialize-coin))</p> <p>(run-logic)   (gravity-logic)</p> <p>(Step idle-animation)   (Step walking-animation)</p> <p>(Step coin-animation)</p> <p>(GFX.MainWindow    :Title \"MainWindow\" :Width 1920 :Height 1080    :Contents    (-&gt;     (Setup      (GFX.DrawQueue) &gt;= .ui-draw-queue      (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)     .ui-draw-queue (GFX.ClearQueue)</p> <pre><code>(UI\n .ui-draw-queue\n (-&gt;\n  (UI.Area\n   :Position .character-position\n   :Anchor Anchor.Top\n   :Contents\n   (-&gt;\n    .character-state\n    (Match [0 (-&gt; .character-direction\n                  (Match [0 (-&gt; .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n                          1 (-&gt; .idle-right-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))]\n                         :Passthrough false))\n            1 (-&gt; .walking-left-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n            2 (-&gt; .walking-right-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n            3 (-&gt; .character-jumping (UI.Image :Scale (float2 0.2)))]\n           :Passthrough false)))\n\n  (UI.Area\n   :Position (float2 0 0)\n   :Anchor Anchor.Top\n   :Contents\n   (-&gt; .coin-image-array\n       (Take .coin-image-index)\n       (UI.Image :Scale (float2 0.2))))))\n\n(GFX.Render :Steps .render-steps)\n\n(button-inputs))))\n</code></pre> <p>(defmesh main) (schedule main main-wire) (run main (/ 1.0 60))</p> <p>Try running your code to see if your coin is animated. Good job if it is!</p>"},{"location":"learn/shards/tutorials/glod-game/steps/step-5/#step-53","title":"Step 5.3","text":"<p>Now let's make our coin fall. To do this, like we did with Glod, we will:</p> <ol> <li> <p>Set a variable in the <code>Position</code> parameter of the coin's <code>UI.Area</code>, replacing the <code>(float2 0 0)</code> used previously.</p> </li> <li> <p>Change this variable accordingly.</p> </li> </ol> <p>Without further ado, let's get started!</p> <p>First we create the coin's x, y, and position variables.</p> Code Added <pre><code>;; ----- Coin 1 ------\n0.0 &gt;= .coinx-1 ;; (1)\n0.0 &gt;= .coiny-1\n(float2 .coinx-1 .coiny-1) &gt;= .coin-position-1\n</code></pre> <ol> <li>Added to line 190.</li> </ol> <p>We then replace the value of the <code>Position</code> parameter in our coin's <code>UI.Area</code>.</p> Code AddedFull Code So Far <pre><code>(UI.Area\n :Position .coin-position-1 ;; (1)\n :Anchor Anchor.Top\n :Contents\n (-&gt; .coin-image-array\n     (Take .coin-image-index)\n     (UI.Image :Scale (float2 0.2))))\n</code></pre> <ol> <li>Amended at line 245.</li> </ol> <pre><code>(defshards load-texture [name]\n  (LoadImage name)\n  (GFX.Texture))\n\n(defshards initialize-character []\n  (LoadTexture \"GlodImages/Character1.png\") = .idle-left-image-array\n  (LoadTexture \"GlodImages/Character1_Left.png\") = .character-left\n  (LoadTexture \"GlodImages/Character1_Right.png\") = .character-right\n  (LoadTexture \"GlodImages/Character1_Jumping.png\") = .character-jumping\n\n  0 &gt;= .character-state\n  0 &gt;= .character-direction ;; 0 = facing left, 1 = facing right\n  true &gt;= .can-jump\n\n  0.0 &gt;= .x\n  310.0 &gt;= .y\n  (float2 .x .y) &gt;= .character-position\n  0.0 &gt;= .character-x-velocity\n  0.0 &gt;= .character-y-velocity\n  0.0 &gt;= .character-y-acceleration\n\n  ;; ---------- Character Idle Array (Facing Left)----------\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png\") &gt;&gt; .idle-left-image-array\n\n  ;; ---------- Character Idle Array (Facing Right) ----------------\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_1.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_2.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_3.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_4.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_5.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_6.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_7.png\") &gt;&gt; .idle-right-image-array\n\n  0 &gt;= .idle-image-index\n  (Count .idle-left-image-array) = .idle-image-index-max\n  0.08 = .idle-animation-speed\n\n  ;; -------------- Walking Array (Facing Left) -----------------\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_1.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_2.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_3.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_4.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_5.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_6.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_7.png\") &gt;&gt; .walking-left-image-array\n\n  ;; ----------- Walking Array (Facing Right) ---------------\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_1.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_2.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_3.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_4.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_5.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_6.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_7.png\") &gt;&gt; .walking-right-image-array\n\n  (Count .walking-left-image-array) = .walking-image-index-max\n  0 &gt;= .walking-image-index\n  0.08 = .walking-animation-speed ;; Reduce number to increase animation speed\n  )\n\n;; --------- Idle Animation Loop ---------\n(defloop idle-animation\n  .idle-image-index (Math.Add 1)\n  &gt; .idle-image-index\n  (When\n   :Predicate (IsMoreEqual .idle-image-index-max)\n   :Action (-&gt; 0 &gt; .idle-image-index))\n  (Pause .idle-animation-speed))\n\n;; -------- Walking Animation Loop --------\n(defloop walking-animation\n  .walking-image-index (Math.Add 1)\n  &gt; .walking-image-index\n  (When\n   :Predicate (IsMoreEqual .walking-image-index-max) \n   :Action (-&gt; 0 &gt; .walking-image-index))\n  (Pause .walking-animation-speed))\n\n;; ---------- Character Boundary ------------\n(defshards clamp [var min max]\n  var (Max min) (Min max) &gt; var)\n\n;; ------------ Character Run Logic ----------------\n(defshards run-logic []\n  .x (Math.Add .character-x-velocity)\n  &gt; .x\n\n  (float2 .x .y) &gt; .character-position\n\n  (clamp .X -600.0 600.0))\n\n;; ------------ Character Gravity Logic ---------------\n(defshards gravity-logic []\n  .y (Math.Add .character-y-velocity)\n  &gt; .y\n\n  .character-y-velocity (Math.Add .character-y-acceleration)\n  &gt; .character-y-velocity\n\n  (float2 .x .y) &gt; .character-position\n\n  (clamp .y -620.0 620.0)\n  .y\n  (When\n   :Predicate (IsMoreEqual 620.0)\n   :Action (-&gt;\n            0.0 &gt; .character-y-velocity\n            0.0 &gt; .character-y-acceleration\n            true &gt; .can-jump\n            .character-state\n            (When\n             :Predicate (Is 3)\n             :Action (-&gt;\n                      0 &gt; .character-state)))))\n\n;; ------- Button Inputs ----------\n(defshards button-inputs []\n  (Inputs.KeyDown\n   :Key \"left\"\n   :Action\n   (-&gt;\n    (Msg \"left\")\n    .character-state\n    (When\n     :Predicate (Is 0)\n     :Action (-&gt; 1 &gt; .character-state))\n    0 &gt; .character-direction\n    -5.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyDown\n   :Key \"right\"\n   :Action\n   (-&gt;\n    (Msg \"right\")\n    .character-state\n    (When\n     :Predicate (Is 0)\n     :Action (-&gt; 2 &gt; .character-state))\n    1 &gt; .character-direction\n    5.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyDown\n   :Key \"up\"\n   :Action\n   (-&gt;\n    (Msg \"up\")\n    3 &gt; .character-state\n    .can-jump\n    (When\n     :Predicate (Is true)\n     :Action (-&gt;\n              -20.0 &gt; .character-y-velocity\n              1.0 &gt;  .character-y-acceleration\n              false &gt;= .can-jump))))\n\n  (Inputs.KeyUp\n   :Key \"left\"\n   :Action \n   (-&gt;\n    0 &gt; .character-state\n    0.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyUp\n   :Key \"right\"\n   :Action\n   (-&gt;\n    0 &gt; .character-state\n    0.0 &gt; .character-x-velocity)))\n\n;; -------------- Initialize Coin ----------\n(defshards initialize-coin []\n  (LoadTexture \"GlodImages/Coin/Coin_1.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_2.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_3.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_4.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_5.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_6.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_7.png\") &gt;&gt; .coin-image-array\n  (Count .coin-image-array) (Math.Subtract 1) &gt;= .coin-image-index-max\n  0 &gt;= .coin-image-index\n  0.1 &gt;= .coin-animation-speed\n\n  ;; ----- Coin 1 ------\n  0.0 &gt;= .coinx-1\n  0.0 &gt;= .coiny-1\n  (float2 .coinx-1 .coiny-1) &gt;= .coin-position-1)\n\n;; -------------- Coin Animation ------------------\n(defloop coin-animation\n  .coin-image-index (Math.Add 1)\n  &gt; .coin-image-index\n  (When\n   :Predicate (IsMore .coin-image-index-max)\n   :Action (-&gt; 0 &gt; .coin-image-index))\n\n  (Pause .coin-animation-speed))   \n\n(defloop main-wire\n  (Setup\n   (initialize-character)\n   (initialize-coin))\n\n  (run-logic)\n  (gravity-logic)\n\n  (Step idle-animation)\n  (Step walking-animation)\n\n  (Step coin-animation)\n\n  (GFX.MainWindow\n   :Title \"MainWindow\" :Width 1920 :Height 1080\n   :Contents\n   (-&gt;\n    (Setup\n     (GFX.DrawQueue) &gt;= .ui-draw-queue\n     (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n    .ui-draw-queue (GFX.ClearQueue)\n\n    (UI\n     .ui-draw-queue\n     (-&gt;\n      (UI.Area\n       :Position .character-position\n       :Anchor Anchor.Top\n       :Contents\n       (-&gt;\n        .character-state\n        (Match [0 (-&gt; .character-direction\n                      (Match [0 (-&gt; .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n                              1 (-&gt; .idle-right-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))]\n                             :Passthrough false))\n                1 (-&gt; .walking-left-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n                2 (-&gt; .walking-right-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n                3 (-&gt; .character-jumping (UI.Image :Scale (float2 0.2)))]\n               :Passthrough false)))\n\n      (UI.Area\n       :Position .coin-position-1\n       :Anchor Anchor.Top\n       :Contents\n       (-&gt; .coin-image-array\n           (Take .coin-image-index)\n           (UI.Image :Scale (float2 0.2))))))\n\n    (GFX.Render :Steps .render-steps)\n\n    (button-inputs))))\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre> <p>Try changing the <code>.coinx-1</code> or <code>.coiny-1</code> values to check if your coin's position changes. Wonderful!</p> <p>Now, similar to our running and jumping logic, we have to create a gravity logic to make our coin fall. Let's once again use velocity and acceleration to make our coin fall realistically.</p> <p>First, create velocity and acceleration variables under the <code>initialize-coin</code> shard.</p> Code Added <pre><code>0.0 &gt;= .coin-velocity-1 ;; (1)\n0.5 &gt;= .coin-acceleration\n</code></pre> <ol> <li>Added to line 188, under <code>initialize-coin</code>.</li> </ol> <p>Create our <code>coin-gravity-logic</code> shard. The logic behind it is the same as our jump logic. We add velocity to the y position and then add acceleration to our velocity to increase the rate of increase.</p> Code Added <pre><code>;; ------------- Coin Gravity ------------------\n(defshards coin-gravity-logic [] ;; (1)\n\n  .coiny-1 (Math.Add .coin-velocity-1)\n  &gt; .coiny-1\n\n  .coin-velocity-1 (Math.Add .coin-acceleration)\n  &gt; .coin-velocity-1\n\n  (float2 .coinx-1 .coiny-1) &gt; .coin-position-1)\n</code></pre> <ol> <li>Added to line 207.</li> </ol> <p>Remember to call the <code>coin-gravity-logic</code> shard in our <code>main-wire</code> loop.</p> Code AddedFull Code So Far <pre><code>(coin-gravity-logic) ;; (1)\n</code></pre> <ol> <li>Added to line 229.</li> </ol> <pre><code>(defshards load-texture [name]\n  (LoadImage name)\n  (GFX.Texture))\n\n(defshards initialize-character []\n  (LoadTexture \"GlodImages/Character1.png\") = .idle-left-image-array\n  (LoadTexture \"GlodImages/Character1_Left.png\") = .character-left\n  (LoadTexture \"GlodImages/Character1_Right.png\") = .character-right\n  (LoadTexture \"GlodImages/Character1_Jumping.png\") = .character-jumping\n\n  0 &gt;= .character-state\n  0 &gt;= .character-direction ;; 0 = facing left, 1 = facing right\n  true &gt;= .can-jump\n\n  0.0 &gt;= .x\n  310.0 &gt;= .y\n  (float2 .x .y) &gt;= .character-position\n  0.0 &gt;= .character-x-velocity\n  0.0 &gt;= .character-y-velocity\n  0.0 &gt;= .character-y-acceleration\n\n  ;; ---------- Character Idle Array (Facing Left)----------\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png\") &gt;&gt; .idle-left-image-array\n\n  ;; ---------- Character Idle Array (Facing Right) ----------------\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_1.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_2.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_3.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_4.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_5.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_6.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_7.png\") &gt;&gt; .idle-right-image-array\n\n  0 &gt;= .idle-image-index\n  (Count .idle-left-image-array) = .idle-image-index-max\n  0.08 = .idle-animation-speed\n\n  ;; -------------- Walking Array (Facing Left) -----------------\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_1.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_2.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_3.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_4.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_5.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_6.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_7.png\") &gt;&gt; .walking-left-image-array\n\n  ;; ----------- Walking Array (Facing Right) ---------------\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_1.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_2.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_3.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_4.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_5.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_6.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_7.png\") &gt;&gt; .walking-right-image-array\n\n  (Count .walking-left-image-array) = .walking-image-index-max\n  0 &gt;= .walking-image-index\n  0.08 = .walking-animation-speed ;; Reduce number to increase animation speed\n  )\n\n;; --------- Idle Animation Loop ---------\n(defloop idle-animation\n  .idle-image-index (Math.Add 1)\n  &gt; .idle-image-index\n  (When\n   :Predicate (IsMoreEqual .idle-image-index-max)\n   :Action (-&gt; 0 &gt; .idle-image-index))\n  (Pause .idle-animation-speed))\n\n;; -------- Walking Animation Loop --------\n(defloop walking-animation\n  .walking-image-index (Math.Add 1)\n  &gt; .walking-image-index\n  (When\n   :Predicate (IsMoreEqual .walking-image-index-max) \n   :Action (-&gt; 0 &gt; .walking-image-index))\n  (Pause .walking-animation-speed))\n\n;; ---------- Character Boundary ------------\n(defshards clamp [var min max]\n  var (Max min) (Min max) &gt; var)\n\n;; ------------ Character Run Logic ----------------\n(defshards run-logic []\n  .x (Math.Add .character-x-velocity)\n  &gt; .x\n\n  (float2 .x .y) &gt; .character-position\n\n  (clamp .X -600.0 600.0))\n\n;; ------------ Character Gravity Logic ---------------\n(defshards gravity-logic []\n  .y (Math.Add .character-y-velocity)\n  &gt; .y\n\n  .character-y-velocity (Math.Add .character-y-acceleration)\n  &gt; .character-y-velocity\n\n  (float2 .x .y) &gt; .character-position\n\n  (clamp .y -620.0 620.0)\n  .y\n  (When\n   :Predicate (IsMoreEqual 620.0)\n   :Action (-&gt;\n            0.0 &gt; .character-y-velocity\n            0.0 &gt; .character-y-acceleration\n            true &gt; .can-jump\n            .character-state\n            (When\n             :Predicate (Is 3)\n             :Action (-&gt;\n                      0 &gt; .character-state)))))\n\n;; ------- Button Inputs ----------\n(defshards button-inputs []\n  (Inputs.KeyDown\n   :Key \"left\"\n   :Action\n   (-&gt;\n    (Msg \"left\")\n    .character-state\n    (When\n     :Predicate (Is 0)\n     :Action (-&gt; 1 &gt; .character-state))\n    0 &gt; .character-direction\n    -5.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyDown\n   :Key \"right\"\n   :Action\n   (-&gt;\n    (Msg \"right\")\n    .character-state\n    (When\n     :Predicate (Is 0)\n     :Action (-&gt; 2 &gt; .character-state))\n    1 &gt; .character-direction\n    5.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyDown\n   :Key \"up\"\n   :Action\n   (-&gt;\n    (Msg \"up\")\n    3 &gt; .character-state\n    .can-jump\n    (When\n     :Predicate (Is true)\n     :Action (-&gt;\n              -20.0 &gt; .character-y-velocity\n              1.0 &gt;  .character-y-acceleration\n              false &gt;= .can-jump))))\n\n  (Inputs.KeyUp\n   :Key \"left\"\n   :Action \n   (-&gt;\n    0 &gt; .character-state\n    0.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyUp\n   :Key \"right\"\n   :Action\n   (-&gt;\n    0 &gt; .character-state\n    0.0 &gt; .character-x-velocity)))\n\n;; -------------- Initialize Coin ----------\n(defshards initialize-coin []\n  (LoadTexture \"GlodImages/Coin/Coin_1.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_2.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_3.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_4.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_5.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_6.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_7.png\") &gt;&gt; .coin-image-array\n  (Count .coin-image-array) (Math.Subtract 1) &gt;= .coin-image-index-max\n  0 &gt;= .coin-image-index\n  0.1 &gt;= .coin-animation-speed\n  0.0 &gt;= .coin-velocity-1\n  0.5 &gt;= .coin-acceleration\n\n  ;; ----- Coin 1 ------\n  0.0 &gt;= .coinx-1\n  0.0 &gt;= .coiny-1\n  (float2 .coinx-1 .coiny-1) &gt;= .coin-position-1)\n\n;; -------------- Coin Animation ------------------\n(defloop coin-animation\n  .coin-image-index (Math.Add 1)\n  &gt; .coin-image-index\n  (When\n   :Predicate (IsMore .coin-image-index-max)\n   :Action (-&gt; 0 &gt; .coin-image-index))\n\n  (Pause .coin-animation-speed))   \n\n;; ------------- Coin Gravity ------------------\n(defshards coin-gravity-logic []\n\n  .coiny-1 (Math.Add .coin-velocity-1)\n  &gt; .coiny-1\n\n  .coin-velocity-1 (Math.Add .coin-acceleration)\n  &gt; .coin-velocity-1\n\n  (float2 .coinx-1 .coiny-1) &gt; .coin-position-1)\n\n(defloop main-wire\n  (Setup\n   (initialize-character)\n   (initialize-coin))\n\n  (run-logic)\n  (gravity-logic)\n\n  (Step idle-animation)\n  (Step walking-animation)\n\n  (Step coin-animation)\n  (coin-gravity-logic)\n\n  (GFX.MainWindow\n   :Title \"MainWindow\" :Width 1920 :Height 1080\n   :Contents\n   (-&gt;\n    (Setup\n     (GFX.DrawQueue) &gt;= .ui-draw-queue\n     (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n    .ui-draw-queue (GFX.ClearQueue)\n\n    (UI\n     .ui-draw-queue\n     (-&gt;\n      (UI.Area\n       :Position .character-position\n       :Anchor Anchor.Top\n       :Contents\n       (-&gt;\n        .character-state\n        (Match [0 (-&gt; .character-direction\n                      (Match [0 (-&gt; .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n                              1 (-&gt; .idle-right-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))]\n                             :Passthrough false))\n                1 (-&gt; .walking-left-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n                2 (-&gt; .walking-right-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n                3 (-&gt; .character-jumping (UI.Image :Scale (float2 0.2)))]\n               :Passthrough false)))\n\n      (UI.Area\n       :Position .coin-position-1\n       :Anchor Anchor.Top\n       :Contents\n       (-&gt; .coin-image-array\n           (Take .coin-image-index)\n           (UI.Image :Scale (float2 0.2))))))\n\n    (GFX.Render :Steps .render-steps)\n\n    (button-inputs))))\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre>"},{"location":"learn/shards/tutorials/glod-game/steps/step-5/#step-54","title":"Step 5.4","text":"<p>If you run your code now, you would see our coin falling! Nice. \ud83d\ude01</p> <p>Now let's have adorable Glod chase some money! \ud83e\udd11\ud83d\udcb0\ud83d\udcb5\ud83d\udcb6\ud83d\udcb7</p> <p>To do that, we need to create the logic to:</p> <ol> <li> <p>Check when Glod is colliding with our coin.</p> </li> <li> <p>Gain a point when the collision happens.</p> </li> </ol> <p>Let's do this step by step.</p> <p>First, nice and easy, let's create a <code>.score</code> variable. Remember to initialize this in your main loop setup.</p> Code Added <p><pre><code>(defshards initialize-game-elements []\n  0 &gt;= .score)\n</code></pre> <pre><code>(initialize-game-elements)\n</code></pre></p> <p>Next, create a new <code>UI.Area</code> to draw our <code>.score</code> using <code>UI.Label</code>. Remember to convert our <code>.score</code> to a string first with the <code>(ToString)</code> shard.</p> Code Added <pre><code>(UI.Area :Position (float2 -40 20)\n                            :Anchor Anchor.TopRight\n                            :Contents (-&gt;\n                                      .score (ToString)(UI.Label)))\n</code></pre> <p>If you try to run our code now you will see a teeny tiny 0 in the corner of your screen. This means that our score is being drawn! But it unfortunately has not been styled yet. So let's do that.</p> <p>We first create a style shard and then call this shard before we draw our <code>UI.Label</code>. Now if you try running your code you would see that our score is styled nicely.</p> Code AddedFull Code So Far <p><pre><code>;; ------ UI Style --------\n(def style\n  {:override_text_style \"MyStyle\"\n  :text_styles\n  [{:name \"MyStyle\"\n    :size (float 46)\n    :family \"Monospace\"}]\n  :visuals\n  {:override_text_color (color 250 250 250)}})\n</code></pre> <pre><code>;; ------ UI Style --------\n(UI.Area :Position (float2 -40 20)\n                            :Anchor Anchor.TopRight\n                            :Contents (-&gt;\n                                      style (UI.Style)\n                                      .Score (ToString)(UI.Label))) ;;(1)\n</code></pre></p> <pre><code>(defshards LoadTexture [name]\n  (LoadImage name)\n  (GFX.Texture))\n\n(defshards initialize-character []\n  (LoadTexture \"GlodImages/Character1_Jumping_Left.png\") = .character-jumping-left\n  (LoadTexture \"GlodImages/Character1_Jumping_Right.png\") = .character-jumping-right\n\n  0 &gt;= .character-state\n  0 &gt;= .character-direction\n  true &gt;= .can-jump\n\n  0.0 &gt;= .X\n  620.0 &gt;= .Y\n  (float2 .X .Y) &gt;= .character-position\n  0.0 &gt;= .character-x-velocity\n  0.0 &gt;= .character-y-velocity\n  0.0 &gt;= .character-y-acceleration\n\n  ;; ---------- Character Idle Array (Facing Left) ----------\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png\") &gt;&gt; .idle-left-image-array\n\n  ;; ---------- Character Idle Array (Facing Right) ----------------\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_1.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_2.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_3.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_4.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_5.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_6.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_7.png\") &gt;&gt; .idle-right-image-array\n\n  0 &gt;= .idle-image-index\n  (Count .idle-left-image-array) = .idle-image-index-max\n  0.08 = .idle-animation-speed\n\n  ;; -------------- Walking Array (Facing Left) -----------------\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_1.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_2.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_3.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_4.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_5.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_6.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_7.png\") &gt;&gt; .walking-left-image-array\n\n  ;; ----------- Walking Array (Facing Right) ---------------\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_1.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_2.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_3.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_4.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_5.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_6.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_7.png\") &gt;&gt; .walking-right-image-array\n\n  (Count .walking-left-image-array) = .walking-image-index-max\n  0 &gt;= .walking-image-index\n  0.08 = .walking-animation-speed) ;; Reduce number to increase animation speed\n\n;; --------- Idle Animation Loop ---------\n(defloop idle-animation\n  .idle-image-index (Math.Add 1)\n  &gt; .idle-image-index\n  (When :Predicate (IsMoreEqual .idle-image-index-max)\n        :Action (-&gt; 0 &gt; .idle-image-index))\n  (Pause .idle-animation-speed))\n\n;; -------- Walking Animation Loop --------\n(defloop walking-animation\n  .walking-image-index (Math.Add 1)\n  &gt; .walking-image-index\n  (When :Predicate (IsMoreEqual .walking-image-index-max)\n        :Action (-&gt; 0 &gt; .walking-image-index))\n  (Pause .walking-animation-speed))\n\n;; ---------- character-boundary ------------\n\n(defshards clamp [var min max]\n  var (Max min) (Min max) &gt; var)\n\n;; ------------ Character Run Logic ----------------\n(defshards run-logic []\n  .X (Math.Add .character-x-velocity)\n  &gt; .X\n\n  (float2 .X .Y) &gt; .character-position\n\n  (clamp .X -600.0 600.0))\n\n;; ------------ Character gravity-logic ---------------\n(defshards gravity-logic []\n  .Y (Math.Add .character-y-velocity)\n  &gt; .Y\n\n  .character-y-velocity (Math.Add .character-y-acceleration)\n  &gt; .character-y-velocity\n\n  (float2 .X .Y) &gt; .character-position\n\n  (clamp .Y -620.0 620.0)\n  .Y\n  (When :Predicate (IsMoreEqual 620.0)\n        :Action (-&gt;\n                0.0 &gt; .character-y-velocity\n                0.0 &gt; .character-y-acceleration\n                true &gt; .can-jump\n                .character-state\n                (When :Predicate (Is 3)\n                      :Action (-&gt;\n                                0 &gt; .character-state)))))\n\n;; ------- Button Inputs ----------\n(defshards button-inputs []\n  (Inputs.KeyDown\n  :Key \"left\"\n  :Action (-&gt;\n            (Msg \"left\")\n\n            .character-state\n            (When :Predicate (Is 0)\n                  :Action (-&gt; 1 &gt; .character-state))\n\n            0 &gt; .character-direction\n            -5.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyDown\n  :Key \"right\"\n  :Action (-&gt;\n            (Msg \"right\")\n\n            .character-state\n            (When :Predicate (Is 0)\n                  :Action (-&gt; 2 &gt; .character-state))\n            1 &gt; .character-direction\n            5.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyDown\n  :Key \"up\"\n  :Action (-&gt;\n            (Msg \"up\")\n            3 &gt; .character-state\n            .can-jump\n            (When :Predicate (Is true)\n                  :Action (-&gt;\n                          -20.0 &gt; .character-y-velocity\n                          1.0 &gt;  .character-y-acceleration\n                          false &gt;= .can-jump))))\n\n  (Inputs.KeyUp\n  :Key \"left\"\n  :Action (-&gt;\n            0 &gt; .character-state\n            0.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyUp\n  :Key \"right\"\n  :Action (-&gt;\n            0 &gt; .character-state\n            0.0 &gt; .character-x-velocity)))\n\n;; -------------- Initialize Coin ----------\n(defshards initialize-coin []\n  (LoadTexture \"GlodImages/Coin/Coin_1.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_2.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_3.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_4.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_5.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_6.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_7.png\") &gt;&gt; .coin-image-array\n  (Count .coin-image-array) = .coin-image-index-max\n  0 &gt;= .coin-image-index\n  0.1 = .coin-animation-speed\n\n  ;; ----- Coin 1 ------\n  0.0 &gt;= .coinx-1\n  0.0 &gt;= .coiny-1\n  (float2 .coinx-1 .coiny-1) &gt;= .coin-position-1\n  0.0 &gt;= .coin-velocity-1\n\n  0.5 &gt;= .coin-acceleration)\n\n;; -------------- Coin Animation ------------------\n(defloop coin-animation\n  .coin-image-index (Math.Add 1)\n  &gt; .coin-image-index\n  (When :Predicate (IsMoreEqual .coin-image-index-max)\n        :Action (-&gt; 0 &gt; .coin-image-index))\n\n  (Pause .coin-animation-speed))\n\n;; ------------- Coin Gravity ------------------\n(defshards coin-gravity-logic []\n\n  .coiny-1 (Math.Add .coin-velocity-1)\n  &gt; .coiny-1\n\n  .coin-velocity-1 (Math.Add .coin-acceleration)\n  &gt; .coin-velocity-1\n\n  (float2 .coinx-1 .coiny-1) &gt; .coin-position-1)\n\n;; --------- Game Elements ------------\n(defshards initialize-game-elements []\n  0 &gt;= .score)\n\n;; ------ UI Style --------\n(def style\n  {:override_text_style \"MyStyle\"\n  :text_styles\n  [{:name \"MyStyle\"\n    :size (float 46)\n    :family \"Monospace\"}]\n  :visuals\n  {:override_text_color (color 250 250 250)}})\n\n;;---------- main-wire ------------\n(defloop main-wire\n  (Setup\n  (initialize-character)\n  (initialize-coin)\n  (initialize-game-elements))\n\n  (run-logic)\n  (gravity-logic)\n\n  (Step idle-animation)\n  (Step walking-animation)\n\n  (Step coin-animation)\n  (coin-gravity-logic)\n\n  (GFX.MainWindow\n  :Title \"MainWindow\" :Width 1920 :Height 1080\n  :Contents\n  (-&gt; (Setup\n        (GFX.DrawQueue) &gt;= .ui-draw-queue\n        (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n      .ui-draw-queue (GFX.ClearQueue)\n\n      (UI\n        .ui-draw-queue\n        (-&gt;\n        (UI.Area :Position .character-position\n                  :Anchor Anchor.Top\n                  :Contents (-&gt;\n                            .character-state\n                            (Match [0 (-&gt; .character-direction\n                                          (Match [0 (-&gt; .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n                                                  1 (-&gt; .idle-right-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))]\n                                                  :Passthrough false))\n                                    1 (-&gt; .walking-left-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n                                    2 (-&gt; .walking-right-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n                                    3 (-&gt;  .character-direction\n                                            (Match [0 (-&gt; .character-jumping-left (UI.Image :Scale (float2 0.2)))\n                                                    1 (-&gt; .character-jumping-right (UI.Image :Scale (float2 0.2)))]\n                                                  :Passthrough false))]\n                                    :Passthrough false)))\n\n        (UI.Area :Position .coin-position-1\n                  :Anchor Anchor.Top\n                  :Contents (-&gt;\n                            .coin-image-array (Take .coin-image-index) (UI.Image :Scale (float2 0.2))))\n\n        (UI.Area :Position (float2 -40 20)\n                  :Anchor Anchor.TopRight\n                  :Contents (-&gt;\n                            style (UI.Style)\n                            .score (ToString) (UI.Label)))))\n\n      (button-inputs)\n\n      (GFX.Render :Steps .render-steps))))\n\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre>"},{"location":"learn/shards/tutorials/glod-game/steps/step-5/#step-55","title":"Step 5.5","text":"<p>Now that we have our score UI, we can start to increase it. To do this, we need our collision logic.</p> <p>Create:</p> <ol> <li> <p>An upper and lower x limit.</p> </li> <li> <p>An upper and lower y limit.</p> </li> </ol> <p>This is to draw a collision box around our dear Glod. These variables are added to our <code>initialize-game-elements</code> shard. Since our character is moving, we have to constantly update our collision box.</p> <p>Glod Collision Box</p> <p>We also create a <code>.scored</code> variable to limit the number of times we can score from one coin. These variables will be added under <code>initialize-game-elements</code>.</p> Code Added <pre><code>.X (Math.Add 50.0)\n&gt;= .scoringUpper-x-limit\n.X (Math.Subtract 50.0)\n&gt;= .scoringLower-x-limit\n\n.Y (Math.Add 10.0)\n&gt;= .scoringUpper-y-limit\n.Y (Math.Subtract 10.0)\n&gt;= .scoringLower-y-limit\n\nfalse &gt;= .scored\n</code></pre> <p>Next, we will implement our collision logic with a conditional statement.</p> <p>Create the logic to trigger whenever our coin falls within our collision box.</p> <p>This conditional statement will check if the x value of our coin:</p> <ul> <li> <p>Is lesser then the upper x limit of our collision box.</p> </li> <li> <p>Is more than the lower x limit of our collision box.</p> </li> </ul> <p>It is checking if it within the stated range and does the same for the y value. Next, we increase the score whenever this happens.</p> <p>Whenever the <code>.scored</code> variable is true, gain a point. Once a point is gained, Reset <code>.scored</code> to false once again. This ensures that only one point is gained whenever we collect a coin. Remember to call the <code>(scoring)</code> shard in your main wire</p> Code AddedFull Code So Far <pre><code>;; ------------- Scoring ------------\n(defshards score-collision []\n  .coinx-1\n  (When :Predicate (-&gt;\n                    (IsLess .scoringUpper-x-limit)\n                    (And)\n                    .coinx-1 (IsMore .scoringLower-x-limit)\n                    (And)\n                    .coiny-1 (IsLess .scoringUpper-y-limit)\n                    (And)\n                    .coiny-1 (IsMore .scoringLower-y-limit)\n                    (And)\n                    .scored (Is false))\n        :Action (-&gt;\n                true &gt; .scored\n                (Log \"Score: \"))))\n\n(defshards scoring []\n  .X (Math.Add 50.0)\n  &gt; .scoringUpper-x-limit\n  .X (Math.Subtract 50.0)\n  &gt; .scoringLower-x-limit\n\n  .Y (Math.Add 10.0)\n  &gt; .scoringUpper-y-limit\n  .Y (Math.Subtract 10.0)\n  &gt; .scoringLower-y-limit \n\n  (score-collision)\n\n  .scored\n  (When :Predicate (Is true)\n        :Action (-&gt;\n                .score (Math.Add 1)\n                &gt; .score\n                false &gt; .scored)))\n</code></pre> <pre><code>(defshards LoadTexture [name]\n  (LoadImage name)\n  (GFX.Texture))\n\n(defshards initialize-character []\n  (LoadTexture \"GlodImages/Character1_Jumping_Left.png\") = .character-jumping-left\n  (LoadTexture \"GlodImages/Character1_Jumping_Right.png\") = .character-jumping-right\n\n  0 &gt;= .character-state\n  0 &gt;= .character-direction\n  true &gt;= .can-jump\n\n  0.0 &gt;= .X\n  620.0 &gt;= .Y\n  (float2 .X .Y) &gt;= .character-position\n  0.0 &gt;= .character-x-velocity\n  0.0 &gt;= .character-y-velocity\n  0.0 &gt;= .character-y-acceleration\n\n  ;; ---------- Character Idle Array (Facing Left) ----------\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png\") &gt;&gt; .idle-left-image-array\n\n  ;; ---------- Character Idle Array (Facing Right) ----------------\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_1.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_2.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_3.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_4.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_5.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_6.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_7.png\") &gt;&gt; .idle-right-image-array\n\n  0 &gt;= .idle-image-index\n  (Count .idle-left-image-array) = .idle-image-index-max\n  0.08 = .idle-animation-speed\n\n  ;; -------------- Walking Array (Facing Left) -----------------\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_1.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_2.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_3.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_4.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_5.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_6.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_7.png\") &gt;&gt; .walking-left-image-array\n\n  ;; ----------- Walking Array (Facing Right) ---------------\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_1.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_2.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_3.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_4.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_5.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_6.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_7.png\") &gt;&gt; .walking-right-image-array\n\n  (Count .walking-left-image-array) = .walking-image-index-max\n  0 &gt;= .walking-image-index\n  0.08 = .walking-animation-speed) ;; Reduce number to increase animation speed\n\n;; --------- Idle Animation Loop ---------\n(defloop idle-animation\n  .idle-image-index (Math.Add 1)\n  &gt; .idle-image-index\n  (When :Predicate (IsMoreEqual .idle-image-index-max)\n        :Action (-&gt; 0 &gt; .idle-image-index))\n  (Pause .idle-animation-speed))\n\n;; -------- Walking Animation Loop --------\n(defloop walking-animation\n  .walking-image-index (Math.Add 1)\n  &gt; .walking-image-index\n  (When :Predicate (IsMoreEqual .walking-image-index-max)\n        :Action (-&gt; 0 &gt; .walking-image-index))\n  (Pause .walking-animation-speed))\n\n;; ---------- character-boundary ------------\n\n(defshards clamp [var min max]\n  var (Max min) (Min max) &gt; var)\n\n;; ------------ Character Run Logic ----------------\n(defshards run-logic []\n  .X (Math.Add .character-x-velocity)\n  &gt; .X\n\n  (float2 .X .Y) &gt; .character-position\n\n  (clamp .X -600.0 600.0))\n\n;; ------------ Character gravity-logic ---------------\n(defshards gravity-logic []\n  .Y (Math.Add .character-y-velocity)\n  &gt; .Y\n\n  .character-y-velocity (Math.Add .character-y-acceleration)\n  &gt; .character-y-velocity\n\n  (float2 .X .Y) &gt; .character-position\n\n  (clamp .Y -620.0 620.0)\n  .Y\n  (When :Predicate (IsMoreEqual 620.0)\n        :Action (-&gt;\n                0.0 &gt; .character-y-velocity\n                0.0 &gt; .character-y-acceleration\n                true &gt; .can-jump\n                .character-state\n                (When :Predicate (Is 3)\n                      :Action (-&gt;\n                                0 &gt; .character-state)))))\n\n;; ------- Button Inputs ----------\n(defshards button-inputs []\n  (Inputs.KeyDown\n  :Key \"left\"\n  :Action (-&gt;\n            (Msg \"left\")\n\n            .character-state\n            (When :Predicate (Is 0)\n                  :Action (-&gt; 1 &gt; .character-state))\n\n            0 &gt; .character-direction\n            -5.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyDown\n  :Key \"right\"\n  :Action (-&gt;\n            (Msg \"right\")\n\n            .character-state\n            (When :Predicate (Is 0)\n                  :Action (-&gt; 2 &gt; .character-state))\n            1 &gt; .character-direction\n            5.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyDown\n  :Key \"up\"\n  :Action (-&gt;\n            (Msg \"up\")\n            3 &gt; .character-state\n            .can-jump\n            (When :Predicate (Is true)\n                  :Action (-&gt;\n                          -20.0 &gt; .character-y-velocity\n                          1.0 &gt;  .character-y-acceleration\n                          false &gt;= .can-jump))))\n\n  (Inputs.KeyUp\n  :Key \"left\"\n  :Action (-&gt;\n            0 &gt; .character-state\n            0.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyUp\n  :Key \"right\"\n  :Action (-&gt;\n            0 &gt; .character-state\n            0.0 &gt; .character-x-velocity)))\n\n;; -------------- Initialize Coin ----------\n(defshards initialize-coin []\n  (LoadTexture \"GlodImages/Coin/Coin_1.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_2.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_3.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_4.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_5.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_6.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_7.png\") &gt;&gt; .coin-image-array\n  (Count .coin-image-array) = .coin-image-index-max\n  0 &gt;= .coin-image-index\n  0.1 = .coin-animation-speed\n\n  ;; ----- Coin 1 ------\n  0.0 &gt;= .coinx-1\n  0.0 &gt;= .coiny-1\n  (float2 .coinx-1 .coiny-1) &gt;= .coin-position-1\n  0.0 &gt;= .coin-velocity-1\n\n  0.5 &gt;= .coin-acceleration)\n\n;; -------------- Coin Animation ------------------\n(defloop coin-animation\n  .coin-image-index (Math.Add 1)\n  &gt; .coin-image-index\n  (When :Predicate (IsMoreEqual .coin-image-index-max)\n        :Action (-&gt; 0 &gt; .coin-image-index))\n\n  (Pause .coin-animation-speed))\n\n;; ------------- Coin Gravity ------------------\n(defshards coin-gravity-logic []\n\n  .coiny-1 (Math.Add .coin-velocity-1)\n  &gt; .coiny-1\n\n  .coin-velocity-1 (Math.Add .coin-acceleration)\n  &gt; .coin-velocity-1\n\n  (float2 .coinx-1 .coiny-1) &gt; .coin-position-1)\n\n;; --------- Game Elements ------------\n(defshards initialize-game-elements []\n  0 &gt;= .score\n  .X (Math.Add 50.0)\n  &gt;= .scoringUpper-x-limit\n  .X (Math.Subtract 50.0)\n  &gt;= .scoringLower-x-limit\n\n  .Y (Math.Add 10.0)\n  &gt;= .scoringUpper-y-limit\n  .Y (Math.Subtract 10.0)\n  &gt;= .scoringLower-y-limit\n\n  false &gt;= .scored)\n\n; ------------- Scoring ------------\n(defshards score-collision []\n  .coinx-1\n  (When :Predicate (-&gt;\n                    (IsLess .scoringUpper-x-limit)\n                    (And)\n                    .coinx-1 (IsMore .scoringLower-x-limit)\n                    (And)\n                    .coiny-1 (IsLess .scoringUpper-y-limit)\n                    (And)\n                    .coiny-1 (IsMore .scoringLower-y-limit)\n                    (And)\n                    .scored (Is false))\n        :Action (-&gt;\n                true &gt; .scored\n                (Log \"Score: \"))))\n\n(defshards scoring []\n  .X (Math.Add 50.0)\n  &gt; .scoringUpper-x-limit\n  .X (Math.Subtract 50.0)\n  &gt; .scoringLower-x-limit\n\n  .Y (Math.Add 10.0)\n  &gt; .scoringUpper-y-limit\n  .Y (Math.Subtract 10.0)\n  &gt; .scoringLower-y-limit\n\n  (score-collision)\n\n  .scored\n  (When :Predicate (Is true)\n        :Action (-&gt;\n                .score (Math.Add 1)\n                &gt; .score\n                false &gt; .scored)))\n\n\n\n;; ------ UI Style --------\n(def style\n  {:override_text_style \"MyStyle\"\n  :text_styles\n  [{:name \"MyStyle\"\n    :size (float 46)\n    :family \"Monospace\"}]\n  :visuals\n  {:override_text_color (color 250 250 250)}})\n\n;;---------- main-wire ------------\n(defloop main-wire\n  (Setup\n  (initialize-character)\n  (initialize-coin)\n  (initialize-game-elements))\n\n  (run-logic)\n  (gravity-logic)\n\n  (Step idle-animation)\n  (Step walking-animation)\n\n  (Step coin-animation)\n  (coin-gravity-logic)\n\n  (scoring)\n\n  (GFX.MainWindow\n  :Title \"MainWindow\" :Width 1920 :Height 1080\n  :Contents\n  (-&gt; (Setup\n        (GFX.DrawQueue) &gt;= .ui-draw-queue\n        (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n      .ui-draw-queue (GFX.ClearQueue)\n\n      (UI\n        .ui-draw-queue\n        (-&gt;\n        (UI.Area :Position .character-position\n                  :Anchor Anchor.Top\n                  :Contents (-&gt;\n                            .character-state\n                            (Match [0 (-&gt; .character-direction\n                                          (Match [0 (-&gt; .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n                                                  1 (-&gt; .idle-right-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))]\n                                                  :Passthrough false))\n                                    1 (-&gt; .walking-left-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n                                    2 (-&gt; .walking-right-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n                                    3 (-&gt;  .character-direction\n                                            (Match [0 (-&gt; .character-jumping-left (UI.Image :Scale (float2 0.2)))\n                                                    1 (-&gt; .character-jumping-right (UI.Image :Scale (float2 0.2)))]\n                                                  :Passthrough false))]\n                                    :Passthrough false)))\n\n        (UI.Area :Position .coin-position-1\n                  :Anchor Anchor.Top\n                  :Contents (-&gt;\n                            .coin-image-array (Take .coin-image-index) (UI.Image :Scale (float2 0.2))))\n\n        (UI.Area :Position (float2 -40 20)\n                  :Anchor Anchor.TopRight\n                  :Contents (-&gt;\n                            style (UI.Style)\n                            .score (ToString) (UI.Label)))))\n\n      (button-inputs)\n\n      (GFX.Render :Steps .render-steps))))\n\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre> <p>Try running your code now and see if you get a point. You did!? Congratulations!</p>"},{"location":"learn/shards/tutorials/glod-game/steps/step-5/#step-56","title":"Step 5.6","text":"<p>Now that we have a scoring system, let's create more coins.</p> <p>Currently, we have only one coin falling down. Let's reuse this coin and have it appear again in another random x position for Glod to run after and collect.</p> <p>Here we are creating a loop that will give our coin a random x value and reset its y value. It will do this every one and a half seconds. This means that our coin will randomly spawn, fall, and then one and a half seconds later, randomly spawn and fall again.</p> Code Added <pre><code>;; ---------- Random Coin ------------\n(defloop random-coin\n  .coinx-1\n  (RandomFloat :Max 1200.0)\n  &gt; .coinx-1\n  (Math.Subtract 600.0)\n  &gt; .coinx-1\n\n  0.0 &gt; .coiny-1\n  0.0 &gt; .coin-velocity-1\n  (float2 .coinx-1 .coiny-1) &gt; .coin-position-1\n  (Pause 1.5))\n</code></pre> <p>Remember to <code>Step</code> into your loop in your main wire.</p> <pre><code>```{.clojure .annotate linenums=\"1\"}\n(Step  random-coin) ;; (1)      \n```\n</code></pre> Full Code So Far <pre><code>(defshards LoadTexture [name]\n  (LoadImage name)\n  (GFX.Texture))\n\n(defshards initialize-character []\n  (LoadTexture \"GlodImages/Character1_Jumping_Left.png\") = .character-jumping-left\n  (LoadTexture \"GlodImages/Character1_Jumping_Right.png\") = .character-jumping-right\n\n  0 &gt;= .character-state\n  0 &gt;= .character-direction\n  true &gt;= .can-jump\n\n  0.0 &gt;= .X\n  620.0 &gt;= .Y\n  (float2 .X .Y) &gt;= .character-position\n  0.0 &gt;= .character-x-velocity\n  0.0 &gt;= .character-y-velocity\n  0.0 &gt;= .character-y-acceleration\n\n  ;; ---------- Character Idle Array (Facing Left) ----------\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png\") &gt;&gt; .idle-left-image-array\n\n  ;; ---------- Character Idle Array (Facing Right) ----------------\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_1.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_2.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_3.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_4.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_5.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_6.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_7.png\") &gt;&gt; .idle-right-image-array\n\n  0 &gt;= .idle-image-index\n  (Count .idle-left-image-array) = .idle-image-index-max\n  0.08 = .idle-animation-speed\n\n  ;; -------------- Walking Array (Facing Left) -----------------\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_1.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_2.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_3.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_4.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_5.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_6.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_7.png\") &gt;&gt; .walking-left-image-array\n\n  ;; ----------- Walking Array (Facing Right) ---------------\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_1.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_2.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_3.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_4.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_5.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_6.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_7.png\") &gt;&gt; .walking-right-image-array\n\n  (Count .walking-left-image-array) = .walking-image-index-max\n  0 &gt;= .walking-image-index\n  0.08 = .walking-animation-speed) ;; Reduce number to increase animation speed\n\n;; --------- Idle Animation Loop ---------\n(defloop idle-animation\n  .idle-image-index (Math.Add 1)\n  &gt; .idle-image-index\n  (When :Predicate (IsMoreEqual .idle-image-index-max)\n        :Action (-&gt; 0 &gt; .idle-image-index))\n  (Pause .idle-animation-speed))\n\n;; -------- Walking Animation Loop --------\n(defloop walking-animation\n  .walking-image-index (Math.Add 1)\n  &gt; .walking-image-index\n  (When :Predicate (IsMoreEqual .walking-image-index-max)\n        :Action (-&gt; 0 &gt; .walking-image-index))\n  (Pause .walking-animation-speed))\n\n;; ---------- character-boundary ------------\n\n(defshards clamp [var min max]\n  var (Max min) (Min max) &gt; var)\n\n;; ------------ Character Run Logic ----------------\n(defshards run-logic []\n  .X (Math.Add .character-x-velocity)\n  &gt; .X\n\n  (float2 .X .Y) &gt; .character-position\n\n  (clamp .X -600.0 600.0))\n\n;; ------------ Character gravity-logic ---------------\n(defshards gravity-logic []\n  .Y (Math.Add .character-y-velocity)\n  &gt; .Y\n\n  .character-y-velocity (Math.Add .character-y-acceleration)\n  &gt; .character-y-velocity\n\n  (float2 .X .Y) &gt; .character-position\n\n  (clamp .Y -620.0 620.0)\n  .Y\n  (When :Predicate (IsMoreEqual 620.0)\n        :Action (-&gt;\n                0.0 &gt; .character-y-velocity\n                0.0 &gt; .character-y-acceleration\n                true &gt; .can-jump\n                .character-state\n                (When :Predicate (Is 3)\n                      :Action (-&gt;\n                                0 &gt; .character-state)))))\n\n;; ------- Button Inputs ----------\n(defshards button-inputs []\n  (Inputs.KeyDown\n  :Key \"left\"\n  :Action (-&gt;\n            (Msg \"left\")\n\n            .character-state\n            (When :Predicate (Is 0)\n                  :Action (-&gt; 1 &gt; .character-state))\n\n            0 &gt; .character-direction\n            -5.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyDown\n  :Key \"right\"\n  :Action (-&gt;\n            (Msg \"right\")\n\n            .character-state\n            (When :Predicate (Is 0)\n                  :Action (-&gt; 2 &gt; .character-state))\n            1 &gt; .character-direction\n            5.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyDown\n  :Key \"up\"\n  :Action (-&gt;\n            (Msg \"up\")\n            3 &gt; .character-state\n            .can-jump\n            (When :Predicate (Is true)\n                  :Action (-&gt;\n                          -20.0 &gt; .character-y-velocity\n                          1.0 &gt;  .character-y-acceleration\n                          false &gt;= .can-jump))))\n\n  (Inputs.KeyUp\n  :Key \"left\"\n  :Action (-&gt;\n            0 &gt; .character-state\n            0.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyUp\n  :Key \"right\"\n  :Action (-&gt;\n            0 &gt; .character-state\n            0.0 &gt; .character-x-velocity)))\n\n;; -------------- Initialize Coin ----------\n(defshards initialize-coin []\n  (LoadTexture \"GlodImages/Coin/Coin_1.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_2.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_3.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_4.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_5.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_6.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_7.png\") &gt;&gt; .coin-image-array\n  (Count .coin-image-array) = .coin-image-index-max\n  0 &gt;= .coin-image-index\n  0.1 = .coin-animation-speed\n\n  ;; ----- Coin 1 ------\n  0.0 &gt;= .coinx-1\n  0.0 &gt;= .coiny-1\n  (float2 .coinx-1 .coiny-1) &gt;= .coin-position-1\n  0.0 &gt;= .coin-velocity-1\n\n  0.5 &gt;= .coin-acceleration)\n\n;; -------------- Coin Animation ------------------\n(defloop coin-animation\n  .coin-image-index (Math.Add 1)\n  &gt; .coin-image-index\n  (When :Predicate (IsMoreEqual .coin-image-index-max)\n        :Action (-&gt; 0 &gt; .coin-image-index))\n\n  (Pause .coin-animation-speed))\n\n;; ------------- Coin Gravity ------------------\n(defshards coin-gravity-logic []\n\n  .coiny-1 (Math.Add .coin-velocity-1)\n  &gt; .coiny-1\n\n  .coin-velocity-1 (Math.Add .coin-acceleration)\n  &gt; .coin-velocity-1\n\n  (float2 .coinx-1 .coiny-1) &gt; .coin-position-1)\n\n;; ------------- Random Coin ------------------\n(defloop random-coin\n  .coinx-1\n  (RandomFloat :Max 1200.0)\n  &gt; .coinx-1\n  (Math.Subtract 600.0)\n  &gt; .coinx-1\n\n  0.0 &gt; .coiny-1\n  0.0 &gt; .coin-velocity-1\n  (float2 .coinx-1 .coiny-1) &gt; .coin-position-1\n  (Pause 1.5))\n\n;; --------- Game Elements ------------\n(defshards initialize-game-elements []\n  0 &gt;= .score\n  .X (Math.Add 50.0)\n  &gt;= .scoringUpper-x-limit\n  .X (Math.Subtract 50.0)\n  &gt;= .scoringLower-x-limit\n\n  .Y (Math.Add 10.0)\n  &gt;= .scoringUpper-y-limit\n  .Y (Math.Subtract 10.0)\n  &gt;= .scoringLower-y-limit\n\n  false &gt;= .scored)\n\n; ------------- Scoring ------------\n(defshards score-collision []\n  .coinx-1\n  (When :Predicate (-&gt;\n                    (IsLess .scoringUpper-x-limit)\n                    (And)\n                    .coinx-1 (IsMore .scoringLower-x-limit)\n                    (And)\n                    .coiny-1 (IsLess .scoringUpper-y-limit)\n                    (And)\n                    .coiny-1 (IsMore .scoringLower-y-limit)\n                    (And)\n                    .scored (Is false))\n        :Action (-&gt;\n                true &gt; .scored\n                (Log \"Score: \"))))\n\n(defshards scoring []\n  .X (Math.Add 50.0)\n  &gt; .scoringUpper-x-limit\n  .X (Math.Subtract 50.0)\n  &gt; .scoringLower-x-limit\n\n  .Y (Math.Add 10.0)\n  &gt; .scoringUpper-y-limit\n  .Y (Math.Subtract 10.0)\n  &gt; .scoringLower-y-limit\n\n  (score-collision)\n\n  .scored\n  (When :Predicate (Is true)\n        :Action (-&gt;\n                .score (Math.Add 1)\n                &gt; .score\n                false &gt; .scored)))\n\n\n\n;; ------ UI Style --------\n(def style\n  {:override_text_style \"MyStyle\"\n  :text_styles\n  [{:name \"MyStyle\"\n    :size (float 46)\n    :family \"Monospace\"}]\n  :visuals\n  {:override_text_color (color 250 250 250)}})\n\n;;---------- main-wire ------------\n(defloop main-wire\n  (Setup\n  (initialize-character)\n  (initialize-coin)\n  (initialize-game-elements))\n\n  (run-logic)\n  (gravity-logic)\n\n  (Step idle-animation)\n  (Step walking-animation)\n\n  (Step coin-animation)\n  (coin-gravity-logic)\n  (Step  random-coin)\n\n  (scoring)\n\n  (GFX.MainWindow\n  :Title \"MainWindow\" :Width 1920 :Height 1080\n  :Contents\n  (-&gt; (Setup\n        (GFX.DrawQueue) &gt;= .ui-draw-queue\n        (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n      .ui-draw-queue (GFX.ClearQueue)\n\n      (UI\n        .ui-draw-queue\n        (-&gt;\n        (UI.Area :Position .character-position\n                  :Anchor Anchor.Top\n                  :Contents (-&gt;\n                            .character-state\n                            (Match [0 (-&gt; .character-direction\n                                          (Match [0 (-&gt; .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n                                                  1 (-&gt; .idle-right-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))]\n                                                  :Passthrough false))\n                                    1 (-&gt; .walking-left-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n                                    2 (-&gt; .walking-right-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n                                    3 (-&gt;  .character-direction\n                                            (Match [0 (-&gt; .character-jumping-left (UI.Image :Scale (float2 0.2)))\n                                                    1 (-&gt; .character-jumping-right (UI.Image :Scale (float2 0.2)))]\n                                                  :Passthrough false))]\n                                    :Passthrough false)))\n\n        (UI.Area :Position .coin-position-1\n                  :Anchor Anchor.Top\n                  :Contents (-&gt;\n                            .coin-image-array (Take .coin-image-index) (UI.Image :Scale (float2 0.2))))\n\n        (UI.Area :Position (float2 -40 20)\n                  :Anchor Anchor.TopRight\n                  :Contents (-&gt;\n                            style (UI.Style)\n                            .score (ToString) (UI.Label)))))\n\n      (button-inputs)\n\n      (GFX.Render :Steps .render-steps))))\n\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre> <p>Try running your code now!</p> <p>Congrats, you have a very basic game. You can try it out and have fun chasing coins! \ud83d\ude01</p>"},{"location":"learn/shards/tutorials/glod-game/steps/step-5/#step-57","title":"Step 5.7","text":"<p>While we have a basic game on our hands now, we can still polish it further. Currently, we only have one coin spawning. Let's have more! To do this, we have to change some of our shards to accept arguments instead of having hard coded variables.</p> <p>Create some new variables for our second coin. These variables are added under <code>initialize-coin</code>.</p> Code Added <pre><code>;; ----- Coin 2 ----\n  0.0 &gt;= .coinx-2\n  0.0 &gt;= .coiny-2\n  (float2 .coinx-2 .coiny-2) &gt;= .coin-position-2\n  0.0 &gt;= .coin-velocity-2)\n</code></pre> <p>Next, create a <code>UI.Area</code> to draw our new coin. You can try running your code at this point to make sure that your coin is being drawn.</p> Code Added <pre><code>(UI.Area :Position .coin-position-2\n                  :Anchor Anchor.Top\n                  :Contents (-&gt;\n                            .coin-image-array (Take .coin-image-index) (UI.Image :Scale (float2 0.2))))\n</code></pre> <p>Now to make it fall...</p> Code Added <pre><code>;; ###### DON'T DO THIS ########\n(defshards coin-gravity-logic []\n\n  .coiny-1 (Math.Add .coin-velocity-1)\n  &gt; .coiny-1\n\n  .coin-velocity-1 (Math.Add .coi-acceleration)\n  &gt; .coin-velocity-1\n\n  (float2 .coinx-1 .coiny-1) &gt; .coin-position-1)\n\n(defshards coin-gravity-logic-2 []\n\n  .coiny-2 (Math.Add .coin-velocity-1)\n  &gt; .coiny-2\n\n  .coin-velocity-2 (Math.Add .coin-acceleration)\n  &gt; .coin-velocity-2\n\n  (float2 .coinx-2 .coiny-2) &gt; .coin-position-2)\n</code></pre> <p>While the above code can work, our code will end up being very messy. Instead, let's have our original <code>coin-gravity-logic</code> shard take in arguments instead.</p> <p>Here we convert our original <code>coin-gravity-logic</code> shard into one that takes arguments. Now that we have this, rather than duplicating this code a million times, we can call it as many times as required and simply pass it the correct variables.</p> Code Added <pre><code>;; ------------- Coin Gravity ------------------\n(defshards coin-gravity-logic [coiny coinx coin-velocity coin-position]\n\n  coiny (Math.Add coin-velocity)\n  &gt; coiny\n\n  coin-velocity (Math.Add .coin-acceleration)\n  &gt; coin-velocity\n\n  (float2 coinx coiny) &gt; coin-position)\n</code></pre> <pre><code>(coin-gravity-logic .coiny-1 .coinx-1 .coin-velocity-1 .coin-position-1)\n(coin-gravity-logic .coiny-2 .coinx-2 .coin-velocity-2 .coin-position-2)\n</code></pre> <p>We'll do the same for our coin randomizing logic.</p> <p>Now you might be wondering how do we get our <code>random-coin</code> logic to accept arguments as it is a <code>defloop</code> and not a <code>defshards</code>.</p> <p>Do not fret!</p> <p>To do this, we simply change our current <code>defloop</code> into a <code>defshards</code> that accepts arguments and create a new <code>defloop</code> that calls this new <code>defshards</code> as shown below.</p> Code Added <pre><code>;; ------------- Random Coin ------------------\n(defshards random-coin [coinx coiny coin-velocity coin-position pause-length]\n  coinx\n  (RandomFloat :Max 1200.0)\n  &gt; coinx\n  (Math.Subtract 600.0)\n  &gt; coinx\n\n  0.0 &gt; coiny\n  0.0 &gt; coin-velocity\n  (float2 coinx coiny) &gt; coin-position\n  (Pause pause-length))\n</code></pre> <pre><code>(defloop random-coin-1\n  (random-coin .coinx-1 .coiny-1 .coin-velocity-1 .coin-position-1 1.5))\n\n(defloop random-coin-2\n  (random-coin .coinx-2 .coiny-2 .coin-velocity-2 .coin-position-2 2.5))\n</code></pre> <pre><code>(Step random-coin-1)\n(Step random-coin-2)\n</code></pre> <p>Now, last but not least, we will convert our scoring logic into a <code>defshards</code> that accepts arguments.</p> Code AddedFull Code So Far <pre><code>;; --------- Scoring ----------\n(defshards score-collision [coinx coiny]\n  coinx\n  (When :Predicate (-&gt;\n                    (IsLess .scoringUpper-x-limit)\n                    (And)\n                    coinx (IsMore .scoringLower-x-limit)\n                    (And)\n                    coiny (IsLess .scoringUpper-y-limit)\n                    (And)\n                    coiny (IsMore .scoringLower-y-limit)\n                    (And)\n                    .scored (Is false))\n        :Action (-&gt;\n                true &gt; .scored\n                (Log \"Score: \"))))\n\n(defshards scoring []\n  .X (Math.Add 50.0)\n  &gt; .scoringUpper-x-limit\n  .X (Math.Subtract 50.0)\n  &gt; .scoringLower-x-limit\n\n  .Y (Math.Add 10.0)\n  &gt; .scoringUpper-y-limit\n  .Y (Math.Subtract 10.0)\n  &gt; .scoringLower-y-limit\n\n  (score-collision .coinx-1 .coiny-1)\n  (score-collision .coinx-2 .coiny-2)\n\n  .scored\n  (When :Predicate (Is true)\n        :Action (-&gt;\n                .score (Math.Add 1)\n                &gt; .score\n                false &gt; .scored)))\n</code></pre> <pre><code>(defshards LoadTexture [name]\n  (LoadImage name)\n  (GFX.Texture))\n\n(defshards initialize-character []\n  (LoadTexture \"GlodImages/Character1_Jumping_Left.png\") = .character-jumping-left\n  (LoadTexture \"GlodImages/Character1_Jumping_Right.png\") = .character-jumping-right\n\n  0 &gt;= .character-state\n  0 &gt;= .character-direction\n  true &gt;= .can-jump\n\n  0.0 &gt;= .X\n  620.0 &gt;= .Y\n  (float2 .X .Y) &gt;= .character-position\n  0.0 &gt;= .character-x-velocity\n  0.0 &gt;= .character-y-velocity\n  0.0 &gt;= .character-y-acceleration\n\n  ;; ---------- Character Idle Array (Facing Left) ----------\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png\") &gt;&gt; .idle-left-image-array\n\n  ;; ---------- Character Idle Array (Facing Right) ----------------\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_1.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_2.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_3.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_4.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_5.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_6.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_7.png\") &gt;&gt; .idle-right-image-array\n\n  0 &gt;= .idle-image-index\n  (Count .idle-left-image-array) = .idle-image-index-max\n  0.08 = .idle-animation-speed\n\n  ;; -------------- Walking Array (Facing Left) -----------------\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_1.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_2.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_3.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_4.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_5.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_6.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_7.png\") &gt;&gt; .walking-left-image-array\n\n  ;; ----------- Walking Array (Facing Right) ---------------\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_1.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_2.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_3.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_4.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_5.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_6.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_7.png\") &gt;&gt; .walking-right-image-array\n\n  (Count .walking-left-image-array) = .walking-image-index-max\n  0 &gt;= .walking-image-index\n  0.08 = .walking-animation-speed) ;; Reduce number to increase animation speed\n\n;; --------- Idle Animation Loop ---------\n(defloop idle-animation\n  .idle-image-index (Math.Add 1)\n  &gt; .idle-image-index\n  (When :Predicate (IsMoreEqual .idle-image-index-max)\n        :Action (-&gt; 0 &gt; .idle-image-index))\n  (Pause .idle-animation-speed))\n\n;; -------- Walking Animation Loop --------\n(defloop walking-animation\n  .walking-image-index (Math.Add 1)\n  &gt; .walking-image-index\n  (When :Predicate (IsMoreEqual .walking-image-index-max)\n        :Action (-&gt; 0 &gt; .walking-image-index))\n  (Pause .walking-animation-speed))\n\n;; ---------- character-boundary ------------\n\n(defshards clamp [var min max]\n  var (Max min) (Min max) &gt; var)\n\n;; ------------ Character Run Logic ----------------\n(defshards run-logic []\n  .X (Math.Add .character-x-velocity)\n  &gt; .X\n\n  (float2 .X .Y) &gt; .character-position\n\n  (clamp .X -600.0 600.0))\n\n;; ------------ Character gravity-logic ---------------\n(defshards gravity-logic []\n  .Y (Math.Add .character-y-velocity)\n  &gt; .Y\n\n  .character-y-velocity (Math.Add .character-y-acceleration)\n  &gt; .character-y-velocity\n\n  (float2 .X .Y) &gt; .character-position\n\n  (clamp .Y -620.0 620.0)\n  .Y\n  (When :Predicate (IsMoreEqual 620.0)\n        :Action (-&gt;\n                0.0 &gt; .character-y-velocity\n                0.0 &gt; .character-y-acceleration\n                true &gt; .can-jump\n                .character-state\n                (When :Predicate (Is 3)\n                      :Action (-&gt;\n                                0 &gt; .character-state)))))\n\n;; ------- Button Inputs ----------\n(defshards button-inputs []\n  (Inputs.KeyDown\n  :Key \"left\"\n  :Action (-&gt;\n            (Msg \"left\")\n\n            .character-state\n            (When :Predicate (Is 0)\n                  :Action (-&gt; 1 &gt; .character-state))\n\n            0 &gt; .character-direction\n            -5.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyDown\n  :Key \"right\"\n  :Action (-&gt;\n            (Msg \"right\")\n\n            .character-state\n            (When :Predicate (Is 0)\n                  :Action (-&gt; 2 &gt; .character-state))\n            1 &gt; .character-direction\n            5.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyDown\n  :Key \"up\"\n  :Action (-&gt;\n            (Msg \"up\")\n            3 &gt; .character-state\n            .can-jump\n            (When :Predicate (Is true)\n                  :Action (-&gt;\n                          -20.0 &gt; .character-y-velocity\n                          1.0 &gt;  .character-y-acceleration\n                          false &gt;= .can-jump))))\n\n  (Inputs.KeyUp\n  :Key \"left\"\n  :Action (-&gt;\n            0 &gt; .character-state\n            0.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyUp\n  :Key \"right\"\n  :Action (-&gt;\n            0 &gt; .character-state\n            0.0 &gt; .character-x-velocity)))\n\n;; -------------- Initialize Coin ----------\n(defshards initialize-coin []\n  (LoadTexture \"GlodImages/Coin/Coin_1.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_2.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_3.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_4.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_5.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_6.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_7.png\") &gt;&gt; .coin-image-array\n  (Count .coin-image-array) = .coin-image-index-max\n  0 &gt;= .coin-image-index\n  0.1 = .coin-animation-speed\n\n  ;; ----- Coin 1 ------\n  0.0 &gt;= .coinx-1\n  0.0 &gt;= .coiny-1\n  (float2 .coinx-1 .coiny-1) &gt;= .coin-position-1\n  0.0 &gt;= .coin-velocity-1\n  0.5 &gt;= .coin-acceleration\n\n  ;; ----- Coin 2 ----\n  0.0 &gt;= .coinx-2\n  0.0 &gt;= .coiny-2\n  (float2 .coinx-2 .coiny-2) &gt;= .coin-position-2\n  0.0 &gt;= .coin-velocity-2)\n\n;; -------------- Coin Animation ------------------\n(defloop coin-animation\n  .coin-image-index (Math.Add 1)\n  &gt; .coin-image-index\n  (When :Predicate (IsMoreEqual .coin-image-index-max)\n        :Action (-&gt; 0 &gt; .coin-image-index))\n\n  (Pause .coin-animation-speed))\n\n;; ------------- Coin Gravity ------------------\n(defshards coin-gravity-logic [coiny coinx coin-velocity coin-position]\n\n  coiny (Math.Add coin-velocity)\n  &gt; coiny\n\n  coin-velocity (Math.Add .coin-acceleration)\n  &gt; coin-velocity\n\n  (float2 coinx coiny) &gt; coin-position)\n\n;; ------------- Random Coin ------------------\n(defshards random-coin [coinx coiny coin-velocity coin-position pause-length]\n  coinx\n  (RandomFloat :Max 1200.0)\n  &gt; coinx\n  (Math.Subtract 600.0)\n  &gt; coinx\n\n  0.0 &gt; coiny\n  0.0 &gt; coin-velocity\n  (float2 coinx coiny) &gt; coin-position\n  (Pause pause-length))\n\n(defloop random-coin-1\n  (random-coin .coinx-1 .coiny-1 .coin-velocity-1 .coin-position-1 1.5))\n\n(defloop random-coin-2\n  (random-coin .coinx-2 .coiny-2 .coin-velocity-2 .coin-position-2 2.5))\n\n;; --------- Game Elements ------------\n(defshards initialize-game-elements []\n  0 &gt;= .score\n  false &gt;= .scored\n\n  .X (Math.Add 50.0)\n  &gt;= .scoringUpper-x-limit\n  .X (Math.Subtract 50.0)\n  &gt;= .scoringLower-x-limit\n\n  .Y (Math.Add 10.0)\n  &gt;= .scoringUpper-y-limit\n  .Y (Math.Subtract 10.0)\n  &gt;= .scoringLower-y-limit)\n\n;; --------- Scoring ----------\n(defshards score-collision [coinx coiny]\n  coinx\n  (When :Predicate (-&gt;\n                    (IsLess .scoringUpper-x-limit)\n                    (And)\n                    coinx (IsMore .scoringLower-x-limit)\n                    (And)\n                    coiny (IsLess .scoringUpper-y-limit)\n                    (And)\n                    coiny (IsMore .scoringLower-y-limit)\n                    (And)\n                    .scored (Is false))\n        :Action (-&gt;\n                true &gt; .scored\n                (Log \"Score: \"))))\n\n(defshards scoring []\n  .X (Math.Add 50.0)\n  &gt; .scoringUpper-x-limit\n  .X (Math.Subtract 50.0)\n  &gt; .scoringLower-x-limit\n\n  .Y (Math.Add 10.0)\n  &gt; .scoringUpper-y-limit\n  .Y (Math.Subtract 10.0)\n  &gt; .scoringLower-y-limit\n\n  (score-collision .coinx-1 .coiny-1)\n  (score-collision .coinx-2 .coiny-2)\n\n  .scored\n  (When :Predicate (Is true)\n        :Action (-&gt;\n                .score (Math.Add 1)\n                &gt; .score\n                false &gt; .scored)))\n\n;; ------ UI Style --------\n(def style\n  {:override_text_style \"MyStyle\"\n  :text_styles\n  [{:name \"MyStyle\"\n    :size (float 46)\n    :family \"Monospace\"}]\n  :visuals\n  {:override_text_color (color 250 250 250)}})\n\n;;---------- main-wire ------------\n(defloop main-wire\n  (Setup\n  (initialize-character)\n  (initialize-coin)\n  (initialize-game-elements))\n\n  (coin-gravity-logic .coiny-1 .coinx-1 .coin-velocity-1 .coin-position-1)\n  (coin-gravity-logic .coiny-2 .coinx-2 .coin-velocity-2 .coin-position-2)\n\n  (run-logic)\n  (gravity-logic)\n  (scoring)\n\n  (Step idle-animation)\n  (Step walking-animation)\n  (Step coin-animation)\n\n  (Step random-coin-1)\n  (Step random-coin-2)\n\n  (GFX.MainWindow\n  :Title \"MainWindow\" :Width 1920 :Height 1080\n  :Contents\n  (-&gt; (Setup\n        (GFX.DrawQueue) &gt;= .ui-draw-queue\n        (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n      .ui-draw-queue (GFX.ClearQueue)\n\n      (UI\n        .ui-draw-queue\n        (-&gt;\n        (UI.Area :Position .character-position\n                  :Anchor Anchor.Top\n                  :Contents (-&gt;\n                            .character-state\n                            (Match [0 (-&gt; .character-direction\n                                          (Match [0 (-&gt; .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n                                                  1 (-&gt; .idle-right-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))]\n                                                  :Passthrough false))\n                                    1 (-&gt; .walking-left-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n                                    2 (-&gt; .walking-right-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n                                    3 (-&gt;  .character-direction\n                                            (Match [0 (-&gt; .character-jumping-left (UI.Image :Scale (float2 0.2)))\n                                                    1 (-&gt; .character-jumping-right (UI.Image :Scale (float2 0.2)))]\n                                                  :Passthrough false))]\n                                    :Passthrough false)))\n\n        (UI.Area :Position .coin-position-1\n                  :Anchor Anchor.Top\n                  :Contents (-&gt;\n                            .coin-image-array (Take .coin-image-index) (UI.Image :Scale (float2 0.2))))\n\n        (UI.Area :Position .coin-position-2\n                  :Anchor Anchor.Top\n                  :Contents (-&gt;\n                            .coin-image-array (Take .coin-image-index) (UI.Image :Scale (float2 0.2))))\n\n        (UI.Area :Position (float2 -40 20)\n                  :Anchor Anchor.TopRight\n                  :Contents (-&gt;\n                            style (UI.Style)\n                            .score (ToString) (UI.Label)))))\n\n      (button-inputs)\n\n      (GFX.Render :Steps .render-steps))))\n\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre> <p>Now with all the pieces in place, we can add as many coins as we want.</p> <p>In this tutorial we will stick to just four coins, but you can create as many as you want! </p> <p>Just remember to follow the same process and flow as the above to make sure that you don't miss out something.</p> <p>In summary:</p> <ol> <li> <p>Create the necessary variables for your new coins.</p> </li> <li> <p>Create a new <code>UI.Area</code> for each of your new coins.</p> </li> <li> <p>Make sure your new coins fall by adding new <code>coin-gravity-logic</code>.</p> </li> <li> <p>Make sure your coins loop and randomize by adding a new <code>random-coin-loop</code>.</p> </li> <li> <p>Make sure you can earn points from them by adding a new <code>score-collision</code>.</p> </li> </ol>"},{"location":"learn/shards/tutorials/glod-game/steps/step-5/#recap","title":"Recap","text":"<p>Phew that was a really long step!</p> <p>Good job for making it through. \ud83d\ude01\ud83c\udf89</p> <p>To recap:</p> <ul> <li> <p>We made a coin fall by using the same logic to make our character move.</p> </li> <li> <p>We created a scoring system by making a collision system.</p> </li> <li> <p>We set up a system to create as many coins as we want by making our <code>defshards</code> accept arguments.</p> </li> </ul> <p>Phew! That was a mouthful but worth it!</p> <p>In the next chapter, we will use the same logic to create falling hazards for Glod!</p> <p>See you! \ud83d\udc4b\ud83c\udffc\ud83d\ude00</p>"},{"location":"learn/shards/tutorials/glod-game/steps/step-6/","title":"Step 6","text":""},{"location":"learn/shards/tutorials/glod-game/steps/step-6/#making-the-game-harder-overview","title":"Making the Game Harder - Overview","text":"<p>We are almost towards the end of the tutorial. Wahoo!</p> <p>In the previous chapter, we learnt how to make coins for Glod to collect.</p> <p>In this chapter, we will do the opposite. We will make the game more challenging by creating hazards for Glod to avoid!</p> <p>Poor Glod. \ud83d\ude22</p> <p>To do this we will be:</p> <ol> <li> <p>Drawing a spiked cannonball image on screen.</p> </li> <li> <p>Having it move using variables.</p> </li> <li> <p>Creating a spawning system to randomly spawn a spiked cannonball on screen.</p> </li> <li> <p>Creating a collision system to allow Glod to be hit.</p> </li> <li> <p>Reusing code to create more Spiked Cannonballs by making shards accept arguments.</p> </li> </ol> <p>If you are wondering why the list above seems familiar, it is because the exact same logic and methods were used in the previous chapter.</p> <p>Let's get to it. \ud83d\udd25</p>"},{"location":"learn/shards/tutorials/glod-game/steps/step-6/#step-61","title":"Step 6.1","text":"<p>We start off nice and easy by downloading the required images and displaying one of them on the screen.</p> <ol> <li>Download spiked cannonball images here.</li> </ol> <p>Load one image first. To keep our code organized, create a new <code>initialize-spiked-cannonballs</code> shard.</p> Code Added <pre><code>;; ------------ Initialize Spiked CanonBalls ---------------\n(defshards initialize-spiked-canonballs []\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall1.png\") = .spikeball-1)\n</code></pre> <p>Remember to call your new shard in <code>main-wire</code>.</p> Code Added <pre><code>(initialize-spiked-canonballs) ;; (1)\n</code></pre> <p>To draw our loaded image, create a <code>UI.Area</code>.</p> Code AddedFull Code So Far <pre><code>(UI.Area :Position (float2 0 0)\n:Anchor Anchor.Top\n:Contents (-&gt;\n.spikeball-1 (UI.Image :Scale (float2 0.15))))\n</code></pre> <pre><code>(defshards LoadTexture [name]\n  (LoadImage name)\n  (GFX.Texture))\n\n(defshards initialize-character []\n  (LoadTexture \"GlodImages/Character1_Jumping_Left.png\") = .character-jumping-left\n  (LoadTexture \"GlodImages/Character1_Jumping_Right.png\") = .character-jumping-right\n\n  0 &gt;= .character-state\n  0 &gt;= .character-direction\n  true &gt;= .can-jump\n\n  0.0 &gt;= .X\n  620.0 &gt;= .Y\n  (float2 .X .Y) &gt;= .character-position\n  0.0 &gt;= .character-x-velocity\n  0.0 &gt;= .character-y-velocity\n  0.0 &gt;= .character-y-acceleration\n\n  ;; ---------- Character Idle Array (Facing Left) ----------\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png\") &gt;&gt; .idle-left-image-array\n\n  ;; ---------- Character Idle Array (Facing Right) ----------------\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_1.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_2.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture\"GlodImages/Character_Idle/Idle_Right/Character1_Idle_3.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_4.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_5.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_6.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_7.png\") &gt;&gt; .idle-right-image-array\n\n  0 &gt;= .idle-image-index\n  (Count .idle-left-image-array) = .idle-image-index-max\n  0.08 = .idle-animation-speed\n\n  ;; -------------- Walking Array (Facing Left) -----------------\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_1.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_2.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_3.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_4.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_5.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_6.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_7.png\") &gt;&gt; .walking-left-image-array\n\n  ;; ----------- Walking Array (Facing Right) ---------------\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_1.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_2.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_3.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_4.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_5.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_6.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_7.png\") &gt;&gt; .walking-right-image-array\n\n  (Count .walking-left-image-array) = .walking-image-index-max\n  0 &gt;= .walking-image-index\n  0.08 = .walking-animation-speed) ;; Reduce number to increase animation speed\n\n;; --------- Idle Animation Loop ---------\n(defloop idle-animation\n  .idle-image-index (Math.Add 1)\n  &gt; .idle-image-index\n  (When :Predicate (IsMoreEqual .idle-image-index-max)\n        :Action (-&gt; 0 &gt; .idle-image-index))\n  (Pause .idle-animation-speed))\n\n;; -------- Walking Animation Loop --------\n(defloop walking-animation\n  .walking-image-index (Math.Add 1)\n  &gt; .walking-image-index\n  (When :Predicate (IsMoreEqual .walking-image-index-max)\n        :Action (-&gt; 0 &gt; .walking-image-index))\n  (Pause .walking-animation-speed))\n\n;; ---------- character-boundary ------------\n\n(defshards clamp [var min max]\n  var (Max min) (Min max) &gt; var)\n\n;; ------------ Character Run Logic ----------------\n(defshards run-logic []\n  .X (Math.Add .character-x-velocity)\n  &gt; .X\n\n  (float2 .X .Y) &gt; .character-position\n\n  (clamp .X -600.0 600.0))\n\n;; ------------ Character gravity-logic ---------------\n(defshards gravity-logic []\n  .Y (Math.Add .character-y-velocity)\n  &gt; .Y\n\n  .character-y-velocity (Math.Add .character-y-acceleration)\n  &gt; .character-y-velocity\n\n  (float2 .X .Y) &gt; .character-position\n\n  (clamp .Y -620.0 620.0)\n  .Y\n  (When :Predicate (IsMoreEqual 620.0)\n        :Action (-&gt;\n                0.0 &gt; .character-y-velocity\n                0.0 &gt; .character-y-acceleration\n                true &gt; .can-jump\n                .character-state\n                (When :Predicate (Is 3)\n                      :Action (-&gt;\n                                0 &gt; .character-state)))))\n\n;; ------- Button Inputs ----------\n(defshards button-inputs []\n  (Inputs.KeyDown\n  :Key \"left\"\n  :Action (-&gt;\n            (Msg \"left\")\n\n            .character-state\n            (When :Predicate (Is 0)\n                  :Action (-&gt; 1 &gt; .character-state))\n\n            0 &gt; .character-direction\n            -5.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyDown\n  :Key \"right\"\n  :Action (-&gt;\n            (Msg \"right\")\n\n            .character-state\n            (When :Predicate (Is 0)\n                  :Action (-&gt; 2 &gt; .character-state))\n            1 &gt; .character-direction\n            5.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyDown\n  :Key \"up\"\n  :Action (-&gt;\n            (Msg \"up\")\n            3 &gt; .character-state\n            .can-jump\n            (When :Predicate (Is true)\n                  :Action (-&gt;\n                          -20.0 &gt; .character-y-velocity\n                          1.0 &gt;  .character-y-acceleration\n                          false &gt;= .can-jump))))\n\n  (Inputs.KeyUp\n  :Key \"left\"\n  :Action (-&gt;\n            0 &gt; .character-state\n            0.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyUp\n  :Key \"right\"\n  :Action (-&gt;\n            0 &gt; .character-state\n            0.0 &gt; .character-x-velocity)))\n\n;; -------------- Initialize Coin ----------\n(defshards initialize-coin []\n  (LoadTexture \"GlodImages/Coin/Coin_1.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_2.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_3.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_4.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_5.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_6.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_7.png\") &gt;&gt; .coin-image-array\n  (Count .coin-image-array) = .coin-image-index-max\n  0 &gt;= .coin-image-index\n  0.1 = .coin-animation-speed\n\n  ;; ----- Coin 1 ------\n  0.0 &gt;= .coinx-1\n  0.0 &gt;= .coiny-1\n  (float2 .coinx-1 .coiny-1) &gt;= .coin-position-1\n  0.0 &gt;= .coin-velocity-1\n  0.5 &gt;= .coin-acceleration\n\n  ;; ----- Coin 2 ----\n  0.0 &gt;= .coinx-2\n  0.0 &gt;= .coiny-2\n  (float2 .coinx-2 .coiny-2) &gt;= .coin-position-2\n  0.0 &gt;= .coin-velocity-2)\n\n;; -------------- Coin Animation ------------------\n(defloop coin-animation\n  .coin-image-index (Math.Add 1)\n  &gt; .coin-image-index\n  (When :Predicate (IsMoreEqual .coin-image-index-max)\n        :Action (-&gt; 0 &gt; .coin-image-index))\n\n  (Pause .coin-animation-speed))\n\n;; ------------- Coin Gravity ------------------\n(defshards coin-gravity-logic [coiny coinx coin-velocity coin-position]\n\n  coiny (Math.Add coin-velocity)\n  &gt; coiny\n\n  coin-velocity (Math.Add .coin-acceleration)\n  &gt; coin-velocity\n\n  (float2 coinx coiny) &gt; coin-position)\n\n;; ------------- Random Coin ------------------\n(defshards random-coin [coinx coiny coin-velocity coin-position pause-length]\n  coinx\n  (RandomFloat :Max 1200.0)\n  &gt; coinx\n  (Math.Subtract 600.0)\n  &gt; coinx\n\n  0.0 &gt; coiny\n  0.0 &gt; coin-velocity\n  (float2 coinx coiny) &gt; coin-position\n  (Pause pause-length))\n\n(defloop random-coin-1\n  (random-coin .coinx-1 .coiny-1 .coin-velocity-1 .coin-position-1 1.5))\n\n(defloop random-coin-2\n  (random-coin .coinx-2 .coiny-2 .coin-velocity-2 .coin-position-2 2.5))\n\n;; ------------ Initialize Spiked CanonBalls ---------------\n(defshards initialize-spiked-canonballs []\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall1.png\") = .spikeball-1)\n\n\n;; --------- Game Elements ------------\n(defshards initialize-game-elements []\n  0 &gt;= .score\n  false &gt;= .scored\n\n  .X (Math.Add 50.0)\n  &gt;= .scoringUpper-x-limit\n  .X (Math.Subtract 50.0)\n  &gt;= .scoringLower-x-limit\n\n  .Y (Math.Add 10.0)\n  &gt;= .scoringUpper-y-limit\n  .Y (Math.Subtract 10.0)\n  &gt;= .scoringLower-y-limit)\n\n;; --------- Scoring ----------\n(defshards score-collision [coinx coiny]\n  coinx\n  (When :Predicate (-&gt;\n                    (IsLess .scoringUpper-x-limit)\n                    (And)\n                    coinx (IsMore .scoringLower-x-limit)\n                    (And)\n                    coiny (IsLess .scoringUpper-y-limit)\n                    (And)\n                    coiny (IsMore .scoringLower-y-limit)\n                    (And)\n                    .scored (Is false))\n        :Action (-&gt;\n                true &gt; .scored\n                (Log \"Score: \"))))\n\n(defshards scoring []\n  .X (Math.Add 50.0)\n  &gt; .scoringUpper-x-limit\n  .X (Math.Subtract 50.0)\n  &gt; .scoringLower-x-limit\n\n  .Y (Math.Add 10.0)\n  &gt; .scoringUpper-y-limit\n  .Y (Math.Subtract 10.0)\n  &gt; .scoringLower-y-limit\n\n  (score-collision .coinx-1 .coiny-1)\n  (score-collision .coinx-2 .coiny-2)\n\n  .scored\n  (When :Predicate (Is true)\n        :Action (-&gt;\n                .score (Math.Add 1)\n                &gt; .score\n                false &gt; .scored)))\n\n\n\n;; ------ UI Style --------\n(def style\n  {:override_text_style \"MyStyle\"\n  :text_styles\n  [{:name \"MyStyle\"\n    :size (float 46)\n    :family \"Monospace\"}]\n  :visuals\n  {:override_text_color (color 250 250 250)}})\n\n;;---------- main-wire ------------\n(defloop main-wire\n  (Setup\n  (initialize-character)\n  (initialize-coin)\n  (initialize-game-elements)\n  (initialize-spiked-canonballs))\n\n  (coin-gravity-logic .coiny-1 .coinx-1 .coin-velocity-1 .coin-position-1)\n  (coin-gravity-logic .coiny-2 .coinx-2 .coin-velocity-2 .coin-position-2)\n\n  (run-logic)\n  (gravity-logic)\n  (scoring)\n\n  (Step idle-animation)\n  (Step walking-animation)\n  (Step coin-animation)\n\n  (Step random-coin-1)\n  (Step random-coin-2)\n\n  (GFX.MainWindow\n  :Title \"MainWindow\" :Width 1920 :Height 1080\n  :Contents\n  (-&gt; (Setup\n        (GFX.DrawQueue) &gt;= .ui-draw-queue\n        (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n      .ui-draw-queue (GFX.ClearQueue)\n\n      (UI\n        .ui-draw-queue\n        (-&gt;\n        (UI.Area :Position .character-position\n                  :Anchor Anchor.Top\n                  :Contents (-&gt;\n                            .character-state\n                            (Match [0 (-&gt; .character-direction\n                                          (Match [0 (-&gt; .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n                                                  1 (-&gt; .idle-right-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))]\n                                                  :Passthrough false))\n                                    1 (-&gt; .walking-left-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n                                    2 (-&gt; .walking-right-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n                                    3 (-&gt;  .character-direction\n                                            (Match [0 (-&gt; .character-jumping-left (UI.Image :Scale (float2 0.2)))\n                                                    1 (-&gt; .character-jumping-right (UI.Image :Scale (float2 0.2)))]\n                                                  :Passthrough false))]\n                                    :Passthrough false)))\n\n        (UI.Area :Position .coin-position-1\n                  :Anchor Anchor.Top\n                  :Contents (-&gt;\n                            .coin-image-array (Take .coin-image-index) (UI.Image :Scale (float2 0.2))))\n\n        (UI.Area :Position .coin-position-2\n                  :Anchor Anchor.Top\n                  :Contents (-&gt;\n                            .coin-image-array (Take .coin-image-index) (UI.Image :Scale (float2 0.2))))\n\n        (UI.Area :Position (float2 0 0)\n                  :Anchor Anchor.Top\n                  :Contents (-&gt;\n                            .spikeball-1 (UI.Image :Scale (float2 0.15))))\n\n        (UI.Area :Position (float2 -40 20)\n                  :Anchor Anchor.TopRight\n                  :Contents (-&gt;\n                            style (UI.Style)\n                            .score (ToString) (UI.Label)))))\n\n      (button-inputs)\n\n      (GFX.Render :Steps .render-steps))))\n\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre>"},{"location":"learn/shards/tutorials/glod-game/steps/step-6/#step-62","title":"Step 6.2","text":"<p>Similar to what we did with our coin, it's time to animate our spiked cannonball.</p> <p>Follow these steps to create an animation once more:</p> <ol> <li> <p>Create an <code>Image</code> array.</p> </li> <li> <p>Create the necessary variables - an index, max index, and animation speed variable.</p> </li> </ol> Code Added <pre><code>;; ------------ Initialize Spiked CanonBalls ---------------\n(defshards initialize-spiked-canonballs []\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall1.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall2.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall3.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall4.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall5.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall6.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall7.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall8.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall9.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall10.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall11.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall12.png\") &gt;&gt; .spikeball-array\n\n  (Count .spikeball-array) (Math.Subtract 1) &gt;= .spikeball-array-index-max\n  0 &gt;= .spikeball-index\n  0.06 &gt;= .spikeball-animation-speed\n</code></pre> <p>Create an animation loop that uses the variables we created. This loop should add one to our index every iteration. It should also have a conditional statement that ensures that our index does not go above the <code>index-max</code>.</p> <p>Lastly, the loop should loop every x seconds, with x being the animation speed.</p> <pre><code>```{.clojure .annotate linenums=\"1\"}\n;;------------- Spiked CanonBall Animation -------------\n(defloop spiked-canonball-animation\n  .spikeball-index (Math.Add 1)\n  &gt; .spikeball-index\n  (When :Predicate (IsMore .spikeball-array-index-max)\n        :Action (-&gt; 0 &gt; .spikeball-index))\n\n  (Pause .spikeball-animation-speed))\n```\n</code></pre> <p>As with all loops, remember to <code>Step</code> it in <code>main-wire</code>.</p> <pre><code>```{.clojure .annotate linenums=\"1\"}\n(Step spiked-canonball-animation) ;; (1)\n\n```\n</code></pre> <p>Remember to update our spiked cannonball's <code>UI.Area</code> to display the correct image in the image array, as specified by <code>.spikeball-index</code>.</p> <pre><code>```{.clojure .annotate linenums=\"1\"}\n;; ------------ Character Run Logic ----------------\n;; -------- Spiked CanonBall UI.Area ----------\n(UI.Area :Position (float2 0 0)\n                  :Anchor Anchor.Top\n                  :Contents (-&gt;\n                            .spikeball-array (Take .spikeball-index) (UI.Image :Scale (float2 0.15))))\n```\n</code></pre> Full Code So Far <pre><code>(defshards LoadTexture [name]\n  (LoadImage name)\n  (GFX.Texture))\n\n(defshards initialize-character []\n  (LoadTexture \"GlodImages/Character1_Jumping_Left.png\") = .character-jumping-left\n  (LoadTexture \"GlodImages/Character1_Jumping_Right.png\") = .character-jumping-right\n\n  0 &gt;= .character-state\n  0 &gt;= .character-direction\n  true &gt;= .can-jump\n\n  0.0 &gt;= .X\n  620.0 &gt;= .Y\n  (float2 .X .Y) &gt;= .character-position\n  0.0 &gt;= .character-x-velocity\n  0.0 &gt;= .character-y-velocity\n  0.0 &gt;= .character-y-acceleration\n\n  ;; ---------- Character Idle Array (Facing Left) ----------\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png\") &gt;&gt; .idle-left-image-array\n\n  ;; ---------- Character Idle Array (Facing Right) ----------------\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_1.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_2.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_3.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_4.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_5.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_6.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_7.png\") &gt;&gt; .idle-right-image-array\n\n  0 &gt;= .idle-image-index\n  (Count .idle-left-image-array) = .idle-image-index-max\n  0.08 = .idle-animation-speed\n\n  ;; -------------- Walking Array (Facing Left) -----------------\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_1.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_2.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_3.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_4.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_5.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_6.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_7.png\") &gt;&gt; .walking-left-image-array\n\n  ;; ----------- Walking Array (Facing Right) ---------------\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_1.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_2.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_3.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_4.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_5.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_6.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_7.png\") &gt;&gt; .walking-right-image-array\n\n  (Count .walking-left-image-array) = .walking-image-index-max\n  0 &gt;= .walking-image-index\n  0.08 = .walking-animation-speed) ;; Reduce number to increase animation speed\n\n;; --------- Idle Animation Loop ---------\n(defloop idle-animation\n  .idle-image-index (Math.Add 1)\n  &gt; .idle-image-index\n  (When :Predicate (IsMoreEqual .idle-image-index-max)\n        :Action (-&gt; 0 &gt; .idle-image-index))\n  (Pause .idle-animation-speed))\n\n;; -------- Walking Animation Loop --------\n(defloop walking-animation\n  .walking-image-index (Math.Add 1)\n  &gt; .walking-image-index\n  (When :Predicate (IsMoreEqual .walking-image-index-max)\n        :Action (-&gt; 0 &gt; .walking-image-index))\n  (Pause .walking-animation-speed))\n\n;; ---------- character-boundary ------------\n\n(defshards clamp [var min max]\n  var (Max min) (Min max) &gt; var)\n\n;; ------------ Character Run Logic ----------------\n(defshards run-logic []\n  .X (Math.Add .character-x-velocity)\n  &gt; .X\n\n  (float2 .X .Y) &gt; .character-position\n\n  (clamp .X -600.0 600.0))\n\n;; ------------ Character gravity-logic ---------------\n(defshards gravity-logic []\n  .Y (Math.Add .character-y-velocity)\n  &gt; .Y\n\n  .character-y-velocity (Math.Add .character-y-acceleration)\n  &gt; .character-y-velocity\n\n  (float2 .X .Y) &gt; .character-position\n\n  (clamp .Y -620.0 620.0)\n  .Y\n  (When :Predicate (IsMoreEqual 620.0)\n        :Action (-&gt;\n                0.0 &gt; .character-y-velocity\n                0.0 &gt; .character-y-acceleration\n                true &gt; .can-jump\n                .character-state\n                (When :Predicate (Is 3)\n                      :Action (-&gt;\n                                0 &gt; .character-state)))))\n\n;; ------- Button Inputs ----------\n(defshards button-inputs []\n  (Inputs.KeyDown\n  :Key \"left\"\n  :Action (-&gt;\n            (Msg \"left\")\n\n            .character-state\n            (When :Predicate (Is 0)\n                  :Action (-&gt; 1 &gt; .character-state))\n\n            0 &gt; .character-direction\n            -5.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyDown\n  :Key \"right\"\n  :Action (-&gt;\n            (Msg \"right\")\n\n            .character-state\n            (When :Predicate (Is 0)\n                  :Action (-&gt; 2 &gt; .character-state))\n            1 &gt; .character-direction\n            5.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyDown\n  :Key \"up\"\n  :Action (-&gt;\n            (Msg \"up\")\n            3 &gt; .character-state\n            .can-jump\n            (When :Predicate (Is true)\n                  :Action (-&gt;\n                          -20.0 &gt; .character-y-velocity\n                          1.0 &gt;  .character-y-acceleration\n                          false &gt;= .can-jump))))\n\n  (Inputs.KeyUp\n  :Key \"left\"\n  :Action (-&gt;\n            0 &gt; .character-state\n            0.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyUp\n  :Key \"right\"\n  :Action (-&gt;\n            0 &gt; .character-state\n            0.0 &gt; .character-x-velocity)))\n\n;; -------------- Initialize Coin ----------\n(defshards initialize-coin []\n  (LoadTexture \"GlodImages/Coin/Coin_1.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_2.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_3.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_4.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_5.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_6.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_7.png\") &gt;&gt; .coin-image-array\n  (Count .coin-image-array) = .coin-image-index-max\n  0 &gt;= .coin-image-index\n  0.1 = .coin-animation-speed\n\n  ;; ----- Coin 1 ------\n  0.0 &gt;= .coinx-1\n  0.0 &gt;= .coiny-1\n  (float2 .coinx-1 .coiny-1) &gt;= .coin-position-1\n  0.0 &gt;= .coin-velocity-1\n  0.5 &gt;= .coin-acceleration\n\n  ;; ----- Coin 2 ----\n  0.0 &gt;= .coinx-2\n  0.0 &gt;= .coiny-2\n  (float2 .coinx-2 .coiny-2) &gt;= .coin-position-2\n  0.0 &gt;= .coin-velocity-2)\n\n;; -------------- Coin Animation ------------------\n(defloop coin-animation\n  .coin-image-index (Math.Add 1)\n  &gt; .coin-image-index\n  (When :Predicate (IsMoreEqual .coin-image-index-max)\n        :Action (-&gt; 0 &gt; .coin-image-index))\n\n  (Pause .coin-animation-speed))\n\n;; ------------- Coin Gravity ------------------\n(defshards coin-gravity-logic [coiny coinx coin-velocity coin-position]\n\n  coiny (Math.Add coin-velocity)\n  &gt; coiny\n\n  coin-velocity (Math.Add .coin-acceleration)\n  &gt; coin-velocity\n\n  (float2 coinx coiny) &gt; coin-position)\n\n;; ------------- Random Coin ------------------\n(defshards random-coin [coinx coiny coin-velocity coin-position pause-length]\n  coinx\n  (RandomFloat :Max 1200.0)\n  &gt; coinx\n  (Math.Subtract 600.0)\n  &gt; coinx\n\n  0.0 &gt; coiny\n  0.0 &gt; coin-velocity\n  (float2 coinx coiny) &gt; coin-position\n  (Pause pause-length))\n\n(defloop random-coin-1\n  (random-coin .coinx-1 .coiny-1 .coin-velocity-1 .coin-position-1 1.5))\n\n(defloop random-coin-2\n  (random-coin .coinx-2 .coiny-2 .coin-velocity-2 .coin-position-2 2.5))\n\n;; ------------ Initialize Spiked CanonBalls ---------------\n(defshards initialize-spiked-canonballs []\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall1.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall2.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall3.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall4.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall5.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall6.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall7.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall8.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall9.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall10.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall11.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall12.png\") &gt;&gt; .spikeball-array\n\n  (Count .spikeball-array) = .spikeball-array-index-max\n  0 &gt;= .spikeball-index\n  0.06 = .spikeball-animation-speed)\n\n;;------------- Spiked CanonBall Animation -------------\n(defloop spiked-canonball-animation\n  .spikeball-index (Math.Add 1)\n  &gt; .spikeball-index\n  (When :Predicate (IsMoreEqual .spikeball-array-index-max)\n        :Action (-&gt; 0 &gt; .spikeball-index))\n\n  (Pause .spikeball-animation-speed))\n\n;; --------- Game Elements ------------\n(defshards initialize-game-elements []\n  0 &gt;= .score\n  false &gt;= .scored\n\n  .X (Math.Add 50.0)\n  &gt;= .scoringUpper-x-limit\n  .X (Math.Subtract 50.0)\n  &gt;= .scoringLower-x-limit\n\n  .Y (Math.Add 10.0)\n  &gt;= .scoringUpper-y-limit\n  .Y (Math.Subtract 10.0)\n  &gt;= .scoringLower-y-limit)\n\n;; --------- Scoring ----------\n(defshards score-collision [coinx coiny]\n  coinx\n  (When :Predicate (-&gt;\n                    (IsLess .scoringUpper-x-limit)\n                    (And)\n                    coinx (IsMore .scoringLower-x-limit)\n                    (And)\n                    coiny (IsLess .scoringUpper-y-limit)\n                    (And)\n                    coiny (IsMore .scoringLower-y-limit)\n                    (And)\n                    .scored (Is false))\n        :Action (-&gt;\n                true &gt; .scored\n                (Log \"Score: \"))))\n\n(defshards scoring []\n  .X (Math.Add 50.0)\n  &gt; .scoringUpper-x-limit\n  .X (Math.Subtract 50.0)\n  &gt; .scoringLower-x-limit\n\n  .Y (Math.Add 10.0)\n  &gt; .scoringUpper-y-limit\n  .Y (Math.Subtract 10.0)\n  &gt; .scoringLower-y-limit\n\n  (score-collision .coinx-1 .coiny-1)\n  (score-collision .coinx-2 .coiny-2)\n\n  .scored\n  (When :Predicate (Is true)\n        :Action (-&gt;\n                .score (Math.Add 1)\n                &gt; .score\n                false &gt; .scored)))\n\n\n\n;; ------ UI Style --------\n(def style\n  {:override_text_style \"MyStyle\"\n  :text_styles\n  [{:name \"MyStyle\"\n    :size (float 46)\n    :family \"Monospace\"}]\n  :visuals\n  {:override_text_color (color 250 250 250)}})\n\n;;---------- main-wire ------------\n(defloop main-wire\n  (Setup\n  (initialize-character)\n  (initialize-coin)\n  (initialize-game-elements)\n  (initialize-spiked-canonballs))\n\n  (coin-gravity-logic .coiny-1 .coinx-1 .coin-velocity-1 .coin-position-1)\n  (coin-gravity-logic .coiny-2 .coinx-2 .coin-velocity-2 .coin-position-2)\n\n  (run-logic)\n  (gravity-logic)\n  (scoring)\n\n  (Step idle-animation)\n  (Step walking-animation)\n\n  (Step coin-animation)\n  (Step random-coin-1)\n  (Step random-coin-2)\n\n  (Step spiked-canonball-animation)\n\n  (GFX.MainWindow\n  :Title \"MainWindow\" :Width 1920 :Height 1080\n  :Contents\n  (-&gt; (Setup\n        (GFX.DrawQueue) &gt;= .ui-draw-queue\n        (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n      .ui-draw-queue (GFX.ClearQueue)\n\n      (UI\n        .ui-draw-queue\n        (-&gt;\n        (UI.Area :Position .character-position\n                  :Anchor Anchor.Top\n                  :Contents (-&gt;\n                            .character-state\n                            (Match [0 (-&gt; .character-direction\n                                          (Match [0 (-&gt; .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n                                                  1 (-&gt; .idle-right-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))]\n                                                  :Passthrough false))\n                                    1 (-&gt; .walking-left-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n                                    2 (-&gt; .walking-right-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n                                    3 (-&gt;  .character-direction\n                                            (Match [0 (-&gt; .character-jumping-left (UI.Image :Scale (float2 0.2)))\n                                                    1 (-&gt; .character-jumping-right (UI.Image :Scale (float2 0.2)))]\n                                                  :Passthrough false))]\n                                    :Passthrough false)))\n\n        (UI.Area :Position .coin-position-1\n                  :Anchor Anchor.Top\n                  :Contents (-&gt;\n                            .coin-image-array (Take .coin-image-index) (UI.Image :Scale (float2 0.2))))\n\n        (UI.Area :Position .coin-position-2\n                  :Anchor Anchor.Top\n                  :Contents (-&gt;\n                            .coin-image-array (Take .coin-image-index) (UI.Image :Scale (float2 0.2))))\n\n        (UI.Area :Position (float2 0 0)\n                  :Anchor Anchor.Top\n                  :Contents (-&gt;\n                            .spikeball-array (Take .spikeball-index) (UI.Image :Scale (float2 0.15))))\n\n        (UI.Area :Position (float2 -40 20)\n                  :Anchor Anchor.TopRight\n                  :Contents (-&gt;\n                            style (UI.Style)\n                            .score (ToString) (UI.Label)))))\n\n      (button-inputs)\n\n      (GFX.Render :Steps .render-steps))))\n\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre>"},{"location":"learn/shards/tutorials/glod-game/steps/step-6/#step-63","title":"Step 6.3","text":"<p>Time to make our spiked cannonball fall.</p> <p>As in the previous chapter, we will:</p> <ol> <li> <p>Create variables that dictate the position of our spiked cannonball.</p> </li> <li> <p>Change our <code>UI.Area</code>'s <code>position</code> parameter to use this variable.</p> </li> <li> <p>Change the variable by using velocity and acceleration.</p> </li> </ol> <p>Initialize the code variables that we will be using to move our spiked cannonball.</p> Code Added <pre><code>;; ---------- spikball-1 -------------\n1.0 &gt;= .spikeball-velocity-1\n0.0 &gt;= .spikeball-y-1\n0.0 &gt;= .spikeball-x-1\n(float2 .spikeball-x-1 .spikeball-y-1) &gt;= .spikeball-position-1\n\n0.5 &gt;= .spikeball-acceleration\n</code></pre> <p>Locate the <code>UI.Area</code> housing our spiked cannonball image.</p> <p>Replace the value of the <code>Position</code> attribute with the <code>.spikeball-position-1</code> variable.</p> Code Added <pre><code>;; -------- Spiked CanonBall UI.Area ----------\n(UI.Area :Position .spikeball-position-1\n        :Anchor Anchor.Top\n        :Contents (-&gt;\n                      LoadTexture .spikeball-array (Take .spikeball-index) (UI.Image :Scale (float2 0.15))))\n</code></pre> <p>To make our image move, we create the gravity logic for it.</p> <p>Create a shard that accepts arguments to allow for the creating of more spiked cannonballs in the future.</p> Code Added <pre><code>;; ------------- SpikeBall Gravity Logic -------------\n(defshards spikeball-gravity-logic [spikeball-y spikeball-velocity spikeball-position spikeball-x]\n  spikeball-y (Math.Add spikeball-velocity)\n  &gt; spikeball-y\n  spikeball-velocity (Math.Add .spikeball-acceleration)\n  &gt; spikeball-velocity\n  (float2 spikeball-x spikeball-y) &gt; spikeball-position)\n</code></pre> <p>Remember to call your shard in the <code>main-wire</code> with the appropriate variables passed in.</p> Code AddedFull Code So Far <pre><code>(spikeball-gravity-logic .spikeball-y-1 .spikeball-velocity-1 .spikeball-position-1 .spikeball-x-1)\n</code></pre> <pre><code>(defshards LoadTexture [name]\n  (LoadImage name)\n  (GFX.Texture))\n\n(defshards initialize-character []\n  (LoadTexture \"GlodImages/Character1_Jumping_Left.png\") = .character-jumping-left\n  (LoadTexture \"GlodImages/Character1_Jumping_Right.png\") = .character-jumping-right\n\n  0 &gt;= .character-state\n  0 &gt;= .character-direction\n  true &gt;= .can-jump\n\n  0.0 &gt;= .X\n  620.0 &gt;= .Y\n  (float2 .X .Y) &gt;= .character-position\n  0.0 &gt;= .character-x-velocity\n  0.0 &gt;= .character-y-velocity\n  0.0 &gt;= .character-y-acceleration\n\n  ;; ---------- Character Idle Array (Facing Left) ----------\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png\") &gt;&gt; .idle-left-image-array\n\n  ;; ---------- Character Idle Array (Facing Right) ----------------\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_1.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_2.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_3.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_4.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_5.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_6.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_7.png\") &gt;&gt; .idle-right-image-array\n\n  0 &gt;= .idle-image-index\n  (Count .idle-left-image-array) = .idle-image-index-max\n  0.08 = .idle-animation-speed\n\n  ;; -------------- Walking Array (Facing Left) -----------------\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_1.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_2.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_3.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_4.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_5.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_6.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_7.png\") &gt;&gt; .walking-left-image-array\n\n  ;; ----------- Walking Array (Facing Right) ---------------\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_1.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_2.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_3.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_4.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_5.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_6.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_7.png\") &gt;&gt; .walking-right-image-array\n\n  (Count .walking-left-image-array) = .walking-image-index-max\n  0 &gt;= .walking-image-index\n  0.08 = .walking-animation-speed) ;; Reduce number to increase animation speed\n\n;; --------- Idle Animation Loop ---------\n(defloop idle-animation\n  .idle-image-index (Math.Add 1)\n  &gt; .idle-image-index\n  (When :Predicate (IsMoreEqual .idle-image-index-max)\n        :Action (-&gt; 0 &gt; .idle-image-index))\n  (Pause .idle-animation-speed))\n\n;; -------- Walking Animation Loop --------\n(defloop walking-animation\n  .walking-image-index (Math.Add 1)\n  &gt; .walking-image-index\n  (When :Predicate (IsMoreEqual .walking-image-index-max)\n        :Action (-&gt; 0 &gt; .walking-image-index))\n  (Pause .walking-animation-speed))\n\n;; ---------- character-boundary ------------\n\n(defshards clamp [var min max]\n  var (Max min) (Min max) &gt; var)\n\n;; ------------ Character Run Logic ----------------\n(defshards run-logic []\n  .X (Math.Add .character-x-velocity)\n  &gt; .X\n\n  (float2 .X .Y) &gt; .character-position\n\n  (clamp .X -600.0 600.0))\n\n;; ------------ Character gravity-logic ---------------\n(defshards gravity-logic []\n  .Y (Math.Add .character-y-velocity)\n  &gt; .Y\n\n  .character-y-velocity (Math.Add .character-y-acceleration)\n  &gt; .character-y-velocity\n\n  (float2 .X .Y) &gt; .character-position\n\n  (clamp .Y -620.0 620.0)\n  .Y\n  (When :Predicate (IsMoreEqual 620.0)\n        :Action (-&gt;\n                0.0 &gt; .character-y-velocity\n                0.0 &gt; .character-y-acceleration\n                true &gt; .can-jump\n                .character-state\n                (When :Predicate (Is 3)\n                      :Action (-&gt;\n                                0 &gt; .character-state)))))\n\n;; ------- Button Inputs ----------\n(defshards button-inputs []\n  (Inputs.KeyDown\n  :Key \"left\"\n  :Action (-&gt;\n            (Msg \"left\")\n\n            .character-state\n            (When :Predicate (Is 0)\n                  :Action (-&gt; 1 &gt; .character-state))\n\n            0 &gt; .character-direction\n            -5.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyDown\n  :Key \"right\"\n  :Action (-&gt;\n            (Msg \"right\")\n\n            .character-state\n            (When :Predicate (Is 0)\n                  :Action (-&gt; 2 &gt; .character-state))\n            1 &gt; .character-direction\n            5.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyDown\n  :Key \"up\"\n  :Action (-&gt;\n            (Msg \"up\")\n            3 &gt; .character-state\n            .can-jump\n            (When :Predicate (Is true)\n                  :Action (-&gt;\n                          -20.0 &gt; .character-y-velocity\n                          1.0 &gt;  .character-y-acceleration\n                          false &gt;= .can-jump))))\n\n  (Inputs.KeyUp\n  :Key \"left\"\n  :Action (-&gt;\n            0 &gt; .character-state\n            0.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyUp\n  :Key \"right\"\n  :Action (-&gt;\n            0 &gt; .character-state\n            0.0 &gt; .character-x-velocity)))\n\n;; -------------- Initialize Coin ----------\n(defshards initialize-coin []\n  (LoadTexture \"GlodImages/Coin/Coin_1.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_2.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_3.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_4.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_5.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_6.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_7.png\") &gt;&gt; .coin-image-array\n  (Count .coin-image-array) = .coin-image-index-max\n  0 &gt;= .coin-image-index\n  0.1 = .coin-animation-speed\n\n  ;; ----- Coin 1 ------\n  0.0 &gt;= .coinx-1\n  0.0 &gt;= .coiny-1\n  (float2 .coinx-1 .coiny-1) &gt;= .coin-position-1\n  0.0 &gt;= .coin-velocity-1\n  0.5 &gt;= .coin-acceleration\n\n  ;; ----- Coin 2 ----\n  0.0 &gt;= .coinx-2\n  0.0 &gt;= .coiny-2\n  (float2 .coinx-2 .coiny-2) &gt;= .coin-position-2\n  0.0 &gt;= .coin-velocity-2)\n\n;; -------------- Coin Animation ------------------\n(defloop coin-animation\n  .coin-image-index (Math.Add 1)\n  &gt; .coin-image-index\n  (When :Predicate (IsMoreEqual .coin-image-index-max)\n        :Action (-&gt; 0 &gt; .coin-image-index))\n\n  (Pause .coin-animation-speed))\n\n;; ------------- Coin Gravity ------------------\n(defshards coin-gravity-logic [coiny coinx coin-velocity coin-position]\n\n  coiny (Math.Add coin-velocity)\n  &gt; coiny\n\n  coin-velocity (Math.Add .coin-acceleration)\n  &gt; coin-velocity\n\n  (float2 coinx coiny) &gt; coin-position)\n\n;; ------------- Random Coin ------------------\n(defshards random-coin [coinx coiny coin-velocity coin-position pause-length]\n  coinx\n  (RandomFloat :Max 1200.0)\n  &gt; coinx\n  (Math.Subtract 600.0)\n  &gt; coinx\n\n  0.0 &gt; coiny\n  0.0 &gt; coin-velocity\n  (float2 coinx coiny) &gt; coin-position\n  (Pause pause-length))\n\n(defloop random-coin-1\n  (random-coin .coinx-1 .coiny-1 .coin-velocity-1 .coin-position-1 1.5))\n\n(defloop random-coin-2\n  (random-coin .coinx-2 .coiny-2 .coin-velocity-2 .coin-position-2 2.5))\n\n;; ------------ Initialize Spiked CanonBalls ---------------\n(defshards initialize-spiked-canonballs []\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall1.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall2.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall3.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall4.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall5.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall6.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall7.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall8.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall9.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall10.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall11.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall12.png\") &gt;&gt; .spikeball-array\n\n  (Count .spikeball-array) = .spikeball-array-index-max\n  0 &gt;= .spikeball-index\n  0.06 = .spikeball-animation-speed\n\n  ;; ---------- spikball-1 -------------\n  1.0 &gt;= .spikeball-velocity-1\n  0.0 &gt;= .spikeball-y-1\n  0.0 &gt;= .spikeball-x-1\n  (float2 .spikeball-x-1 .spikeball-y-1) &gt;= .spikeball-position-1\n\n  0.5 &gt;= .spikeball-acceleration)\n\n;;------------- Spiked CanonBall Animation -------------\n(defloop spiked-canonball-animation\n  .spikeball-index (Math.Add 1)\n  &gt; .spikeball-index\n  (When :Predicate (IsMoreEqual .spikeball-array-index-max)\n        :Action (-&gt; 0 &gt; .spikeball-index))\n\n  (Pause .spikeball-animation-speed))\n\n;; ------------- SpikeBall_Gravity_Logic -------------\n(defshards spikeball-gravity-logic [spikeball-y spikeball-velocity spikeball-position spikeball-x]\n  spikeball-y (Math.Add spikeball-velocity)\n  &gt; spikeball-y\n  spikeball-velocity (Math.Add .spikeball-acceleration)\n  &gt; spikeball-velocity\n  (float2 spikeball-x spikeball-y) &gt; spikeball-position)\n\n;; --------- Game Elements ------------\n(defshards initialize-game-elements []\n  0 &gt;= .score\n  false &gt;= .scored\n\n  .X (Math.Add 50.0)\n  &gt;= .scoringUpper-x-limit\n  .X (Math.Subtract 50.0)\n  &gt;= .scoringLower-x-limit\n\n  .Y (Math.Add 10.0)\n  &gt;= .scoringUpper-y-limit\n  .Y (Math.Subtract 10.0)\n  &gt;= .scoringLower-y-limit)\n\n;; --------- Scoring ----------\n(defshards score-collision [coinx coiny]\n  coinx\n  (When :Predicate (-&gt;\n                    (IsLess .scoringUpper-x-limit)\n                    (And)\n                    coinx (IsMore .scoringLower-x-limit)\n                    (And)\n                    coiny (IsLess .scoringUpper-y-limit)\n                    (And)\n                    coiny (IsMore .scoringLower-y-limit)\n                    (And)\n                    .scored (Is false))\n        :Action (-&gt;\n                true &gt; .scored\n                (Log \"Score: \"))))\n\n(defshards scoring []\n  .X (Math.Add 50.0)\n  &gt; .scoringUpper-x-limit\n  .X (Math.Subtract 50.0)\n  &gt; .scoringLower-x-limit\n\n  .Y (Math.Add 10.0)\n  &gt; .scoringUpper-y-limit\n  .Y (Math.Subtract 10.0)\n  &gt; .scoringLower-y-limit\n\n  (score-collision .coinx-1 .coiny-1)\n  (score-collision .coinx-2 .coiny-2)\n\n  .scored\n  (When :Predicate (Is true)\n        :Action (-&gt;\n                .score (Math.Add 1)\n                &gt; .score\n                false &gt; .scored)))\n\n\n\n;; ------ UI Style --------\n(def style\n  {:override_text_style \"MyStyle\"\n  :text_styles\n  [{:name \"MyStyle\"\n    :size (float 46)\n    :family \"Monospace\"}]\n  :visuals\n  {:override_text_color (color 250 250 250)}})\n\n;;---------- main-wire ------------\n(defloop main-wire\n  (Setup\n  (initialize-character)\n  (initialize-coin)\n  (initialize-game-elements)\n  (initialize-spiked-canonballs))\n\n  (coin-gravity-logic .coiny-1 .coinx-1 .coin-velocity-1 .coin-position-1)\n  (coin-gravity-logic .coiny-2 .coinx-2 .coin-velocity-2 .coin-position-2)\n\n  (run-logic)\n  (gravity-logic)\n  (scoring)\n\n  (Step idle-animation)\n  (Step walking-animation)\n\n  (Step coin-animation)\n  (Step random-coin-1)\n  (Step random-coin-2)\n\n  (Step spiked-canonball-animation)\n  (spikeball-gravity-logic .spikeball-y-1 .spikeball-velocity-1 .spikeball-position-1 .spikeball-x-1)\n\n  (GFX.MainWindow\n  :Title \"MainWindow\" :Width 1920 :Height 1080\n  :Contents\n  (-&gt; (Setup\n        (GFX.DrawQueue) &gt;= .ui-draw-queue\n        (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n      .ui-draw-queue (GFX.ClearQueue)\n\n      (UI\n        .ui-draw-queue\n        (-&gt;\n        (UI.Area :Position .character-position\n                  :Anchor Anchor.Top\n                  :Contents (-&gt;\n                            .character-state\n                            (Match [0 (-&gt; .character-direction\n                                          (Match [0 (-&gt; .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n                                                  1 (-&gt; .idle-right-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))]\n                                                  :Passthrough false))\n                                    1 (-&gt; .walking-left-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n                                    2 (-&gt; .walking-right-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n                                    3 (-&gt;  .character-direction\n                                            (Match [0 (-&gt; .character-jumping-left (UI.Image :Scale (float2 0.2)))\n                                                    1 (-&gt; .character-jumping-right (UI.Image :Scale (float2 0.2)))]\n                                                  :Passthrough false))]\n                                    :Passthrough false)))\n\n        (UI.Area :Position .coin-position-1\n                  :Anchor Anchor.Top\n                  :Contents (-&gt;\n                            .coin-image-array (Take .coin-image-index) (UI.Image :Scale (float2 0.2))))\n\n        (UI.Area :Position .coin-position-2\n                  :Anchor Anchor.Top\n                  :Contents (-&gt;\n                            .coin-image-array (Take .coin-image-index) (UI.Image :Scale (float2 0.2))))\n\n        (UI.Area :Position .spikeball-position-1\n                  :Anchor Anchor.Top\n                  :Contents (-&gt;\n                            .spikeball-array (Take .spikeball-index) (UI.Image :Scale (float2 0.15))))\n\n        (UI.Area :Position (float2 -40 20)\n                  :Anchor Anchor.TopRight\n                  :Contents (-&gt;\n                            style (UI.Style)\n                            .score (ToString) (UI.Label)))))\n\n      (button-inputs)\n\n      (GFX.Render :Steps .render-steps))))\n\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre> <p>Try running your code now to see if it falls!</p>"},{"location":"learn/shards/tutorials/glod-game/steps/step-6/#step-64","title":"Step 6.4","text":"<p>To make sure that our spiked cannonball loops and randomly spawns in different locations, we will implement the same spawning logic used previously.</p> <p>Create our <code>randomise-spikeball</code> logic. Similar to our coin, we reset the spiked cannonball's y value back to zero, so that it appears at the top of the screen again.</p> <p>This time however, we will have different randomized x values and have this happen every <code>pausefloat</code> number of seconds.</p> Code Added <pre><code>;; ------------- Randomise Spikeball ----------------\n(defshards randomise-spikeball [spikeball-x spikeball-y spikeball-velocity spikeball-position pausefloat]\n  spikeball-x\n  (RandomFloat :Max 1200.0)\n  &gt; spikeball-x\n  (Math.Subtract 600.0)\n  &gt; spikeball-x\n\n  0.0 &gt; spikeball-y\n  0.0 &gt; spikeball-velocity\n  (float2 spikeball-x spikeball-y) &gt; spikeball-position\n  .spikeball-x-1\n  (Pause pausefloat))\n</code></pre> <p>We then plug this shard into a loop and fill in the appropriate variables.</p> Code Added <pre><code>(defloop spikeball-1\n  (randomise-spikeball .spikeball-x-1 .spikeball-y-1 .spikeball-velocity-1 .spikeball-position-1 2))\n</code></pre> <p>Call your <code>spikeball-1</code> loop in the <code>main-wire</code>.</p> Code AddedFull Code So Far <pre><code>;; ------- Button Inputs ----------\n(Step spikeball-1)\n</code></pre> <pre><code>(defshards LoadTexture [name]\n  (LoadImage name)\n  (GFX.Texture))\n\n(defshards initialize-character []\n  (LoadTexture \"GlodImages/Character1_Jumping_Left.png\") = .character-jumping-left\n  (LoadTexture \"GlodImages/Character1_Jumping_Right.png\") = .character-jumping-right\n\n  0 &gt;= .character-state\n  0 &gt;= .character-direction\n  true &gt;= .can-jump\n\n  0.0 &gt;= .X\n  620.0 &gt;= .Y\n  (float2 .X .Y) &gt;= .character-position\n  0.0 &gt;= .character-x-velocity\n  0.0 &gt;= .character-y-velocity\n  0.0 &gt;= .character-y-acceleration\n\n  ;; ---------- Character Idle Array (Facing Left) ----------\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png\") &gt;&gt; .idle-left-image-array\n\n  ;; ---------- Character Idle Array (Facing Right) ----------------\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_1.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_2.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_3.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_4.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_5.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_6.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_7.png\") &gt;&gt; .idle-right-image-array\n\n  0 &gt;= .idle-image-index\n  (Count .idle-left-image-array) = .idle-image-index-max\n  0.08 = .idle-animation-speed\n\n  ;; -------------- Walking Array (Facing Left) -----------------\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_1.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_2.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_3.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_4.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_5.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_6.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_7.png\") &gt;&gt; .walking-left-image-array\n\n  ;; ----------- Walking Array (Facing Right) ---------------\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_1.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_2.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_3.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_4.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_5.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_6.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_7.png\") &gt;&gt; .walking-right-image-array\n\n  (Count .walking-left-image-array) = .walking-image-index-max\n  0 &gt;= .walking-image-index\n  0.08 = .walking-animation-speed) ;; Reduce number to increase animation speed\n\n;; --------- Idle Animation Loop ---------\n(defloop idle-animation\n  .idle-image-index (Math.Add 1)\n  &gt; .idle-image-index\n  (When :Predicate (IsMoreEqual .idle-image-index-max)\n        :Action (-&gt; 0 &gt; .idle-image-index))\n  (Pause .idle-animation-speed))\n\n;; -------- Walking Animation Loop --------\n(defloop walking-animation\n  .walking-image-index (Math.Add 1)\n  &gt; .walking-image-index\n  (When :Predicate (IsMoreEqual .walking-image-index-max)\n        :Action (-&gt; 0 &gt; .walking-image-index))\n  (Pause .walking-animation-speed))\n\n;; ---------- character-boundary ------------\n\n(defshards clamp [var min max]\n  var (Max min) (Min max) &gt; var)\n\n;; ------------ Character Run Logic ----------------\n(defshards run-logic []\n  .X (Math.Add .character-x-velocity)\n  &gt; .X\n\n  (float2 .X .Y) &gt; .character-position\n\n  (clamp .X -600.0 600.0))\n\n;; ------------ Character gravity-logic ---------------\n(defshards gravity-logic []\n  .Y (Math.Add .character-y-velocity)\n  &gt; .Y\n\n  .character-y-velocity (Math.Add .character-y-acceleration)\n  &gt; .character-y-velocity\n\n  (float2 .X .Y) &gt; .character-position\n\n  (clamp .Y -620.0 620.0)\n  .Y\n  (When :Predicate (IsMoreEqual 620.0)\n        :Action (-&gt;\n                0.0 &gt; .character-y-velocity\n                0.0 &gt; .character-y-acceleration\n                true &gt; .can-jump\n                .character-state\n                (When :Predicate (Is 3)\n                      :Action (-&gt;\n                                0 &gt; .character-state)))))\n\n;; ------- Button Inputs ----------\n(defshards button-inputs []\n  (Inputs.KeyDown\n  :Key \"left\"\n  :Action (-&gt;\n            (Msg \"left\")\n\n            .character-state\n            (When :Predicate (Is 0)\n                  :Action (-&gt; 1 &gt; .character-state))\n\n            0 &gt; .character-direction\n            -5.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyDown\n  :Key \"right\"\n  :Action (-&gt;\n            (Msg \"right\")\n\n            .character-state\n            (When :Predicate (Is 0)\n                  :Action (-&gt; 2 &gt; .character-state))\n            1 &gt; .character-direction\n            5.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyDown\n  :Key \"up\"\n  :Action (-&gt;\n            (Msg \"up\")\n            3 &gt; .character-state\n            .can-jump\n            (When :Predicate (Is true)\n                  :Action (-&gt;\n                          -20.0 &gt; .character-y-velocity\n                          1.0 &gt;  .character-y-acceleration\n                          false &gt;= .can-jump))))\n\n  (Inputs.KeyUp\n  :Key \"left\"\n  :Action (-&gt;\n            0 &gt; .character-state\n            0.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyUp\n  :Key \"right\"\n  :Action (-&gt;\n            0 &gt; .character-state\n            0.0 &gt; .character-x-velocity)))\n\n;; -------------- Initialize Coin ----------\n(defshards initialize-coin []\n  (LoadTexture \"GlodImages/Coin/Coin_1.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_2.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_3.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_4.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_5.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_6.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_7.png\") &gt;&gt; .coin-image-array\n  (Count .coin-image-array) = .coin-image-index-max\n  0 &gt;= .coin-image-index\n  0.1 = .coin-animation-speed\n\n  ;; ----- Coin 1 ------\n  0.0 &gt;= .coinx-1\n  0.0 &gt;= .coiny-1\n  (float2 .coinx-1 .coiny-1) &gt;= .coin-position-1\n  0.0 &gt;= .coin-velocity-1\n  0.5 &gt;= .coin-acceleration\n\n  ;; ----- Coin 2 ----\n  0.0 &gt;= .coinx-2\n  0.0 &gt;= .coiny-2\n  (float2 .coinx-2 .coiny-2) &gt;= .coin-position-2\n  0.0 &gt;= .coin-velocity-2)\n\n;; -------------- Coin Animation ------------------\n(defloop coin-animation\n  .coin-image-index (Math.Add 1)\n  &gt; .coin-image-index\n  (When :Predicate (IsMoreEqual .coin-image-index-max)\n        :Action (-&gt; 0 &gt; .coin-image-index))\n\n  (Pause .coin-animation-speed))\n\n;; ------------- Coin Gravity ------------------\n(defshards coin-gravity-logic [coiny coinx coin-velocity coin-position]\n\n  coiny (Math.Add coin-velocity)\n  &gt; coiny\n\n  coin-velocity (Math.Add .coin-acceleration)\n  &gt; coin-velocity\n\n  (float2 coinx coiny) &gt; coin-position)\n\n;; ------------- Random Coin ------------------\n(defshards random-coin [coinx coiny coin-velocity coin-position pause-length]\n  coinx\n  (RandomFloat :Max 1200.0)\n  &gt; coinx\n  (Math.Subtract 600.0)\n  &gt; coinx\n\n  0.0 &gt; coiny\n  0.0 &gt; coin-velocity\n  (float2 coinx coiny) &gt; coin-position\n  (Pause pause-length))\n\n(defloop random-coin-1\n  (random-coin .coinx-1 .coiny-1 .coin-velocity-1 .coin-position-1 1.5))\n\n(defloop random-coin-2\n  (random-coin .coinx-2 .coiny-2 .coin-velocity-2 .coin-position-2 2.5))\n\n;; ------------ Initialize Spiked CanonBalls ---------------\n(defshards initialize-spiked-canonballs []\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall1.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall2.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall3.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall4.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall5.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall6.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall7.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall8.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall9.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall10.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall11.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall12.png\") &gt;&gt; .spikeball-array\n\n  (Count .spikeball-array) = .spikeball-array-index-max\n  0 &gt;= .spikeball-index\n  0.06 = .spikeball-animation-speed\n\n  ;; ---------- spikball-1 -------------\n  1.0 &gt;= .spikeball-velocity-1\n  0.0 &gt;= .spikeball-y-1\n  0.0 &gt;= .spikeball-x-1\n  (float2 .spikeball-x-1 .spikeball-y-1) &gt;= .spikeball-position-1\n\n  0.5 &gt;= .spikeball-acceleration)\n\n;;------------- Spiked CanonBall Animation -------------\n(defloop spiked-canonball-animation\n  .spikeball-index (Math.Add 1)\n  &gt; .spikeball-index\n  (When :Predicate (IsMoreEqual .spikeball-array-index-max)\n        :Action (-&gt; 0 &gt; .spikeball-index))\n\n  (Pause .spikeball-animation-speed))\n\n;; ------------- SpikeBall_Gravity_Logic -------------\n(defshards spikeball-gravity-logic [spikeball-y spikeball-velocity spikeball-position spikeball-x]\n  spikeball-y (Math.Add spikeball-velocity)\n  &gt; spikeball-y\n  spikeball-velocity (Math.Add .spikeball-acceleration)\n  &gt; spikeball-velocity\n  (float2 spikeball-x spikeball-y) &gt; spikeball-position)\n\n;; ------------- Randomise Spikeball ----------------\n(defshards randomise-spikeball [spikeball-x spikeball-y spikeball-velocity spikeball-position pausefloat]\n  spikeball-x\n  (RandomFloat :Max 1200.0)\n  &gt; spikeball-x\n  (Math.Subtract 600.0)\n  &gt; spikeball-x\n\n  0.0 &gt; spikeball-y\n  0.0 &gt; spikeball-velocity\n  (float2 spikeball-x spikeball-y) &gt; spikeball-position\n  .spikeball-x-1\n  (Pause pausefloat))\n\n(defloop spikeball-1\n  (randomise-spikeball .spikeball-x-1 .spikeball-y-1 .spikeball-velocity-1 .spikeball-position-1 2))\n\n;; --------- Game Elements ------------\n(defshards initialize-game-elements []\n  0 &gt;= .score\n  false &gt;= .scored\n\n  .X (Math.Add 50.0)\n  &gt;= .scoringUpper-x-limit\n  .X (Math.Subtract 50.0)\n  &gt;= .scoringLower-x-limit\n\n  .Y (Math.Add 10.0)\n  &gt;= .scoringUpper-y-limit\n  .Y (Math.Subtract 10.0)\n  &gt;= .scoringLower-y-limit)\n\n;; --------- Scoring ----------\n(defshards score-collision [coinx coiny]\n  coinx\n  (When :Predicate (-&gt;\n                    (IsLess .scoringUpper-x-limit)\n                    (And)\n                    coinx (IsMore .scoringLower-x-limit)\n                    (And)\n                    coiny (IsLess .scoringUpper-y-limit)\n                    (And)\n                    coiny (IsMore .scoringLower-y-limit)\n                    (And)\n                    .scored (Is false))\n        :Action (-&gt;\n                true &gt; .scored\n                (Log \"Score: \"))))\n\n(defshards scoring []\n  .X (Math.Add 50.0)\n  &gt; .scoringUpper-x-limit\n  .X (Math.Subtract 50.0)\n  &gt; .scoringLower-x-limit\n\n  .Y (Math.Add 10.0)\n  &gt; .scoringUpper-y-limit\n  .Y (Math.Subtract 10.0)\n  &gt; .scoringLower-y-limit\n\n  (score-collision .coinx-1 .coiny-1)\n  (score-collision .coinx-2 .coiny-2)\n\n  .scored\n  (When :Predicate (Is true)\n        :Action (-&gt;\n                .score (Math.Add 1)\n                &gt; .score\n                false &gt; .scored)))\n\n\n\n;; ------ UI Style --------\n(def style\n  {:override_text_style \"MyStyle\"\n  :text_styles\n  [{:name \"MyStyle\"\n    :size (float 46)\n    :family \"Monospace\"}]\n  :visuals\n  {:override_text_color (color 250 250 250)}})\n\n;;---------- main-wire ------------\n(defloop main-wire\n  (Setup\n  (initialize-character)\n  (initialize-coin)\n  (initialize-game-elements)\n  (initialize-spiked-canonballs))\n\n  (coin-gravity-logic .coiny-1 .coinx-1 .coin-velocity-1 .coin-position-1)\n  (coin-gravity-logic .coiny-2 .coinx-2 .coin-velocity-2 .coin-position-2)\n\n  (run-logic)\n  (gravity-logic)\n  (scoring)\n\n  (Step idle-animation)\n  (Step walking-animation)\n\n  (Step coin-animation)\n  (Step random-coin-1)\n  (Step random-coin-2)\n\n  (Step spiked-canonball-animation)\n  (spikeball-gravity-logic .spikeball-y-1 .spikeball-velocity-1 .spikeball-position-1 .spikeball-x-1)\n  (Step  spikeball-1)\n\n  (GFX.MainWindow\n  :Title \"MainWindow\" :Width 1920 :Height 1080\n  :Contents\n  (-&gt; (Setup\n        (GFX.DrawQueue) &gt;= .ui-draw-queue\n        (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n      .ui-draw-queue (GFX.ClearQueue)\n\n      (UI\n        .ui-draw-queue\n        (-&gt;\n        (UI.Area :Position .character-position\n                  :Anchor Anchor.Top\n                  :Contents (-&gt;\n                            .character-state\n                            (Match [0 (-&gt; .character-direction\n                                          (Match [0 (-&gt; .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n                                                  1 (-&gt; .idle-right-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))]\n                                                  :Passthrough false))\n                                    1 (-&gt; .walking-left-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n                                    2 (-&gt; .walking-right-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n                                    3 (-&gt;  .character-direction\n                                            (Match [0 (-&gt; .character-jumping-left (UI.Image :Scale (float2 0.2)))\n                                                    1 (-&gt; .character-jumping-right (UI.Image :Scale (float2 0.2)))]\n                                                  :Passthrough false))]\n                                    :Passthrough false)))\n\n        (UI.Area :Position .coin-position-1\n                  :Anchor Anchor.Top\n                  :Contents (-&gt;\n                            .coin-image-array (Take .coin-image-index) (UI.Image :Scale (float2 0.2))))\n\n        (UI.Area :Position .coin-position-2\n                  :Anchor Anchor.Top\n                  :Contents (-&gt;\n                            .coin-image-array (Take .coin-image-index) (UI.Image :Scale (float2 0.2))))\n\n        (UI.Area :Position .spikeball-position-1\n                  :Anchor Anchor.Top\n                  :Contents (-&gt;\n                            .spikeball-array (Take .spikeball-index) (UI.Image :Scale (float2 0.15))))\n\n        (UI.Area :Position (float2 -40 20)\n                  :Anchor Anchor.TopRight\n                  :Contents (-&gt;\n                            style (UI.Style)\n                            .score (ToString) (UI.Label)))))\n\n      (button-inputs)\n\n      (GFX.Render :Steps .render-steps))))\n\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre>"},{"location":"learn/shards/tutorials/glod-game/steps/step-6/#step-65","title":"Step 6.5","text":"<p>Now that we have our spiked cannonball looping and randomizing, the next step is to have it damage Glod.</p> <p>Poor Glod. \ud83d\ude22</p> <p>It will follow the same logic as our coin. However, instead of gaining points when Glod collides with it, points will be lost.</p> <p>Create the variables that we will be using. They are similar to the collision box we used for scoring.</p> <p>Add this to the <code>initialize-game-elements</code> shard.</p> Code Added <pre><code>;; ---------- Damage Limits ------------\n.X (Math.Add 50.0)\n&gt;= .damageUpper-x-limit\n.X (Math.Subtract 50.0)\n&gt;= .damageLower-x-limit\n\n.Y (Math.Add 5.0)\n&gt;= .damageUpper-y-limit\n.Y (Math.Subtract 5.0)\n&gt;= .damageLower-y-limit\n\nfalse &gt;= .damaged\n</code></pre> <p>Create the logic to dictate what happens when our spiked cannonball hits Glod. Remember to call this in <code>main-wire</code>.</p> Code AddedFull Code So Far <pre><code>;; ------------- spikeBall-collision-logic --------------\n(defshards spikeBall-collision-logic [spikeBall-x spikeBall-y]\n\n  spikeBall-x\n  (If :Predicate (-&gt; (IsLess .damageUpper-x-limit)\n                    (And)\n                    spikeBall-x (IsMore .damageLower-x-limit)\n                    (And)\n                    spikeBall-y (IsLess .damageUpper-y-limit)\n                    (And)\n                    spikeBall-y (IsMore .damageLower-y-limit))\n\n      :Then (-&gt; .damaged\n                (When :Predicate (Is false)\n                      :Action (-&gt;\n                              true &gt; .damaged\n                              (Log \"damaged: \"))))))\n</code></pre> <pre><code>;; -------------- Damaging --------------\n(defshards damaging []\n\n  .X (Math.Add 120.0)\n  &gt; .damageUpper-x-limit\n  .X (Math.Subtract 120.0)\n  &gt; .damageLower-x-limit\n\n  .Y (Math.Add 15.0)\n  &gt; .damageUpper-y-limit\n  .Y (Math.Subtract 15.0)\n  &gt; .damageLower-y-limit\n\n  (spikeBall-collision-logic .spikeball-x-1 .spikeball-y-1)\n\n  .damaged\n  (When :Predicate (Is true)\n        :Action (-&gt;\n                .score (Math.Subtract 1)\n                &gt; .score\n                false &gt; .damaged)))\n</code></pre> <pre><code>(damaging)\n</code></pre> <pre><code>(defshards LoadTexture [name]\n  (LoadImage name)\n  (GFX.Texture))\n\n(defshards initialize-character []\n  (LoadTexture \"GlodImages/Character1_Jumping_Left.png\") = .character-jumping-left\n  (LoadTexture \"GlodImages/Character1_Jumping_Right.png\") = .character-jumping-right\n\n  0 &gt;= .character-state\n  0 &gt;= .character-direction\n  true &gt;= .can-jump\n\n  0.0 &gt;= .X\n  620.0 &gt;= .Y\n  (float2 .X .Y) &gt;= .character-position\n  0.0 &gt;= .character-x-velocity\n  0.0 &gt;= .character-y-velocity\n  0.0 &gt;= .character-y-acceleration\n\n  ;; ---------- Character Idle Array (Facing Left) ----------\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png\") &gt;&gt; .idle-left-image-array\n\n  ;; ---------- Character Idle Array (Facing Right) ----------------\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_1.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_2.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_3.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_4.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_5.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_6.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_7.png\") &gt;&gt; .idle-right-image-array\n\n  0 &gt;= .idle-image-index\n  (Count .idle-left-image-array) = .idle-image-index-max\n  0.08 = .idle-animation-speed\n\n  ;; -------------- Walking Array (Facing Left) -----------------\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_1.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_2.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_3.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_4.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_5.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_6.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_7.png\") &gt;&gt; .walking-left-image-array\n\n  ;; ----------- Walking Array (Facing Right) ---------------\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_1.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_2.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_3.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_4.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_5.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_6.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_7.png\") &gt;&gt; .walking-right-image-array\n\n  (Count .walking-left-image-array) = .walking-image-index-max\n  0 &gt;= .walking-image-index\n  0.08 = .walking-animation-speed) ;; Reduce number to increase animation speed\n\n;; --------- Idle Animation Loop ---------\n(defloop idle-animation\n  .idle-image-index (Math.Add 1)\n  &gt; .idle-image-index\n  (When :Predicate (IsMoreEqual .idle-image-index-max)\n        :Action (-&gt; 0 &gt; .idle-image-index))\n  (Pause .idle-animation-speed))\n\n;; -------- Walking Animation Loop --------\n(defloop walking-animation\n  .walking-image-index (Math.Add 1)\n  &gt; .walking-image-index\n  (When :Predicate (IsMoreEqual .walking-image-index-max)\n        :Action (-&gt; 0 &gt; .walking-image-index))\n  (Pause .walking-animation-speed))\n\n;; ---------- character-boundary ------------\n\n(defshards clamp [var min max]\n  var (Max min) (Min max) &gt; var)\n\n;; ------------ Character Run Logic ----------------\n(defshards run-logic []\n  .X (Math.Add .character-x-velocity)\n  &gt; .X\n\n  (float2 .X .Y) &gt; .character-position\n\n  (clamp .X -600.0 600.0))\n\n;; ------------ Character gravity-logic ---------------\n(defshards gravity-logic []\n  .Y (Math.Add .character-y-velocity)\n  &gt; .Y\n\n  .character-y-velocity (Math.Add .character-y-acceleration)\n  &gt; .character-y-velocity\n\n  (float2 .X .Y) &gt; .character-position\n\n  (clamp .Y -620.0 620.0)\n  .Y\n  (When :Predicate (IsMoreEqual 620.0)\n        :Action (-&gt;\n                0.0 &gt; .character-y-velocity\n                0.0 &gt; .character-y-acceleration\n                true &gt; .can-jump\n                .character-state\n                (When :Predicate (Is 3)\n                      :Action (-&gt;\n                                0 &gt; .character-state)))))\n\n;; ------- Button Inputs ----------\n(defshards button-inputs []\n  (Inputs.KeyDown\n  :Key \"left\"\n  :Action (-&gt;\n            (Msg \"left\")\n\n            .character-state\n            (When :Predicate (Is 0)\n                  :Action (-&gt; 1 &gt; .character-state))\n\n            0 &gt; .character-direction\n            -5.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyDown\n  :Key \"right\"\n  :Action (-&gt;\n            (Msg \"right\")\n\n            .character-state\n            (When :Predicate (Is 0)\n                  :Action (-&gt; 2 &gt; .character-state))\n            1 &gt; .character-direction\n            5.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyDown\n  :Key \"up\"\n  :Action (-&gt;\n            (Msg \"up\")\n            3 &gt; .character-state\n            .can-jump\n            (When :Predicate (Is true)\n                  :Action (-&gt;\n                          -20.0 &gt; .character-y-velocity\n                          1.0 &gt;  .character-y-acceleration\n                          false &gt;= .can-jump))))\n\n  (Inputs.KeyUp\n  :Key \"left\"\n  :Action (-&gt;\n            0 &gt; .character-state\n            0.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyUp\n  :Key \"right\"\n  :Action (-&gt;\n            0 &gt; .character-state\n            0.0 &gt; .character-x-velocity)))\n\n;; -------------- Initialize Coin ----------\n(defshards initialize-coin []\n  (LoadTexture \"GlodImages/Coin/Coin_1.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_2.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_3.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_4.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_5.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_6.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_7.png\") &gt;&gt; .coin-image-array\n  (Count .coin-image-array) = .coin-image-index-max\n  0 &gt;= .coin-image-index\n  0.1 = .coin-animation-speed\n\n  ;; ----- Coin 1 ------\n  0.0 &gt;= .coinx-1\n  0.0 &gt;= .coiny-1\n  (float2 .coinx-1 .coiny-1) &gt;= .coin-position-1\n  0.0 &gt;= .coin-velocity-1\n  0.5 &gt;= .coin-acceleration\n\n  ;; ----- Coin 2 ----\n  0.0 &gt;= .coinx-2\n  0.0 &gt;= .coiny-2\n  (float2 .coinx-2 .coiny-2) &gt;= .coin-position-2\n  0.0 &gt;= .coin-velocity-2)\n\n;; -------------- Coin Animation ------------------\n(defloop coin-animation\n  .coin-image-index (Math.Add 1)\n  &gt; .coin-image-index\n  (When :Predicate (IsMoreEqual .coin-image-index-max)\n        :Action (-&gt; 0 &gt; .coin-image-index))\n\n  (Pause .coin-animation-speed))\n\n;; ------------- Coin Gravity ------------------\n(defshards coin-gravity-logic [coiny coinx coin-velocity coin-position]\n\n  coiny (Math.Add coin-velocity)\n  &gt; coiny\n\n  coin-velocity (Math.Add .coin-acceleration)\n  &gt; coin-velocity\n\n  (float2 coinx coiny) &gt; coin-position)\n\n;; ------------- Random Coin ------------------\n(defshards random-coin [coinx coiny coin-velocity coin-position pause-length]\n  coinx\n  (RandomFloat :Max 1200.0)\n  &gt; coinx\n  (Math.Subtract 600.0)\n  &gt; coinx\n\n  0.0 &gt; coiny\n  0.0 &gt; coin-velocity\n  (float2 coinx coiny) &gt; coin-position\n  (Pause pause-length))\n\n(defloop random-coin-1\n  (random-coin .coinx-1 .coiny-1 .coin-velocity-1 .coin-position-1 1.5))\n\n(defloop random-coin-2\n  (random-coin .coinx-2 .coiny-2 .coin-velocity-2 .coin-position-2 2.5))\n\n;; ------------ Initialize Spiked CanonBalls ---------------\n(defshards initialize-spiked-canonballs []\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall1.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall2.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall3.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall4.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall5.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall6.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall7.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall8.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall9.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall10.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall11.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall12.png\") &gt;&gt; .spikeball-array\n\n  (Count .spikeball-array) = .spikeball-array-index-max\n  0 &gt;= .spikeball-index\n  0.06 = .spikeball-animation-speed\n\n  ;; ---------- spikball-1 -------------\n  1.0 &gt;= .spikeball-velocity-1\n  0.0 &gt;= .spikeball-y-1\n  0.0 &gt;= .spikeball-x-1\n  (float2 .spikeball-x-1 .spikeball-y-1) &gt;= .spikeball-position-1\n\n  0.5 &gt;= .spikeball-acceleration)\n\n;;------------- Spiked CanonBall Animation -------------\n(defloop spiked-canonball-animation\n  .spikeball-index (Math.Add 1)\n  &gt; .spikeball-index\n  (When :Predicate (IsMoreEqual .spikeball-array-index-max)\n        :Action (-&gt; 0 &gt; .spikeball-index))\n\n  (Pause .spikeball-animation-speed))\n\n;; ------------- SpikeBall_Gravity_Logic -------------\n(defshards spikeball-gravity-logic [spikeball-y spikeball-velocity spikeball-position spikeball-x]\n  spikeball-y (Math.Add spikeball-velocity)\n  &gt; spikeball-y\n  spikeball-velocity (Math.Add .spikeball-acceleration)\n  &gt; spikeball-velocity\n  (float2 spikeball-x spikeball-y) &gt; spikeball-position)\n\n;; ------------- Randomise Spikeball ----------------\n(defshards randomise-spikeball [spikeball-x spikeball-y spikeball-velocity spikeball-position pausefloat]\n  spikeball-x\n  (RandomFloat :Max 1200.0)\n  &gt; spikeball-x\n  (Math.Subtract 600.0)\n  &gt; spikeball-x\n\n  0.0 &gt; spikeball-y\n  0.0 &gt; spikeball-velocity\n  (float2 spikeball-x spikeball-y) &gt; spikeball-position\n  .spikeball-x-1\n  (Pause pausefloat))\n\n(defloop spikeball-1\n  (randomise-spikeball .spikeball-x-1 .spikeball-y-1 .spikeball-velocity-1 .spikeball-position-1 2))\n\n;; --------- Game Elements ------------\n(defshards initialize-game-elements []\n  ;;------------ Scoring Limits ----------\n  0 &gt;= .score\n  false &gt;= .scored\n\n  .X (Math.Add 50.0)\n  &gt;= .scoringUpper-x-limit\n  .X (Math.Subtract 50.0)\n  &gt;= .scoringLower-x-limit\n\n  .Y (Math.Add 10.0)\n  &gt;= .scoringUpper-y-limit\n  .Y (Math.Subtract 10.0)\n  &gt;= .scoringLower-y-limit\n\n  ;; ---------- Damage Limits ------------\n  .X (Math.Add 50.0)\n  &gt;= .damageUpper-x-limit\n  .X (Math.Subtract 50.0)\n  &gt;= .damageLower-x-limit\n\n  .Y (Math.Add 5.0)\n  &gt;= .damageUpper-y-limit\n  .Y (Math.Subtract 5.0)\n  &gt;= .damageLower-y-limit\n\n  false &gt;= .damaged)\n\n;; --------- Scoring ----------\n(defshards score-collision [coinx coiny]\n  coinx\n  (When :Predicate (-&gt;\n                    (IsLess .scoringUpper-x-limit)\n                    (And)\n                    coinx (IsMore .scoringLower-x-limit)\n                    (And)\n                    coiny (IsLess .scoringUpper-y-limit)\n                    (And)\n                    coiny (IsMore .scoringLower-y-limit)\n                    (And)\n                    .scored (Is false))\n        :Action (-&gt;\n                true &gt; .scored\n                (Log \"Score: \"))))\n\n(defshards scoring []\n  .X (Math.Add 50.0)\n  &gt; .scoringUpper-x-limit\n  .X (Math.Subtract 50.0)\n  &gt; .scoringLower-x-limit\n\n  .Y (Math.Add 10.0)\n  &gt; .scoringUpper-y-limit\n  .Y (Math.Subtract 10.0)\n  &gt; .scoringLower-y-limit\n\n  (score-collision .coinx-1 .coiny-1)\n  (score-collision .coinx-2 .coiny-2)\n\n  .scored\n  (When :Predicate (Is true)\n        :Action (-&gt;\n                .score (Math.Add 1)\n                &gt; .score\n                false &gt; .scored)))\n\n;; ------------- spikeBall-collision-logic --------------\n(defshards spikeBall-collision-logic [spikeBall-x spikeBall-y]\n\n  spikeBall-x\n  (If :Predicate (-&gt; (IsLess .damageUpper-x-limit)\n                    (And)\n                    spikeBall-x (IsMore .damageLower-x-limit)\n                    (And)\n                    spikeBall-y (IsLess .damageUpper-y-limit)\n                    (And)\n                    spikeBall-y (IsMore .damageLower-y-limit))\n\n      :Then (-&gt; .damaged\n                (When :Predicate (Is false)\n                      :Action (-&gt;\n                              true &gt; .damaged\n                              (Log \"damaged: \"))))))\n\n;; -------------- Damaging --------------\n(defshards damaging []\n\n  .X (Math.Add 120.0)\n  &gt; .damageUpper-x-limit\n  .X (Math.Subtract 120.0)\n  &gt; .damageLower-x-limit\n\n  .Y (Math.Add 15.0)\n  &gt; .damageUpper-y-limit\n  .Y (Math.Subtract 15.0)\n  &gt; .damageLower-y-limit\n\n  (spikeBall-collision-logic .spikeball-x-1 .spikeball-y-1)\n\n  .damaged\n  (When :Predicate (Is true)\n        :Action (-&gt;\n                .score (Math.Subtract 1)\n                &gt; .score\n                false &gt; .damaged)))\n\n\n\n;; ------ UI Style --------\n(def style\n  {:override_text_style \"MyStyle\"\n  :text_styles\n  [{:name \"MyStyle\"\n    :size (float 46)\n    :family \"Monospace\"}]\n  :visuals\n  {:override_text_color (color 250 250 250)}})\n\n;;---------- main-wire ------------\n(defloop main-wire\n  (Setup\n  (initialize-character)\n  (initialize-coin)\n  (initialize-game-elements)\n  (initialize-spiked-canonballs))\n\n  (coin-gravity-logic .coiny-1 .coinx-1 .coin-velocity-1 .coin-position-1)\n  (coin-gravity-logic .coiny-2 .coinx-2 .coin-velocity-2 .coin-position-2)\n\n  (run-logic)\n  (gravity-logic)\n  (scoring)\n  (damaging)\n\n  (Step idle-animation)\n  (Step walking-animation)\n\n  (Step coin-animation)\n  (Step random-coin-1)\n  (Step random-coin-2)\n\n  (Step spiked-canonball-animation)\n  (spikeball-gravity-logic .spikeball-y-1 .spikeball-velocity-1 .spikeball-position-1 .spikeball-x-1)\n  (Step  spikeball-1)\n\n  (GFX.MainWindow\n  :Title \"MainWindow\" :Width 1920 :Height 1080\n  :Contents\n  (-&gt; (Setup\n        (GFX.DrawQueue) &gt;= .ui-draw-queue\n        (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n      .ui-draw-queue (GFX.ClearQueue)\n\n      (UI\n        .ui-draw-queue\n        (-&gt;\n        (UI.Area :Position .character-position\n                  :Anchor Anchor.Top\n                  :Contents (-&gt;\n                            .character-state\n                            (Match [0 (-&gt; .character-direction\n                                          (Match [0 (-&gt; .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n                                                  1 (-&gt; .idle-right-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))]\n                                                  :Passthrough false))\n                                    1 (-&gt; .walking-left-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n                                    2 (-&gt; .walking-right-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n                                    3 (-&gt;  .character-direction\n                                            (Match [0 (-&gt; .character-jumping-left (UI.Image :Scale (float2 0.2)))\n                                                    1 (-&gt; .character-jumping-right (UI.Image :Scale (float2 0.2)))]\n                                                  :Passthrough false))]\n                                    :Passthrough false)))\n\n        (UI.Area :Position .coin-position-1\n                  :Anchor Anchor.Top\n                  :Contents (-&gt;\n                            .coin-image-array (Take .coin-image-index) (UI.Image :Scale (float2 0.2))))\n\n        (UI.Area :Position .coin-position-2\n                  :Anchor Anchor.Top\n                  :Contents (-&gt;\n                            .coin-image-array (Take .coin-image-index) (UI.Image :Scale (float2 0.2))))\n\n        (UI.Area :Position .spikeball-position-1\n                  :Anchor Anchor.Top\n                  :Contents (-&gt;\n                            .spikeball-array (Take .spikeball-index) (UI.Image :Scale (float2 0.15))))\n\n        (UI.Area :Position (float2 -40 20)\n                  :Anchor Anchor.TopRight\n                  :Contents (-&gt;\n                            style (UI.Style)\n                            .score (ToString) (UI.Label)))))\n\n      (button-inputs)\n\n      (GFX.Render :Steps .render-steps))))\n\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre> <p>Now that we have our spiked cannonball system up, we can create as many as we want. And since we already set up our shards to take in arguments, this time it would be much easier!</p> <p>Create more spiked cannonballs.</p> <p>All we have to do is to follow these easy steps:</p> <ol> <li> <p>Create the variables for our new spiked cannonball.</p> </li> <li> <p>Create new <code>UI.Area</code> for each new spiked cannonball.</p> </li> <li> <p>Add in <code>spikeball-gravity-logic</code> to ensure it falls.</p> </li> <li> <p>Add in <code>randomise_spikeball_logic</code> to ensure that it randomizes.</p> </li> <li> <p>Ensure that Glod get's damaged whenever he gets hit.</p> </li> </ol> Code AddedFull Code So Far <pre><code>;; ---------- spikeball-2 -------------\n1.0 &gt;= .spikeball-velocity-2\n0.0 &gt;= .spikeball-y-2\n0.0 &gt;= .spikeball-x-2\n(float2 .spikeball-x-2 .spikeball-y-2) &gt;= .spikeball-position-2\n\n;; ---------- SpikeBall_3 -------------\n1.0 &gt;= .spikeball-velocity-3\n0.0 &gt;= .spikeball-y-3\n0.0 &gt;= .spikeball-x-3\n(float2 .spikeball-x-3 .spikeball-y-3) &gt;= .spikeball-position-3\n</code></pre> <p>Step 1 ! Create the variables</p> <pre><code>(UI.Area :Position .spikeball-position-2\n                  :Anchor Anchor.Top\n                  :Contents (-&gt;\n                            .spikeball-array (Take .spikeball-index) (UI.Image :Scale (float2 0.15))))\n\n(UI.Area :Position .spikeball-position-3\n                  :Anchor Anchor.Top\n                  :Contents (-&gt;\n                            .spikeball-array (Take .spikeball-index) (UI.Image :Scale (float2 0.15))))\n</code></pre> <p>Step 2 ! Create the UI.Area</p> <pre><code>(spikeball-gravity-logic .spikeball-y-2 .spikeball-velocity-2 .spikeball-position-2 .spikeball-x-2)\n(spikeball-gravity-logic .spikeball-y-3 .spikeball-velocity-3 .spikeball-position-3 .spikeball-x-3)\n</code></pre> <p>Step 3 ! Add the Gravity logic</p> <pre><code>(defloop spikeball-2\n  (randomise-spikeball .spikeball-x-2 .spikeball-y-2 .spikeball-velocity-2 .spikeball-position-2 3))\n(defloop spikeball-3\n  (randomise-spikeball .spikeball-x-3 .spikeball-y-3 .spikeball-velocity-3 .spikeball-position-3 4))\n</code></pre> <pre><code>(Step  spikeball-2)\n(Step  spikeball-3)\n</code></pre> <p>Step 4 ! Add the Randomise logic!</p> <pre><code>(spikeBall-collision-logic .spikeball-x-2 .spikeball-y-2)\n(spikeBall-collision-logic .spikeball-x-3 .spikeball-y-3)\n</code></pre> <p>Step 5 ! Add the collision logic (remember this is in our damaging shard)</p> <pre><code>(defshards LoadTexture [name]\n  (LoadImage name)\n  (GFX.Texture))\n\n(defshards initialize-character []\n  (LoadTexture \"GlodImages/Character1_Jumping_Left.png\") = .character-jumping-left\n  (LoadTexture \"GlodImages/Character1_Jumping_Right.png\") = .character-jumping-right\n\n  0 &gt;= .character-state\n  0 &gt;= .character-direction\n  true &gt;= .can-jump\n\n  0.0 &gt;= .X\n  620.0 &gt;= .Y\n  (float2 .X .Y) &gt;= .character-position\n  0.0 &gt;= .character-x-velocity\n  0.0 &gt;= .character-y-velocity\n  0.0 &gt;= .character-y-acceleration\n\n  ;; ---------- Character Idle Array (Facing Left) ----------\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png\") &gt;&gt; .idle-left-image-array\n\n  ;; ---------- Character Idle Array (Facing Right) ----------------\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_1.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_2.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_3.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_4.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_5.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_6.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_7.png\") &gt;&gt; .idle-right-image-array\n\n  0 &gt;= .idle-image-index\n  (Count .idle-left-image-array) = .idle-image-index-max\n  0.08 = .idle-animation-speed\n\n  ;; -------------- Walking Array (Facing Left) -----------------\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_1.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_2.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_3.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_4.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_5.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_6.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_7.png\") &gt;&gt; .walking-left-image-array\n\n  ;; ----------- Walking Array (Facing Right) ---------------\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_1.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_2.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_3.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_4.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_5.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_6.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_7.png\") &gt;&gt; .walking-right-image-array\n\n  (Count .walking-left-image-array) = .walking-image-index-max\n  0 &gt;= .walking-image-index\n  0.08 = .walking-animation-speed) ;; Reduce number to increase animation speed\n\n;; --------- Idle Animation Loop ---------\n(defloop idle-animation\n  .idle-image-index (Math.Add 1)\n  &gt; .idle-image-index\n  (When :Predicate (IsMoreEqual .idle-image-index-max)\n        :Action (-&gt; 0 &gt; .idle-image-index))\n  (Pause .idle-animation-speed))\n\n;; -------- Walking Animation Loop --------\n(defloop walking-animation\n  .walking-image-index (Math.Add 1)\n  &gt; .walking-image-index\n  (When :Predicate (IsMoreEqual .walking-image-index-max)\n        :Action (-&gt; 0 &gt; .walking-image-index))\n  (Pause .walking-animation-speed))\n\n;; ---------- character-boundary ------------\n\n(defshards clamp [var min max]\n  var (Max min) (Min max) &gt; var)\n\n;; ------------ Character Run Logic ----------------\n(defshards run-logic []\n  .X (Math.Add .character-x-velocity)\n  &gt; .X\n\n  (float2 .X .Y) &gt; .character-position\n\n  (clamp .X -600.0 600.0))\n\n;; ------------ Character gravity-logic ---------------\n(defshards gravity-logic []\n  .Y (Math.Add .character-y-velocity)\n  &gt; .Y\n\n  .character-y-velocity (Math.Add .character-y-acceleration)\n  &gt; .character-y-velocity\n\n  (float2 .X .Y) &gt; .character-position\n\n  (clamp .Y -620.0 620.0)\n  .Y\n  (When :Predicate (IsMoreEqual 620.0)\n        :Action (-&gt;\n                0.0 &gt; .character-y-velocity\n                0.0 &gt; .character-y-acceleration\n                true &gt; .can-jump\n                .character-state\n                (When :Predicate (Is 3)\n                      :Action (-&gt;\n                                0 &gt; .character-state)))))\n\n;; ------- Button Inputs ----------\n(defshards button-inputs []\n  (Inputs.KeyDown\n  :Key \"left\"\n  :Action (-&gt;\n            (Msg \"left\")\n\n            .character-state\n            (When :Predicate (Is 0)\n                  :Action (-&gt; 1 &gt; .character-state))\n\n            0 &gt; .character-direction\n            -5.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyDown\n  :Key \"right\"\n  :Action (-&gt;\n            (Msg \"right\")\n\n            .character-state\n            (When :Predicate (Is 0)\n                  :Action (-&gt; 2 &gt; .character-state))\n            1 &gt; .character-direction\n            5.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyDown\n  :Key \"up\"\n  :Action (-&gt;\n            (Msg \"up\")\n            3 &gt; .character-state\n            .can-jump\n            (When :Predicate (Is true)\n                  :Action (-&gt;\n                          -20.0 &gt; .character-y-velocity\n                          1.0 &gt;  .character-y-acceleration\n                          false &gt;= .can-jump))))\n\n  (Inputs.KeyUp\n  :Key \"left\"\n  :Action (-&gt;\n            0 &gt; .character-state\n            0.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyUp\n  :Key \"right\"\n  :Action (-&gt;\n            0 &gt; .character-state\n            0.0 &gt; .character-x-velocity)))\n\n;; -------------- Initialize Coin ----------\n(defshards initialize-coin []\n  (LoadTexture \"GlodImages/Coin/Coin_1.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_2.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_3.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_4.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_5.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_6.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_7.png\") &gt;&gt; .coin-image-array\n  (Count .coin-image-array) = .coin-image-index-max\n  0 &gt;= .coin-image-index\n  0.1 = .coin-animation-speed\n\n  ;; ----- Coin 1 ------\n  0.0 &gt;= .coinx-1\n  0.0 &gt;= .coiny-1\n  (float2 .coinx-1 .coiny-1) &gt;= .coin-position-1\n  0.0 &gt;= .coin-velocity-1\n  0.5 &gt;= .coin-acceleration\n\n  ;; ----- Coin 2 ----\n  0.0 &gt;= .coinx-2\n  0.0 &gt;= .coiny-2\n  (float2 .coinx-2 .coiny-2) &gt;= .coin-position-2\n  0.0 &gt;= .coin-velocity-2)\n\n;; -------------- Coin Animation ------------------\n(defloop coin-animation\n  .coin-image-index (Math.Add 1)\n  &gt; .coin-image-index\n  (When :Predicate (IsMoreEqual .coin-image-index-max)\n        :Action (-&gt; 0 &gt; .coin-image-index))\n\n  (Pause .coin-animation-speed))\n\n;; ------------- Coin Gravity ------------------\n(defshards coin-gravity-logic [coiny coinx coin-velocity coin-position]\n\n  coiny (Math.Add coin-velocity)\n  &gt; coiny\n\n  coin-velocity (Math.Add .coin-acceleration)\n  &gt; coin-velocity\n\n  (float2 coinx coiny) &gt; coin-position)\n\n;; ------------- Random Coin ------------------\n(defshards random-coin [coinx coiny coin-velocity coin-position pause-length]\n  coinx\n  (RandomFloat :Max 1200.0)\n  &gt; coinx\n  (Math.Subtract 600.0)\n  &gt; coinx\n\n  0.0 &gt; coiny\n  0.0 &gt; coin-velocity\n  (float2 coinx coiny) &gt; coin-position\n  (Pause pause-length))\n\n(defloop random-coin-1\n  (random-coin .coinx-1 .coiny-1 .coin-velocity-1 .coin-position-1 1.5))\n\n(defloop random-coin-2\n  (random-coin .coinx-2 .coiny-2 .coin-velocity-2 .coin-position-2 2.5))\n\n;; ------------ Initialize Spiked CanonBalls ---------------\n(defshards initialize-spiked-canonballs []\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall1.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall2.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall3.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall4.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall5.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall6.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall7.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall8.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall9.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall10.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall11.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall12.png\") &gt;&gt; .spikeball-array\n\n  (Count .spikeball-array) = .spikeball-array-index-max\n  0 &gt;= .spikeball-index\n  0.06 = .spikeball-animation-speed\n\n  ;; ---------- spikball-1 -------------\n  1.0 &gt;= .spikeball-velocity-1\n  0.0 &gt;= .spikeball-y-1\n  0.0 &gt;= .spikeball-x-1\n  (float2 .spikeball-x-1 .spikeball-y-1) &gt;= .spikeball-position-1\n\n  ;; ---------- spikeball-2 -------------\n  1.0 &gt;= .spikeball-velocity-2\n  0.0 &gt;= .spikeball-y-2\n  0.0 &gt;= .spikeball-x-2\n  (float2 .spikeball-x-2 .spikeball-y-2) &gt;= .spikeball-position-2\n\n;; ---------- SpikeBall_3 -------------\n  1.0 &gt;= .spikeball-velocity-3\n  0.0 &gt;= .spikeball-y-3\n  0.0 &gt;= .spikeball-x-3\n  (float2 .spikeball-x-3 .spikeball-y-3) &gt;= .spikeball-position-3\n\n  0.5 &gt;= .spikeball-acceleration)\n\n;;------------- Spiked CanonBall Animation -------------\n(defloop spiked-canonball-animation\n  .spikeball-index (Math.Add 1)\n  &gt; .spikeball-index\n  (When :Predicate (IsMoreEqual .spikeball-array-index-max)\n        :Action (-&gt; 0 &gt; .spikeball-index))\n\n  (Pause .spikeball-animation-speed))\n\n;; ------------- SpikeBall_Gravity_Logic -------------\n(defshards spikeball-gravity-logic [spikeball-y spikeball-velocity spikeball-position spikeball-x]\n  spikeball-y (Math.Add spikeball-velocity)\n  &gt; spikeball-y\n  spikeball-velocity (Math.Add .spikeball-acceleration)\n  &gt; spikeball-velocity\n  (float2 spikeball-x spikeball-y) &gt; spikeball-position)\n\n;; ------------- Randomise Spikeball ----------------\n(defshards randomise-spikeball [spikeball-x spikeball-y spikeball-velocity spikeball-position pausefloat]\n  spikeball-x\n  (RandomFloat :Max 1200.0)\n  &gt; spikeball-x\n  (Math.Subtract 600.0)\n  &gt; spikeball-x\n\n  0.0 &gt; spikeball-y\n  0.0 &gt; spikeball-velocity\n  (float2 spikeball-x spikeball-y) &gt; spikeball-position\n  .spikeball-x-1\n  (Pause pausefloat))\n\n(defloop spikeball-1\n  (randomise-spikeball .spikeball-x-1 .spikeball-y-1 .spikeball-velocity-1 .spikeball-position-1 2))\n(defloop spikeball-2\n  (randomise-spikeball .spikeball-x-2 .spikeball-y-2 .spikeball-velocity-2 .spikeball-position-2 3))\n(defloop spikeball-3\n  (randomise-spikeball .spikeball-x-3 .spikeball-y-3 .spikeball-velocity-3 .spikeball-position-3 4))\n\n;; --------- Game Elements ------------\n(defshards initialize-game-elements []\n  ;;------------ Scoring Limits ----------\n  0 &gt;= .score\n  false &gt;= .scored\n\n  .X (Math.Add 50.0)\n  &gt;= .scoringUpper-x-limit\n  .X (Math.Subtract 50.0)\n  &gt;= .scoringLower-x-limit\n\n  .Y (Math.Add 10.0)\n  &gt;= .scoringUpper-y-limit\n  .Y (Math.Subtract 10.0)\n  &gt;= .scoringLower-y-limit\n\n  ;; ---------- Damage Limits ------------\n  .X (Math.Add 50.0)\n  &gt;= .damageUpper-x-limit\n  .X (Math.Subtract 50.0)\n  &gt;= .damageLower-x-limit\n\n  .Y (Math.Add 5.0)\n  &gt;= .damageUpper-y-limit\n  .Y (Math.Subtract 5.0)\n  &gt;= .damageLower-y-limit\n\n  false &gt;= .damaged)\n\n;; --------- Scoring ----------\n(defshards score-collision [coinx coiny]\n  coinx\n  (When :Predicate (-&gt;\n                    (IsLess .scoringUpper-x-limit)\n                    (And)\n                    coinx (IsMore .scoringLower-x-limit)\n                    (And)\n                    coiny (IsLess .scoringUpper-y-limit)\n                    (And)\n                    coiny (IsMore .scoringLower-y-limit)\n                    (And)\n                    .scored (Is false))\n        :Action (-&gt;\n                true &gt; .scored\n                (Log \"Score: \"))))\n\n(defshards scoring []\n  .X (Math.Add 50.0)\n  &gt; .scoringUpper-x-limit\n  .X (Math.Subtract 50.0)\n  &gt; .scoringLower-x-limit\n\n  .Y (Math.Add 10.0)\n  &gt; .scoringUpper-y-limit\n  .Y (Math.Subtract 10.0)\n  &gt; .scoringLower-y-limit\n\n  (score-collision .coinx-1 .coiny-1)\n  (score-collision .coinx-2 .coiny-2)\n\n  .scored\n  (When :Predicate (Is true)\n        :Action (-&gt;\n                .score (Math.Add 1)\n                &gt; .score\n                false &gt; .scored)))\n\n;; ------------- spikeBall-collision-logic --------------\n(defshards spikeBall-collision-logic [spikeBall-x spikeBall-y]\n\n  spikeBall-x\n  (If :Predicate (-&gt; (IsLess .damageUpper-x-limit)\n                    (And)\n                    spikeBall-x (IsMore .damageLower-x-limit)\n                    (And)\n                    spikeBall-y (IsLess .damageUpper-y-limit)\n                    (And)\n                    spikeBall-y (IsMore .damageLower-y-limit))\n\n      :Then (-&gt; .damaged\n                (When :Predicate (Is false)\n                      :Action (-&gt;\n                              true &gt; .damaged\n                              (Log \"damaged: \"))))))\n\n;; -------------- Damaging --------------\n(defshards damaging []\n\n  .X (Math.Add 120.0)\n  &gt; .damageUpper-x-limit\n  .X (Math.Subtract 120.0)\n  &gt; .damageLower-x-limit\n\n  .Y (Math.Add 15.0)\n  &gt; .damageUpper-y-limit\n  .Y (Math.Subtract 15.0)\n  &gt; .damageLower-y-limit\n\n  (spikeBall-collision-logic .spikeball-x-1 .spikeball-y-1)\n  (spikeBall-collision-logic .spikeball-x-2 .spikeball-y-2)\n  (spikeBall-collision-logic .spikeball-x-3 .spikeball-y-3)\n\n  .damaged\n  (When :Predicate (Is true)\n        :Action (-&gt;\n                .score (Math.Subtract 1)\n                &gt; .score\n                false &gt; .damaged)))\n\n\n\n;; ------ UI Style --------\n(def style\n  {:override_text_style \"MyStyle\"\n  :text_styles\n  [{:name \"MyStyle\"\n    :size (float 46)\n    :family \"Monospace\"}]\n  :visuals\n  {:override_text_color (color 250 250 250)}})\n\n;;---------- main-wire ------------\n(defloop main-wire\n  (Setup\n  (initialize-character)\n  (initialize-coin)\n  (initialize-game-elements)\n  (initialize-spiked-canonballs))\n\n  (coin-gravity-logic .coiny-1 .coinx-1 .coin-velocity-1 .coin-position-1)\n  (coin-gravity-logic .coiny-2 .coinx-2 .coin-velocity-2 .coin-position-2)\n\n  (run-logic)\n  (gravity-logic)\n  (scoring)\n  (damaging)\n\n  (Step idle-animation)\n  (Step walking-animation)\n\n  (Step coin-animation)\n  (Step random-coin-1)\n  (Step random-coin-2)\n\n  (Step spiked-canonball-animation)\n  (spikeball-gravity-logic .spikeball-y-1 .spikeball-velocity-1 .spikeball-position-1 .spikeball-x-1)\n  (spikeball-gravity-logic .spikeball-y-2 .spikeball-velocity-2 .spikeball-position-2 .spikeball-x-2)\n  (spikeball-gravity-logic .spikeball-y-3 .spikeball-velocity-3 .spikeball-position-3 .spikeball-x-3)\n  (Step  spikeball-1)\n  (Step  spikeball-2)\n  (Step  spikeball-3)\n\n  (GFX.MainWindow\n  :Title \"MainWindow\" :Width 1920 :Height 1080\n  :Contents\n  (-&gt; (Setup\n        (GFX.DrawQueue) &gt;= .ui-draw-queue\n        (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n      .ui-draw-queue (GFX.ClearQueue)\n\n      (UI\n        .ui-draw-queue\n        (-&gt;\n        (UI.Area :Position .character-position\n                  :Anchor Anchor.Top\n                  :Contents (-&gt;\n                            .character-state\n                            (Match [0 (-&gt; .character-direction\n                                          (Match [0 (-&gt; .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n                                                  1 (-&gt; .idle-right-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))]\n                                                  :Passthrough false))\n                                    1 (-&gt; .walking-left-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n                                    2 (-&gt; .walking-right-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n                                    3 (-&gt;  .character-direction\n                                            (Match [0 (-&gt; .character-jumping-left (UI.Image :Scale (float2 0.2)))\n                                                    1 (-&gt; .character-jumping-right (UI.Image :Scale (float2 0.2)))]\n                                                  :Passthrough false))]\n                                    :Passthrough false)))\n\n        (UI.Area :Position .coin-position-1\n                  :Anchor Anchor.Top\n                  :Contents (-&gt;\n                            .coin-image-array (Take .coin-image-index) (UI.Image :Scale (float2 0.2))))\n\n        (UI.Area :Position .coin-position-2\n                  :Anchor Anchor.Top\n                  :Contents (-&gt;\n                            .coin-image-array (Take .coin-image-index) (UI.Image :Scale (float2 0.2))))\n\n        (UI.Area :Position .spikeball-position-1\n                  :Anchor Anchor.Top\n                  :Contents (-&gt;\n                            .spikeball-array (Take .spikeball-index) (UI.Image :Scale (float2 0.15))))\n\n        (UI.Area :Position .spikeball-position-2\n                  :Anchor Anchor.Top\n                  :Contents (-&gt;\n                            .spikeball-array (Take .spikeball-index) (UI.Image :Scale (float2 0.15))))\n\n        (UI.Area :Position .spikeball-position-3\n                  :Anchor Anchor.Top\n                  :Contents (-&gt;\n                            .spikeball-array (Take .spikeball-index) (UI.Image :Scale (float2 0.15))))\n\n        (UI.Area :Position (float2 -40 20)\n                  :Anchor Anchor.TopRight\n                  :Contents (-&gt;\n                            style (UI.Style)\n                            .score (ToString) (UI.Label)))))\n\n      (button-inputs)\n\n      (GFX.Render :Steps .render-steps))))\n\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre>"},{"location":"learn/shards/tutorials/glod-game/steps/step-6/#recap","title":"Recap","text":"<p>Good job in reaching this far!</p> <p>In this chapter, we created falling spiked cannonballs using the same logic as our coins.</p> <p>In the next chapter, we will round off and finish the game by adding a few more elements that will be the icing on the cake for our game.</p> <p>Almost there! \ud83d\ude00 </p> <p>See you in the next chapter.</p>"},{"location":"learn/shards/tutorials/glod-game/steps/step-7/","title":"Step 7","text":""},{"location":"learn/shards/tutorials/glod-game/steps/step-7/#polishing-up-the-game","title":"Polishing up the Game","text":"<p>At this point in the tutorial, we already possess a fully functional game that we can have fun playing.</p> <p>However, it could use some polishing to add more flair and make it more exciting... and that is what we will be doing in the final step of the tutorial.</p> <p>We will be:</p> <ol> <li> <p>Adding a visual effect that happens when Glod collects a coin.</p> </li> <li> <p>Adding a visual effect that happens when Glod is hit by a spiked cannonball.</p> </li> <li> <p>Adding a background image.</p> </li> <li> <p>Adding a timer and a Game Over screen.</p> </li> <li> <p>Adding a reset function to play the game again.</p> </li> </ol> <p>So let's get to it! \ud83d\udcaa\ud83c\udffc</p>"},{"location":"learn/shards/tutorials/glod-game/steps/step-7/#visual-effect-for-collecting","title":"Visual Effect for Collecting","text":"<p>To make collecting more satisfying, we will add a visual feedback that happens whenever Glod collects a coin.</p> <p>This will use the same logic and principles as when creating an animation.</p> <ul> <li>Download Scoring Effect Images here.</li> </ul> <p>Visual Feedback</p> <p>\"Feedback is information relayed to the player in response to an in-game interaction.\"  - Liam Charlton , Game Design Psychology: Signs &amp; Feedback   Here we use positive visual feedback to make it more satisfying whenever a player collects coins. The sense of satisfaction encourages the player to want to play more and continue playing.</p> <p>We also use negative visual feedback when a player collides with a spiked cannonball to discourage them from getting hit.</p> <p>Feedback can come in many forms - tactile, auditory, visual, and even as rewards!</p> <p>What are some feedback from your favorite games that you have found effective?</p> <p>You should be familiar with creating animations by now!</p> <p>As per before, let us create a new shard <code>initialize-effects</code> that will house all the variables that we need. Remember to call <code>initialize-effects</code> under <code>Setup</code> in <code>main-wire</code>.</p> Code Added <pre><code>;; ------------- initialize effects -------------\n(defshards initialize-effects []\n  (LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_1.png\") &gt;&gt; .score-effect-array\n  (LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_2.png\") &gt;&gt; .score-effect-array\n  (LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_3.png\") &gt;&gt; .score-effect-array\n  (LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_4.png\") &gt;&gt; .score-effect-array\n  (LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_5.png\") &gt;&gt; .score-effect-array\n  (LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_6.png\") &gt;&gt; .score-effect-array\n  (LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_7.png\") &gt;&gt; .score-effect-array\n  (LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_8.png\") &gt;&gt; .score-effect-array\n  (Count .score-effect-array) (Math.Subtract 1) &gt;= .score-effect-array-index-max\n  0 &gt;= .score-effect-array-index\n  0.05 &gt;=  .score-effect-animation-speed ;; Reduce number to increase animation speed\n  false &gt;= .score-effect-play\n\n  0.0 &gt;= .score-effect-position-x\n  0.0 &gt;= .score-effect-position-y\n  (float2 .score-effect-position-x .score-effect-position-y) &gt;= .score-effect-position)\n</code></pre> <pre><code>(initialize-effects)\n</code></pre> <p>Next we create a <code>UI.Area</code> that will house our animation.</p> Code Added <pre><code>;; ----------------- Visual Effects  -------------------\n  (UI.Area :Position .score-effect-position\n      :Anchor Anchor.Top\n      :Contents (-&gt;\n            .score-effect-array (Take .score-effect-array-index) (UI.Image :Scale (float2 0.15))))\n</code></pre> <p>We adjust the value of <code>.character-x-velocity</code> whenever the left and right directional keys are pressed.</p> <p>Remember to return the value of <code>.character-x-velocity</code> to zero when the directional keys are released - otherwise Glod will move to the left or right forever!</p> Code Added <pre><code>;; ------------ ScoreEffect Animation Position ------------\n(defshards scoreEffect-animation-position []\n  .Y (Math.Add -15.0)\n  &gt; .score-effect-position-y\n  .X\n  &gt; .score-effect-position-x\n\n  (float2 .score-effect-position-x .score-effect-position-y)\n  &gt; .score-effect-position)\n</code></pre> <pre><code>;; ------------ ScoreEffect Animation ------------\n(defloop scoreEffect-animation-logic\n  .score-effect-play\n  (When\n   :Predicate (Is true)\n   :Action\n   (-&gt;\n    .score-effect-array-index (Math.Add 1)\n    &gt; .score-effect-array-index\n    (When\n     :Predicate (IsMore .score-effect-array-index-max)\n     :Action\n     (-&gt;\n      0 &gt; .score-effect-array-index\n      false &gt; .score-effect-play))))\n  (Pause .score-effect-animation-speed))\n</code></pre> <p>Next we have some logic to loop and play our animation. This animation plays when <code>.score-effect-play</code> is true.</p> <p>This variable will then go false at the end of the animation for it to stop. This is the technique to use when you want an animation to only play once.</p> Code Added <pre><code>true &gt; .score-effect-play\n</code></pre> <p>Then remember to make <code>.score-effect-play</code> true whenever we collect a coin. We can add this line in our scoring code that we have written previously.</p> Code Added <pre><code>(scoreEffect-animation-position)\n(Step scoreEffect-animation-logic)\n</code></pre> <p>Lastly, remember to call your shard and loop in your <code>main-wire</code>.</p> Full Code So Far <pre><code>(defshards LoadTexture [name]\n  (LoadImage name)\n  (GFX.Texture))\n\n(defshards initialize-character []\n  (LoadTexture \"GlodImages/Character1_Jumping_Left.png\") = .character-jumping-left\n  (LoadTexture \"GlodImages/Character1_Jumping_Right.png\") = .character-jumping-right\n\n  0 &gt;= .character-state\n  0 &gt;= .character-direction\n  true &gt;= .can-jump\n\n  0.0 &gt;= .X\n  620.0 &gt;= .Y\n  (float2 .X .Y) &gt;= .character-position\n  0.0 &gt;= .character-x-velocity\n  0.0 &gt;= .character-y-velocity\n  0.0 &gt;= .character-y-acceleration\n\n  ;; ---------- Character Idle Array (Facing Left) ----------\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png\") &gt;&gt; .idle-left-image-array\n\n  ;; ---------- Character Idle Array (Facing Right) ----------------\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_1.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_2.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_3.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_4.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_5.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_6.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_7.png\") &gt;&gt; .idle-right-image-array\n\n  0 &gt;= .idle-image-index\n  (Count .idle-left-image-array) = .idle-image-index-max\n  0.08 = .idle-animation-speed\n\n  ;; -------------- Walking Array (Facing Left) -----------------\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_1.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_2.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_3.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_4.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_5.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_6.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_7.png\") &gt;&gt; .walking-left-image-array\n\n  ;; ----------- Walking Array (Facing Right) ---------------\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_1.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_2.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_3.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_4.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_5.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_6.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_7.png\") &gt;&gt; .walking-right-image-array\n\n  (Count .walking-left-image-array) = .walking-image-index-max\n  0 &gt;= .walking-image-index\n  0.08 = .walking-animation-speed) ;; Reduce number to increase animation speed\n\n;; --------- Idle Animation Loop ---------\n(defloop idle-animation\n  .idle-image-index (Math.Add 1)\n  &gt; .idle-image-index\n  (When :Predicate (IsMoreEqual .idle-image-index-max)\n        :Action (-&gt; 0 &gt; .idle-image-index))\n  (Pause .idle-animation-speed))\n\n;; -------- Walking Animation Loop --------\n(defloop walking-animation\n  .walking-image-index (Math.Add 1)\n  &gt; .walking-image-index\n  (When :Predicate (IsMoreEqual .walking-image-index-max)\n        :Action (-&gt; 0 &gt; .walking-image-index))\n  (Pause .walking-animation-speed))\n\n;; ---------- character-boundary ------------\n\n(defshards clamp [var min max]\n  var (Max min) (Min max) &gt; var)\n\n;; ------------ Character Run Logic ----------------\n(defshards run-logic []\n  .X (Math.Add .character-x-velocity)\n  &gt; .X\n\n  (float2 .X .Y) &gt; .character-position\n\n  (clamp .X -600.0 600.0))\n\n;; ------------ Character gravity-logic ---------------\n(defshards gravity-logic []\n  .Y (Math.Add .character-y-velocity)\n  &gt; .Y\n\n  .character-y-velocity (Math.Add .character-y-acceleration)\n  &gt; .character-y-velocity\n\n  (float2 .X .Y) &gt; .character-position\n\n  (clamp .Y -620.0 620.0)\n  .Y\n  (When :Predicate (IsMoreEqual 620.0)\n        :Action (-&gt;\n                0.0 &gt; .character-y-velocity\n                0.0 &gt; .character-y-acceleration\n                true &gt; .can-jump\n                .character-state\n                (When :Predicate (Is 3)\n                      :Action (-&gt;\n                                0 &gt; .character-state)))))\n\n;; ------- Button Inputs ----------\n(defshards button-inputs []\n  (Inputs.KeyDown\n  :Key \"left\"\n  :Action (-&gt;\n            (Msg \"left\")\n\n            .character-state\n            (When :Predicate (Is 0)\n                  :Action (-&gt; 1 &gt; .character-state))\n\n            0 &gt; .character-direction\n            -5.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyDown\n  :Key \"right\"\n  :Action (-&gt;\n            (Msg \"right\")\n\n            .character-state\n            (When :Predicate (Is 0)\n                  :Action (-&gt; 2 &gt; .character-state))\n            1 &gt; .character-direction\n            5.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyDown\n  :Key \"up\"\n  :Action (-&gt;\n            (Msg \"up\")\n            3 &gt; .character-state\n            .can-jump\n            (When :Predicate (Is true)\n                  :Action (-&gt;\n                          -20.0 &gt; .character-y-velocity\n                          1.0 &gt;  .character-y-acceleration\n                          false &gt;= .can-jump))))\n\n  (Inputs.KeyUp\n  :Key \"left\"\n  :Action (-&gt;\n            0 &gt; .character-state\n            0.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyUp\n  :Key \"right\"\n  :Action (-&gt;\n            0 &gt; .character-state\n            0.0 &gt; .character-x-velocity)))\n\n;; -------------- Initialize Coin ----------\n(defshards initialize-coin []\n  (LoadTexture \"GlodImages/Coin/Coin_1.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_2.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_3.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_4.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_5.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_6.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_7.png\") &gt;&gt; .coin-image-array\n  (Count .coin-image-array) = .coin-image-index-max\n  0 &gt;= .coin-image-index\n  0.1 = .coin-animation-speed\n\n  ;; ----- Coin 1 ------\n  0.0 &gt;= .coinx-1\n  0.0 &gt;= .coiny-1\n  (float2 .coinx-1 .coiny-1) &gt;= .coin-position-1\n  0.0 &gt;= .coin-velocity-1\n  0.5 &gt;= .coin-acceleration\n\n  ;; ----- Coin 2 ----\n  0.0 &gt;= .coinx-2\n  0.0 &gt;= .coiny-2\n  (float2 .coinx-2 .coiny-2) &gt;= .coin-position-2\n  0.0 &gt;= .coin-velocity-2)\n\n;; -------------- Coin Animation ------------------\n(defloop coin-animation\n  .coin-image-index (Math.Add 1)\n  &gt; .coin-image-index\n  (When :Predicate (IsMoreEqual .coin-image-index-max)\n        :Action (-&gt; 0 &gt; .coin-image-index))\n\n  (Pause .coin-animation-speed))\n\n;; ------------- Coin Gravity ------------------\n(defshards coin-gravity-logic [coiny coinx coin-velocity coin-position]\n\n  coiny (Math.Add coin-velocity)\n  &gt; coiny\n\n  coin-velocity (Math.Add .coin-acceleration)\n  &gt; coin-velocity\n\n  (float2 coinx coiny) &gt; coin-position)\n\n;; ------------- Random Coin ------------------\n(defshards random-coin [coinx coiny coin-velocity coin-position pause-length]\n  coinx\n  (RandomFloat :Max 1200.0)\n  &gt; coinx\n  (Math.Subtract 600.0)\n  &gt; coinx\n\n  0.0 &gt; coiny\n  0.0 &gt; coin-velocity\n  (float2 coinx coiny) &gt; coin-position\n  (Pause pause-length))\n\n(defloop random-coin-1\n  (random-coin .coinx-1 .coiny-1 .coin-velocity-1 .coin-position-1 1.5))\n\n(defloop random-coin-2\n  (random-coin .coinx-2 .coiny-2 .coin-velocity-2 .coin-position-2 2.5))\n\n;; ------------ Initialize Spiked CanonBalls ---------------\n(defshards initialize-spiked-canonballs []\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall1.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall2.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall3.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall4.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall5.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall6.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall7.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall8.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall9.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall10.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall11.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall12.png\") &gt;&gt; .spikeball-array\n\n  (Count .spikeball-array) = .spikeball-array-index-max\n  0 &gt;= .spikeball-index\n  0.06 = .spikeball-animation-speed\n\n  ;; ---------- spikball-1 -------------\n  1.0 &gt;= .spikeball-velocity-1\n  0.0 &gt;= .spikeball-y-1\n  0.0 &gt;= .spikeball-x-1\n  (float2 .spikeball-x-1 .spikeball-y-1) &gt;= .spikeball-position-1\n\n  ;; ---------- spikeball-2 -------------\n  1.0 &gt;= .spikeball-velocity-2\n  0.0 &gt;= .spikeball-y-2\n  0.0 &gt;= .spikeball-x-2\n  (float2 .spikeball-x-2 .spikeball-y-2) &gt;= .spikeball-position-2\n\n;; ---------- SpikeBall_3 -------------\n  1.0 &gt;= .spikeball-velocity-3\n  0.0 &gt;= .spikeball-y-3\n  0.0 &gt;= .spikeball-x-3\n  (float2 .spikeball-x-3 .spikeball-y-3) &gt;= .spikeball-position-3\n\n  0.5 &gt;= .spikeball-acceleration)\n\n;;------------- Spiked CanonBall Animation -------------\n(defloop spiked-canonball-animation\n  .spikeball-index (Math.Add 1)\n  &gt; .spikeball-index\n  (When :Predicate (IsMoreEqual .spikeball-array-index-max)\n        :Action (-&gt; 0 &gt; .spikeball-index))\n\n  (Pause .spikeball-animation-speed))\n\n;; ------------- SpikeBall_Gravity_Logic -------------\n(defshards spikeball-gravity-logic [spikeball-y spikeball-velocity spikeball-position spikeball-x]\n  spikeball-y (Math.Add spikeball-velocity)\n  &gt; spikeball-y\n  spikeball-velocity (Math.Add .spikeball-acceleration)\n  &gt; spikeball-velocity\n  (float2 spikeball-x spikeball-y) &gt; spikeball-position)\n\n;; ------------- Randomise Spikeball ----------------\n(defshards randomise-spikeball [spikeball-x spikeball-y spikeball-velocity spikeball-position pausefloat]\n  spikeball-x\n  (RandomFloat :Max 1200.0)\n  &gt; spikeball-x\n  (Math.Subtract 600.0)\n  &gt; spikeball-x\n\n  0.0 &gt; spikeball-y\n  0.0 &gt; spikeball-velocity\n  (float2 spikeball-x spikeball-y) &gt; spikeball-position\n  .spikeball-x-1\n  (Pause pausefloat))\n\n(defloop spikeball-1\n  (randomise-spikeball .spikeball-x-1 .spikeball-y-1 .spikeball-velocity-1 .spikeball-position-1 2))\n(defloop spikeball-2\n  (randomise-spikeball .spikeball-x-2 .spikeball-y-2 .spikeball-velocity-2 .spikeball-position-2 3))\n(defloop spikeball-3\n  (randomise-spikeball .spikeball-x-3 .spikeball-y-3 .spikeball-velocity-3 .spikeball-position-3 4))\n\n;; --------- Game Elements ------------\n(defshards initialize-game-elements []\n  ;;------------ Scoring Limits ----------\n  0 &gt;= .score\n  false &gt;= .scored\n\n  .X (Math.Add 50.0)\n  &gt;= .scoringUpper-x-limit\n  .X (Math.Subtract 50.0)\n  &gt;= .scoringLower-x-limit\n\n  .Y (Math.Add 10.0)\n  &gt;= .scoringUpper-y-limit\n  .Y (Math.Subtract 10.0)\n  &gt;= .scoringLower-y-limit\n\n  ;; ---------- Damage Limits ------------\n  .X (Math.Add 50.0)\n  &gt;= .damageUpper-x-limit\n  .X (Math.Subtract 50.0)\n  &gt;= .damageLower-x-limit\n\n  .Y (Math.Add 5.0)\n  &gt;= .damageUpper-y-limit\n  .Y (Math.Subtract 5.0)\n  &gt;= .damageLower-y-limit\n\n  false &gt;= .damaged)\n\n;; --------- Scoring ----------\n(defshards score-collision [coinx coiny]\n  coinx\n  (When :Predicate (-&gt;\n                    (IsLess .scoringUpper-x-limit)\n                    (And)\n                    coinx (IsMore .scoringLower-x-limit)\n                    (And)\n                    coiny (IsLess .scoringUpper-y-limit)\n                    (And)\n                    coiny (IsMore .scoringLower-y-limit)\n                    (And)\n                    .scored (Is false))\n        :Action (-&gt;\n                true &gt; .scored\n                (Log \"Score: \"))))\n\n(defshards scoring []\n  .X (Math.Add 50.0)\n  &gt; .scoringUpper-x-limit\n  .X (Math.Subtract 50.0)\n  &gt; .scoringLower-x-limit\n\n  .Y (Math.Add 10.0)\n  &gt; .scoringUpper-y-limit\n  .Y (Math.Subtract 10.0)\n  &gt; .scoringLower-y-limit\n\n  (score-collision .coinx-1 .coiny-1)\n  (score-collision .coinx-2 .coiny-2)\n\n  .scored\n  (When :Predicate (Is true)\n        :Action (-&gt;\n                .score (Math.Add 1)\n                &gt; .score\n                true &gt; .score-effect-play\n                false &gt; .scored)))\n\n;; ------------- spikeBall-collision-logic --------------\n(defshards spikeBall-collision-logic [spikeBall-x spikeBall-y]\n\n  spikeBall-x\n  (If :Predicate (-&gt; (IsLess .damageUpper-x-limit)\n                    (And)\n                    spikeBall-x (IsMore .damageLower-x-limit)\n                    (And)\n                    spikeBall-y (IsLess .damageUpper-y-limit)\n                    (And)\n                    spikeBall-y (IsMore .damageLower-y-limit))\n\n      :Then (-&gt; .damaged\n                (When :Predicate (Is false)\n                      :Action (-&gt;\n                              true &gt; .damaged\n                              (Log \"damaged: \"))))))\n\n;; -------------- Damaging --------------\n(defshards damaging []\n\n  .X (Math.Add 120.0)\n  &gt; .damageUpper-x-limit\n  .X (Math.Subtract 120.0)\n  &gt; .damageLower-x-limit\n\n  .Y (Math.Add 15.0)\n  &gt; .damageUpper-y-limit\n  .Y (Math.Subtract 15.0)\n  &gt; .damageLower-y-limit\n\n  (spikeBall-collision-logic .spikeball-x-1 .spikeball-y-1)\n  (spikeBall-collision-logic .spikeball-x-2 .spikeball-y-2)\n  (spikeBall-collision-logic .spikeball-x-3 .spikeball-y-3)\n\n  .damaged\n  (When :Predicate (Is true)\n        :Action (-&gt;\n                .score (Math.Subtract 1)\n                &gt; .score\n                false &gt; .damaged)))\n\n;; ------------- initialize effects -------------\n(defshards initialize-effects []\n  (LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_1.png\") &gt;&gt; .score-effect-array\n  (LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_2.png\") &gt;&gt; .score-effect-array\n  (LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_3.png\") &gt;&gt; .score-effect-array\n  (LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_4.png\") &gt;&gt; .score-effect-array\n  (LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_5.png\") &gt;&gt; .score-effect-array\n  (LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_6.png\") &gt;&gt; .score-effect-array\n  (LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_7.png\") &gt;&gt; .score-effect-array\n  (LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_8.png\") &gt;&gt; .score-effect-array\n  (Count .score-effect-array) (Math.Subtract 1) &gt;= .score-effect-array-index-max\n  0 &gt;= .score-effect-array-index\n  0.05 &gt;=  .score-effect-animation-speed ;; Reduce number to increase animation speed\n  false &gt;= .score-effect-play\n\n  0.0 &gt;= .score-effect-position-x\n  0.0 &gt;= .score-effect-position-y\n  (float2 .score-effect-position-x .score-effect-position-y) &gt;= .score-effect-position)\n\n;; ------------ ScoreEffect_Animation_Position ------------\n(defshards scoreEffect-animation-position []\n  .Y (Math.Add -15.0)\n  &gt; .score-effect-position-y\n\n  .X\n  &gt; .score-effect-position-x\n\n  (float2 .score-effect-position-x .score-effect-position-y)\n  &gt; .score-effect-position)\n\n;; ------------ ScoreEffect Animation ------------\n(defloop scoreEffect-animation-logic\n\n  .score-effect-play\n  (When :Predicate (Is true)\n        :Action (-&gt;\n                .score-effect-array-index (Math.Add 1)\n                &gt; .score-effect-array-index\n                (When :Predicate (IsMore .score-effect-array-index-max)\n                      :Action (-&gt;\n                                0 &gt; .score-effect-array-index\n                                false &gt; .score-effect-play))))\n\n\n  (Pause .score-effect-animation-speed))\n\n;; ------ UI Style --------\n(def style\n  {:override_text_style \"MyStyle\"\n  :text_styles\n  [{:name \"MyStyle\"\n    :size (float 46)\n    :family \"Monospace\"}]\n  :visuals\n  {:override_text_color (color 250 250 250)}})\n\n;;---------- main-wire ------------\n(defloop main-wire\n  (Setup\n  (initialize-character)\n  (initialize-coin)\n  (initialize-game-elements)\n  (initialize-spiked-canonballs)\n  (initialize-effects))\n\n  (coin-gravity-logic .coiny-1 .coinx-1 .coin-velocity-1 .coin-position-1)\n  (coin-gravity-logic .coiny-2 .coinx-2 .coin-velocity-2 .coin-position-2)\n\n  (run-logic)\n  (gravity-logic)\n  (scoring)\n  (damaging)\n\n  (Step idle-animation)\n  (Step walking-animation)\n\n  (Step coin-animation)\n  (Step random-coin-1)\n  (Step random-coin-2)\n\n  (Step spiked-canonball-animation)\n  (spikeball-gravity-logic .spikeball-y-1 .spikeball-velocity-1 .spikeball-position-1 .spikeball-x-1)\n  (spikeball-gravity-logic .spikeball-y-2 .spikeball-velocity-2 .spikeball-position-2 .spikeball-x-2)\n  (spikeball-gravity-logic .spikeball-y-3 .spikeball-velocity-3 .spikeball-position-3 .spikeball-x-3)\n  (Step  spikeball-1)\n  (Step  spikeball-2)\n  (Step  spikeball-3)\n\n  (scoreEffect-animation-position)\n  (Step scoreEffect-animation-logic)\n\n  (GFX.MainWindow\n  :Title \"MainWindow\" :Width 1920 :Height 1080\n  :Contents\n  (-&gt; (Setup\n        (GFX.DrawQueue) &gt;= .ui-draw-queue\n        (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n      .ui-draw-queue (GFX.ClearQueue)\n\n      (UI\n        .ui-draw-queue\n        (-&gt;\n        (UI.Area :Position .character-position\n                  :Anchor Anchor.Top\n                  :Contents (-&gt;\n                            .character-state\n                            (Match [0 (-&gt; .character-direction\n                                          (Match [0 (-&gt; .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n                                                  1 (-&gt; .idle-right-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))]\n                                                  :Passthrough false))\n                                    1 (-&gt; .walking-left-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n                                    2 (-&gt; .walking-right-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n                                    3 (-&gt;  .character-direction\n                                            (Match [0 (-&gt; .character-jumping-left (UI.Image :Scale (float2 0.2)))\n                                                    1 (-&gt; .character-jumping-right (UI.Image :Scale (float2 0.2)))]\n                                                  :Passthrough false))]\n                                    :Passthrough false)))\n\n        ;; ---------- Coins -----------\n\n        (UI.Area :Position .coin-position-1\n                  :Anchor Anchor.Top\n                  :Contents (-&gt;\n                            .coin-image-array (Take .coin-image-index) (UI.Image :Scale (float2 0.2))))\n\n        (UI.Area :Position .coin-position-2\n                  :Anchor Anchor.Top\n                  :Contents (-&gt;\n                            .coin-image-array (Take .coin-image-index) (UI.Image :Scale (float2 0.2))))\n\n        ;; ------------SpikeBalls ------------\n\n        (UI.Area :Position .spikeball-position-1\n                  :Anchor Anchor.Top\n                  :Contents (-&gt;\n                            .spikeball-array (Take .spikeball-index) (UI.Image :Scale (float2 0.15))))\n\n        (UI.Area :Position .spikeball-position-2\n                  :Anchor Anchor.Top\n                  :Contents (-&gt;\n                            .spikeball-array (Take .spikeball-index) (UI.Image :Scale (float2 0.15))))\n\n        (UI.Area :Position .spikeball-position-3\n                  :Anchor Anchor.Top\n                  :Contents (-&gt;\n                            .spikeball-array (Take .spikeball-index) (UI.Image :Scale (float2 0.15))))\n\n        ;; ----------------- Visual Effects  -------------------\n        (UI.Area :Position .score-effect-position\n                  :Anchor Anchor.Top\n                  :Contents (-&gt;\n                            .score-effect-array (Take .score-effect-array-index) (UI.Image :Scale (float2 0.15))))\n\n        (UI.Area :Position (float2 -40 20)\n                  :Anchor Anchor.TopRight\n                  :Contents (-&gt;\n                            style (UI.Style)\n                            .score (ToString) (UI.Label)))))\n\n      (button-inputs)\n\n      (GFX.Render :Steps .render-steps))))\n\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre> <p>Now, it should be more fun for you to collect coins! \ud83d\udcb0</p>"},{"location":"learn/shards/tutorials/glod-game/steps/step-7/#step-72","title":"Step 7.2","text":"<p>Now following the same logic, we will create feedback for when we are damaged.</p> <ul> <li>Download Damage Effect images here.</li> </ul> <p>Create all the variables that we need for creating animations. Add it under <code>initialize-effects</code>.</p> Code Added <pre><code>;; --------------- Damaged Effect ----------------\n(LoadTexture \"GlodImages/Damage_Effect/Damaged_Effect_1.png\") &gt;&gt; .damage-effect-array\n(LoadTexture \"GlodImages/Damage_Effect/Damaged_Effect_2.png\") &gt;&gt; .damage-effect-array\n(LoadTexture \"GlodImages/Damage_Effect/Damaged_Effect_3.png\") &gt;&gt; .damage-effect-array\n(LoadTexture \"GlodImages/Damage_Effect/Damaged_Effect_4.png\") &gt;&gt; .damage-effect-array\n(LoadTexture \"GlodImages/Damage_Effect/Damaged_Effect_5.png\") &gt;&gt; .damage-effect-array\n(LoadTexture \"GlodImages/Damage_Effect/Damaged_Effect_6.png\") &gt;&gt; .damage-effect-array\n(LoadTexture \"GlodImages/Damage_Effect/Damaged_Effect_7.png\") &gt;&gt; .damage-effect-array\n(LoadTexture \"GlodImages/Damage_Effect/Damaged_Effect_8.png\") &gt;&gt; .damage-effect-array\n(Count .damage-effect-array) (Math.Subtract 1) &gt;= .damage-effect-array-index-max\n0 &gt;= .damage-effect-array-index\n0.02 &gt;=  .damage-effect-animation-speed ;; Reduce number to increase animation speed\nfalse &gt;= .damage-effect-play\n</code></pre> <p>Create a <code>UI.Area</code> which will house our animation.</p> Code Added <pre><code>(UI.Area :Position (float2 0 0)\n        :Anchor Anchor.TopLeft\n        :Contents (-&gt;\n                      .damage-effect-array (Take .damage-effect-array-index) (UI.Image :Scale (float2 10))))\n</code></pre> <p>Create our logic to loop our damage effect animation which plays when <code>.damage-effect-play</code> is true.</p> Code Added <pre><code>;; ------------ DamageEffect Animation ------------\n(defloop damage-effect-animation-logic\n\n  .damage-effect-play\n  (When :Predicate (Is true)\n        :Action (-&gt;\n                .damage-effect-array-index (Math.Add 1)\n                &gt; .damage-effect-array-index\n                (When :Predicate (IsMore .damage-effect-array-index-max)\n                      :Action (-&gt;\n                                0 &gt; .damage-effect-array-index\n                                false &gt; .damage-effect-play))))\n\n\n  (Pause .damage-effect-animation-speed))\n</code></pre> <p>Make <code>.damage-effect-play</code> <code>true</code> whenever we collide with our spiked cannonballs. This will be added to our <code>spikeball-damage-logic</code>, which we have created earlier.</p> Code AddedFull Code So Far <pre><code>true &gt; .damage-effect-play\n</code></pre> <pre><code>(defshards LoadTexture [name]\n  (LoadImage name)\n  (GFX.Texture))\n\n(defshards initialize-character []\n  (LoadTexture \"GlodImages/Character1_Jumping_Left.png\") = .character-jumping-left\n  (LoadTexture \"GlodImages/Character1_Jumping_Right.png\") = .character-jumping-right\n\n  0 &gt;= .character-state\n  0 &gt;= .character-direction\n  true &gt;= .can-jump\n\n  0.0 &gt;= .X\n  620.0 &gt;= .Y\n  (float2 .X .Y) &gt;= .character-position\n  0.0 &gt;= .character-x-velocity\n  0.0 &gt;= .character-y-velocity\n  0.0 &gt;= .character-y-acceleration\n\n  ;; ---------- Character Idle Array (Facing Left) ----------\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png\") &gt;&gt; .idle-left-image-array\n\n  ;; ---------- Character Idle Array (Facing Right) ----------------\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_1.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_2.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_3.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_4.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_5.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_6.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_7.png\") &gt;&gt; .idle-right-image-array\n\n  0 &gt;= .idle-image-index\n  (Count .idle-left-image-array) = .idle-image-index-max\n  0.08 = .idle-animation-speed\n\n  ;; -------------- Walking Array (Facing Left) -----------------\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_1.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_2.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_3.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_4.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_5.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_6.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_7.png\") &gt;&gt; .walking-left-image-array\n\n  ;; ----------- Walking Array (Facing Right) ---------------\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_1.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_2.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_3.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_4.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_5.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_6.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_7.png\") &gt;&gt; .walking-right-image-array\n\n  (Count .walking-left-image-array) = .walking-image-index-max\n  0 &gt;= .walking-image-index\n  0.08 = .walking-animation-speed) ;; Reduce number to increase animation speed\n\n;; --------- Idle Animation Loop ---------\n(defloop idle-animation\n  .idle-image-index (Math.Add 1)\n  &gt; .idle-image-index\n  (When :Predicate (IsMoreEqual .idle-image-index-max)\n        :Action (-&gt; 0 &gt; .idle-image-index))\n  (Pause .idle-animation-speed))\n\n;; -------- Walking Animation Loop --------\n(defloop walking-animation\n  .walking-image-index (Math.Add 1)\n  &gt; .walking-image-index\n  (When :Predicate (IsMoreEqual .walking-image-index-max)\n        :Action (-&gt; 0 &gt; .walking-image-index))\n  (Pause .walking-animation-speed))\n\n;; ---------- character-boundary ------------\n\n(defshards clamp [var min max]\n  var (Max min) (Min max) &gt; var)\n\n;; ------------ Character Run Logic ----------------\n(defshards run-logic []\n  .X (Math.Add .character-x-velocity)\n  &gt; .X\n\n  (float2 .X .Y) &gt; .character-position\n\n  (clamp .X -600.0 600.0))\n\n;; ------------ Character gravity-logic ---------------\n(defshards gravity-logic []\n  .Y (Math.Add .character-y-velocity)\n  &gt; .Y\n\n  .character-y-velocity (Math.Add .character-y-acceleration)\n  &gt; .character-y-velocity\n\n  (float2 .X .Y) &gt; .character-position\n\n  (clamp .Y -620.0 620.0)\n  .Y\n  (When :Predicate (IsMoreEqual 620.0)\n        :Action (-&gt;\n                0.0 &gt; .character-y-velocity\n                0.0 &gt; .character-y-acceleration\n                true &gt; .can-jump\n                .character-state\n                (When :Predicate (Is 3)\n                      :Action (-&gt;\n                                0 &gt; .character-state)))))\n\n;; ------- Button Inputs ----------\n(defshards button-inputs []\n  (Inputs.KeyDown\n  :Key \"left\"\n  :Action (-&gt;\n            (Msg \"left\")\n\n            .character-state\n            (When :Predicate (Is 0)\n                  :Action (-&gt; 1 &gt; .character-state))\n\n            0 &gt; .character-direction\n            -5.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyDown\n  :Key \"right\"\n  :Action (-&gt;\n            (Msg \"right\")\n\n            .character-state\n            (When :Predicate (Is 0)\n                  :Action (-&gt; 2 &gt; .character-state))\n            1 &gt; .character-direction\n            5.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyDown\n  :Key \"up\"\n  :Action (-&gt;\n            (Msg \"up\")\n            3 &gt; .character-state\n            .can-jump\n            (When :Predicate (Is true)\n                  :Action (-&gt;\n                          -20.0 &gt; .character-y-velocity\n                          1.0 &gt;  .character-y-acceleration\n                          false &gt;= .can-jump))))\n\n  (Inputs.KeyUp\n  :Key \"left\"\n  :Action (-&gt;\n            0 &gt; .character-state\n            0.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyUp\n  :Key \"right\"\n  :Action (-&gt;\n            0 &gt; .character-state\n            0.0 &gt; .character-x-velocity)))\n\n;; -------------- Initialize Coin ----------\n(defshards initialize-coin []\n  (LoadTexture \"GlodImages/Coin/Coin_1.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_2.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_3.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_4.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_5.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_6.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_7.png\") &gt;&gt; .coin-image-array\n  (Count .coin-image-array) = .coin-image-index-max\n  0 &gt;= .coin-image-index\n  0.1 = .coin-animation-speed\n\n  ;; ----- Coin 1 ------\n  0.0 &gt;= .coinx-1\n  0.0 &gt;= .coiny-1\n  (float2 .coinx-1 .coiny-1) &gt;= .coin-position-1\n  0.0 &gt;= .coin-velocity-1\n  0.5 &gt;= .coin-acceleration\n\n  ;; ----- Coin 2 ----\n  0.0 &gt;= .coinx-2\n  0.0 &gt;= .coiny-2\n  (float2 .coinx-2 .coiny-2) &gt;= .coin-position-2\n  0.0 &gt;= .coin-velocity-2)\n\n;; -------------- Coin Animation ------------------\n(defloop coin-animation\n  .coin-image-index (Math.Add 1)\n  &gt; .coin-image-index\n  (When :Predicate (IsMoreEqual .coin-image-index-max)\n        :Action (-&gt; 0 &gt; .coin-image-index))\n\n  (Pause .coin-animation-speed))\n\n;; ------------- Coin Gravity ------------------\n(defshards coin-gravity-logic [coiny coinx coin-velocity coin-position]\n\n  coiny (Math.Add coin-velocity)\n  &gt; coiny\n\n  coin-velocity (Math.Add .coin-acceleration)\n  &gt; coin-velocity\n\n  (float2 coinx coiny) &gt; coin-position)\n\n;; ------------- Random Coin ------------------\n(defshards random-coin [coinx coiny coin-velocity coin-position pause-length]\n  coinx\n  (RandomFloat :Max 1200.0)\n  &gt; coinx\n  (Math.Subtract 600.0)\n  &gt; coinx\n\n  0.0 &gt; coiny\n  0.0 &gt; coin-velocity\n  (float2 coinx coiny) &gt; coin-position\n  (Pause pause-length))\n\n(defloop random-coin-1\n  (random-coin .coinx-1 .coiny-1 .coin-velocity-1 .coin-position-1 1.5))\n\n(defloop random-coin-2\n  (random-coin .coinx-2 .coiny-2 .coin-velocity-2 .coin-position-2 2.5))\n\n;; ------------ Initialize Spiked CanonBalls ---------------\n(defshards initialize-spiked-canonballs []\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall1.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall2.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall3.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall4.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall5.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall6.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall7.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall8.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall9.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall10.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall11.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall12.png\") &gt;&gt; .spikeball-array\n\n  (Count .spikeball-array) = .spikeball-array-index-max\n  0 &gt;= .spikeball-index\n  0.06 = .spikeball-animation-speed\n\n  ;; ---------- spikball-1 -------------\n  1.0 &gt;= .spikeball-velocity-1\n  0.0 &gt;= .spikeball-y-1\n  0.0 &gt;= .spikeball-x-1\n  (float2 .spikeball-x-1 .spikeball-y-1) &gt;= .spikeball-position-1\n\n  ;; ---------- spikeball-2 -------------\n  1.0 &gt;= .spikeball-velocity-2\n  0.0 &gt;= .spikeball-y-2\n  0.0 &gt;= .spikeball-x-2\n  (float2 .spikeball-x-2 .spikeball-y-2) &gt;= .spikeball-position-2\n\n;; ---------- SpikeBall_3 -------------\n  1.0 &gt;= .spikeball-velocity-3\n  0.0 &gt;= .spikeball-y-3\n  0.0 &gt;= .spikeball-x-3\n  (float2 .spikeball-x-3 .spikeball-y-3) &gt;= .spikeball-position-3\n\n  0.5 &gt;= .spikeball-acceleration)\n\n;;------------- Spiked CanonBall Animation -------------\n(defloop spiked-canonball-animation\n  .spikeball-index (Math.Add 1)\n  &gt; .spikeball-index\n  (When :Predicate (IsMoreEqual .spikeball-array-index-max)\n        :Action (-&gt; 0 &gt; .spikeball-index))\n\n  (Pause .spikeball-animation-speed))\n\n;; ------------- SpikeBall_Gravity_Logic -------------\n(defshards spikeball-gravity-logic [spikeball-y spikeball-velocity spikeball-position spikeball-x]\n  spikeball-y (Math.Add spikeball-velocity)\n  &gt; spikeball-y\n  spikeball-velocity (Math.Add .spikeball-acceleration)\n  &gt; spikeball-velocity\n  (float2 spikeball-x spikeball-y) &gt; spikeball-position)\n\n;; ------------- Randomise Spikeball ----------------\n(defshards randomise-spikeball [spikeball-x spikeball-y spikeball-velocity spikeball-position pausefloat]\n  spikeball-x\n  (RandomFloat :Max 1200.0)\n  &gt; spikeball-x\n  (Math.Subtract 600.0)\n  &gt; spikeball-x\n\n  0.0 &gt; spikeball-y\n  0.0 &gt; spikeball-velocity\n  (float2 spikeball-x spikeball-y) &gt; spikeball-position\n  .spikeball-x-1\n  (Pause pausefloat))\n\n(defloop spikeball-1\n  (randomise-spikeball .spikeball-x-1 .spikeball-y-1 .spikeball-velocity-1 .spikeball-position-1 2))\n(defloop spikeball-2\n  (randomise-spikeball .spikeball-x-2 .spikeball-y-2 .spikeball-velocity-2 .spikeball-position-2 3))\n(defloop spikeball-3\n  (randomise-spikeball .spikeball-x-3 .spikeball-y-3 .spikeball-velocity-3 .spikeball-position-3 4))\n\n;; --------- Game Elements ------------\n(defshards initialize-game-elements []\n  ;;------------ Scoring Limits ----------\n  0 &gt;= .score\n  false &gt;= .scored\n\n  .X (Math.Add 50.0)\n  &gt;= .scoringUpper-x-limit\n  .X (Math.Subtract 50.0)\n  &gt;= .scoringLower-x-limit\n\n  .Y (Math.Add 10.0)\n  &gt;= .scoringUpper-y-limit\n  .Y (Math.Subtract 10.0)\n  &gt;= .scoringLower-y-limit\n\n  ;; ---------- Damage Limits ------------\n  .X (Math.Add 50.0)\n  &gt;= .damageUpper-x-limit\n  .X (Math.Subtract 50.0)\n  &gt;= .damageLower-x-limit\n\n  .Y (Math.Add 5.0)\n  &gt;= .damageUpper-y-limit\n  .Y (Math.Subtract 5.0)\n  &gt;= .damageLower-y-limit\n\n  false &gt;= .damaged)\n\n;; --------- Scoring ----------\n(defshards score-collision [coinx coiny]\n  coinx\n  (When :Predicate (-&gt;\n                    (IsLess .scoringUpper-x-limit)\n                    (And)\n                    coinx (IsMore .scoringLower-x-limit)\n                    (And)\n                    coiny (IsLess .scoringUpper-y-limit)\n                    (And)\n                    coiny (IsMore .scoringLower-y-limit)\n                    (And)\n                    .scored (Is false))\n        :Action (-&gt;\n                true &gt; .scored\n                (Log \"Score: \"))))\n\n(defshards scoring []\n  .X (Math.Add 50.0)\n  &gt; .scoringUpper-x-limit\n  .X (Math.Subtract 50.0)\n  &gt; .scoringLower-x-limit\n\n  .Y (Math.Add 10.0)\n  &gt; .scoringUpper-y-limit\n  .Y (Math.Subtract 10.0)\n  &gt; .scoringLower-y-limit\n\n  (score-collision .coinx-1 .coiny-1)\n  (score-collision .coinx-2 .coiny-2)\n\n  .scored\n  (When :Predicate (Is true)\n        :Action (-&gt;\n                .score (Math.Add 1)\n                &gt; .score\n                true &gt; .score-effect-play\n                false &gt; .scored)))\n\n;; ------------- spikeBall-collision-logic --------------\n(defshards spikeBall-collision-logic [spikeBall-x spikeBall-y]\n\n  spikeBall-x\n  (If :Predicate (-&gt; (IsLess .damageUpper-x-limit)\n                    (And)\n                    spikeBall-x (IsMore .damageLower-x-limit)\n                    (And)\n                    spikeBall-y (IsLess .damageUpper-y-limit)\n                    (And)\n                    spikeBall-y (IsMore .damageLower-y-limit))\n\n      :Then (-&gt; .damaged\n                (When :Predicate (Is false)\n                      :Action (-&gt;\n                              true &gt; .damaged\n                              (Log \"damaged: \"))))))\n\n;; -------------- Damaging --------------\n(defshards damaging []\n\n  .X (Math.Add 120.0)\n  &gt; .damageUpper-x-limit\n  .X (Math.Subtract 120.0)\n  &gt; .damageLower-x-limit\n\n  .Y (Math.Add 15.0)\n  &gt; .damageUpper-y-limit\n  .Y (Math.Subtract 15.0)\n  &gt; .damageLower-y-limit\n\n  (spikeBall-collision-logic .spikeball-x-1 .spikeball-y-1)\n  (spikeBall-collision-logic .spikeball-x-2 .spikeball-y-2)\n  (spikeBall-collision-logic .spikeball-x-3 .spikeball-y-3)\n\n  .damaged\n  (When :Predicate (Is true)\n        :Action (-&gt;\n                .score (Math.Subtract 1)\n                &gt; .score\n                true &gt; .damage-effect-play\n                false &gt; .damaged)))\n\n;; ------------- initialize effects -------------\n(defshards initialize-effects []\n  (LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_1.png\") &gt;&gt; .score-effect-array\n  (LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_2.png\") &gt;&gt; .score-effect-array\n  (LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_3.png\") &gt;&gt; .score-effect-array\n  (LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_4.png\") &gt;&gt; .score-effect-array\n  (LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_5.png\") &gt;&gt; .score-effect-array\n  (LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_6.png\") &gt;&gt; .score-effect-array\n  (LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_7.png\") &gt;&gt; .score-effect-array\n  (LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_8.png\") &gt;&gt; .score-effect-array\n  (Count .score-effect-array) (Math.Subtract 1) &gt;= .score-effect-array-index-max\n  0 &gt;= .score-effect-array-index\n  0.05 &gt;=  .score-effect-animation-speed ;; Reduce number to increase animation speed\n  false &gt;= .score-effect-play\n\n  0.0 &gt;= .score-effect-position-x\n  0.0 &gt;= .score-effect-position-y\n  (float2 .score-effect-position-x .score-effect-position-y) &gt;= .score-effect-position\n\n  ;; --------------- Damaged Effect ----------------\n  (LoadTexture \"GlodImages/Damage_Effect/Damaged_Effect_1.png\") &gt;&gt; .damage-effect-array\n  (LoadTexture \"GlodImages/Damage_Effect/Damaged_Effect_2.png\") &gt;&gt; .damage-effect-array\n  (LoadTexture \"GlodImages/Damage_Effect/Damaged_Effect_3.png\") &gt;&gt; .damage-effect-array\n  (LoadTexture \"GlodImages/Damage_Effect/Damaged_Effect_4.png\") &gt;&gt; .damage-effect-array\n  (LoadTexture \"GlodImages/Damage_Effect/Damaged_Effect_5.png\") &gt;&gt; .damage-effect-array\n  (LoadTexture \"GlodImages/Damage_Effect/Damaged_Effect_6.png\") &gt;&gt; .damage-effect-array\n  (LoadTexture \"GlodImages/Damage_Effect/Damaged_Effect_7.png\") &gt;&gt; .damage-effect-array\n  (LoadTexture \"GlodImages/Damage_Effect/Damaged_Effect_8.png\") &gt;&gt; .damage-effect-array\n  (Count .damage-effect-array) (Math.Subtract 1) &gt;= .damage-effect-array-index-max\n  0 &gt;= .damage-effect-array-index\n  0.02 &gt;=  .damage-effect-animation-speed ;; Reduce number to increase animation speed\n  false &gt;= .damage-effect-play)\n\n;; ------------ DamageEffect Animation ------------\n(defloop damage-effect-animation-logic\n\n  .damage-effect-play\n  (When :Predicate (Is true)\n        :Action (-&gt;\n                .damage-effect-array-index (Math.Add 1)\n                &gt; .damage-effect-array-index\n                (When :Predicate (IsMore .damage-effect-array-index-max)\n                      :Action (-&gt;\n                                0 &gt; .damage-effect-array-index\n                                false &gt; .damage-effect-play))))\n\n  (Pause .damage-effect-animation-speed))\n\n;; ------------ ScoreEffect_Animation_Position ------------\n(defshards scoreEffect-animation-position []\n  .Y (Math.Add -15.0)\n  &gt; .score-effect-position-y\n\n  .X\n  &gt; .score-effect-position-x\n\n  (float2 .score-effect-position-x .score-effect-position-y)\n  &gt; .score-effect-position)\n\n;; ------------ ScoreEffect Animation ------------\n(defloop scoreEffect-animation-logic\n\n  .score-effect-play\n  (When :Predicate (Is true)\n        :Action (-&gt;\n                .score-effect-array-index (Math.Add 1)\n                &gt; .score-effect-array-index\n                (When :Predicate (IsMore .score-effect-array-index-max)\n                      :Action (-&gt;\n                                0 &gt; .score-effect-array-index\n                                false &gt; .score-effect-play))))\n\n\n  (Pause .score-effect-animation-speed))\n\n;; ------ UI Style --------\n(def style\n  {:override_text_style \"MyStyle\"\n  :text_styles\n  [{:name \"MyStyle\"\n    :size (float 46)\n    :family \"Monospace\"}]\n  :visuals\n  {:override_text_color (color 250 250 250)}})\n\n;;---------- main-wire ------------\n(defloop main-wire\n  (Setup\n  (initialize-character)\n  (initialize-coin)\n  (initialize-game-elements)\n  (initialize-spiked-canonballs)\n  (initialize-effects))\n\n  (coin-gravity-logic .coiny-1 .coinx-1 .coin-velocity-1 .coin-position-1)\n  (coin-gravity-logic .coiny-2 .coinx-2 .coin-velocity-2 .coin-position-2)\n\n  (run-logic)\n  (gravity-logic)\n  (scoring)\n  (damaging)\n\n  (Step idle-animation)\n  (Step walking-animation)\n\n  (Step coin-animation)\n  (Step random-coin-1)\n  (Step random-coin-2)\n\n  (Step spiked-canonball-animation)\n  (spikeball-gravity-logic .spikeball-y-1 .spikeball-velocity-1 .spikeball-position-1 .spikeball-x-1)\n  (spikeball-gravity-logic .spikeball-y-2 .spikeball-velocity-2 .spikeball-position-2 .spikeball-x-2)\n  (spikeball-gravity-logic .spikeball-y-3 .spikeball-velocity-3 .spikeball-position-3 .spikeball-x-3)\n  (Step  spikeball-1)\n  (Step  spikeball-2)\n  (Step  spikeball-3)\n\n  (scoreEffect-animation-position)\n  (Step scoreEffect-animation-logic)\n  (Step damage-effect-animation-logic)\n\n  (GFX.MainWindow\n  :Title \"MainWindow\" :Width 1920 :Height 1080\n  :Contents\n  (-&gt; (Setup\n        (GFX.DrawQueue) &gt;= .ui-draw-queue\n        (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n      .ui-draw-queue (GFX.ClearQueue)\n\n      (UI\n        .ui-draw-queue\n        (-&gt;\n        (UI.Area :Position .character-position\n                  :Anchor Anchor.Top\n                  :Contents (-&gt;\n                            .character-state\n                            (Match [0 (-&gt; .character-direction\n                                          (Match [0 (-&gt; .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n                                                  1 (-&gt; .idle-right-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))]\n                                                  :Passthrough false))\n                                    1 (-&gt; .walking-left-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n                                    2 (-&gt; .walking-right-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n                                    3 (-&gt;  .character-direction\n                                            (Match [0 (-&gt; .character-jumping-left (UI.Image :Scale (float2 0.2)))\n                                                    1 (-&gt; .character-jumping-right (UI.Image :Scale (float2 0.2)))]\n                                                  :Passthrough false))]\n                                    :Passthrough false)))\n\n        ;; ---------- Coins -----------\n\n        (UI.Area :Position .coin-position-1\n                  :Anchor Anchor.Top\n                  :Contents (-&gt;\n                            .coin-image-array (Take .coin-image-index) (UI.Image :Scale (float2 0.2))))\n\n        (UI.Area :Position .coin-position-2\n                  :Anchor Anchor.Top\n                  :Contents (-&gt;\n                            .coin-image-array (Take .coin-image-index) (UI.Image :Scale (float2 0.2))))\n\n        ;; ------------SpikeBalls ------------\n\n        (UI.Area :Position .spikeball-position-1\n                  :Anchor Anchor.Top\n                  :Contents (-&gt;\n                            .spikeball-array (Take .spikeball-index) (UI.Image :Scale (float2 0.15))))\n\n        (UI.Area :Position .spikeball-position-2\n                  :Anchor Anchor.Top\n                  :Contents (-&gt;\n                            .spikeball-array (Take .spikeball-index) (UI.Image :Scale (float2 0.15))))\n\n        (UI.Area :Position .spikeball-position-3\n                  :Anchor Anchor.Top\n                  :Contents (-&gt;\n                            .spikeball-array (Take .spikeball-index) (UI.Image :Scale (float2 0.15))))\n\n        ;; ----------------- Visual Effects  -------------------\n        (UI.Area :Position .score-effect-position\n                  :Anchor Anchor.Top\n                  :Contents (-&gt;\n                            .score-effect-array (Take .score-effect-array-index) (UI.Image :Scale (float2 0.15))))\n\n        (UI.Area :Position (float2 0 0)\n                  :Anchor Anchor.TopLeft\n                  :Contents (-&gt;\n                            .damage-effect-array (Take .damage-effect-array-index) (UI.Image :Scale (float2 10))))\n\n        ;; --------------- UI Score --------------\n\n        (UI.Area :Position (float2 -40 20)\n                  :Anchor Anchor.TopRight\n                  :Contents (-&gt;\n                            style (UI.Style)\n                            .score (ToString) (UI.Label)))))\n\n      (button-inputs)\n\n      (GFX.Render :Steps .render-steps))))\n\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre> <p>Good job!</p> <p>Now we have even more motivation to avoid getting hit! \ud83d\udea8\ud83d\udea8\ud83d\udea8\ud83d\udea8\ud83d\udea8</p>"},{"location":"learn/shards/tutorials/glod-game/steps/step-7/#step-73","title":"Step 7.3","text":"<p>This step will be extremely easy.</p> <p>We will simply be adding a background image to our game to make it more visually appealing.</p> <ul> <li>Download background image here.</li> </ul> <p>First, load our image.</p> Code Added <pre><code>(LoadTexture \"GlodImages/BG.png\") = .bg-image \n</code></pre> <p>Next, create a <code>UI.Area</code> to house our new image.</p> <p>Remember to add this <code>UI.Area</code> before the <code>UI.Area</code> which houses your character to ensure that it is drawn below your character.</p> Code AddedFull Code So Far <pre><code>(UI.Area :Position (float2 0 0)\n                  :Anchor Anchor.TopLeft\n                  :Contents (-&gt;\n                            .bg-image (UI.Image :Scale (float2 0.7))))\n</code></pre> <pre><code>(defshards initialize-character []\n  (LoadImage \"GlodImages/Character1_Jumping_Left.png\") = .character-jumping-left\n  (LoadImage \"GlodImages/Character1_Jumping_Right.png\") = .character-jumping-right\n\n  0 &gt;= .character-state\n  0 &gt;= .character-direction\n  true &gt;= .can-jump\n\n  0.0 &gt;= .X\n  620.0 &gt;= .Y\n  (float2 .X .Y) &gt;= .character-position\n  0.0 &gt;= .character-x-velocity\n  0.0 &gt;= .character-y-velocity\n  0.0 &gt;= .character-y-acceleration\n\n  ;; ---------- Character Idle Array (Facing Left) ----------\n  (LoadImage \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png\") &gt;&gt; .idle-left-image-array\n  (LoadImage \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png\") &gt;&gt; .idle-left-image-array\n  (LoadImage \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png\") &gt;&gt; .idle-left-image-array\n  (LoadImage \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png\") &gt;&gt; .idle-left-image-array\n  (LoadImage \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png\") &gt;&gt; .idle-left-image-array\n  (LoadImage \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png\") &gt;&gt; .idle-left-image-array\n  (LoadImage \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png\") &gt;&gt; .idle-left-image-array\n\n  ;; ---------- Character Idle Array (Facing Right) ----------------\n  (LoadImage \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_1.png\") &gt;&gt; .idle-right-image-array\n  (LoadImage \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_2.png\") &gt;&gt; .idle-right-image-array\n  (LoadImage \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_3.png\") &gt;&gt; .idle-right-image-array\n  (LoadImage \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_4.png\") &gt;&gt; .idle-right-image-array\n  (LoadImage \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_5.png\") &gt;&gt; .idle-right-image-array\n  (LoadImage \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_6.png\") &gt;&gt; .idle-right-image-array\n  (LoadImage \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_7.png\") &gt;&gt; .idle-right-image-array\n\n  0 &gt;= .idle-image-index\n  (Count .idle-left-image-array) (Math.Subtract 1) &gt;= .idle-image-index-max\n  0.08 &gt;= .idle-animation-speed\n\n  ;; -------------- Walking Array (Facing Left) -----------------\n  (LoadImage \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_1.png\") &gt;&gt; .walking-left-image-array\n  (LoadImage \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_2.png\") &gt;&gt; .walking-left-image-array\n  (LoadImage \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_3.png\") &gt;&gt; .walking-left-image-array\n  (LoadImage \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_4.png\") &gt;&gt; .walking-left-image-array\n  (LoadImage \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_5.png\") &gt;&gt; .walking-left-image-array\n  (LoadImage \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_6.png\") &gt;&gt; .walking-left-image-array\n  (LoadImage \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_7.png\") &gt;&gt; .walking-left-image-array\n\n  ;; ----------- Walking Array (Facing Right) ---------------\n  (LoadImage \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_1.png\") &gt;&gt; .walking-right-image-array\n  (LoadImage \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_2.png\") &gt;&gt; .walking-right-image-array\n  (LoadImage \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_3.png\") &gt;&gt; .walking-right-image-array\n  (LoadImage \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_4.png\") &gt;&gt; .walking-right-image-array\n  (LoadImage \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_5.png\") &gt;&gt; .walking-right-image-array\n  (LoadImage \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_6.png\") &gt;&gt; .walking-right-image-array\n  (LoadImage \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_7.png\") &gt;&gt; .walking-right-image-array\n\n  (Count .walking-left-image-array) (Math.Subtract 1) &gt;= .walking-image-index-max\n  0 &gt;= .walking-image-index\n  0.08 &gt;= .walking-animation-speed) ;; Reduce number to increase animation speed\n\n;; --------- Idle Animation Loop ---------\n(defloop idle-animation\n  .idle-image-index (Math.Add 1)\n  &gt; .idle-image-index\n  (When :Predicate (IsMore .idle-image-index-max)\n        :Action (-&gt; 0 &gt; .idle-image-index))\n  (Pause .idle-animation-speed))\n\n;; -------- Walking Animation Loop --------\n(defloop walking-animation\n  .walking-image-index (Math.Add 1)\n  &gt; .walking-image-index\n  (When :Predicate (IsMore .walking-image-index-max)\n        :Action (-&gt; 0 &gt; .walking-image-index))\n  (Pause .walking-animation-speed))\n\n(defshards LoadTexture [name]\n  (LoadImage name)\n  (GFX.Texture))\n\n;; ---------- character-boundary ------------\n\n(defshards clamp [var min max]\n  var (Max min) (Min max) &gt; var)\n\n;; ------------ Character Run Logic ----------------\n(defshards run-logic []\n  .X (Math.Add .character-x-velocity)\n  &gt; .X\n\n  (float2 .X .Y) &gt; .character-position\n\n  (clamp .X -600.0 600.0))\n\n;; ------------ Character gravity-logic ---------------\n(defshards gravity-logic []\n  .Y (Math.Add .character-y-velocity)\n  &gt; .Y\n\n  .character-y-velocity (Math.Add .character-y-acceleration)\n  &gt; .character-y-velocity\n\n  (float2 .X .Y) &gt; .character-position\n\n  (clamp .Y -620.0 620.0)\n  .Y\n  (When :Predicate (IsMoreEqual 620.0)\n        :Action (-&gt;\n                0.0 &gt; .character-y-velocity\n                0.0 &gt; .character-y-acceleration\n                true &gt; .can-jump\n                .character-state\n                (When :Predicate (Is 3)\n                      :Action (-&gt;\n                                0 &gt; .character-state)))))\n\n;; ------- Button Inputs ----------\n(defshards button-inputs []\n  (Inputs.KeyDown\n  :Key \"left\"\n  :Action (-&gt;\n            (Msg \"left\")\n\n            .character-state\n            (When :Predicate (Is 0)\n                  :Action (-&gt; 1 &gt; .character-state))\n\n            0 &gt; .character-direction\n            -5.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyDown\n  :Key \"right\"\n  :Action (-&gt;\n            (Msg \"right\")\n\n            .character-state\n            (When :Predicate (Is 0)\n                  :Action (-&gt; 2 &gt; .character-state))\n            1 &gt; .character-direction\n            5.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyDown\n  :Key \"up\"\n  :Action (-&gt;\n            (Msg \"up\")\n            3 &gt; .character-state\n            .can-jump\n            (When :Predicate (Is true)\n                  :Action (-&gt;\n                          -20.0 &gt; .character-y-velocity\n                          1.0 &gt;  .character-y-acceleration\n                          false &gt;= .can-jump))))\n\n  (Inputs.KeyUp\n  :Key \"left\"\n  :Action (-&gt;\n            0 &gt; .character-state\n            0.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyUp\n  :Key \"right\"\n  :Action (-&gt;\n            0 &gt; .character-state\n            0.0 &gt; .character-x-velocity)))\n\n;; -------------- Initialize Coin ----------\n(defshards initialize-coin []\n  (LoadImage \"GlodImages/Coin/Coin_1.png\") &gt;&gt; .coin-image-array\n  (LoadImage \"GlodImages/Coin/Coin_2.png\") &gt;&gt; .coin-image-array\n  (LoadImage \"GlodImages/Coin/Coin_3.png\") &gt;&gt; .coin-image-array\n  (LoadImage \"GlodImages/Coin/Coin_4.png\") &gt;&gt; .coin-image-array\n  (LoadImage \"GlodImages/Coin/Coin_5.png\") &gt;&gt; .coin-image-array\n  (LoadImage \"GlodImages/Coin/Coin_6.png\") &gt;&gt; .coin-image-array\n  (LoadImage \"GlodImages/Coin/Coin_7.png\") &gt;&gt; .coin-image-array\n  (Count .coin-image-array) (Math.Subtract 1) &gt;= .coin-image-index-max\n  0 &gt;= .coin-image-index\n  0.1 &gt;= .coin-animation-speed\n\n  ;; ----- Coin 1 ------\n  0.0 &gt;= .coinx-1\n  0.0 &gt;= .coiny-1\n  (float2 .coinx-1 .coiny-1) &gt;= .coin-position-1\n  0.0 &gt;= .coin-velocity-1\n  0.5 &gt;= .coin-acceleration\n\n  ;; ----- Coin 2 ----\n  0.0 &gt;= .coinx-2\n  0.0 &gt;= .coiny-2\n  (float2 .coinx-2 .coiny-2) &gt;= .coin-position-2\n  0.0 &gt;= .coin-velocity-2)\n\n;; -------------- Coin Animation ------------------\n(defloop coin-animation\n  .coin-image-index (Math.Add 1)\n  &gt; .coin-image-index\n  (When :Predicate (IsMore .coin-image-index-max)\n        :Action (-&gt; 0 &gt; .coin-image-index))\n\n  (Pause .coin-animation-speed))\n\n;; ------------- Coin Gravity ------------------\n(defshards coin-gravity-logic [coiny coinx coin-velocity coin-position]\n\n  coiny (Math.Add coin-velocity)\n  &gt; coiny\n\n  coin-velocity (Math.Add .coin-acceleration)\n  &gt; coin-velocity\n\n  (float2 coinx coiny) &gt; coin-position)\n\n;; ------------- Random Coin ------------------\n(defshards random-coin [coinx coiny coin-velocity coin-position pause-length]\n  coinx\n  (RandomFloat :Max 1200.0)\n  &gt; coinx\n  (Math.Subtract 600.0)\n  &gt; coinx\n\n  0.0 &gt; coiny\n  0.0 &gt; coin-velocity\n  (float2 coinx coiny) &gt; coin-position\n  (Pause pause-length))\n\n(defloop random-coin-1\n  (random-coin .coinx-1 .coiny-1 .coin-velocity-1 .coin-position-1 1.5))\n\n(defloop random-coin-2\n  (random-coin .coinx-2 .coiny-2 .coin-velocity-2 .coin-position-2 2.5))\n\n;; ------------ Initialize Spiked CanonBalls ---------------\n(defshards initialize-spiked-canonballs []\n  (LoadImage \"GlodImages/SpikeBall/SpikeBall1.png\") &gt;&gt; .spikeball-array\n  (LoadImage \"GlodImages/SpikeBall/SpikeBall2.png\") &gt;&gt; .spikeball-array\n  (LoadImage \"GlodImages/SpikeBall/SpikeBall3.png\") &gt;&gt; .spikeball-array\n  (LoadImage \"GlodImages/SpikeBall/SpikeBall4.png\") &gt;&gt; .spikeball-array\n  (LoadImage \"GlodImages/SpikeBall/SpikeBall5.png\") &gt;&gt; .spikeball-array\n  (LoadImage \"GlodImages/SpikeBall/SpikeBall6.png\") &gt;&gt; .spikeball-array\n  (LoadImage \"GlodImages/SpikeBall/SpikeBall7.png\") &gt;&gt; .spikeball-array\n  (LoadImage \"GlodImages/SpikeBall/SpikeBall8.png\") &gt;&gt; .spikeball-array\n  (LoadImage \"GlodImages/SpikeBall/SpikeBall9.png\") &gt;&gt; .spikeball-array\n  (LoadImage \"GlodImages/SpikeBall/SpikeBall10.png\") &gt;&gt; .spikeball-array\n  (LoadImage \"GlodImages/SpikeBall/SpikeBall11.png\") &gt;&gt; .spikeball-array\n  (LoadImage \"GlodImages/SpikeBall/SpikeBall12.png\") &gt;&gt; .spikeball-array\n\n  (Count .spikeball-array) (Math.Subtract 1) &gt;= .spikeball-array-index-max\n  0 &gt;= .spikeball-index\n  0.06 &gt;= .spikeball-animation-speed\n\n  ;; ---------- spikball-1 -------------\n  1.0 &gt;= .spikeball-velocity-1\n  0.0 &gt;= .spikeball-y-1\n  0.0 &gt;= .spikeball-x-1\n  (float2 .spikeball-x-1 .spikeball-y-1) &gt;= .spikeball-position-1\n\n  ;; ---------- spikeball-2 -------------\n  1.0 &gt;= .spikeball-velocity-2\n  0.0 &gt;= .spikeball-y-2\n  0.0 &gt;= .spikeball-x-2\n  (float2 .spikeball-x-2 .spikeball-y-2) &gt;= .spikeball-position-2\n\n  ;; ---------- SpikeBall_3 -------------\n  1.0 &gt;= .spikeball-velocity-3\n  0.0 &gt;= .spikeball-y-3\n  0.0 &gt;= .spikeball-x-3\n  (float2 .spikeball-x-3 .spikeball-y-3) &gt;= .spikeball-position-3\n\n  0.5 &gt;= .spikeball-acceleration)\n\n;;------------- Spiked CanonBall Animation -------------\n(defloop spiked-canonball-animation\n  .spikeball-index (Math.Add 1)\n  &gt; .spikeball-index\n  (When :Predicate (IsMore .spikeball-array-index-max)\n        :Action (-&gt; 0 &gt; .spikeball-index))\n\n  (Pause .spikeball-animation-speed))\n\n;; ------------- SpikeBall_Gravity_Logic -------------\n(defshards spikeball-gravity-logic [spikeball-y spikeball-velocity spikeball-position spikeball-x]\n  spikeball-y (Math.Add spikeball-velocity)\n  &gt; spikeball-y\n  spikeball-velocity (Math.Add .spikeball-acceleration)\n  &gt; spikeball-velocity\n  (float2 spikeball-x spikeball-y) &gt; spikeball-position)\n\n(defshards randomise-spikeball [spikeball-x spikeball-y spikeball-velocity spikeball-position pausefloat]\n  spikeball-x\n  (RandomFloat :Max 1200.0)\n  &gt; spikeball-x\n  (Math.Subtract 600.0)\n  &gt; spikeball-x\n\n  0.0 &gt; spikeball-y\n  0.0 &gt; spikeball-velocity\n  (float2 spikeball-x spikeball-y) &gt; spikeball-position\n  .spikeball-x-1\n  (Pause pausefloat))\n\n(defloop spikeball-1\n  (randomise-spikeball .spikeball-x-1 .spikeball-y-1 .spikeball-velocity-1 .spikeball-position-1 2))\n(defloop spikeball-2\n  (randomise-spikeball .spikeball-x-2 .spikeball-y-2 .spikeball-velocity-2 .spikeball-position-2 3))\n(defloop spikeball-3\n  (randomise-spikeball .spikeball-x-3 .spikeball-y-3 .spikeball-velocity-3 .spikeball-position-3 4))\n\n\n;; --------- Game Elements ------------\n(defshards initialize-game-elements []\n  0 &gt;= .score\n  false &gt;= .scored\n\n  .X (Math.Add 50.0)\n  &gt;= .scoringUpper-x-limit\n  .X (Math.Subtract 50.0)\n  &gt;= .scoringLower-x-limit\n\n  .Y (Math.Add 10.0)\n  &gt;= .scoringUpper-y-limit\n  .Y (Math.Subtract 10.0)\n  &gt;= .scoringLower-y-limit\n\n  ;; ---------- Damage Limits ------------\n  .X (Math.Add 50.0)\n  &gt;= .damageUpper-x-limit\n  .X (Math.Subtract 50.0)\n  &gt;= .damageLower-x-limit\n\n  .Y (Math.Add 5.0)\n  &gt;= .damageUpper-y-limit\n  .Y (Math.Subtract 5.0)\n  &gt;= .damageLower-y-limit\n\n  false &gt;= .damaged)\n\n;; --------- Scoring ----------\n(defshards score-collision [coinx coiny]\n  coinx\n  (When :Predicate (-&gt;\n                    (IsLess .scoringUpper-x-limit)\n                    (And)\n                    coinx (IsMore .scoringLower-x-limit)\n                    (And)\n                    coiny (IsLess .scoringUpper-y-limit)\n                    (And)\n                    coiny (IsMore .scoringLower-y-limit)\n                    (And)\n                    .scored (Is false))\n        :Action (-&gt;\n                true &gt; .scored\n                (Log \"Score: \"))))\n\n(defshards scoring []\n  .X (Math.Add 50.0)\n  &gt; .scoringUpper-x-limit\n  .X (Math.Subtract 50.0)\n  &gt; .scoringLower-x-limit\n\n  .Y (Math.Add 10.0)\n  &gt; .scoringUpper-y-limit\n  .Y (Math.Subtract 10.0)\n  &gt; .scoringLower-y-limit\n\n  (score-collision .coinx-1 .coiny-1)\n  (score-collision .coinx-2 .coiny-2)\n\n  .scored\n  (When :Predicate (Is true)\n        :Action (-&gt;\n                .score (Math.Add 1)\n                &gt; .score\n                true &gt; .score-effect-play\n                false &gt; .scored)))\n\n;; ------------- spikeBall-collision-logic --------------\n(defshards spikeBall-collision-logic [spikeBall-x spikeBall-y]\n\n  spikeBall-x\n  (If :Predicate (-&gt; (IsLess .damageUpper-x-limit)\n                    (And)\n                    spikeBall-x (IsMore .damageLower-x-limit)\n                    (And)\n                    spikeBall-y (IsLess .damageUpper-y-limit)\n                    (And)\n                    spikeBall-y (IsMore .damageLower-y-limit))\n\n      :Then (-&gt; .damaged\n                (When :Predicate (Is false)\n                      :Action (-&gt;\n                              true &gt; .damaged\n                              (Log \"damaged: \"))))))\n\n;; -------------- Damaging --------------\n(defshards damaging []\n\n  .X (Math.Add 120.0)\n  &gt; .damageUpper-x-limit\n  .X (Math.Subtract 120.0)\n  &gt; .damageLower-x-limit\n\n  .Y (Math.Add 15.0)\n  &gt; .damageUpper-y-limit\n  .Y (Math.Subtract 15.0)\n  &gt; .damageLower-y-limit\n\n  (spikeBall-collision-logic .spikeball-x-1 .spikeball-y-1)\n  (spikeBall-collision-logic .spikeball-x-2 .spikeball-y-2)\n  (spikeBall-collision-logic .spikeball-x-3 .spikeball-y-3)\n\n  .damaged\n  (When :Predicate (Is true)\n        :Action (-&gt;\n                .score (Math.Subtract 1)\n                &gt; .score\n                true &gt; .damage-effect-play\n                false &gt; .damaged)))\n\n\n;; ------------- innitialize effects -------------\n(defshards initialize-effects []\n  ;; --------------- Animation Effects -----------------\n  (LoadImage \"GlodImages/Coin/CoinEffect/Score_Effect_1.png\") &gt;&gt; .score-effect-array\n  (LoadImage \"GlodImages/Coin/CoinEffect/Score_Effect_2.png\") &gt;&gt; .score-effect-array\n  (LoadImage \"GlodImages/Coin/CoinEffect/Score_Effect_3.png\") &gt;&gt; .score-effect-array\n  (LoadImage \"GlodImages/Coin/CoinEffect/Score_Effect_4.png\") &gt;&gt; .score-effect-array\n  (LoadImage \"GlodImages/Coin/CoinEffect/Score_Effect_5.png\") &gt;&gt; .score-effect-array\n  (LoadImage \"GlodImages/Coin/CoinEffect/Score_Effect_6.png\") &gt;&gt; .score-effect-array\n  (LoadImage \"GlodImages/Coin/CoinEffect/Score_Effect_7.png\") &gt;&gt; .score-effect-array\n  (LoadImage \"GlodImages/Coin/CoinEffect/Score_Effect_8.png\") &gt;&gt; .score-effect-array\n  (Count .score-effect-array) (Math.Subtract 1) &gt;= .score-effect-array-index-max\n  0 &gt;= .score-effect-array-index\n  0.02 &gt;=  .score-effect-animation-speed ;; Reduce number to increase animation speed\n  false &gt;= .score-effect-play\n\n  0.0 &gt;= .score-effect-position-x\n  0.0 &gt;= .score-effect-position-y\n  (float2 .score-effect-position-x .score-effect-position-y) &gt;= .score-effect-position\n\n  ;; --------------- Damaged Effect ----------------\n  (LoadImage \"GlodImages/Damage_Effect/Damaged_Effect_1.png\") &gt;&gt; .damage-effect-array\n  (LoadImage \"GlodImages/Damage_Effect/Damaged_Effect_2.png\") &gt;&gt; .damage-effect-array\n  (LoadImage \"GlodImages/Damage_Effect/Damaged_Effect_3.png\") &gt;&gt; .damage-effect-array\n  (LoadImage \"GlodImages/Damage_Effect/Damaged_Effect_4.png\") &gt;&gt; .damage-effect-array\n  (LoadImage \"GlodImages/Damage_Effect/Damaged_Effect_5.png\") &gt;&gt; .damage-effect-array\n  (LoadImage \"GlodImages/Damage_Effect/Damaged_Effect_6.png\") &gt;&gt; .damage-effect-array\n  (LoadImage \"GlodImages/Damage_Effect/Damaged_Effect_7.png\") &gt;&gt; .damage-effect-array\n  (LoadImage \"GlodImages/Damage_Effect/Damaged_Effect_8.png\") &gt;&gt; .damage-effect-array\n  (Count .damage-effect-array) (Math.Subtract 1) &gt;= .damage-effect-array-index-max\n  0 &gt;= .damage-effect-array-index\n  0.02 &gt;=  .damage-effect-animation-speed ;; Reduce number to increase animation speed\n  false &gt;= .damage-effect-play\n\n  (LoadImage \"GlodImages/BG.png\") = .bg-image)\n\n;; ------------ ScoreEffect Animation Position ------------\n(defshards scoreEffect-animation-position []\n  .Y (Math.Add -15.0)\n  &gt; .score-effect-position-y\n\n  .X\n  &gt; .score-effect-position-x\n\n  (float2 .score-effect-position-x .score-effect-position-y)\n  &gt; .score-effect-position)\n\n;; ------------ ScoreEffect Animation ------------\n(defloop scoreEffect-animation-logic\n\n  .score-effect-play\n  (When :Predicate (Is true)\n        :Action (-&gt;\n                .score-effect-array-index (Math.Add 1)\n                &gt; .score-effect-array-index\n                (When :Predicate (IsMore .score-effect-array-index-max)\n                      :Action (-&gt;\n                                0 &gt; .score-effect-array-index\n                                false &gt; .score-effect-play))))\n\n\n  (Pause .score-effect-animation-speed))\n\n;; ------------ DamageEffect Animation ------------\n(defloop damage-effect-animation-logic\n\n  .damage-effect-play\n  (When :Predicate (Is true)\n        :Action (-&gt;\n                .damage-effect-array-index (Math.Add 1)\n                &gt; .damage-effect-array-index\n                (When :Predicate (IsMore .damage-effect-array-index-max)\n                      :Action (-&gt;\n                                0 &gt; .damage-effect-array-index\n                                false &gt; .damage-effect-play))))\n\n\n  (Pause .damage-effect-animation-speed))\n\n\n;; ------ UI Style --------\n(def style\n  {:override_text_style \"MyStyle\"\n  :text_styles\n  [{:name \"MyStyle\"\n    :size (float 46)\n    :family \"Monospace\"}]\n  :visuals\n  {:override_text_color (color 250 250 250)}})\n\n;;---------- main-wire ------------\n(defloop main-wire\n  (Setup\n  (initialize-character)\n  (initialize-coin)\n  (initialize-game-elements)\n  (initialize-spiked-canonballs)\n  (initialize-effects))\n\n  (coin-gravity-logic .coiny-1 .coinx-1 .coin-velocity-1 .coin-position-1)\n  (coin-gravity-logic .coiny-2 .coinx-2 .coin-velocity-2 .coin-position-2)\n\n  (run-logic)\n  (gravity-logic)\n  (scoring)\n  (damaging)\n\n  (Step idle-animation)\n  (Step walking-animation)\n\n  (Step coin-animation)\n  (Step random-coin-1)\n  (Step random-coin-2)\n\n  (Step spiked-canonball-animation)\n  (spikeball-gravity-logic .spikeball-y-1 .spikeball-velocity-1 .spikeball-position-1 .spikeball-x-1)\n  (spikeball-gravity-logic .spikeball-y-2 .spikeball-velocity-2 .spikeball-position-2 .spikeball-x-2)\n  (spikeball-gravity-logic .spikeball-y-3 .spikeball-velocity-3 .spikeball-position-3 .spikeball-x-3)\n  (Step  spikeball-1)\n  (Step  spikeball-2)\n  (Step  spikeball-3)\n\n  (scoreEffect-animation-position)\n  (Step scoreEffect-animation-logic)\n  (Step damage-effect-animation-logic)\n\n  (GFX.MainWindow\n  :Title \"MainWindow\" :Width 1920 :Height 1080\n  :Contents\n  (-&gt; (Setup\n        (GFX.DrawQueue) &gt;= .ui-draw-queue\n        (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n      .ui-draw-queue (GFX.ClearQueue)\n\n      (UI\n        .ui-draw-queue\n        (-&gt;\n\n        (UI.Area :Position (float2 0 0)\n                  :Anchor Anchor.TopLeft\n                  :Contents (-&gt;\n                            .bg-image (UI.Image :Scale (float2 0.7))))\n\n        (UI.Area :Position .character-position\n                  :Anchor Anchor.Top\n                  :Contents (-&gt;\n                            .character-state\n                            (Match [0 (-&gt; .character-direction\n                                          (Match [0 (-&gt; LoadTexture .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n                                                  1 (-&gt; LoadTexture .idle-right-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))]\n                                                  :Passthrough false))\n                                    1 (-&gt; LoadTexture .walking-left-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n                                    2 (-&gt; LoadTexture .walking-right-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n                                    3 (-&gt;  .character-direction\n                                            (Match [0 (-&gt; LoadTexture .character-jumping-left (UI.Image :Scale (float2 0.2)))\n                                                    1 (-&gt; LoadTexture .character-jumping-right (UI.Image :Scale (float2 0.2)))]\n                                                  :Passthrough false))]\n                                    :Passthrough false)))\n\n        ;; -------- coins ui area -----------\n\n        (UI.Area :Position .coin-position-1\n                  :Anchor Anchor.Top\n                  :Contents (-&gt;\n                            LoadTexture .coin-image-array (Take .coin-image-index) (UI.Image :Scale (float2 0.2))))\n\n        (UI.Area :Position .coin-position-2\n                  :Anchor Anchor.Top\n                  :Contents (-&gt;\n                            LoadTexture .coin-image-array (Take .coin-image-index) (UI.Image :Scale (float2 0.2))))\n        ;; --------- spikeball ui area ----------\n\n        (UI.Area :Position .spikeball-position-1\n                  :Anchor Anchor.Top\n                  :Contents (-&gt;\n                            LoadTexture .spikeball-array (Take .spikeball-index) (UI.Image :Scale (float2 0.15))))\n\n        (UI.Area :Position .spikeball-position-2\n                  :Anchor Anchor.Top\n                  :Contents (-&gt;\n                            LoadTexture .spikeball-array (Take .spikeball-index) (UI.Image :Scale (float2 0.15))))\n\n        (UI.Area :Position .spikeball-position-3\n                  :Anchor Anchor.Top\n                  :Contents (-&gt;\n                            LoadTexture .spikeball-array (Take .spikeball-index) (UI.Image :Scale (float2 0.15))))\n\n        ;; ----------------- Visual Effects  -------------------\n        (UI.Area :Position .score-effect-position\n                  :Anchor Anchor.Top\n                  :Contents (-&gt;\n                            LoadTexture .score-effect-array (Take .score-effect-array-index) (UI.Image :Scale (float2 0.15))))\n\n        (UI.Area :Position (float2 0 0)\n                  :Anchor Anchor.TopLeft\n                  :Contents (-&gt;\n                            LoadTexture .damage-effect-array (Take .damage-effect-array-index) (UI.Image :Scale (float2 10))))\n\n        ;; ---------------- UI ------------------\n\n        (UI.Area :Position (float2 -40 20)\n                  :Anchor Anchor.TopRight\n                  :Contents (-&gt;\n                            style (UI.Style)\n                            .score (ToString) (UI.Label)))))\n\n      (button-inputs)\n\n      (GFX.Render :Steps .render-steps))))\n\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre> <p>Now we have a background image! \ud83d\uddbc\ufe0f</p>"},{"location":"learn/shards/tutorials/glod-game/steps/step-7/#step-74","title":"Step 7.4","text":"<p>Let's make our game more challenging by adding a timer. \u23f1\ufe0f</p> <p>Create a <code>.timer</code> variable and add it under <code>initialize-game-elements</code>.</p> Code Added <pre><code>60 &gt;= .timer\n0 &gt;= .gameOver\n</code></pre> <p>Create a <code>UI.Area</code> to draw our timer variable. Place it on the top left.</p> Code Added <pre><code>(UI.Area :Position (float2 40 20)\n:Anchor Anchor.TopLeft\n:Contents (-&gt;\nstyle (UI.Style)\n.timer (ToString) (UI.Label)))\n</code></pre> <p>Create a countdown logic.</p> <p>Here, we subtract one from our <code>.timer</code> variable and <code>Step</code> into the loop every second.</p> <p>Set a conditional statement to ensure that this only happens while <code>.gameOver</code> is false and <code>.timer</code> is greater than zero.</p> Code Added <pre><code>;; -------- Timer -----------\n(defloop timer-countdown\n  .gameOver\n  (When :Predicate (-&gt;\n                    (Is 0)\n                    (And)\n                    .timer (IsMore 0))\n        :Action (-&gt;\n                .timer (Math.Subtract 1)\n                &gt; .timer))\n\n  (Pause 1.0))\n</code></pre> <p>Create the Game Over logic to dictate that <code>.gameOver</code> becomes true when <code>.timer</code> reaches zero.</p> Code Added <pre><code>;; ---------- GameOver Logic ------------\n(defshards gameOver-logic []\n  .timer\n  (When :Predicate (Is 0)\n        :Action (-&gt;\n                1 &gt; .gameOver)))\n</code></pre> <p>Remember to call and <code>Step</code> them in the <code>main-wire</code>.</p> Code AddedFull Code So Far <pre><code>(Step timer-countdown)\n(gameOver-logic)\n</code></pre> <pre><code>(defshards initialize-character []\n  (LoadImage \"GlodImages/Character1_Jumping_Left.png\") = .character-jumping-left\n  (LoadImage \"GlodImages/Character1_Jumping_Right.png\") = .character-jumping-right\n\n  0 &gt;= .character-state\n  0 &gt;= .character-direction\n  true &gt;= .can-jump\n\n  0.0 &gt;= .X\n  620.0 &gt;= .Y\n  (float2 .X .Y) &gt;= .character-position\n  0.0 &gt;= .character-x-velocity\n  0.0 &gt;= .character-y-velocity\n  0.0 &gt;= .character-y-acceleration\n\n  ;; ---------- Character Idle Array (Facing Left) ----------\n  (LoadImage \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png\") &gt;&gt; .idle-left-image-array\n  (LoadImage \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png\") &gt;&gt; .idle-left-image-array\n  (LoadImage \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png\") &gt;&gt; .idle-left-image-array\n  (LoadImage \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png\") &gt;&gt; .idle-left-image-array\n  (LoadImage \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png\") &gt;&gt; .idle-left-image-array\n  (LoadImage \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png\") &gt;&gt; .idle-left-image-array\n  (LoadImage \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png\") &gt;&gt; .idle-left-image-array\n\n  ;; ---------- Character Idle Array (Facing Right) ----------------\n  (LoadImage \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_1.png\") &gt;&gt; .idle-right-image-array\n  (LoadImage \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_2.png\") &gt;&gt; .idle-right-image-array\n  (LoadImage \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_3.png\") &gt;&gt; .idle-right-image-array\n  (LoadImage \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_4.png\") &gt;&gt; .idle-right-image-array\n  (LoadImage \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_5.png\") &gt;&gt; .idle-right-image-array\n  (LoadImage \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_6.png\") &gt;&gt; .idle-right-image-array\n  (LoadImage \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_7.png\") &gt;&gt; .idle-right-image-array\n\n  0 &gt;= .idle-image-index\n  (Count .idle-left-image-array) (Math.Subtract 1) &gt;= .idle-image-index-max\n  0.08 &gt;= .idle-animation-speed\n\n  ;; -------------- Walking Array (Facing Left) -----------------\n  (LoadImage \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_1.png\") &gt;&gt; .walking-left-image-array\n  (LoadImage \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_2.png\") &gt;&gt; .walking-left-image-array\n  (LoadImage \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_3.png\") &gt;&gt; .walking-left-image-array\n  (LoadImage \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_4.png\") &gt;&gt; .walking-left-image-array\n  (LoadImage \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_5.png\") &gt;&gt; .walking-left-image-array\n  (LoadImage \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_6.png\") &gt;&gt; .walking-left-image-array\n  (LoadImage \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_7.png\") &gt;&gt; .walking-left-image-array\n\n  ;; ----------- Walking Array (Facing Right) ---------------\n  (LoadImage \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_1.png\") &gt;&gt; .walking-right-image-array\n  (LoadImage \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_2.png\") &gt;&gt; .walking-right-image-array\n  (LoadImage \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_3.png\") &gt;&gt; .walking-right-image-array\n  (LoadImage \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_4.png\") &gt;&gt; .walking-right-image-array\n  (LoadImage \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_5.png\") &gt;&gt; .walking-right-image-array\n  (LoadImage \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_6.png\") &gt;&gt; .walking-right-image-array\n  (LoadImage \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_7.png\") &gt;&gt; .walking-right-image-array\n\n  (Count .walking-left-image-array) (Math.Subtract 1) &gt;= .walking-image-index-max\n  0 &gt;= .walking-image-index\n  0.08 &gt;= .walking-animation-speed) ;; Reduce number to increase animation speed\n\n;; --------- Idle Animation Loop ---------\n(defloop idle-animation\n  .idle-image-index (Math.Add 1)\n  &gt; .idle-image-index\n  (When :Predicate (IsMore .idle-image-index-max)\n        :Action (-&gt; 0 &gt; .idle-image-index))\n  (Pause .idle-animation-speed))\n\n;; -------- Walking Animation Loop --------\n(defloop walking-animation\n  .walking-image-index (Math.Add 1)\n  &gt; .walking-image-index\n  (When :Predicate (IsMore .walking-image-index-max)\n        :Action (-&gt; 0 &gt; .walking-image-index))\n  (Pause .walking-animation-speed))\n\n(defshards LoadTexture [name]\n  (LoadImage name)\n  (GFX.Texture))\n\n;; ---------- character-boundary ------------\n\n(defshards clamp [var min max]\n  var (Max min) (Min max) &gt; var)\n\n;; ------------ Character Run Logic ----------------\n(defshards run-logic []\n  .X (Math.Add .character-x-velocity)\n  &gt; .X\n\n  (float2 .X .Y) &gt; .character-position\n\n  (clamp .X -600.0 600.0))\n\n;; ------------ Character gravity-logic ---------------\n(defshards gravity-logic []\n  .Y (Math.Add .character-y-velocity)\n  &gt; .Y\n\n  .character-y-velocity (Math.Add .character-y-acceleration)\n  &gt; .character-y-velocity\n\n  (float2 .X .Y) &gt; .character-position\n\n  (clamp .Y -620.0 620.0)\n  .Y\n  (When :Predicate (IsMoreEqual 620.0)\n        :Action (-&gt;\n                0.0 &gt; .character-y-velocity\n                0.0 &gt; .character-y-acceleration\n                true &gt; .can-jump\n                .character-state\n                (When :Predicate (Is 3)\n                      :Action (-&gt;\n                                0 &gt; .character-state)))))\n\n;; ------- Button Inputs ----------\n(defshards button-inputs []\n  (Inputs.KeyDown\n  :Key \"left\"\n  :Action (-&gt;\n            (Msg \"left\")\n\n            .character-state\n            (When :Predicate (Is 0)\n                  :Action (-&gt; 1 &gt; .character-state))\n\n            0 &gt; .character-direction\n            -5.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyDown\n  :Key \"right\"\n  :Action (-&gt;\n            (Msg \"right\")\n\n            .character-state\n            (When :Predicate (Is 0)\n                  :Action (-&gt; 2 &gt; .character-state))\n            1 &gt; .character-direction\n            5.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyDown\n  :Key \"up\"\n  :Action (-&gt;\n            (Msg \"up\")\n            3 &gt; .character-state\n            .can-jump\n            (When :Predicate (Is true)\n                  :Action (-&gt;\n                          -20.0 &gt; .character-y-velocity\n                          1.0 &gt;  .character-y-acceleration\n                          false &gt;= .can-jump))))\n\n  (Inputs.KeyUp\n  :Key \"left\"\n  :Action (-&gt;\n            0 &gt; .character-state\n            0.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyUp\n  :Key \"right\"\n  :Action (-&gt;\n            0 &gt; .character-state\n            0.0 &gt; .character-x-velocity)))\n\n;; -------------- Initialize Coin ----------\n(defshards initialize-coin []\n  (LoadImage \"GlodImages/Coin/Coin_1.png\") &gt;&gt; .coin-image-array\n  (LoadImage \"GlodImages/Coin/Coin_2.png\") &gt;&gt; .coin-image-array\n  (LoadImage \"GlodImages/Coin/Coin_3.png\") &gt;&gt; .coin-image-array\n  (LoadImage \"GlodImages/Coin/Coin_4.png\") &gt;&gt; .coin-image-array\n  (LoadImage \"GlodImages/Coin/Coin_5.png\") &gt;&gt; .coin-image-array\n  (LoadImage \"GlodImages/Coin/Coin_6.png\") &gt;&gt; .coin-image-array\n  (LoadImage \"GlodImages/Coin/Coin_7.png\") &gt;&gt; .coin-image-array\n  (Count .coin-image-array) (Math.Subtract 1) &gt;= .coin-image-index-max\n  0 &gt;= .coin-image-index\n  0.1 &gt;= .coin-animation-speed\n\n  ;; ----- Coin 1 ------\n  0.0 &gt;= .coinx-1\n  0.0 &gt;= .coiny-1\n  (float2 .coinx-1 .coiny-1) &gt;= .coin-position-1\n  0.0 &gt;= .coin-velocity-1\n  0.5 &gt;= .coin-acceleration\n\n  ;; ----- Coin 2 ----\n  0.0 &gt;= .coinx-2\n  0.0 &gt;= .coiny-2\n  (float2 .coinx-2 .coiny-2) &gt;= .coin-position-2\n  0.0 &gt;= .coin-velocity-2)\n\n;; -------------- Coin Animation ------------------\n(defloop coin-animation\n  .coin-image-index (Math.Add 1)\n  &gt; .coin-image-index\n  (When :Predicate (IsMore .coin-image-index-max)\n        :Action (-&gt; 0 &gt; .coin-image-index))\n\n  (Pause .coin-animation-speed))\n\n;; ------------- Coin Gravity ------------------\n(defshards coin-gravity-logic [coiny coinx coin-velocity coin-position]\n\n  coiny (Math.Add coin-velocity)\n  &gt; coiny\n\n  coin-velocity (Math.Add .coin-acceleration)\n  &gt; coin-velocity\n\n  (float2 coinx coiny) &gt; coin-position)\n\n;; ------------- Random Coin ------------------\n(defshards random-coin [coinx coiny coin-velocity coin-position pause-length]\n  coinx\n  (RandomFloat :Max 1200.0)\n  &gt; coinx\n  (Math.Subtract 600.0)\n  &gt; coinx\n\n  0.0 &gt; coiny\n  0.0 &gt; coin-velocity\n  (float2 coinx coiny) &gt; coin-position\n  (Pause pause-length))\n\n(defloop random-coin-1\n  (random-coin .coinx-1 .coiny-1 .coin-velocity-1 .coin-position-1 1.5))\n\n(defloop random-coin-2\n  (random-coin .coinx-2 .coiny-2 .coin-velocity-2 .coin-position-2 2.5))\n\n;; ------------ Initialize Spiked CanonBalls ---------------\n(defshards initialize-spiked-canonballs []\n  (LoadImage \"GlodImages/SpikeBall/SpikeBall1.png\") &gt;&gt; .spikeball-array\n  (LoadImage \"GlodImages/SpikeBall/SpikeBall2.png\") &gt;&gt; .spikeball-array\n  (LoadImage \"GlodImages/SpikeBall/SpikeBall3.png\") &gt;&gt; .spikeball-array\n  (LoadImage \"GlodImages/SpikeBall/SpikeBall4.png\") &gt;&gt; .spikeball-array\n  (LoadImage \"GlodImages/SpikeBall/SpikeBall5.png\") &gt;&gt; .spikeball-array\n  (LoadImage \"GlodImages/SpikeBall/SpikeBall6.png\") &gt;&gt; .spikeball-array\n  (LoadImage \"GlodImages/SpikeBall/SpikeBall7.png\") &gt;&gt; .spikeball-array\n  (LoadImage \"GlodImages/SpikeBall/SpikeBall8.png\") &gt;&gt; .spikeball-array\n  (LoadImage \"GlodImages/SpikeBall/SpikeBall9.png\") &gt;&gt; .spikeball-array\n  (LoadImage \"GlodImages/SpikeBall/SpikeBall10.png\") &gt;&gt; .spikeball-array\n  (LoadImage \"GlodImages/SpikeBall/SpikeBall11.png\") &gt;&gt; .spikeball-array\n  (LoadImage \"GlodImages/SpikeBall/SpikeBall12.png\") &gt;&gt; .spikeball-array\n\n  (Count .spikeball-array) (Math.Subtract 1) &gt;= .spikeball-array-index-max\n  0 &gt;= .spikeball-index\n  0.06 &gt;= .spikeball-animation-speed\n\n  ;; ---------- spikball-1 -------------\n  1.0 &gt;= .spikeball-velocity-1\n  0.0 &gt;= .spikeball-y-1\n  0.0 &gt;= .spikeball-x-1\n  (float2 .spikeball-x-1 .spikeball-y-1) &gt;= .spikeball-position-1\n\n  ;; ---------- spikeball-2 -------------\n  1.0 &gt;= .spikeball-velocity-2\n  0.0 &gt;= .spikeball-y-2\n  0.0 &gt;= .spikeball-x-2\n  (float2 .spikeball-x-2 .spikeball-y-2) &gt;= .spikeball-position-2\n\n  ;; ---------- SpikeBall_3 -------------\n  1.0 &gt;= .spikeball-velocity-3\n  0.0 &gt;= .spikeball-y-3\n  0.0 &gt;= .spikeball-x-3\n  (float2 .spikeball-x-3 .spikeball-y-3) &gt;= .spikeball-position-3\n\n  0.5 &gt;= .spikeball-acceleration)\n\n;;------------- Spiked CanonBall Animation -------------\n(defloop spiked-canonball-animation\n  .spikeball-index (Math.Add 1)\n  &gt; .spikeball-index\n  (When :Predicate (IsMore .spikeball-array-index-max)\n        :Action (-&gt; 0 &gt; .spikeball-index))\n\n  (Pause .spikeball-animation-speed))\n\n;; ------------- SpikeBall_Gravity_Logic -------------\n(defshards spikeball-gravity-logic [spikeball-y spikeball-velocity spikeball-position spikeball-x]\n  spikeball-y (Math.Add spikeball-velocity)\n  &gt; spikeball-y\n  spikeball-velocity (Math.Add .spikeball-acceleration)\n  &gt; spikeball-velocity\n  (float2 spikeball-x spikeball-y) &gt; spikeball-position)\n\n(defshards randomise-spikeball [spikeball-x spikeball-y spikeball-velocity spikeball-position pausefloat]\n  spikeball-x\n  (RandomFloat :Max 1200.0)\n  &gt; spikeball-x\n  (Math.Subtract 600.0)\n  &gt; spikeball-x\n\n  0.0 &gt; spikeball-y\n  0.0 &gt; spikeball-velocity\n  (float2 spikeball-x spikeball-y) &gt; spikeball-position\n  .spikeball-x-1\n  (Pause pausefloat))\n\n(defloop spikeball-1\n  (randomise-spikeball .spikeball-x-1 .spikeball-y-1 .spikeball-velocity-1 .spikeball-position-1 2))\n(defloop spikeball-2\n  (randomise-spikeball .spikeball-x-2 .spikeball-y-2 .spikeball-velocity-2 .spikeball-position-2 3))\n(defloop spikeball-3\n  (randomise-spikeball .spikeball-x-3 .spikeball-y-3 .spikeball-velocity-3 .spikeball-position-3 4))\n\n\n;; --------- Game Elements ------------\n(defshards initialize-game-elements []\n  0 &gt;= .score\n  false &gt;= .scored\n\n  .X (Math.Add 50.0)\n  &gt;= .scoringUpper-x-limit\n  .X (Math.Subtract 50.0)\n  &gt;= .scoringLower-x-limit\n\n  .Y (Math.Add 10.0)\n  &gt;= .scoringUpper-y-limit\n  .Y (Math.Subtract 10.0)\n  &gt;= .scoringLower-y-limit\n\n  ;; ---------- Damage Limits ------------\n  .X (Math.Add 50.0)\n  &gt;= .damageUpper-x-limit\n  .X (Math.Subtract 50.0)\n  &gt;= .damageLower-x-limit\n\n  .Y (Math.Add 5.0)\n  &gt;= .damageUpper-y-limit\n  .Y (Math.Subtract 5.0)\n  &gt;= .damageLower-y-limit\n\n  false &gt;= .damaged\n\n  60 &gt;= .timer\n  0 &gt;= .gameOver)\n\n;; --------- Scoring ----------\n(defshards score-collision [coinx coiny]\n  coinx\n  (When :Predicate (-&gt;\n                    (IsLess .scoringUpper-x-limit)\n                    (And)\n                    coinx (IsMore .scoringLower-x-limit)\n                    (And)\n                    coiny (IsLess .scoringUpper-y-limit)\n                    (And)\n                    coiny (IsMore .scoringLower-y-limit)\n                    (And)\n                    .scored (Is false))\n        :Action (-&gt;\n                true &gt; .scored\n                (Log \"Score: \"))))\n\n(defshards scoring []\n  .X (Math.Add 50.0)\n  &gt; .scoringUpper-x-limit\n  .X (Math.Subtract 50.0)\n  &gt; .scoringLower-x-limit\n\n  .Y (Math.Add 10.0)\n  &gt; .scoringUpper-y-limit\n  .Y (Math.Subtract 10.0)\n  &gt; .scoringLower-y-limit\n\n  (score-collision .coinx-1 .coiny-1)\n  (score-collision .coinx-2 .coiny-2)\n\n  .scored\n  (When :Predicate (Is true)\n        :Action (-&gt;\n                .score (Math.Add 1)\n                &gt; .score\n                true &gt; .score-effect-play\n                false &gt; .scored)))\n\n;; ------------- spikeBall-collision-logic --------------\n(defshards spikeBall-collision-logic [spikeBall-x spikeBall-y]\n\n  spikeBall-x\n  (If :Predicate (-&gt; (IsLess .damageUpper-x-limit)\n                    (And)\n                    spikeBall-x (IsMore .damageLower-x-limit)\n                    (And)\n                    spikeBall-y (IsLess .damageUpper-y-limit)\n                    (And)\n                    spikeBall-y (IsMore .damageLower-y-limit))\n\n      :Then (-&gt; .damaged\n                (When :Predicate (Is false)\n                      :Action (-&gt;\n                              true &gt; .damaged\n                              (Log \"damaged: \"))))))\n\n;; -------------- Damaging --------------\n(defshards damaging []\n\n  .X (Math.Add 120.0)\n  &gt; .damageUpper-x-limit\n  .X (Math.Subtract 120.0)\n  &gt; .damageLower-x-limit\n\n  .Y (Math.Add 15.0)\n  &gt; .damageUpper-y-limit\n  .Y (Math.Subtract 15.0)\n  &gt; .damageLower-y-limit\n\n  (spikeBall-collision-logic .spikeball-x-1 .spikeball-y-1)\n  (spikeBall-collision-logic .spikeball-x-2 .spikeball-y-2)\n  (spikeBall-collision-logic .spikeball-x-3 .spikeball-y-3)\n\n  .damaged\n  (When :Predicate (Is true)\n        :Action (-&gt;\n                .score (Math.Subtract 1)\n                &gt; .score\n                true &gt; .damage-effect-play\n                false &gt; .damaged)))\n\n\n;; ------------- innitialize effects -------------\n(defshards initialize-effects []\n  ;; --------------- Animation Effects -----------------\n  (LoadImage \"GlodImages/Coin/CoinEffect/Score_Effect_1.png\") &gt;&gt; .score-effect-array\n  (LoadImage \"GlodImages/Coin/CoinEffect/Score_Effect_2.png\") &gt;&gt; .score-effect-array\n  (LoadImage \"GlodImages/Coin/CoinEffect/Score_Effect_3.png\") &gt;&gt; .score-effect-array\n  (LoadImage \"GlodImages/Coin/CoinEffect/Score_Effect_4.png\") &gt;&gt; .score-effect-array\n  (LoadImage \"GlodImages/Coin/CoinEffect/Score_Effect_5.png\") &gt;&gt; .score-effect-array\n  (LoadImage \"GlodImages/Coin/CoinEffect/Score_Effect_6.png\") &gt;&gt; .score-effect-array\n  (LoadImage \"GlodImages/Coin/CoinEffect/Score_Effect_7.png\") &gt;&gt; .score-effect-array\n  (LoadImage \"GlodImages/Coin/CoinEffect/Score_Effect_8.png\") &gt;&gt; .score-effect-array\n  (Count .score-effect-array) (Math.Subtract 1) &gt;= .score-effect-array-index-max\n  0 &gt;= .score-effect-array-index\n  0.02 &gt;=  .score-effect-animation-speed ;; Reduce number to increase animation speed\n  false &gt;= .score-effect-play\n\n  0.0 &gt;= .score-effect-position-x\n  0.0 &gt;= .score-effect-position-y\n  (float2 .score-effect-position-x .score-effect-position-y) &gt;= .score-effect-position\n\n  ;; --------------- Damaged Effect ----------------\n  (LoadImage \"GlodImages/Damage_Effect/Damaged_Effect_1.png\") &gt;&gt; .damage-effect-array\n  (LoadImage \"GlodImages/Damage_Effect/Damaged_Effect_2.png\") &gt;&gt; .damage-effect-array\n  (LoadImage \"GlodImages/Damage_Effect/Damaged_Effect_3.png\") &gt;&gt; .damage-effect-array\n  (LoadImage \"GlodImages/Damage_Effect/Damaged_Effect_4.png\") &gt;&gt; .damage-effect-array\n  (LoadImage \"GlodImages/Damage_Effect/Damaged_Effect_5.png\") &gt;&gt; .damage-effect-array\n  (LoadImage \"GlodImages/Damage_Effect/Damaged_Effect_6.png\") &gt;&gt; .damage-effect-array\n  (LoadImage \"GlodImages/Damage_Effect/Damaged_Effect_7.png\") &gt;&gt; .damage-effect-array\n  (LoadImage \"GlodImages/Damage_Effect/Damaged_Effect_8.png\") &gt;&gt; .damage-effect-array\n  (Count .damage-effect-array) (Math.Subtract 1) &gt;= .damage-effect-array-index-max\n  0 &gt;= .damage-effect-array-index\n  0.02 &gt;=  .damage-effect-animation-speed ;; Reduce number to increase animation speed\n  false &gt;= .damage-effect-play\n\n  (LoadImage \"GlodImages/BG.png\") = .bg-image)\n\n;; ------------ ScoreEffect Animation Position ------------\n(defshards scoreEffect-animation-position []\n  .Y (Math.Add -15.0)\n  &gt; .score-effect-position-y\n\n  .X\n  &gt; .score-effect-position-x\n\n  (float2 .score-effect-position-x .score-effect-position-y)\n  &gt; .score-effect-position)\n\n;; ------------ ScoreEffect Animation ------------\n(defloop scoreEffect-animation-logic\n\n  .score-effect-play\n  (When :Predicate (Is true)\n        :Action (-&gt;\n                .score-effect-array-index (Math.Add 1)\n                &gt; .score-effect-array-index\n                (When :Predicate (IsMore .score-effect-array-index-max)\n                      :Action (-&gt;\n                                0 &gt; .score-effect-array-index\n                                false &gt; .score-effect-play))))\n\n\n  (Pause .score-effect-animation-speed))\n\n;; ------------ DamageEffect Animation ------------\n(defloop damage-effect-animation-logic\n\n  .damage-effect-play\n  (When :Predicate (Is true)\n        :Action (-&gt;\n                .damage-effect-array-index (Math.Add 1)\n                &gt; .damage-effect-array-index\n                (When :Predicate (IsMore .damage-effect-array-index-max)\n                      :Action (-&gt;\n                                0 &gt; .damage-effect-array-index\n                                false &gt; .damage-effect-play))))\n\n\n  (Pause .damage-effect-animation-speed))\n\n;; -------- Timer -----------\n(defloop timer-countdown\n  .gameOver\n  (When :Predicate (-&gt;\n                    (Is 0)\n                    (And)\n                    .timer (IsMore 0))\n        :Action (-&gt;\n                .timer (Math.Subtract 1)\n                &gt; .timer))\n\n  (Pause 1.0))\n\n;; ---------- GameOver Logic ------------\n(defshards gameOver-logic []\n  .timer\n  (When :Predicate (Is 0)\n        :Action (-&gt;\n                1 &gt; .gameOver)))\n\n\n;; ------ UI Style --------\n(def style\n  {:override_text_style \"MyStyle\"\n  :text_styles\n  [{:name \"MyStyle\"\n    :size (float 46)\n    :family \"Monospace\"}]\n  :visuals\n  {:override_text_color (color 250 250 250)}})\n\n;;---------- main-wire ------------\n(defloop main-wire\n  (Setup\n  (initialize-character)\n  (initialize-coin)\n  (initialize-game-elements)\n  (initialize-spiked-canonballs)\n  (initialize-effects))\n\n  (coin-gravity-logic .coiny-1 .coinx-1 .coin-velocity-1 .coin-position-1)\n  (coin-gravity-logic .coiny-2 .coinx-2 .coin-velocity-2 .coin-position-2)\n\n  (run-logic)\n  (gravity-logic)\n  (scoring)\n  (damaging)\n\n  (Step idle-animation)\n  (Step walking-animation)\n\n  (Step coin-animation)\n  (Step random-coin-1)\n  (Step random-coin-2)\n\n  (Step spiked-canonball-animation)\n  (spikeball-gravity-logic .spikeball-y-1 .spikeball-velocity-1 .spikeball-position-1 .spikeball-x-1)\n  (spikeball-gravity-logic .spikeball-y-2 .spikeball-velocity-2 .spikeball-position-2 .spikeball-x-2)\n  (spikeball-gravity-logic .spikeball-y-3 .spikeball-velocity-3 .spikeball-position-3 .spikeball-x-3)\n  (Step  spikeball-1)\n  (Step  spikeball-2)\n  (Step  spikeball-3)\n\n  (scoreEffect-animation-position)\n  (Step scoreEffect-animation-logic)\n  (Step damage-effect-animation-logic)\n\n  (Step timer-countdown)\n  (gameOver-logic)\n\n  (GFX.MainWindow\n  :Title \"MainWindow\" :Width 1920 :Height 1080\n  :Contents\n  (-&gt; (Setup\n        (GFX.DrawQueue) &gt;= .ui-draw-queue\n        (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n      .ui-draw-queue (GFX.ClearQueue)\n\n      (UI\n        .ui-draw-queue\n        (-&gt;\n\n        (UI.Area :Position (float2 0 0)\n                  :Anchor Anchor.TopLeft\n                  :Contents (-&gt;\n                            .bg-image (UI.Image :Scale (float2 0.7))))\n\n        (UI.Area :Position .character-position\n                  :Anchor Anchor.Top\n                  :Contents (-&gt;\n                            .character-state\n                            (Match [0 (-&gt; .character-direction\n                                          (Match [0 (-&gt; LoadTexture .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n                                                  1 (-&gt; LoadTexture .idle-right-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))]\n                                                  :Passthrough false))\n                                    1 (-&gt; LoadTexture .walking-left-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n                                    2 (-&gt; LoadTexture .walking-right-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n                                    3 (-&gt;  .character-direction\n                                            (Match [0 (-&gt; LoadTexture .character-jumping-left (UI.Image :Scale (float2 0.2)))\n                                                    1 (-&gt; LoadTexture .character-jumping-right (UI.Image :Scale (float2 0.2)))]\n                                                  :Passthrough false))]\n                                    :Passthrough false)))\n\n        ;; -------- coins ui area -----------\n\n        (UI.Area :Position .coin-position-1\n                  :Anchor Anchor.Top\n                  :Contents (-&gt;\n                            LoadTexture .coin-image-array (Take .coin-image-index) (UI.Image :Scale (float2 0.2))))\n\n        (UI.Area :Position .coin-position-2\n                  :Anchor Anchor.Top\n                  :Contents (-&gt;\n                            LoadTexture .coin-image-array (Take .coin-image-index) (UI.Image :Scale (float2 0.2))))\n        ;; --------- spikeball ui area ----------\n\n        (UI.Area :Position .spikeball-position-1\n                  :Anchor Anchor.Top\n                  :Contents (-&gt;\n                            LoadTexture .spikeball-array (Take .spikeball-index) (UI.Image :Scale (float2 0.15))))\n\n        (UI.Area :Position .spikeball-position-2\n                  :Anchor Anchor.Top\n                  :Contents (-&gt;\n                            LoadTexture .spikeball-array (Take .spikeball-index) (UI.Image :Scale (float2 0.15))))\n\n        (UI.Area :Position .spikeball-position-3\n                  :Anchor Anchor.Top\n                  :Contents (-&gt;\n                            LoadTexture .spikeball-array (Take .spikeball-index) (UI.Image :Scale (float2 0.15))))\n\n        ;; ----------------- Visual Effects  -------------------\n        (UI.Area :Position .score-effect-position\n                  :Anchor Anchor.Top\n                  :Contents (-&gt;\n                            LoadTexture .score-effect-array (Take .score-effect-array-index) (UI.Image :Scale (float2 0.15))))\n\n        (UI.Area :Position (float2 0 0)\n                  :Anchor Anchor.TopLeft\n                  :Contents (-&gt;\n                            LoadTexture .damage-effect-array (Take .damage-effect-array-index) (UI.Image :Scale (float2 10))))\n\n        ;; ---------------- UI ------------------\n\n        (UI.Area :Position (float2 -40 20)\n                  :Anchor Anchor.TopRight\n                  :Contents (-&gt;\n                            style (UI.Style)\n                            .score (ToString) (UI.Label)))\n\n        (UI.Area :Position (float2 40 20)\n                  :Anchor Anchor.TopLeft\n                  :Contents (-&gt;\n                            style (UI.Style)\n                            .timer (ToString) (UI.Label)))))\n\n      (button-inputs)\n\n      (GFX.Render :Steps .render-steps))))\n\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre>"},{"location":"learn/shards/tutorials/glod-game/steps/step-7/#step-75","title":"Step  7.5","text":"<p>Finally its time to code the final bit for our game. We need to add some finality to our game by having it end when our Timer reaches 0. Then we also need to create a way to reset the game so that we can play it again. While this might seem daunting, don't worry! It's much easier than you might think.</p> Code AddedFull Code So Far <pre><code>;; -------- Game_Over_UI -------------\n(defloop gameOver-ui\n  (UI.Area :Position (float2 -40 20)\n          :Anchor Anchor.Center\n          :Contents (-&gt;\n                      style (UI.Style)\n                      \"Score\" (UI.Label)\n                      .score (ToString) (UI.Label)\n                      (UI.Button :Label \"Restart\"\n                                :Action (-&gt;\n                                          0 &gt; .gameOver\n                                          60 &gt; .timer\n                                          0 &gt; .score\n                                          (float2 0 0) &gt; .character-position)))))\n</code></pre> <ol> <li>First we create a defloop with a <code>UI.Area</code> that houses everything we want to show when the game is over. In this case, we want to show our player's score and then a reset button. In the reset Button's <code>:Action</code> tag, we change variables that have changed to revert the game back to it's initial state.</li> </ol> <pre><code>;; ------------ Character Run Logic ----------------\n(defshards run-logic []\n  .X (Math.Add .character-x-velocity)\n  &gt; .X\n\n  (float2 .X .Y) &gt; .character-position) ;; (1)\n</code></pre> <ol> <li>Next we create the <code>run-logic</code>. When <code>.character-x-velocity</code> is changed, it will be added to <code>.X</code> and the <code>.character-position</code> will be updated accordingly Added on lines 77-82</li> </ol> <pre><code>(defloop mainGame-ui\n  (UI.Area :Position (float2 0 0)\n          :Anchor Anchor.TopLeft\n          :Contents (-&gt;\n                      .bg-image (UI.Image :Scale (float2 0.7))))\n\n  (UI.Area :Position .character-position\n          :Anchor Anchor.Top\n          :Contents (-&gt;\n                      .character-state\n                      (Match [0 (-&gt; .character-direction\n                                    (Match [0 (-&gt; .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n                                            1 (-&gt; .idle-right-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))]\n                                          :Passthrough false))\n                              1 (-&gt; .walking-left-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n                              2 (-&gt; .walking-right-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n                              3 (-&gt;  .character-direction\n                                    (Match [0 (-&gt; .character-jumping-left (UI.Image :Scale (float2 0.2)))\n                                            1 (-&gt; .character-jumping-right (UI.Image :Scale (float2 0.2)))]\n                                            :Passthrough false))]\n                            :Passthrough false)))\n\n        ;; ---------- Coins -----------\n\n  (UI.Area :Position .coin-position-1\n          :Anchor Anchor.Top\n          :Contents (-&gt;\n                      .coin-image-array (Take .coin-image-index) (UI.Image :Scale (float2 0.2))))\n\n  (UI.Area :Position .coin-position-2\n          :Anchor Anchor.Top\n          :Contents (-&gt;\n                      .coin-image-array (Take .coin-image-index) (UI.Image :Scale (float2 0.2))))\n\n        ;; ------------SpikeBalls ------------\n\n  (UI.Area :Position .spikeball-position-1\n          :Anchor Anchor.Top\n          :Contents (-&gt;\n                      .spikeball-array (Take .spikeball-index) (UI.Image :Scale (float2 0.15))))\n\n  (UI.Area :Position .spikeball-position-2\n          :Anchor Anchor.Top\n          :Contents (-&gt;\n                      .spikeball-array (Take .spikeball-index) (UI.Image :Scale (float2 0.15))))\n\n  (UI.Area :Position .spikeball-position-3\n          :Anchor Anchor.Top\n          :Contents (-&gt;\n                      .spikeball-array (Take .spikeball-index) (UI.Image :Scale (float2 0.15))))\n\n        ;; ----------------- Visual Effects  -------------------\n  (UI.Area :Position .score-effect-position\n          :Anchor Anchor.Top\n          :Contents (-&gt;\n                      .score-effect-array (Take .score-effect-array-index) (UI.Image :Scale (float2 0.15))))\n\n  (UI.Area :Position (float2 0 0)\n          :Anchor Anchor.TopLeft\n          :Contents (-&gt;\n                      .damage-effect-array (Take .damage-effect-array-index) (UI.Image :Scale (float2 10))))\n\n        ;; --------------- UI Score --------------\n\n  (UI.Area :Position (float2 -40 20)\n          :Anchor Anchor.TopRight\n          :Contents (-&gt;\n                      style (UI.Style)\n                      .score (ToString) (UI.Label)))\n\n        ;; --------------- UI Timer --------------\n  (UI.Area :Position (float2 40 20)\n          :Anchor Anchor.TopLeft\n          :Contents (-&gt;\n                      style (UI.Style)\n                      .timer (ToString) (UI.Label))))\n</code></pre> <p>Next we shift all the UI.Area that we have created so far in main-wire to a new defloop called mainGame-ui. Now if yout ry to run your game now you will get an error as there in nothing in your main-wire to be drawn. Don't panic! All will be clear soon.</p> <pre><code>(UI\n        .ui-draw-queue\n        (-&gt;\n        .gameOver\n        (Match [0 (-&gt; (Step mainGame-ui))\n                1 (-&gt; (Step gameOver-ui))]\n                :Passthrough false)))\n</code></pre> <p>Now inside our <code>main-wire</code> UI, we create a <code>Match</code> shard. If <code>.gameOver</code> is 0 (false), then draw the <code>mainGame-ui</code>. If <code>.gameOver</code> is 1(true) then draw the <code>gameOver-ui.</code></p> <pre><code>(defshards LoadTexture [name]\n  (LoadImage name)\n  (GFX.Texture))\n\n(defshards initialize-character []\n  (LoadTexture \"GlodImages/Character1_Jumping_Left.png\") = .character-jumping-left\n  (LoadTexture \"GlodImages/Character1_Jumping_Right.png\") = .character-jumping-right\n\n  0 &gt;= .character-state\n  0 &gt;= .character-direction\n  true &gt;= .can-jump\n\n  0.0 &gt;= .X\n  620.0 &gt;= .Y\n  (float2 .X .Y) &gt;= .character-position\n  0.0 &gt;= .character-x-velocity\n  0.0 &gt;= .character-y-velocity\n  0.0 &gt;= .character-y-acceleration\n\n  ;; ---------- Character Idle Array (Facing Left) ----------\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png\") &gt;&gt; .idle-left-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png\") &gt;&gt; .idle-left-image-array\n\n  ;; ---------- Character Idle Array (Facing Right) ----------------\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_1.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_2.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_3.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_4.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_5.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_6.png\") &gt;&gt; .idle-right-image-array\n  (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_7.png\") &gt;&gt; .idle-right-image-array\n\n  0 &gt;= .idle-image-index\n  (Count .idle-left-image-array) = .idle-image-index-max\n  0.08 = .idle-animation-speed\n\n  ;; -------------- Walking Array (Facing Left) -----------------\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_1.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_2.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_3.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_4.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_5.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_6.png\") &gt;&gt; .walking-left-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_7.png\") &gt;&gt; .walking-left-image-array\n\n  ;; ----------- Walking Array (Facing Right) ---------------\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_1.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_2.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_3.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_4.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_5.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_6.png\") &gt;&gt; .walking-right-image-array\n  (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_7.png\") &gt;&gt; .walking-right-image-array\n\n  (Count .walking-left-image-array) = .walking-image-index-max\n  0 &gt;= .walking-image-index\n  0.08 = .walking-animation-speed) ;; Reduce number to increase animation speed\n\n;; --------- Idle Animation Loop ---------\n(defloop idle-animation\n  .idle-image-index (Math.Add 1)\n  &gt; .idle-image-index\n  (When :Predicate (IsMoreEqual .idle-image-index-max)\n        :Action (-&gt; 0 &gt; .idle-image-index))\n  (Pause .idle-animation-speed))\n\n;; -------- Walking Animation Loop --------\n(defloop walking-animation\n  .walking-image-index (Math.Add 1)\n  &gt; .walking-image-index\n  (When :Predicate (IsMoreEqual .walking-image-index-max)\n        :Action (-&gt; 0 &gt; .walking-image-index))\n  (Pause .walking-animation-speed))\n\n;; ---------- character-boundary ------------\n\n(defshards clamp [var min max]\n  var (Max min) (Min max) &gt; var)\n\n;; ------------ Character Run Logic ----------------\n(defshards run-logic []\n  .X (Math.Add .character-x-velocity)\n  &gt; .X\n\n  (float2 .X .Y) &gt; .character-position\n\n  (clamp .X -600.0 600.0))\n\n;; ------------ Character gravity-logic ---------------\n(defshards gravity-logic []\n  .Y (Math.Add .character-y-velocity)\n  &gt; .Y\n\n  .character-y-velocity (Math.Add .character-y-acceleration)\n  &gt; .character-y-velocity\n\n  (float2 .X .Y) &gt; .character-position\n\n  (clamp .Y -620.0 620.0)\n  .Y\n  (When :Predicate (IsMoreEqual 620.0)\n        :Action (-&gt;\n                0.0 &gt; .character-y-velocity\n                0.0 &gt; .character-y-acceleration\n                true &gt; .can-jump\n                .character-state\n                (When :Predicate (Is 3)\n                      :Action (-&gt;\n                                0 &gt; .character-state)))))\n\n;; ------- Button Inputs ----------\n(defshards button-inputs []\n  (Inputs.KeyDown\n  :Key \"left\"\n  :Action (-&gt;\n            (Msg \"left\")\n\n            .character-state\n            (When :Predicate (Is 0)\n                  :Action (-&gt; 1 &gt; .character-state))\n\n            0 &gt; .character-direction\n            -5.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyDown\n  :Key \"right\"\n  :Action (-&gt;\n            (Msg \"right\")\n\n            .character-state\n            (When :Predicate (Is 0)\n                  :Action (-&gt; 2 &gt; .character-state))\n            1 &gt; .character-direction\n            5.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyDown\n  :Key \"up\"\n  :Action (-&gt;\n            (Msg \"up\")\n            3 &gt; .character-state\n            .can-jump\n            (When :Predicate (Is true)\n                  :Action (-&gt;\n                          -20.0 &gt; .character-y-velocity\n                          1.0 &gt;  .character-y-acceleration\n                          false &gt;= .can-jump))))\n\n  (Inputs.KeyUp\n  :Key \"left\"\n  :Action (-&gt;\n            0 &gt; .character-state\n            0.0 &gt; .character-x-velocity))\n\n  (Inputs.KeyUp\n  :Key \"right\"\n  :Action (-&gt;\n            0 &gt; .character-state\n            0.0 &gt; .character-x-velocity)))\n\n;; -------------- Initialize Coin ----------\n(defshards initialize-coin []\n  (LoadTexture \"GlodImages/Coin/Coin_1.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_2.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_3.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_4.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_5.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_6.png\") &gt;&gt; .coin-image-array\n  (LoadTexture \"GlodImages/Coin/Coin_7.png\") &gt;&gt; .coin-image-array\n  (Count .coin-image-array) = .coin-image-index-max\n  0 &gt;= .coin-image-index\n  0.1 = .coin-animation-speed\n\n  ;; ----- Coin 1 ------\n  0.0 &gt;= .coinx-1\n  0.0 &gt;= .coiny-1\n  (float2 .coinx-1 .coiny-1) &gt;= .coin-position-1\n  0.0 &gt;= .coin-velocity-1\n  0.5 &gt;= .coin-acceleration\n\n  ;; ----- Coin 2 ----\n  0.0 &gt;= .coinx-2\n  0.0 &gt;= .coiny-2\n  (float2 .coinx-2 .coiny-2) &gt;= .coin-position-2\n  0.0 &gt;= .coin-velocity-2)\n\n;; -------------- Coin Animation ------------------\n(defloop coin-animation\n  .coin-image-index (Math.Add 1)\n  &gt; .coin-image-index\n  (When :Predicate (IsMoreEqual .coin-image-index-max)\n        :Action (-&gt; 0 &gt; .coin-image-index))\n\n  (Pause .coin-animation-speed))\n\n;; ------------- Coin Gravity ------------------\n(defshards coin-gravity-logic [coiny coinx coin-velocity coin-position]\n\n  coiny (Math.Add coin-velocity)\n  &gt; coiny\n\n  coin-velocity (Math.Add .coin-acceleration)\n  &gt; coin-velocity\n\n  (float2 coinx coiny) &gt; coin-position)\n\n;; ------------- Random Coin ------------------\n(defshards random-coin [coinx coiny coin-velocity coin-position pause-length]\n  coinx\n  (RandomFloat :Max 1200.0)\n  &gt; coinx\n  (Math.Subtract 600.0)\n  &gt; coinx\n\n  0.0 &gt; coiny\n  0.0 &gt; coin-velocity\n  (float2 coinx coiny) &gt; coin-position\n  (Pause pause-length))\n\n(defloop random-coin-1\n  (random-coin .coinx-1 .coiny-1 .coin-velocity-1 .coin-position-1 1.5))\n\n(defloop random-coin-2\n  (random-coin .coinx-2 .coiny-2 .coin-velocity-2 .coin-position-2 2.5))\n\n;; ------------ Initialize Spiked CanonBalls ---------------\n(defshards initialize-spiked-canonballs []\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall1.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall2.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall3.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall4.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall5.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall6.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall7.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall8.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall9.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall10.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall11.png\") &gt;&gt; .spikeball-array\n  (LoadTexture \"GlodImages/SpikeBall/SpikeBall12.png\") &gt;&gt; .spikeball-array\n\n  (Count .spikeball-array) = .spikeball-array-index-max\n  0 &gt;= .spikeball-index\n  0.06 = .spikeball-animation-speed\n\n  ;; ---------- spikball-1 -------------\n  1.0 &gt;= .spikeball-velocity-1\n  0.0 &gt;= .spikeball-y-1\n  0.0 &gt;= .spikeball-x-1\n  (float2 .spikeball-x-1 .spikeball-y-1) &gt;= .spikeball-position-1\n\n  ;; ---------- spikeball-2 -------------\n  1.0 &gt;= .spikeball-velocity-2\n  0.0 &gt;= .spikeball-y-2\n  0.0 &gt;= .spikeball-x-2\n  (float2 .spikeball-x-2 .spikeball-y-2) &gt;= .spikeball-position-2\n\n;; ---------- SpikeBall_3 -------------\n  1.0 &gt;= .spikeball-velocity-3\n  0.0 &gt;= .spikeball-y-3\n  0.0 &gt;= .spikeball-x-3\n  (float2 .spikeball-x-3 .spikeball-y-3) &gt;= .spikeball-position-3\n\n  0.5 &gt;= .spikeball-acceleration)\n\n;;------------- Spiked CanonBall Animation -------------\n(defloop spiked-canonball-animation\n  .spikeball-index (Math.Add 1)\n  &gt; .spikeball-index\n  (When :Predicate (IsMoreEqual .spikeball-array-index-max)\n        :Action (-&gt; 0 &gt; .spikeball-index))\n\n  (Pause .spikeball-animation-speed))\n\n;; ------------- SpikeBall_Gravity_Logic -------------\n(defshards spikeball-gravity-logic [spikeball-y spikeball-velocity spikeball-position spikeball-x]\n  spikeball-y (Math.Add spikeball-velocity)\n  &gt; spikeball-y\n  spikeball-velocity (Math.Add .spikeball-acceleration)\n  &gt; spikeball-velocity\n  (float2 spikeball-x spikeball-y) &gt; spikeball-position)\n\n;; ------------- Randomise Spikeball ----------------\n(defshards randomise-spikeball [spikeball-x spikeball-y spikeball-velocity spikeball-position pausefloat]\n  spikeball-x\n  (RandomFloat :Max 1200.0)\n  &gt; spikeball-x\n  (Math.Subtract 600.0)\n  &gt; spikeball-x\n\n  0.0 &gt; spikeball-y\n  0.0 &gt; spikeball-velocity\n  (float2 spikeball-x spikeball-y) &gt; spikeball-position\n  .spikeball-x-1\n  (Pause pausefloat))\n\n(defloop spikeball-1\n  (randomise-spikeball .spikeball-x-1 .spikeball-y-1 .spikeball-velocity-1 .spikeball-position-1 2))\n(defloop spikeball-2\n  (randomise-spikeball .spikeball-x-2 .spikeball-y-2 .spikeball-velocity-2 .spikeball-position-2 3))\n(defloop spikeball-3\n  (randomise-spikeball .spikeball-x-3 .spikeball-y-3 .spikeball-velocity-3 .spikeball-position-3 4))\n\n;; --------- Game Elements ------------\n(defshards initialize-game-elements []\n  ;;------------ Scoring Limits ----------\n  0 &gt;= .score\n  false &gt;= .scored\n\n  .X (Math.Add 50.0)\n  &gt;= .scoringUpper-x-limit\n  .X (Math.Subtract 50.0)\n  &gt;= .scoringLower-x-limit\n\n  .Y (Math.Add 10.0)\n  &gt;= .scoringUpper-y-limit\n  .Y (Math.Subtract 10.0)\n  &gt;= .scoringLower-y-limit\n\n  ;; ---------- Damage Limits ------------\n  .X (Math.Add 50.0)\n  &gt;= .damageUpper-x-limit\n  .X (Math.Subtract 50.0)\n  &gt;= .damageLower-x-limit\n\n  .Y (Math.Add 5.0)\n  &gt;= .damageUpper-y-limit\n  .Y (Math.Subtract 5.0)\n  &gt;= .damageLower-y-limit\n\n  false &gt;= .damaged\n\n  60 &gt;= .timer\n  0 &gt;= .gameOver)\n\n;; --------- Scoring ----------\n(defshards score-collision [coinx coiny]\n  coinx\n  (When :Predicate (-&gt;\n                    (IsLess .scoringUpper-x-limit)\n                    (And)\n                    coinx (IsMore .scoringLower-x-limit)\n                    (And)\n                    coiny (IsLess .scoringUpper-y-limit)\n                    (And)\n                    coiny (IsMore .scoringLower-y-limit)\n                    (And)\n                    .scored (Is false))\n        :Action (-&gt;\n                true &gt; .scored\n                (Log \"Score: \"))))\n\n(defshards scoring []\n  .X (Math.Add 50.0)\n  &gt; .scoringUpper-x-limit\n  .X (Math.Subtract 50.0)\n  &gt; .scoringLower-x-limit\n\n  .Y (Math.Add 10.0)\n  &gt; .scoringUpper-y-limit\n  .Y (Math.Subtract 10.0)\n  &gt; .scoringLower-y-limit\n\n  (score-collision .coinx-1 .coiny-1)\n  (score-collision .coinx-2 .coiny-2)\n\n  .scored\n  (When :Predicate (Is true)\n        :Action (-&gt;\n                .score (Math.Add 1)\n                &gt; .score\n                true &gt; .score-effect-play\n                false &gt; .scored)))\n\n;; ------------- spikeBall-collision-logic --------------\n(defshards spikeBall-collision-logic [spikeBall-x spikeBall-y]\n\n  spikeBall-x\n  (If :Predicate (-&gt; (IsLess .damageUpper-x-limit)\n                    (And)\n                    spikeBall-x (IsMore .damageLower-x-limit)\n                    (And)\n                    spikeBall-y (IsLess .damageUpper-y-limit)\n                    (And)\n                    spikeBall-y (IsMore .damageLower-y-limit))\n\n      :Then (-&gt; .damaged\n                (When :Predicate (Is false)\n                      :Action (-&gt;\n                              true &gt; .damaged\n                              (Log \"damaged: \"))))))\n\n;; -------------- Damaging --------------\n(defshards damaging []\n\n  .X (Math.Add 120.0)\n  &gt; .damageUpper-x-limit\n  .X (Math.Subtract 120.0)\n  &gt; .damageLower-x-limit\n\n  .Y (Math.Add 15.0)\n  &gt; .damageUpper-y-limit\n  .Y (Math.Subtract 15.0)\n  &gt; .damageLower-y-limit\n\n  (spikeBall-collision-logic .spikeball-x-1 .spikeball-y-1)\n  (spikeBall-collision-logic .spikeball-x-2 .spikeball-y-2)\n  (spikeBall-collision-logic .spikeball-x-3 .spikeball-y-3)\n\n  .damaged\n  (When :Predicate (Is true)\n        :Action (-&gt;\n                .score (Math.Subtract 1)\n                &gt; .score\n                true &gt; .damage-effect-play\n                false &gt; .damaged)))\n\n;; ------------- initialize effects -------------\n(defshards initialize-effects []\n  (LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_1.png\") &gt;&gt; .score-effect-array\n  (LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_2.png\") &gt;&gt; .score-effect-array\n  (LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_3.png\") &gt;&gt; .score-effect-array\n  (LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_4.png\") &gt;&gt; .score-effect-array\n  (LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_5.png\") &gt;&gt; .score-effect-array\n  (LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_6.png\") &gt;&gt; .score-effect-array\n  (LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_7.png\") &gt;&gt; .score-effect-array\n  (LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_8.png\") &gt;&gt; .score-effect-array\n  (Count .score-effect-array) (Math.Subtract 1) &gt;= .score-effect-array-index-max\n  0 &gt;= .score-effect-array-index\n  0.05 &gt;=  .score-effect-animation-speed ;; Reduce number to increase animation speed\n  false &gt;= .score-effect-play\n\n  0.0 &gt;= .score-effect-position-x\n  0.0 &gt;= .score-effect-position-y\n  (float2 .score-effect-position-x .score-effect-position-y) &gt;= .score-effect-position\n\n  ;; --------------- Damaged Effect ----------------\n  (LoadTexture \"GlodImages/Damage_Effect/Damaged_Effect_1.png\") &gt;&gt; .damage-effect-array\n  (LoadTexture \"GlodImages/Damage_Effect/Damaged_Effect_2.png\") &gt;&gt; .damage-effect-array\n  (LoadTexture \"GlodImages/Damage_Effect/Damaged_Effect_3.png\") &gt;&gt; .damage-effect-array\n  (LoadTexture \"GlodImages/Damage_Effect/Damaged_Effect_4.png\") &gt;&gt; .damage-effect-array\n  (LoadTexture \"GlodImages/Damage_Effect/Damaged_Effect_5.png\") &gt;&gt; .damage-effect-array\n  (LoadTexture \"GlodImages/Damage_Effect/Damaged_Effect_6.png\") &gt;&gt; .damage-effect-array\n  (LoadTexture \"GlodImages/Damage_Effect/Damaged_Effect_7.png\") &gt;&gt; .damage-effect-array\n  (LoadTexture \"GlodImages/Damage_Effect/Damaged_Effect_8.png\") &gt;&gt; .damage-effect-array\n  (Count .damage-effect-array) (Math.Subtract 1) &gt;= .damage-effect-array-index-max\n  0 &gt;= .damage-effect-array-index\n  0.02 &gt;=  .damage-effect-animation-speed ;; Reduce number to increase animation speed\n  false &gt;= .damage-effect-play\n\n  (LoadTexture \"GlodImages/BG.png\") = .bg-image)\n\n;; ------------ DamageEffect Animation ------------\n(defloop damage-effect-animation-logic\n\n  .damage-effect-play\n  (When :Predicate (Is true)\n        :Action (-&gt;\n                .damage-effect-array-index (Math.Add 1)\n                &gt; .damage-effect-array-index\n                (When :Predicate (IsMore .damage-effect-array-index-max)\n                      :Action (-&gt;\n                                0 &gt; .damage-effect-array-index\n                                false &gt; .damage-effect-play))))\n\n  (Pause .damage-effect-animation-speed))\n\n;; ------------ ScoreEffect_Animation_Position ------------\n(defshards scoreEffect-animation-position []\n  .Y (Math.Add -15.0)\n  &gt; .score-effect-position-y\n\n  .X\n  &gt; .score-effect-position-x\n\n  (float2 .score-effect-position-x .score-effect-position-y)\n  &gt; .score-effect-position)\n\n;; ------------ ScoreEffect Animation ------------\n(defloop scoreEffect-animation-logic\n\n  .score-effect-play\n  (When :Predicate (Is true)\n        :Action (-&gt;\n                .score-effect-array-index (Math.Add 1)\n                &gt; .score-effect-array-index\n                (When :Predicate (IsMore .score-effect-array-index-max)\n                      :Action (-&gt;\n                                0 &gt; .score-effect-array-index\n                                false &gt; .score-effect-play))))\n\n\n  (Pause .score-effect-animation-speed))\n\n;; -------- Timer -----------\n(defloop timer-countdown\n  .gameOver\n  (When :Predicate (-&gt;\n                    (Is 0)\n                    (And)\n                    .timer (IsMore 0))\n        :Action (-&gt;\n                .timer (Math.Subtract 1)\n                &gt; .timer))\n\n  (Pause 1.0))\n\n;; ---------- GameOver Logic ------------\n(defshards gameOver-logic []\n  .timer\n  (When :Predicate (Is 0)\n        :Action (-&gt;\n                1 &gt; .gameOver)))\n\n;; ------ UI Style --------\n(def style\n  {:override_text_style \"MyStyle\"\n  :text_styles\n  [{:name \"MyStyle\"\n    :size (float 46)\n    :family \"Monospace\"}]\n  :visuals\n  {:override_text_color (color 250 250 250)}})\n\n;; -------- Game_Over_UI -------------\n(defloop gameOver-ui\n  (UI.Area :Position (float2 -40 20)\n          :Anchor Anchor.Center\n          :Contents (-&gt;\n                      style (UI.Style)\n                      \"Score\" (UI.Label)\n                      .score (ToString) (UI.Label)\n                      (UI.Button :Label \"Restart\"\n                                :Action (-&gt;\n                                          0 &gt; .gameOver\n                                          60 &gt; .timer\n                                          0 &gt; .score\n                                          (float2 0 0) &gt; .character-position)))))\n\n(defloop mainGame-ui\n  (UI.Area :Position (float2 0 0)\n          :Anchor Anchor.TopLeft\n          :Contents (-&gt;\n                      .bg-image (UI.Image :Scale (float2 0.7))))\n\n  (UI.Area :Position .character-position\n          :Anchor Anchor.Top\n          :Contents (-&gt;\n                      .character-state\n                      (Match [0 (-&gt; .character-direction\n                                    (Match [0 (-&gt; .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n                                            1 (-&gt; .idle-right-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))]\n                                          :Passthrough false))\n                              1 (-&gt; .walking-left-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n                              2 (-&gt; .walking-right-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n                              3 (-&gt;  .character-direction\n                                    (Match [0 (-&gt; .character-jumping-left (UI.Image :Scale (float2 0.2)))\n                                            1 (-&gt; .character-jumping-right (UI.Image :Scale (float2 0.2)))]\n                                            :Passthrough false))]\n                            :Passthrough false)))\n\n        ;; ---------- Coins -----------\n\n  (UI.Area :Position .coin-position-1\n          :Anchor Anchor.Top\n          :Contents (-&gt;\n                      .coin-image-array (Take .coin-image-index) (UI.Image :Scale (float2 0.2))))\n\n  (UI.Area :Position .coin-position-2\n          :Anchor Anchor.Top\n          :Contents (-&gt;\n                      .coin-image-array (Take .coin-image-index) (UI.Image :Scale (float2 0.2))))\n\n        ;; ------------SpikeBalls ------------\n\n  (UI.Area :Position .spikeball-position-1\n          :Anchor Anchor.Top\n          :Contents (-&gt;\n                      .spikeball-array (Take .spikeball-index) (UI.Image :Scale (float2 0.15))))\n\n  (UI.Area :Position .spikeball-position-2\n          :Anchor Anchor.Top\n          :Contents (-&gt;\n                      .spikeball-array (Take .spikeball-index) (UI.Image :Scale (float2 0.15))))\n\n  (UI.Area :Position .spikeball-position-3\n          :Anchor Anchor.Top\n          :Contents (-&gt;\n                      .spikeball-array (Take .spikeball-index) (UI.Image :Scale (float2 0.15))))\n\n        ;; ----------------- Visual Effects  -------------------\n  (UI.Area :Position .score-effect-position\n          :Anchor Anchor.Top\n          :Contents (-&gt;\n                      .score-effect-array (Take .score-effect-array-index) (UI.Image :Scale (float2 0.15))))\n\n  (UI.Area :Position (float2 0 0)\n          :Anchor Anchor.TopLeft\n          :Contents (-&gt;\n                      .damage-effect-array (Take .damage-effect-array-index) (UI.Image :Scale (float2 10))))\n\n        ;; --------------- UI Score --------------\n\n  (UI.Area :Position (float2 -40 20)\n          :Anchor Anchor.TopRight\n          :Contents (-&gt;\n                      style (UI.Style)\n                      .score (ToString) (UI.Label)))\n\n        ;; --------------- UI Timer --------------\n  (UI.Area :Position (float2 40 20)\n          :Anchor Anchor.TopLeft\n          :Contents (-&gt;\n                      style (UI.Style)\n                      .timer (ToString) (UI.Label))))\n\n;;---------- main-wire ------------\n(defloop main-wire\n  (Setup\n  (initialize-character)\n  (initialize-coin)\n  (initialize-game-elements)\n  (initialize-spiked-canonballs)\n  (initialize-effects))\n\n  (coin-gravity-logic .coiny-1 .coinx-1 .coin-velocity-1 .coin-position-1)\n  (coin-gravity-logic .coiny-2 .coinx-2 .coin-velocity-2 .coin-position-2)\n\n  (run-logic)\n  (gravity-logic)\n  (scoring)\n  (damaging)\n\n  (Step idle-animation)\n  (Step walking-animation)\n\n  (Step coin-animation)\n  (Step random-coin-1)\n  (Step random-coin-2)\n\n  (Step spiked-canonball-animation)\n  (spikeball-gravity-logic .spikeball-y-1 .spikeball-velocity-1 .spikeball-position-1 .spikeball-x-1)\n  (spikeball-gravity-logic .spikeball-y-2 .spikeball-velocity-2 .spikeball-position-2 .spikeball-x-2)\n  (spikeball-gravity-logic .spikeball-y-3 .spikeball-velocity-3 .spikeball-position-3 .spikeball-x-3)\n  (Step  spikeball-1)\n  (Step  spikeball-2)\n  (Step  spikeball-3)\n\n  (scoreEffect-animation-position)\n  (Step scoreEffect-animation-logic)\n  (Step damage-effect-animation-logic)\n\n  (Step timer-countdown)\n  (gameOver-logic)\n\n  (GFX.MainWindow\n  :Title \"MainWindow\" :Width 1920 :Height 1080\n  :Contents\n  (-&gt; (Setup\n        (GFX.DrawQueue) &gt;= .ui-draw-queue\n        (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n      .ui-draw-queue (GFX.ClearQueue)\n\n      (UI\n        .ui-draw-queue\n        (-&gt;\n        .gameOver\n        (Match [0 (-&gt; (Step mainGame-ui))\n                1 (-&gt; (Step gameOver-ui))]\n                :Passthrough false)))\n\n      (button-inputs)\n\n      (GFX.Render :Steps .render-steps))))\n\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre> <p>CONGRATULATIONS! \ud83c\udf89\ud83c\udf89\ud83c\udf89\ud83c\udf89\ud83c\udf89\ud83c\udf89</p> <p>You have successfully created a game!</p> <p>Give it a whirl and see how many points you can get!</p>"},{"location":"learn/shards/tutorials/snake/","title":"Snake game tutorial","text":"<p>Welcome! In this tutorial, we will create a simple snake-like game using Shards.</p> <p>You can either follow the step by step tutorial or use the full-game version directly.</p> <ul> <li>Introduction</li> <li>Step by step</li> <li>Full game</li> </ul>"},{"location":"learn/shards/tutorials/snake/#acknowledgments","title":"Acknowledgments","text":"<p>Gremlin Industries which made the original Blockade arcade game, and Nokia which popularized the game under the Snake name.</p> <p> </p>"},{"location":"learn/shards/tutorials/snake/introduction/","title":"Introduction","text":""},{"location":"learn/shards/tutorials/snake/introduction/#gameplay","title":"Gameplay","text":"<p>Snake is a simple game where the player has to move a snake by choosing a direction (up, down, left, or right). Each time the snake eats a fruit it grows by one unit in size. The goal is to continually grow the snake till it occupies all available (game) play-space. However, the game ends if the snake eats a part of its own body or hits the invisible walls (play-space borders).</p> <p> </p>"},{"location":"learn/shards/tutorials/snake/full-game/","title":"Full game","text":"EDNResult snake.edn<pre><code>; SPDX-License-Identifier: BSD-3-Clause\n; Copyright \u00a9 2021 Fragcolor Pte. Ltd.\n\n(def grid-cols 12)\n(def grid-rows 10)\n(def empty-grid\n  [0 0 0 0 0 0 0 0 0 0 0 0\n   0 0 0 0 0 0 0 0 0 0 0 0\n   0 0 0 0 0 0 0 0 0 0 0 0\n   0 0 0 0 0 0 0 0 0 0 0 0\n   0 0 0 0 0 0 0 0 0 0 0 0\n   0 0 0 0 0 0 0 0 0 0 0 0\n   0 0 0 0 0 0 0 0 0 0 0 0\n   0 0 0 0 0 0 0 0 0 0 0 0\n   0 0 0 0 0 0 0 0 0 0 0 0\n   0 0 0 0 0 0 0 0 0 0 0 0])\n\n(defshards get-index []\n  (| (Take 0) &gt;= .x)\n  (| (Take 1) &gt;= .y)\n  .y (Math.Multiply grid-cols) (Math.Add .x))\n\n(defshards get-free-locations [fruit snake]\n  [] &gt;= .locations\n  (ForRange\n   :From 0 :To (- grid-cols 1) :Action\n   (-&gt; &gt;= .a\n       (ForRange\n        :From 0 :To (- grid-rows 1) :Action\n        (-&gt; &gt;= .b\n            [.a .b] (ToInt2) &gt;= .location\n            (When (-&gt; snake (IndexOf .location) (Is -1) (And) fruit (IsNot .location))\n                  (-&gt; .location (Push .locations)))))))\n  .locations)\n\n(defshards move-fruit [fruit snake]\n  (get-free-locations fruit snake) &gt;= .free-loc\n  (Count .free-loc) &gt;= .max\n  (RandomInt .max) &gt;= .next-fruit-loc\n  .free-loc (Take .next-fruit-loc) (ToInt2))\n\n(defshards move-snake [snake offset grow]\n  snake (RTake 0) (Math.Add offset) (Push snake)\n  (WhenNot (-&gt; grow) (DropFront snake)))\n\n(defshards populate-grid [fruit snake]\n  &gt;= .tmp-grid\n  ; first the snake tail and body\n  snake (Take 0) (get-index) &gt;= .tail-index\n  [.tail-index 4] (Assoc .tmp-grid)\n  snake (Slice 1 -1)\n  (ForEach\n   (-&gt; (get-index) &gt;= .limb-index\n       [.limb-index 3] (Assoc .tmp-grid)))\n  ; then the fruit\n  fruit (get-index) &gt;= .fruit-index\n  [.fruit-index 1] (Assoc .tmp-grid)\n  ; finally the snake head\n  snake (RTake 0) (get-index) &gt;= .head-index\n  [.head-index 2] (Assoc .tmp-grid)\n  ; return the populated grid\n  .tmp-grid)\n\n(def cell-size 18)\n(def x-offset 48)\n(def y-offset 36)\n(defn render-cells [n]\n  (if\n   (= n -1)\n    nil\n    (-&gt;\n     (| (int2\n         (% n grid-cols)\n         (/ n grid-cols))\n        (ToFloat2)\n        (Math.Multiply (float2 cell-size))\n        (Math.Add (float2 x-offset y-offset)) &gt; .position)\n     (| (Take n)\n        (UI.Area\n         :Position .position\n         :Contents\n         (-&gt; (Match\n              [0 (-&gt; \".\") ; empty\n               1 (-&gt; \"F\") ; fruit\n               2 (-&gt; \"H\") ; head\n               3 (-&gt; \"B\") ; body\n               4 (-&gt; \"T\") ; tail\n               ]false)\n             (UI.Label))))\n     (render-cells (- n 1)))))\n\n(defshards menus []\n  (UI.MenuBar\n   (-&gt;\n    (UI.Menu\n     \"File\"\n     (-&gt;\n      (UI.Button \"New game\" (-&gt; (initialize) (UI.CloseMenu)))\n      (UI.Separator)\n      (UI.Button \"Quit\" (Stop)))))))\n\n(defshards initialize []\n  [(int2 1 2) (int2 2 2) (int2 3 2) (int2 3 3) (int2 4 3)] &gt;= .snake\n  false &gt;= .grow\n  (move-fruit (int2 0 0) .snake) &gt;= .fruit\n  \"right\" &gt;= .direction &gt;= .prev-direction\n  (Time.Now) &gt;= .last-tick\n  ; do it once to not wait the next tick\n  empty-grid (populate-grid .fruit .snake) &gt;= .grid\n  false &gt;= .game-over)\n\n(defloop main-wire\n  (Once (initialize))\n  ; logic\n  (WhenNot (-&gt; .game-over)\n           ; normal game\n           (When (-&gt; (Time.Now) (Math.Subtract .last-tick) (IsMoreEqual 0.33))\n                 (-&gt; (Time.Now) &gt; .last-tick\n                     ; move the snake\n                     .direction (Match [\"up\" (move-snake .snake (int2 0 -1) .grow)\n                                        \"right\" (move-snake .snake (int2 1 0) .grow)\n                                        \"down\" (move-snake .snake (int2 0 1) .grow)\n                                        \"left\" (move-snake .snake (int2 -1 0) .grow)])\n\n                     (Count .snake) (Math.Subtract 1) &gt;= .head-idx\n                     .snake (Take .head-idx) &gt;= .head\n                     ; snake eats its own body?\n                     (When (-&gt; .snake (IndexOf .head) (IsNot .head-idx))\n                           (-&gt; true &gt; .game-over))\n                     ; snake hits a wall?\n                     (When (-&gt; .head (Take 0) (IsLess 0) (Or) (Take 0) (IsMoreEqual grid-cols)\n                               (Or)\n                               .head (Take 1) (IsLess 0) (Or) (Take 1) (IsMoreEqual grid-rows))\n                           (-&gt; true &gt; .game-over))\n                     ; did the snake eat the fruit?\n                     (If (-&gt; .head (Is .fruit))\n                         (-&gt; true &gt; .grow\n                             (move-fruit .fruit .snake) &gt; .fruit)\n                         (-&gt; false &gt; .grow)\n                         :Passthrough true)\n\n                     (WhenNot (-&gt; .game-over)\n                              (-&gt; empty-grid (populate-grid .fruit .snake) &gt; .grid\n                                  .direction &gt; .prev-direction)))))\n  ; window\n  (GFX.MainWindow\n   :Title \"Snake game\" :Width 480 :Height 360\n   :Contents\n   (-&gt;\n    (Setup\n     (GFX.DrawQueue) &gt;= .ui-draw-queue\n     (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n\n    .ui-draw-queue (GFX.ClearQueue)\n\n    (UI\n     .ui-draw-queue\n     (-&gt;\n      (UI.TopPanel :Contents (menus))\n      (UI.BottomPanel\n       :Contents\n       (-&gt;\n        (When (-&gt; .game-over)\n              (UI.Horizontal\n               (-&gt; \"GAME OVER!\" (UI.Label :Style {:color (color 255 0 0)})\n                   (UI.Space 10.0)\n                   \"Final score: \" (UI.Label)\n                   (Count .snake) (ToString) (UI.Label))))))\n      .grid\n      (Setup (float2 0) &gt;= .position)\n      (render-cells (- (* grid-cols grid-rows) 1))))\n\n    (GFX.Render :Steps .render-steps)\n\n    (Inputs.KeyDown\n     \"up\"\n     (When (-&gt; .prev-direction (IsNot \"down\"))\n           (-&gt; \"up\" &gt; .direction)))\n    (Inputs.KeyDown\n     \"right\"\n     (When (-&gt; .prev-direction (IsNot \"left\"))\n           (-&gt; \"right\" &gt; .direction)))\n    (Inputs.KeyDown\n     \"down\"\n     (When (-&gt; .prev-direction (IsNot \"up\"))\n           (-&gt; \"down\" &gt; .direction)))\n    (Inputs.KeyDown\n     \"left\"\n     (When (-&gt; .prev-direction (IsNot \"right\"))\n           (-&gt; \"left\" &gt; .direction)))\n    (Inputs.KeyDown\n     \"space\" (initialize)))))\n\n(defmesh root)\n(schedule root main-wire)\n(run root (/ 1.0 60))\n</code></pre>"},{"location":"learn/shards/tutorials/snake/steps/","title":"Steps","text":"<ul> <li>Step 1 - getting started</li> <li>Step 2 - basic window</li> <li>Step 3 - drawing the fruit, the snake, and the grid</li> <li>Step 4 - player input</li> <li>Step 5 - game over conditions and final touches</li> </ul>"},{"location":"learn/shards/tutorials/snake/steps/step-1/","title":"Step 1","text":""},{"location":"learn/shards/tutorials/snake/steps/step-1/#basic-file-structure","title":"Basic file structure","text":"<p>In this tutorial, we will program using a Clojure-like syntax and an EDN-like format (JSON equivalent for Clojure). The similarity of Shards' syntax to Clojure means more expressive code in fewer lines (as compared to traditional programming languages like Javascript or Python). Additionally, the code is more focused on data which makes it easier for beginners to grasp.</p> <p>A simple program in Shards would look like this:</p> EDN <pre><code>; define a wire named 'main-wire'\n(defwire main-wire\n  ; print a message on the standard output\n  (Msg \"Hello World!\"))\n\n; define the root mesh\n(defmesh root)\n; schedule the wire on that mesh\n(schedule root main-wire)\n; run\n(run root)\n</code></pre> <p>To run the program, execute the following from the command line:</p> WindowsUnixOutput <pre><code>.\\shards.exe &lt;path\\to\\program.edn&gt;\n</code></pre> <pre><code>./shards path/to/program.edn\n</code></pre> <pre><code>[info] [2021-11-12 16:12:52.712] [T-13596] [logging.cpp::94] [main-wire] Hello World!\n</code></pre>"},{"location":"learn/shards/tutorials/snake/steps/step-1/#game-loop","title":"Game loop","text":"<p>Contrary to simple programs (e.g. a command-line utility) that execute an operation and exit afterwards, a game typically runs for a longer time. Most games have the concept of a \"game loop\".</p> <p>A game loop is the overall flow control of the program that runs continuously during gameplay. In each turn of the loop (known as a frame), the program processes the user's input, updates the game state, and renders the game.</p> <p>In Shards, a wire (self-contained piece of code made that can be suspended/resumed and is made up of shards and functions) can be transformed into a loop by simply replacing <code>(defwire)</code> with <code>(defloop)</code>. Additionally, <code>(run)</code> takes a second argument to specify the delay between two consecutive executions of the loop, specifying the frame rate (FPS). Games tend to run at 60 FPS (or 60 Hz).</p> EDNOutput <pre><code>(defloop main-wire\n  (Msg \"Hello World!\"))\n\n(defmesh root)\n(schedule root main-wire)\n(run root (/ 1.0 60))\n</code></pre> <pre><code>[info] [2021-11-12 16:25:54.487] [T-32668] [logging.cpp::94] [main-wire] Hello World!\n[info] [2021-11-12 16:25:54.514] [T-32668] [logging.cpp::94] [main-wire] Hello World!\n[info] [2021-11-12 16:25:54.530] [T-32668] [logging.cpp::94] [main-wire] Hello World!\n[info] [2021-11-12 16:25:54.546] [T-32668] [logging.cpp::94] [main-wire] Hello World!\n[info] [2021-11-12 16:25:54.562] [T-32668] [logging.cpp::94] [main-wire] Hello World!\n...\n</code></pre> <p> </p>"},{"location":"learn/shards/tutorials/snake/steps/step-2/","title":"Step 2","text":"<p>In this tutorial, we will implement a simplified version of the snake game. For now, we won't have high-end graphics but we'll instead focus on the game logic.</p>"},{"location":"learn/shards/tutorials/snake/steps/step-2/#defining-the-play-space","title":"Defining the play space","text":"<p>The snake evolves inside a grid. It moves one cell at a time either horizontally or vertically. The fruit that the snake must eat to grow can appear on any unoccupied cell.</p> <p>Such a grid may be defined in many ways. We could use a 2D array (or in our case, a sequence of sequences since our grid exists in two-dimensional space). However, to keep our code simple, we will instead use a flat sequence to hold the states of all our grid elements.</p> <p>The trick is to visualize the 1D sequence as a 2D matrix with defined grid row and grid column values (see code below).</p> EDN <pre><code>(def grid-cols 5) ;; (1)\n(def grid-rows 4)\n(def empty-grid\n  [0 0 0 0 0\n   0 0 0 0 0\n   0 0 0 0 0\n   0 0 0 0 0]) ;; (2)\n</code></pre> <ol> <li>The <code>def</code> keyword associates a value with a name.</li> <li><code>[]</code> is the syntax to define a sequence of values.</li> </ol> <p>Now, to compute the index of a grid element in that sequence from its 2D coordinates, we can define the following function.</p> EDN <pre><code>(defn get-index [] ;; (1)\n  (-&gt; (| (Take 0) &gt;= .x) ;; (2) (3)\n      (| (Take 1) &gt;= .y) ;; (4) (5)\n      .y (Math.Multiply grid-cols) (Math.Add .x))) ;; (6) (7)\n</code></pre> <ol> <li>The <code>defn</code> keyword associates a function with a name. Note the <code>[]</code> after the <code>get-index</code> name. This indicates that this function has 0 parameters. We will later see functions that do have parameters.</li> <li><code>(-&gt;)</code> is a shard container that will group and execute its inner shard(s) in order.</li> <li><code>(|)</code> is an alias for <code>(Sub)</code>. It allows reusing the same input across a sequence of shards.</li> <li><code>(Take)</code> returns the value from a sequence at a given index (starting at <code>0</code>).</li> <li><code>&gt;=</code> is an alias for the shard <code>(Set)</code> which saves the output of a shard into a context variable.</li> <li><code>(Math.Multiply)</code> multiplies its input (written to the left of the shard) with a given value (written to the right of the shard and enclosed within its brackets) and outputs the result.</li> <li><code>(Math.Add)</code> adds a value to its input and outputs the result.</li> </ol> Note <p>Because defn expects a single \"value\" (called function return value) after the function name and the list of parameters, and our function\u2019s logic (function body) contains multiple shards, a <code>(-&gt;)</code> shard is required to group these shards in a single (return) shard. Since this is a common situation with <code>(defn)</code> function, a convenient alternative is to use <code>(defshards)</code> instead. A <code>(defshards)</code> behaves exactly like a function (including the ability to accept input parameters) but can contain multiple shards in its body. These multiple shards are executed in the order that they appear and the <code>(defshards)</code> return value is the output of the last shard in its body.</p> <pre><code>(defshards get-index []\n  (| (Take 0) &gt;= .x)\n  (| (Take 1) &gt;= .y)\n  .y (Math.Multiply grid-cols) (Math.Add .x))\n</code></pre> <p>It can be a bit confusing considering that the function doesn't have any parameters. This is because there is an implicit parameter which is the input.</p> <p>Since the <code>(Take)</code>shard statements start with a <code>(|)</code>, they both process the same input (i.e. the implicit input parameter) passed to the <code>get-index</code> function. The first statement stores the 0th element of the input (sequence) into a context variable <code>.x</code>, while the second statement stores the 1st element of the input into a context variable <code>.y</code>.</p> <p>Similarly, there is an implicit output at the end of the function (the equivalent of the <code>return</code> statement in other programming languages) which is also the function's return value.</p> <p>Let's break down the last line to understand what's happening here.</p> EDN <pre><code>.y (Math.Multiply grid-cols) (Math.Add .x)\n</code></pre> <ul> <li>Here <code>.y</code> is a context variable.</li> <li>Its value becomes the input of the next shard: <code>(Math.Multiply)</code>.</li> <li><code>(Math.Multiply)</code> takes that value, multiplies it by <code>grid-cols</code>, and returns the result as output.</li> <li>The output becomes the input for the next shard: <code>(Math.Add)</code>.</li> <li><code>(Math.Add)</code> takes that input and adds it to the value of the context variable <code>.x</code>.</li> <li>Since this is the last shard of the function, the output of this shard becomes the output of the whole function.</li> </ul> <p>Whenever this function is called, the same processing will happen.</p> EDN <pre><code>(int2 1 2) (get-index)\n</code></pre> <p>This time our input is a 2D integer vector represented as a single <code>int2</code> value. Inside <code>(get-index)</code> each component of that vector will be extracted using <code>(Take)</code> (see above code listings).</p>"},{"location":"learn/shards/tutorials/snake/steps/step-2/#creating-a-window","title":"Creating a window","text":"<p>We will render our game as a windowed application. Therefore we first need to define a window.</p> EDNResult <pre><code>(defloop main-wire ;; (1)\n  (GFX.MainWindow  ;; (2)\n   :Title \"Snake game\" :Width 480 :Height 360))\n\n(defmesh root)\n(schedule root main-wire)\n(run root (/ 1.0 60))\n</code></pre> <ol> <li>We have already seen <code>defloop</code>, <code>defmesh</code>, <code>schedule</code> and <code>run</code> in step 1.</li> <li><code>(GFX.MainWindow)</code> creates the application window.</li> </ol> <p></p>"},{"location":"learn/shards/tutorials/snake/steps/step-2/#adding-ui","title":"Adding UI","text":"<p>We will render the game using UI elements. We need to initialize some code to get the UI working.</p> EDNResult <ol> <li>Boilerplate code to initialize some stuff required for rendering the UI.</li> <li><code>(UI)</code> defines a UI context.</li> <li>UI code will go here.</li> <li>Actual render of the UI.</li> </ol> <p></p>"},{"location":"learn/shards/tutorials/snake/steps/step-2/#lets-try-it-out","title":"Let's try it out!","text":"<p>Let's give our function a try. First, we will change a few values in the grid to be something other than <code>0</code>. And then we will try to retrieve and display those values in our brand-new window. Can you guess which values will be displayed?</p> EDNResult <pre><code>(def grid-cols 5)\n(def grid-rows 4)\n(def grid\n  [0 2 0 0 3\n   1 0 7 0 0\n   0 0 0 4 0\n   6 0 5 0 8])\n\n(defn get-index []\n  (-&gt; (| (Take 0) &gt;= .x)\n      (| (Take 1) &gt;= .y)\n      .y (Math.Multiply grid-cols) (Math.Add .x)))\n\n(defloop main-wire\n  (GFX.MainWindow\n   :Title \"Snake game\" :Width 480 :Height 360\n   :Contents\n   (-&gt;\n    (Setup\n     (GFX.DrawQueue) &gt;= .ui-draw-queue\n     (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n    .ui-draw-queue (GFX.ClearQueue)\n\n    (UI\n     .ui-draw-queue\n     (UI.CentralPanel\n      (-&gt;\n       (int2 0 1) (get-index) &gt;= .a\n       (int2 3 2) (get-index) &gt;= .b\n\n       grid (Take .a) (ToString) (UI.Label)\n       grid (Take .b) (ToString) (UI.Label))))\n\n    (GFX.Render :Steps .render-steps))))\n\n(defmesh root)\n(schedule root main-wire)\n(run root (/ 1.0 60))\n</code></pre> <p></p> <p> </p>"},{"location":"learn/shards/tutorials/snake/steps/step-3/","title":"Step 3","text":""},{"location":"learn/shards/tutorials/snake/steps/step-3/#drawing-the-grid-the-fruit-and-the-snake","title":"Drawing the grid, the fruit, and the snake","text":"<p>We will assign some values to define what entity each cell of our grid can represent. For now, we will map these numeric values to draw a unique single character each as the visual representation.</p> value entity character 0 empty <code>\".\"</code> 1 fruit <code>\"F\"</code> 2 head <code>\"H\"</code> 3 body <code>\"B\"</code> 4 tail <code>\"T\"</code> <p>A snake has a head and a tail, and a body. We can represent these entities as a sequence of coordinates. The first element is the tail, the last one is the head, and everything in between is the body.</p> EDN <pre><code>[(int2 1 2) (int2 2 2) (int2 3 2) (int2 3 3) (int2 4 3)] &gt;= .snake\n</code></pre> <p>The fruit, however, occupies a single cell - so we just need one set of coordinates.</p> <p>Every other cell is empty (or unoccupied) and is represented with a \u2018.\u2019.</p> EDN <pre><code>(int2 4 4) &gt;= .fruit\n</code></pre> <p>To position the cells, we will use a <code>(UI.Area)</code>. By default, it is anchored at the top left corner, which means the position at that corner is <code>(float2 0 0)</code>.</p> <p>To calculate the position of our cell, we take into account the number of columns, the size in pixels we want our cell to have (<code>cell-size</code>) and additional <code>x-offset</code> and <code>y-offset</code> so that the overall grid is not stuck at the top left corner but slightly moved right and down.</p> EDN <pre><code>(def cell-size 18)\n(def x-offset 48)\n(def y-offset 36)\n(defn render-cell [n] ;; (1)\n  (| (int2 ;; (2)\n      (% n grid-cols) ;; (3)\n      (/ n grid-cols)) ;; (4)\n    (ToFloat2) ;; (5)\n    (Math.Multiply (float2 cell-size)) ;; (6)\n    (Math.Add (float2 x-offset y-offset)) &gt; .position) ;; (7)\n  (| (Take n) ;; (8)\n    (UI.Area\n      :Position .position\n      :Contents\n      (-&gt; (Match ;; (9)\n          [0 (-&gt; \".\") ; empty\n            1 (-&gt; \"F\") ; fruit\n            2 (-&gt; \"H\") ; head\n            3 (-&gt; \"B\") ; body\n            4 (-&gt; \"T\") ; tail\n            ]false)\n          (UI.Label))))) ;; (10)\n</code></pre> <ol> <li>The input of this function will be our grid. The parameter <code>n</code> is the cell index we want to render.</li> <li>We want to apply mathematical functions to integral numbers (so-called integers) so we explicitly use the <code>(int2)</code>type.</li> <li><code>%</code> is the modulo function. We use it to get the <code>x</code> coordinate, i.e. the index of the column in our grid.</li> <li><code>/</code> is the division function. We use it to get the <code>y</code> coordinate, i.e. the index of the row in our grid.</li> <li><code>(UI.Area)</code> requires a <code>(float2)</code> type for its <code>:Position</code> parameter, so we do a conversion using <code>(ToFloat2)</code></li> <li>We defined the size for a single cell to be <code>cell-size</code>. Without it, it would have been a 1x1 pixel which we could hardly see.</li> <li>Finally, we add the offsets so that our grid is more centered. The final value is saved into the <code>.position</code> variable.</li> <li>Now, we get the value of <code>n</code>-indexed cell from the <code>.grid</code> variable that was given as input to the <code>render-area</code> function.</li> <li>In that action, we <code>(Match)</code> the value of the cell to the corresponding character we have chosen.</li> <li>Then the matched character is displayed in place of that grid element using <code>(UI.Label)</code>.</li> </ol> <p>The above function only deals with a single cell. We want to render all cells. To do so we will slightly modify it to recursively apply to each cell index (from <code>0</code> to <code>(- (* grid-cols grid-rows) 1)</code>, i.e. the number of columns times the number of rows, minus 1 because we start our index at <code>0</code>).</p> EDN <pre><code>(def cell-size 18)\n(def x-offset 48)\n(def y-offset 36)\n(defn render-cells [n] ;; (1)\n  (if\n  (= n -1) ;; (2)\n    nil  ;; (3)\n    (-&gt; ;; (4)\n    (| (int2\n        (% n grid-cols)\n        (/ n grid-cols))\n        (ToFloat2)\n        (Math.Multiply (float2 cell-size))\n        (Math.Add (float2 x-offset y-offset)) &gt; .position)\n    (| (Take n)\n        (UI.Area\n        :Position .position\n        :Contents\n        (-&gt; (Match\n              [0 (-&gt; \".\") ; empty\n              1 (-&gt; \"F\") ; fruit\n              2 (-&gt; \"H\") ; head\n              3 (-&gt; \"B\") ; body\n              4 (-&gt; \"T\") ; tail\n              ]false)\n            (UI.Label))))\n    (render-cells (- n 1))))) ;; (5)\n</code></pre> <ol> <li>We pluralized the function since it now renders several cells.</li> <li>We test whether <code>n</code> equals <code>-1</code>. Since we want to render cells from <code>0</code> to <code>(- (* grid-cols grid-rows) 1)</code>, this is our stopping condition.</li> <li>If we are in that case, we do nothing (<code>nil</code>).</li> <li>Otherwise, we perform the same code as we did above.</li> <li>Finally we do the recursion, which is just calling the same <code>render-cells</code> function but with a decremented value for <code>n</code>.</li> </ol>"},{"location":"learn/shards/tutorials/snake/steps/step-3/#populating-the-grid","title":"Populating the grid","text":"<p>Before we can draw anything we need to update the grid with the fruit and the snake. To update a sequence at a given index, we can use the <code>(Assoc)</code> shard. And since the snake is saved as a sequence itself, we need to iterate through all its elements. However, the head, tail, and body are represented by different values, so we will handle them separately.</p> EDN <pre><code>(defshards populate-grid [fruit snake]\n  ; saves the input into a variable\n  &gt;= .tmp-grid\n\n  ; first the snake tail and body\n  snake (Take 0) (get-index) &gt;= .tail-index ;; (1)\n  [.tail-index 4] (Assoc .tmp-grid) ;; (2)\n  snake (Slice 1 -1) ;; (3)\n  (ForEach\n   (-&gt; (get-index) &gt;= .limb-index\n       [.limb-index 3] (Assoc .tmp-grid)))\n\n  ; then the fruit\n  fruit (get-index) &gt;= .fruit-index\n  [.fruit-index 1] (Assoc .tmp-grid)\n\n  ; finally the snake head\n  snake (RTake 0) (get-index) &gt;= .head-index ;; (4)\n  [.head-index 2] (Assoc .tmp-grid)\n\n  ; return the populated grid\n  .tmp-grid)\n</code></pre> <ol> <li>We have already seen <code>(Take)</code> and <code>get-index</code> in step 2.</li> <li>Assoc lets us update the sequence.</li> <li><code>(Slice)</code> gives a part of a sequence in a range. <code>1</code> means we start at the second element of the sequence (in other words, we skip <code>1</code> element), and <code>-1</code> means we stop at one element before the last (in other words, we skip <code>1</code> element from the end).</li> <li><code>(RTake)</code> is similar to <code>(Take)</code>, except it starts from the end of the sequence instead of the beginning (i.e. \"reverse take\").</li> </ol> <p>This new function <code>populate-grid</code> will take our empty grid as input and return a populated grid. That is why we need a temporary variable inside the function (<code>.tmp-grid</code>).</p> Note <p>Another alternative would have been, to have a single grid and erase the previous positions of the fruit and the snake before updating to their new positions. We find it easier to just update the whole grid at once for this tutorial.</p>"},{"location":"learn/shards/tutorials/snake/steps/step-3/#lets-try-it-out","title":"Let's try it out!","text":"<p>Let's put into practice all that we have seen so far.</p> EDNResult <pre><code>(def grid-cols 12)\n(def grid-rows 10)\n(def empty-grid\n  [0 0 0 0 0 0 0 0 0 0 0 0\n   0 0 0 0 0 0 0 0 0 0 0 0\n   0 0 0 0 0 0 0 0 0 0 0 0\n   0 0 0 0 0 0 0 0 0 0 0 0\n   0 0 0 0 0 0 0 0 0 0 0 0\n   0 0 0 0 0 0 0 0 0 0 0 0\n   0 0 0 0 0 0 0 0 0 0 0 0\n   0 0 0 0 0 0 0 0 0 0 0 0\n   0 0 0 0 0 0 0 0 0 0 0 0\n   0 0 0 0 0 0 0 0 0 0 0 0])\n\n(defshards get-index []\n  (| (Take 0) &gt;= .x)\n  (| (Take 1) &gt;= .y)\n  .y (Math.Multiply grid-cols) (Math.Add .x))\n\n(defshards populate-grid [fruit snake]\n  ; saves the input into a variable\n  &gt;= .tmp-grid\n\n  ; first the snake tail and body\n  snake (Take 0) (get-index) &gt;= .tail-index\n  [.tail-index 4] (Assoc .tmp-grid)\n  snake (Slice 1 -1)\n  (ForEach\n   (-&gt; (get-index) &gt;= .limb-index\n       [.limb-index 3] (Assoc .tmp-grid)))\n\n  ; then the fruit\n  fruit (get-index) &gt;= .fruit-index\n  [.fruit-index 1] (Assoc .tmp-grid)\n\n  ; finally the snake head\n  snake (RTake 0) (get-index) &gt;= .head-index\n  [.head-index 2] (Assoc .tmp-grid)\n\n  ; return the populated grid\n  .tmp-grid)\n\n(def cell-size 18)\n(def x-offset 48)\n(def y-offset 36)\n(defn render-cells [n]\n  (if\n   (= n -1)\n    nil\n    (-&gt;\n     (| (int2\n         (% n grid-cols)\n         (/ n grid-cols))\n        (ToFloat2)\n        (Math.Multiply (float2 cell-size))\n        (Math.Add (float2 x-offset y-offset)) &gt; .position)\n     (| (Take n)\n        (UI.Area\n         :Position .position\n         :Contents\n         (-&gt; (Match\n              [0 (-&gt; \".\") ; empty\n               1 (-&gt; \"F\") ; fruit\n               2 (-&gt; \"H\") ; head\n               3 (-&gt; \"B\") ; body\n               4 (-&gt; \"T\") ; tail\n               ]false)\n             (UI.Label))))\n     (render-cells (- n 1)))))\n\n(defloop main-wire\n  ; logic\n  [(int2 1 2) (int2 2 2) (int2 3 2) (int2 3 3) (int2 4 3)] &gt;= .snake\n  (int2 6 7) &gt;= .fruit\n  empty-grid (populate-grid .fruit .snake) &gt;= .grid\n  ; window\n  (GFX.MainWindow\n   :Title \"Snake game\" :Width 480 :Height 360\n   :Contents\n   (-&gt;\n    (Setup\n     (GFX.DrawQueue) &gt;= .ui-draw-queue\n     (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n    .ui-draw-queue (GFX.ClearQueue)\n\n    (UI\n     .ui-draw-queue\n     (-&gt;\n      .grid\n      (Setup (float2 0) &gt;= .position)\n      (render-cells (- (* grid-cols grid-rows) 1))))\n\n    (GFX.Render :Steps .render-steps))))\n\n(defmesh root)\n(schedule root main-wire)\n(run root (/ 1.0 60))\n</code></pre> <p></p> <p> </p>"},{"location":"learn/shards/tutorials/snake/steps/step-4/","title":"Step 4","text":""},{"location":"learn/shards/tutorials/snake/steps/step-4/#moving-the-fruit","title":"Moving the fruit","text":"<p>When the snake eats a fruit we will need another unoccupied location for the new fruit.</p> <p>Let's first compute the list of locations that are unoccupied.</p> EDN <pre><code>(defshards get-free-locations [snake fruit]\n  [] &gt;= .locations ;; (1)\n  (ForRange ;; (2)\n   :From 0 :To (- grid-cols 1) :Action ;; (3)\n   (-&gt; &gt;= .a\n       (ForRange\n        :From 0 :To (- grid-rows 1) :Action\n        (-&gt; &gt;= .b\n            [.a .b] (ToInt2) &gt;= .location\n            (When (-&gt; snake (IndexOf .location) (Is -1) (And) fruit (IsNot .location)) ;; (4) (5) (6)\n                  (-&gt; .location (Push .locations))))))) ;; (7)\n  .locations)\n</code></pre> <ol> <li><code>[]</code> is an empty sequence.</li> <li><code>(ForRange)</code> iterates a range of values (including both <code>:From</code> and <code>:To</code> ends).</li> <li><code>(- a b)</code> is a built-in function that can act on constant values (as opposed to <code>(Math.Subtract)</code> that can act on constants and variables).</li> <li><code>(When)</code> is similar to <code>(If)</code>, except it is \"passthrough\" by default (don't worry about that concept for now).</li> <li><code>(Is)</code> and <code>(IsNot)</code> compare two values.</li> <li><code>(And)</code> is a logic operator.</li> <li><code>(Push)</code> adds a value to a sequence.</li> </ol> <p>The function takes the positions of the snake body (incl. head and tail) and the current fruit position. It then iterates through all possible coordinates skipping the ones that are either occupied by the snake or the current fruit. The sequence of potential locations is then returned as the function's output.</p> <p>Now all we need to do is select a random position from this sequence and that will be our next fruit position.</p> EDN <pre><code>(defshards move-fruit [fruit snake]\n  (get-free-locations fruit snake) &gt;= .free-loc\n  (Count .free-loc) &gt;= .max ;; (1)\n  (RandomInt .max) &gt;= .next-fruit-loc ;; (2)\n  .free-loc (Take .next-fruit-loc) (ToInt2)) ;; (3) (4)\n</code></pre> <ol> <li><code>(Count)</code> returns the number of elements in a sequence.</li> <li><code>(RandomInt)</code> returns a random value between 0 and the given maximum (exclusive).</li> <li>We have already seen <code>(Take)</code> in step 2.</li> <li><code>(ToInt2)</code> ensures that we return an <code>int2</code> value.</li> </ol>"},{"location":"learn/shards/tutorials/snake/steps/step-4/#moving-the-snake","title":"Moving the snake","text":"<p>In the snake game, the snake moves by one cell either horizontally or vertically. We could \"move\" every cell of its body one by one, but there is a clever trick we can use: we can just remove the first element (tail) from the snake's sequence and add one for the new head position.</p> <p>When the snake is growing (after eating a fruit) we only add the new head (in place of the fruit element) but keep the tail such that snake seems to grow in the direction of the fruit it just ate.</p> EDN <pre><code>(defshards move-snake [snake offset grow]\n  snake (RTake 0) (Math.Add offset) (Push snake) ;; (1)\n  (WhenNot (-&gt; grow) (DropFront snake))) ;; (2) (3)\n</code></pre> <ol> <li>We have already seen <code>(RTake)</code> in step 3.</li> <li><code>(WhenNot)</code> is similar to <code>(When)</code> but with the opposite logic.</li> <li><code>(DropFront)</code> removes the first element of a sequence.</li> </ol> <p>Now we need the snake to move at regular intervals in the direction chosen by the player.</p> <p>Let's first listen to the player's input. We will use the keyboard's arrow keys (up, down, left, right) for this.</p> EDN <pre><code>(Inputs.KeyDown \"up\" (-&gt; \"up\" &gt; .direction)) ;; (1)\n(Inputs.KeyDown \"right\" (-&gt; \"right\" &gt; .direction))\n(Inputs.KeyDown \"down\" (-&gt; \"down\" &gt; .direction))\n(Inputs.KeyDown \"left\" (-&gt; \"left\" &gt; .direction))\n</code></pre> <ol> <li><code>(Inputs.KeyDown)</code> executes an action when a key is down. It has a sibling event: <code>(Inputs.KeyUp)</code>. <code>(&gt;)</code> is an alias for <code>Push</code>.</li> </ol> <p>We also want to prevent the player from accidentally selecting the opposite direction (e.g. down while the snake is going up) since that would immediately end the game (as the snake would immediately turn backward to eat its own body starting with its neck). One easy way to do this is to compare the newly chosen direction with the previous one.</p> EDN <pre><code>(Inputs.KeyDown\n \"up\"\n (When (-&gt; .prev-direction (IsNot \"down\"))\n       (-&gt; \"up\" &gt; .direction)))\n(Inputs.KeyDown\n \"right\"\n (When (-&gt; .prev-direction (IsNot \"left\"))\n       (-&gt; \"right\" &gt; .direction)))\n(Inputs.KeyDown\n \"down\"\n (When (-&gt; .prev-direction (IsNot \"up\"))\n       (-&gt; \"down\" &gt; .direction)))\n(Inputs.KeyDown\n \"left\"\n (When (-&gt; .prev-direction (IsNot \"right\"))\n       (-&gt; \"left\" &gt; .direction)))\n</code></pre> <p>Finally, the snake will move at regular intervals. We can do that by comparing the current time and the time since the last update.</p> EDN <pre><code> (When (-&gt; (Time.Now) (Math.Subtract .last-tick) (IsMoreEqual 0.50)) ;; (1)\n       (-&gt; (Time.Now) &gt; .last-tick\n           ; move the snake\n           .direction (Match [\"up\" (move-snake .snake (int2 0 -1) .grow)\n                              \"right\" (move-snake .snake (int2 1 0) .grow)\n                              \"down\" (move-snake .snake (int2 0 1) .grow)\n                              \"left\" (move-snake .snake (int2 -1 0) .grow)])))\n</code></pre> <ol> <li><code>(Time.Now)</code> returns the time elapsed since the start of the game.</li> </ol> <p>Now the snake will move every half a second. We could change this value to vary the difficulty of the game.</p>"},{"location":"learn/shards/tutorials/snake/steps/step-4/#lets-try-it-out","title":"Let's try it out!","text":"<p>Putting together all that we have seen so far, and adding a bit of initialization (that we conveniently put in its function to allow us to reinitialize the game if the player hits the space bar), we have the following code.</p> EDNResult <pre><code>(def grid-cols 12)\n(def grid-rows 10)\n(def empty-grid\n  [0 0 0 0 0 0 0 0 0 0 0 0\n   0 0 0 0 0 0 0 0 0 0 0 0\n   0 0 0 0 0 0 0 0 0 0 0 0\n   0 0 0 0 0 0 0 0 0 0 0 0\n   0 0 0 0 0 0 0 0 0 0 0 0\n   0 0 0 0 0 0 0 0 0 0 0 0\n   0 0 0 0 0 0 0 0 0 0 0 0\n   0 0 0 0 0 0 0 0 0 0 0 0\n   0 0 0 0 0 0 0 0 0 0 0 0\n   0 0 0 0 0 0 0 0 0 0 0 0])\n\n(defshards get-index []\n  (| (Take 0) &gt;= .x)\n  (| (Take 1) &gt;= .y)\n  .y (Math.Multiply grid-cols) (Math.Add .x))\n\n(defshards get-free-locations [fruit snake]\n  [] &gt;= .locations\n  (ForRange\n   :From 0 :To (- grid-cols 1) :Action\n   (-&gt; &gt;= .a\n       (ForRange\n        :From 0 :To (- grid-rows 1) :Action\n        (-&gt; &gt;= .b\n            [.a .b] (ToInt2) &gt;= .location\n            (When (-&gt; snake (IndexOf .location) (Is -1) (And) fruit (IsNot .location))\n                  (-&gt; .location (Push .locations)))))))\n  .locations)\n\n(defshards move-fruit [fruit snake]\n  (get-free-locations fruit snake) &gt;= .free-loc\n  (Count .free-loc) &gt;= .max\n  (RandomInt .max) &gt;= .next-fruit-loc\n  .free-loc (Take .next-fruit-loc) (ToInt2))\n\n(defshards move-snake [snake offset grow]\n  snake (RTake 0) (Math.Add offset) (Push snake)\n  (WhenNot (-&gt; grow) (DropFront snake)))\n\n(defshards populate-grid [fruit snake]\n  &gt;= .tmp-grid\n\n  ; first the snake tail and body\n  snake (Take 0) (get-index) &gt;= .tail-index\n  [.tail-index 4] (Assoc .tmp-grid)\n  snake (Slice 1 -1)\n  (ForEach\n   (-&gt; (get-index) &gt;= .limb-index\n       [.limb-index 3] (Assoc .tmp-grid)))\n\n  ; then the fruit\n  fruit (get-index) &gt;= .fruit-index\n  [.fruit-index 1] (Assoc .tmp-grid)\n\n  ; finally the snake head\n  snake (RTake 0) (get-index) &gt;= .head-index\n  [.head-index 2] (Assoc .tmp-grid)\n\n  ; return the populated grid\n  .tmp-grid)\n\n(def cell-size 18)\n(def x-offset 48)\n(def y-offset 36)\n(defn render-cells [n]\n  (if\n   (= n -1)\n    nil\n    (-&gt;\n     (| (int2\n         (% n grid-cols)\n         (/ n grid-cols))\n        (ToFloat2)\n        (Math.Multiply (float2 cell-size))\n        (Math.Add (float2 x-offset y-offset)) &gt; .position)\n     (| (Take n)\n        (UI.Area\n         :Position .position\n         :Contents\n         (-&gt; (Match\n              [0 (-&gt; \".\") ; empty\n               1 (-&gt; \"F\") ; fruit\n               2 (-&gt; \"H\") ; head\n               3 (-&gt; \"B\") ; body\n               4 (-&gt; \"T\") ; tail\n               ]false)\n             (UI.Label))))\n     (render-cells (- n 1)))))\n\n(defshards initialize []\n  [(int2 1 2) (int2 2 2) (int2 3 2) (int2 3 3) (int2 4 3)] &gt;= .snake\n  false &gt;= .grow\n  (move-fruit (int2 0 0) .snake) &gt;= .fruit\n  \"right\" &gt;= .direction &gt;= .prev-direction\n  (Time.Now) &gt;= .last-tick\n  ; do it once to not wait the next tick\n  empty-grid (populate-grid .fruit .snake) &gt;= .grid)\n\n(defloop main-wire\n  (Once (initialize))\n  ; logic\n  (When (-&gt; (Time.Now) (Math.Subtract .last-tick) (IsMoreEqual 0.33))\n        (-&gt; (Time.Now) &gt; .last-tick\n            ; move the snake\n            .direction (Match [\"up\" (move-snake .snake (int2 0 -1) .grow)\n                               \"right\" (move-snake .snake (int2 1 0) .grow)\n                               \"down\" (move-snake .snake (int2 0 1) .grow)\n                               \"left\" (move-snake .snake (int2 -1 0) .grow)])\n            .snake (RTake 0) &gt;= .head\n            ; did the snake eat the fruit?\n            (If (-&gt; .head (Is .fruit))\n                (-&gt; true &gt; .grow\n                    (move-fruit .fruit .snake) &gt; .fruit)\n                (-&gt; false &gt; .grow)\n                :Passthrough true)\n            ; update\n            empty-grid (populate-grid .fruit .snake) &gt; .grid\n            .direction &gt; .prev-direction))\n  ; window\n  (GFX.MainWindow\n   :Title \"Snake game\" :Width 480 :Height 360\n   :Contents\n   (-&gt;\n    (Setup\n     (GFX.DrawQueue) &gt;= .ui-draw-queue\n     (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n    .ui-draw-queue (GFX.ClearQueue)\n\n    (UI\n     .ui-draw-queue\n     (-&gt;\n      .grid\n      (Setup (float2 0) &gt;= .position)\n      (render-cells (- (* grid-cols grid-rows) 1))))\n\n    (GFX.Render :Steps .render-steps)\n\n    (Inputs.KeyDown\n     \"up\"\n     (When (-&gt; .prev-direction (IsNot \"down\"))\n           (-&gt; \"up\" &gt; .direction)))\n    (Inputs.KeyDown\n     \"right\"\n     (When (-&gt; .prev-direction (IsNot \"left\"))\n           (-&gt; \"right\" &gt; .direction)))\n    (Inputs.KeyDown\n     \"down\"\n     (When (-&gt; .prev-direction (IsNot \"up\"))\n           (-&gt; \"down\" &gt; .direction)))\n    (Inputs.KeyDown\n     \"left\"\n     (When (-&gt; .prev-direction (IsNot \"right\"))\n           (-&gt; \"left\" &gt; .direction)))\n    (Inputs.KeyDown\n     \"space\" (initialize)))))\n\n(defmesh root)\n(schedule root main-wire)\n(run root (/ 1.0 60))\n</code></pre> <p></p> Note <p><code>(Once)</code> is executed only once and thus is not repeated every frame.</p> <p> </p>"},{"location":"learn/shards/tutorials/snake/steps/step-5/","title":"Step 5","text":""},{"location":"learn/shards/tutorials/snake/steps/step-5/#wall-collision-and-game-over-conditions","title":"Wall collision and game over conditions","text":"<p>If the snake hits a wall, the game ends. Similarly, if the snake tries to eat a part of its own body, the game still ends.</p> <p>Remember that we have a sequence that represents the whole snake body. The last element of that sequence is the head.</p> <p>To test whether the snake is going outside the bounds of the play space, we just need to compare the <code>x</code> (first coordinate) and <code>y</code> (second coordinate) of the head with the number of columns and rows respectively. If this x or y value is greater than the maximum column or row value respectively, then the snake has breached the grid walls. </p> <p>We need to do this before attempting to render as otherwise the computed render position could go out of bounds and produce an error (and since we are not yet handling this error the game would crash). We will use a boolean value (<code>true</code> or <code>false</code>) to mark when the game is over and avoid updating the grid in such a case.</p> EDN <pre><code>; get the head coordinates\n.snake (RTake 0) &gt;= .head\n\n; snake hits a wall?\n(When (-&gt; .head (Take 0) (IsLess 0) (Or) (Take 0) (IsMoreEqual grid-cols)\n          (Or)\n          .head (Take 1) (IsLess 0) (Or) (Take 1) (IsMoreEqual grid-rows))\n      (-&gt; true &gt; .game-over))\n</code></pre> <p>To check whether the snake is eating its own body, we use the fact that the head is the last element of the snake sequence. If we find another body cell that has the same coordinates while having a different index in the sequence, it means that we have an overlap and the poor snake is in pain.</p> EDN <pre><code>; get the index of the head (which is count - 1)\n(Count .snake) (Math.Subtract 1) &gt;= .head-idx\n\n; snake eats its own body?\n(When (-&gt; .snake (IndexOf .head) (IsNot .head-idx))\n      (-&gt; true &gt; .game-over))\n</code></pre>"},{"location":"learn/shards/tutorials/snake/steps/step-5/#a-few-graphical-changes","title":"A few graphical changes","text":"<p>Now that have conditions to end the game, we can add a bit more logic to display the final score (which in our case will be the length of the snake).</p> EDN <pre><code>(UI.BottomPanel\n :Contents\n (-&gt;\n  (When (-&gt; .game-over)\n   (UI.Horizontal\n   (-&gt; \"GAME OVER!\" (UI.Label :Style {:color (color 255 0 0)}) ;; (1)\n       (UI.Space 10.0)\n       \"Final score: \" (UI.Label)\n       (Count .snake) (ToString) (UI.Label))))))\n</code></pre> <ol> <li><code>:Style</code> is an optional parameter for <code>(UI.Label)</code>. It lets specify the color of the dsiplay text using <code>(color)</code> (which is a built-in type that represents an RGBA color, where each component is a value in the <code>[0, 255]</code> range.)</li> </ol> <p>We will also add a small menu, to enable the player to cleanly restart or exit the game.</p> EDN <pre><code>(defshards menus []\n  (UI.MenuBar\n   (-&gt;\n    (UI.Menu ;; (1)\n     \"File\"\n     (-&gt;\n      (UI.Button \"New game\" (-&gt; (initialize) (UI.CloseMenu)))\n      (UI.Separator)\n      (UI.Button \"Quit\" (Stop)))))))\n</code></pre> <ol> <li><code>(UI.Menu)</code> contains one or more <code>(UI.Button)</code> and is hosted in a <code>(UI.MenuBar)</code>.</li> </ol> <p>To display the menu we need to add it to a <code>(UI.TopPanel)</code>.</p> EDN <pre><code>(UI.TopPanel :Contents (menus))\n</code></pre> <p>That's it! Congratulations on completing the snake tutorial.</p> <p>The complete code is available in the full game section.</p> <p> </p>"},{"location":"learn/shards/tutorials/yes-no-game/","title":"Yes-No Game Tutorial","text":"<p>Welcome! In this tutorial, we will be creating a simple game of reflexes using Shards.</p> <p>This tutorial assumes that you have a basic understanding of Shards. In order to run the code examples used here, you are required to have Shards built. </p> <p>For more information, check out the following links on:</p> <ol> <li> <p>The Basics of Shards</p> </li> <li> <p>Building Shards</p> </li> <li> <p>Running Shards</p> </li> </ol> <p>Here are the key concepts that we will be covering in this tutorial:</p> <ol> <li> <p>How to create UI and receive User Input</p> </li> <li> <p>How to create variance with Random</p> </li> <li> <p>How to run a Timer</p> </li> <li> <p>How to set up a basic game loop</p> </li> </ol> <p>You can either follow the step-by-step guide, or jump directly to the full game.</p> <ul> <li> <p>Introduction</p> </li> <li> <p>Step by step</p> </li> <li> <p>Full game</p> </li> </ul> <p> </p>"},{"location":"learn/shards/tutorials/yes-no-game/introduction/","title":"Introduction","text":""},{"location":"learn/shards/tutorials/yes-no-game/introduction/#gameplay","title":"Gameplay","text":"<p>In this game, the player will be shown 2 images. They will have 5 seconds to decide whether the animals shown are the same, or different. The player will have to press the \u2191 directional key to answer \"Yes\", and the \u2193 directional key to answer \"No\". There will be a total of 10 rounds, and the player's total score is tabulated and shown at the end. If the 5s timer runs out, no score is given for the round and the next round is started.</p> <p> </p>"},{"location":"learn/shards/tutorials/yes-no-game/full-game/","title":"Full game","text":"EDN yesnogame.edn<pre><code>(def total-rounds 10)\n(def max-timer 5)\n\n(defshards load-resources []\n  (LoadImage \"data/cats/cat01.png\") (Push :Name .images)\n  (LoadImage \"data/cats/cat02.png\") (Push :Name .images)\n  (LoadImage \"data/cats/cat03.png\") (Push :Name .images))\n\n(defshards initialize-variables []\n  ;; Variables to reset each round \n  true &gt;= .new-round\n  max-timer &gt;= .time-remaining\n  false &gt;= .input-received\n\n  ;; Variables to reset each game \n  0 &gt;= .total-score\n  1 &gt;= .current-round\n  false &gt;= .game-over\n\n  ;; Other Shared Variables\n  0 &gt;= .left-image-index\n  0 &gt;= .right-image-index\n  (Count .images) &gt;= .total-images\n  true &gt;= .same-image)\n\n(defshards reset-round-variables []\n  false &gt; .new-round\n  max-timer &gt; .time-remaining\n  false &gt; .input-received)\n\n(defshards reset-game-variables []\n  (reset-round-variables)\n  0 &gt; .total-score\n  1 &gt; .current-round\n  false &gt; .game-over)\n\n(defshards initialize-round []\n  (RandomInt :Max .total-images) &gt; .left-image-index\n  (RandomInt :Max .total-images) &gt; .right-image-index\n\n  (If\n   :Predicate (-&gt; .left-image-index (Is .right-image-index))\n   :Then (-&gt; true &gt; .same-image)\n   :Else (-&gt; false &gt; .same-image))\n\n  (reset-round-variables))\n\n(defwire end-round\n  (Setup 0 &gt;= .new-round-number)\n\n  .current-round (Math.Add 1)\n  &gt; .new-round-number\n\n  (If\n   :Predicate\n   (-&gt; .new-round-number (IsMore total-rounds))\n   :Then\n   (-&gt; true &gt; .game-over)\n   :Else\n   (-&gt;\n    .new-round-number &gt; .current-round\n    true &gt; .new-round)))\n\n(defshards check-answer [yes-input]\n  (When\n   :Predicate (-&gt; .input-received (Is false))\n   :Action\n   (-&gt;\n    (When\n     :Predicate (-&gt; .same-image (Is yes-input))\n     :Action (-&gt; (Math.Inc .total-score)))\n\n    true &gt; .input-received\n    (When\n     :Predicate (-&gt; .game-over (IsNot true))\n     :Action (-&gt; nil (Step end-round))))))\n\n(defshards timer-tick []\n  (When\n   :Predicate (-&gt; .game-over (Is false))\n   :Action\n   (-&gt;\n    (Math.Dec .time-remaining)\n    (When\n     :Predicate (-&gt; .time-remaining (IsLess 0))\n     :Action (-&gt; nil (Step end-round))))))\n\n(defshards main-game-ui []\n  (UI.BottomPanel\n   :Contents (-&gt; \"Are they the same image? Press the UP arrow if YES, and the DOWN arrow if NO.\" (UI.Label)))\n\n  (UI.TopPanel\n   :Contents\n   (-&gt;\n    (UI.Horizontal\n     :Contents\n     (-&gt;\n      \"Score: \" (UI.Label)\n      .total-score (ToString) (UI.Label)\n      (UI.Separator)\n      \"Round: \" (UI.Label)\n      .current-round (ToString) (UI.Label)\n      (UI.Separator)\n      \"Time Left: \" (UI.Label)\n      .time-remaining (ToString) (UI.Label)))))\n\n  (UI.CentralPanel\n   :Contents\n   (-&gt;\n    (UI.Horizontal\n     :Contents\n     (-&gt;\n      (UI.Area\n       :Position (float2 -250.0, 0.0)\n       :Anchor Anchor.Center\n       :Contents\n       (-&gt; .images (Take .left-image-index) (UI.Image)))\n      (UI.Area\n       :Position (float2 250.0, 0.0)\n       :Anchor Anchor.Center\n       :Contents\n       (-&gt; .images (Take .right-image-index) (UI.Image))))))))\n\n(defshards game-over-ui []\n  (UI.CentralPanel\n   :Contents\n   (-&gt;\n    (UI.Area\n     :Position (float2 0.0, 0.0)\n     :Anchor Anchor.Center\n     :Contents\n     (-&gt;\n      \"GAME OVER\" (UI.Label)\n      (UI.Horizontal\n       :Contents\n       (-&gt;\n        \"Final Score: \" (UI.Label)\n        .total-score (ToString) (UI.Label)\n        \"/\"  (UI.Label)\n        total-rounds (ToString) (UI.Label)))\n\n      (UI.Button\n       :Label \"Play Again!\"\n       :Action (-&gt; (reset-game-variables))))))))\n\n(defloop ui-loop\n  (GFX.MainWindow\n   :Title \"Yes-No Game\"\n   :Width 1280 :Height 768\n   :Contents\n   (-&gt;\n    (Setup\n     (GFX.DrawQueue) &gt;= .ui-draw-queue\n     (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n    (| .ui-draw-queue (GFX.ClearQueue))\n\n    (If\n     :Predicate (-&gt; .game-over)\n     :Then\n     (-&gt; (UI .ui-draw-queue (game-over-ui)))\n     :Else\n     (-&gt; (UI .ui-draw-queue (main-game-ui))))\n\n    (GFX.Render :Steps .render-steps)\n\n    (Inputs.KeyDown\n     :Key \"up\"\n     :Action (-&gt; (check-answer true)))\n\n    (Inputs.KeyDown\n     :Key \"down\"\n     :Action (-&gt; (check-answer false))))))\n\n(defloop logic-loop\n  (Once\n   :Action (-&gt; (timer-tick))\n   :Every 1.0)\n\n  (WhenNot\n   :Predicate (-&gt; .game-over)\n   :Action\n   (-&gt;\n    (When\n     :Predicate (-&gt; .new-round)\n     :Action (-&gt; (initialize-round))))))\n\n(defshards initialize-round []\n  (RandomInt :Max .total-images) &gt; .left-image-index\n  (RandomInt :Max .total-images) &gt; .right-image-index\n\n  (If\n   :Predicate (-&gt; .left-image-index (Is .right-image-index))\n   :Then (-&gt; true &gt; .same-image)\n   :Else (-&gt; false &gt; .same-image))\n\n  (reset-round-variables))\n\n(defloop game-loop\n  (Setup (load-resources) (initialize-variables))\n  (Branch [ui-loop, logic-loop]))\n\n(defmesh main)\n(schedule main game-loop)\n(run main (/ 1.0 60.0))\n</code></pre>"},{"location":"learn/shards/tutorials/yes-no-game/steps/","title":"Steps","text":"<ul> <li>Step 1 - Setting up the Game Loop</li> <li>Step 2 - Drawing the Game UI</li> <li>Step 3 - Initializing each Round</li> <li>Step 4 - Adding Multiple Rounds</li> <li>Step 5 - Handling User Input</li> <li>Step 6 - Finishing Touches</li> </ul>"},{"location":"learn/shards/tutorials/yes-no-game/steps/step-1/","title":"Step 1","text":"<p>This chapter will guide you on setting up the base of your game so that it can start running.</p>"},{"location":"learn/shards/tutorials/yes-no-game/steps/step-1/#the-programs-base","title":"The Program's Base","text":"<p>A basic Shards program consists of:</p> <ul> <li> <p>Writing Shards and Wires</p> </li> <li> <p>Scheduling Wires onto a Mesh</p> </li> </ul> <p>To learn more about Wires, Meshes, and the overall flow of Shards, check out the primer here.</p> <p>A basic Shards program looks like this:</p> Code <pre><code>(defwire game-wire          ;; Define a Wire named \"game-wire\" (1)\n    (Msg \"Hello World!\"))   ;; Insert stuff to run here (2)\n\n(defmesh main)              ;; Define a Mesh named \"main\" (3)\n(schedule main game-wire)   ;; Schedule the Wire on the Mesh (4)\n(run main)                  ;; Run the Mesh (5)\n</code></pre> <ol> <li><code>defwire</code> is a macro used to define a Wire.</li> <li><code>Msg</code> prints out the string passed into it.</li> <li><code>defmesh</code> is a macro used to define a Mesh.</li> <li><code>schedule</code> queues a Wire on the Mesh.</li> <li><code>run</code> executes Wires on the Mesh.</li> </ol> <p>For the program to run continuously, we will be using a looped Wire instead. This can be done by replacing <code>defwire</code> with <code>defloop</code>. You can then adjust the time interval between each loop by adding a second argument to <code>(run)</code>.</p> <p>Since most games run at 60 FPS (Frames per Second), we will be using <code>(/ 1.0 60.0)</code>  to get the time interval between each frame.</p> <p>Note</p> <p><code>(/ 1.0 60.0)</code> reads as \"1 divided by 60\".</p> Code <pre><code>(defloop game-loop          ;; Define a Looped Wire named \"game-loop\" (1)\n    (Msg \"Hello World!\"))   ;; Insert stuff to run here \n\n(defmesh main)              ;; Define a Mesh named \"main\"\n(schedule main game-loop)   ;; Schedule the Loop on the Mesh\n(run main (/ 1.0 60.0))     ;; Run the Mesh\n</code></pre> <ol> <li><code>defloop</code> is a macro used to define a Loop.</li> </ol>"},{"location":"learn/shards/tutorials/yes-no-game/steps/step-1/#game-loops","title":"Game Loops","text":"<p>To make a game, you will need:</p> <ul> <li> <p>Code to draw the UI (such as your game menus, text boxes, and images)</p> </li> <li> <p>Code to run the game's logic (such as calculating the score, determining when to end a round)</p> </li> </ul> <p>It might be quite disorderly if we did everything within a single <code>defloop</code>. </p> <p>To keep our code easily readable and organized, we split the UI and logic code into separate Loops running together on the Mesh. </p> <p>We can achieve this by employing the <code>Branch</code> shard and creating two separate loops for the game's logic and UI.</p> Branch <p><code>Branch</code> creates a mini-Mesh of sorts and schedules Wires to run on it.</p> Code <pre><code>(defloop ui-loop)                   ;; Insert UI code here\n(defloop logic-loop)                ;; Insert logic code here\n\n(defloop game-loop\n    (Branch [ui-loop, logic-loop]))\n\n(defmesh main)\n(schedule main game-loop)\n(run main (/ 1.0 60.0))\n</code></pre>"},{"location":"learn/shards/tutorials/yes-no-game/steps/step-1/#the-setup-zone","title":"The Setup Zone","text":"<p>Most games will require code to ready the program, such as by loading resources and setting up variables to use. </p> <p>We can ready empty shards <code>load-resources</code> and <code>initialize-variables</code> to carry out these tasks. Place them in a <code>Setup</code> shard within the <code>game-loop</code> to ensure that they only run once.</p> Variables <p>Variables are containers that store values. You define a variable with a name, and assign a value to it. The value can then be retrieved by calling the variable with its assigned name.</p> Setup <p>The <code>Setup</code> shard will only be executed once, even within a Looped Wire. This makes it ideal to hold code that is only used once to ready the game. </p> Full Code <pre><code>(defshards load-resources [] nil)          ;; Load resources here (1)\n(defshards initialize-variables [] nil)    ;; Ready variables here\n(defloop ui-loop)                   ;; Insert UI code here\n(defloop logic-loop)                ;; Insert logic code here\n\n(defloop game-loop\n    (Setup (load-resources)(initialize-variables)) ;; (2)\n    (Branch [ui-loop, logic-loop]))\n\n(defmesh main)\n(schedule main game-loop)\n(run main (/ 1.0 60.0))\n</code></pre> <ol> <li><code>defshards</code> allows multiple shards to be grouped together into a single shard. We will be placing shards that load resources into <code>load-resources</code> for example.</li> <li>The shards to load resources and initialize variables are only run once in the game loop</li> </ol> <p>The basic game loop is now ready!</p> <p>In the next chapter, we will learn about drawing the User Interface and adding graphics.</p> <p> </p>"},{"location":"learn/shards/tutorials/yes-no-game/steps/step-2/","title":"Step 2","text":"<p>In this chapter, we will be adding graphics to your game. You will be able to create a game window and start seeing your game come to life.</p>"},{"location":"learn/shards/tutorials/yes-no-game/steps/step-2/#the-ui-template","title":"The UI Template","text":"<p>To start drawing the UI in shards, we will have to ready the GFX window which serves as the base for our UI operations. It follows a fixed template that should be placed within our <code>ui-loop</code>.</p> UI Template <pre><code>(defshards main-game-ui [] nil)     ;; Add your UI shards here\n\n(defloop ui-loop\n  (GFX.MainWindow\n   :Title \"Yes-No Game\"\n   :Width 1280 :Height 768\n   :Contents\n   (-&gt;\n    (Setup\n     (GFX.DrawQueue) &gt;= .ui-draw-queue\n     (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n    (| .ui-draw-queue (GFX.ClearQueue))\n    (UI .ui-draw-queue (main-game-ui))\n    (GFX.Render :Steps .render-steps))))\n</code></pre> What does the GFX code mean? <p>How the GFX window works is beyond the scope of this tutorial. The rough idea is that we are giving instructions to the computer on what to draw to the screen. For more information, check out the documentation on the UI class.</p>"},{"location":"learn/shards/tutorials/yes-no-game/steps/step-2/#planning-the-ui","title":"Planning the UI","text":"<p>Before writing code for the UI, it is good to have a design in mind. For this tutorial, we have prepared a simple design to follow:</p> <p></p> <p>With a design plan, it will be easier to identify the elements that will make up your UI. You can then implement the appropriate shards to draw them.</p> <p></p>"},{"location":"learn/shards/tutorials/yes-no-game/steps/step-2/#the-bottom-panel","title":"The Bottom Panel","text":"<p>Let us start with the simplest panel, the Bottom Panel with a single Label. </p> <p>We will pass a string of instructions into the <code>UI.Label</code> shard, which we then pass into the Bottom Panel shard as its content.</p> Code <pre><code>(UI.BottomPanel ;; (1)\n :Contents\n (-&gt; \"Are they the same image? Press the UP arrow if YES, and the DOWN arrow if NO.\"\n (UI.Label) ;; (2)\n ))\n</code></pre> <ol> <li><code>UI.BottomPanel</code> is a UI element to hold other UI elements within it. It starts from the bottom of the Window.</li> <li><code>UI.Label</code> is a UI element to hold text.</li> </ol>"},{"location":"learn/shards/tutorials/yes-no-game/steps/step-2/#the-top-panel","title":"The Top Panel","text":"<p>The Top Panel consists of a sequence of Labels and Separators in a Horizontal Group so that they are naturally aligned from left to right.</p> Code <pre><code>(UI.TopPanel ;; (1)\n :Contents\n (-&gt;\n  (UI.Horizontal ;; (2)\n   :Contents\n    (-&gt;\n     \"Score: 0\" (UI.Label)\n     (UI.Separator) ;; (3)\n     \"Round: 1\" (UI.Label)\n     (UI.Separator)\n     \"Time Left: 5\" (UI.Label)))))\n</code></pre> <ol> <li><code>UI.TopPanel</code> is a UI element to hold other UI elements within it. It starts from the top of the Window.</li> <li><code>UI.Horizontal</code> is a UI element to hold other UI elements within it. It aligns its elements horizontally, from left to right.</li> <li><code>UI.Separator</code> is a UI element that appears as a horizontal line within a vertical layout, and appears as a vertical line within a horizontal layout.</li> </ol> <p>We want to be able to change the values used for Score, the Round Number, and Time Left (they can't remain static after all!).</p> <p>This is where variables come in. We will be defining our variables in the <code>initialize-variables</code> shard created earlier.</p> <p>Define the following variables: </p> <ul> <li> <p><code>.total-score</code></p> </li> <li> <p><code>.current-round</code></p> </li> <li> <p><code>.time-remaining</code></p> </li> </ul> <p>Some values will remain the same throughout the game - these are known as constants. </p> <p>Define the following constants:</p> <ul> <li> <p><code>total-rounds</code></p> </li> <li> <p><code>max-timer</code></p> </li> </ul> Declaring Constants <p>Constants are values that cannot be changed. </p> <p>In Shards, you can declare named constants by using the macro <code>def</code>, which is used to give an alias to a value. Unnamed constants can be declared with <code>Const</code>.</p> Code <pre><code>(def total-rounds 10)\n(def max-timer 5)\n\n(defshards initialize-variables []\n  0 &gt;= .total-score\n  1 &gt;= .current-round\n  max-timer &gt;= .time-remaining)\n</code></pre> <p>We can now replace the fixed string numbers in our UI code with variables that will be updated as their values change.</p> Code <pre><code>(UI.TopPanel\n :Contents\n (-&gt;\n  (UI.Horizontal\n   :Contents\n    (-&gt;\n     \"Score: \" (UI.Label)\n     .total-score (ToString) (UI.Label) ;; (1)\n     (UI.Separator)\n     \"Round: \" (UI.Label)\n     .current-round (ToString) (UI.Label)\n     (UI.Separator)\n     \"Time Left: \" (UI.Label)\n     .time-remaining (ToString) (UI.Label)))))\n</code></pre> <ol> <li><code>ToString</code> converts values into strings. In the code above, <code>UI.Label</code> expects a string input, which is why we have to convert the integer variables into strings.</li> </ol>"},{"location":"learn/shards/tutorials/yes-no-game/steps/step-2/#the-central-panel","title":"The Central Panel","text":"<p>The central panel shows two images side by side. To draw the images onto the screen, we have to load them into our game's resources. We can do so in the <code>load-resources</code> shard created earlier. </p> <p>Create a folder named \"data\" at the directory where your game's script is located - we will be placing our images here.</p> <p>Note</p> <p>For this tutorial, we will be using 3 images of cats. You are free to choose the images of your own accord though!</p> <p>Our images have been standardized to have a length of 400 pixels for horizontal images. You can use an image editing tool to resize your images for consistency.</p> <p>Use the <code>Push</code> shard to push the images into a sequence.</p> Code <pre><code>(defshards load-resources []\n  (LoadImage \"data/cats/cat01.png\") (Push :Name .images) ;; (1)(2)\n  (LoadImage \"data/cats/cat02.png\") (Push :Name .images)\n  (LoadImage \"data/cats/cat03.png\") (Push :Name .images))\n</code></pre> <ol> <li><code>LoadImage</code> is used to load images into your game's resources.</li> <li><code>Push</code> adds elements to the back of a sequence. It will create the sequence if it does not exist.</li> </ol> <p>We will randomize the images shown when tackling the logic of the game later. For now, let us display the first two images in the sequence as a placeholder.</p> <p>To better control where the images are drawn, we place each image in a <code>UI.Area</code> and specify its position.</p> Code <pre><code>(UI.CentralPanel\n    :Contents\n    (-&gt;\n     (UI.Horizontal\n      :Contents\n      (-&gt;\n        (UI.Area ;; (1)\n         :Position (float2 -250.0, 0.0) ;; (2)\n         :Anchor Anchor.Center\n         :Contents\n         (-&gt; .images (Take 0) (UI.Image))) ;; (3)\n        (UI.Area\n         :Position (float2 250.0, 0.0) ;; (4) \n         :Anchor Anchor.Center\n         :Contents\n         (-&gt; .images (Take 1) (UI.Image)))))))\n</code></pre> <ol> <li><code>UI.Area</code> is a UI element that is used to place its contents at a specific position.</li> <li>Minus 250 pixels from the center on the x-axis</li> <li><code>Take</code> is used to retrieve the element stored at a specified index of a sequence.</li> <li>Add 250 pixels from the center on the x-axis</li> </ol> <p>Caution</p> <p>When using panels, ensure that <code>UI.CentralPanel</code> is always the last of the panels to be drawn to prevent errors.</p>"},{"location":"learn/shards/tutorials/yes-no-game/steps/step-2/#outcome","title":"Outcome","text":"<p>The game's base UI is now ready! Try running the code to see your results.</p> <p>In the next chapter, we will delve into the game's logic and allow your program to ready itself for each game round.</p> <p>The code thus far:</p> Full CodeResult <pre><code>(def total-rounds 10)\n(def max-timer 5)\n\n(defshards load-resources []\n  (LoadImage \"data/cats/cat01.png\") (Push :Name .images)\n  (LoadImage \"data/cats/cat02.png\") (Push :Name .images)\n  (LoadImage \"data/cats/cat03.png\") (Push :Name .images))\n\n(defshards initialize-variables []\n  0 &gt;= .total-score\n  1 &gt;= .current-round\n  max-timer &gt;= .time-remaining)\n\n(defshards main-game-ui []\n  (UI.BottomPanel\n   :Contents (-&gt; \"Are they the same image? Press the UP arrow if YES, and the DOWN arrow if NO.\" (UI.Label)))\n\n  (UI.TopPanel\n   :Contents\n   (-&gt;\n    (UI.Horizontal\n    :Contents\n     (-&gt;\n      \"Score: \" (UI.Label)\n      .total-score (ToString) (UI.Label)\n      (UI.Separator)\n      \"Round: \" (UI.Label)\n      .current-round (ToString) (UI.Label)\n      (UI.Separator)\n      \"Time Left: \" (UI.Label)\n      .time-remaining (ToString) (UI.Label)))))\n\n  (UI.CentralPanel\n   :Contents\n   (-&gt;\n    (UI.Horizontal\n     :Contents\n     (-&gt;\n      (UI.Area\n       :Position (float2 -250.0, 0.0)\n       :Anchor Anchor.Center\n       :Contents\n       (-&gt; .images (Take 0) (UI.Image)))\n      (UI.Area\n       :Position (float2 250.0, 0.0)\n       :Anchor Anchor.Center\n       :Contents\n       (-&gt; .images (Take 1) (UI.Image))))))))     \n\n(defloop ui-loop\n  (GFX.MainWindow\n   :Title \"Yes-No Game\"\n   :Width 1280 :Height 768\n   :Contents\n   (-&gt;\n    (Setup\n     (GFX.DrawQueue) &gt;= .ui-draw-queue\n     (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n    (| .ui-draw-queue (GFX.ClearQueue))\n    (UI .ui-draw-queue (main-game-ui))\n    (GFX.Render :Steps .render-steps))))\n\n(defloop logic-loop)\n\n(defloop game-loop\n  (Setup (load-resources) (initialize-variables))\n  (Branch [ui-loop, logic-loop]))\n\n(defmesh main)\n(schedule main game-loop)\n(run main (/ 1.0 60.0))\n</code></pre> <p></p> <p> </p>"},{"location":"learn/shards/tutorials/yes-no-game/steps/step-3/","title":"Step 3","text":"<p>In this chapter, we will be implementing logic that lets your program ready itself for a game round!</p>"},{"location":"learn/shards/tutorials/yes-no-game/steps/step-3/#initializing-each-round","title":"Initializing each Round","text":"<p>Create a shard named <code>initialize-round</code>. We will be adding code to prepare each round here.</p> Code <pre><code>(defshards initialize-round [])\n</code></pre> <p>Place the new shard into the <code>logic-loop</code>. Wrap it within a <code>Setup</code> shard to ensure it only runs once (for now). We will add conditionals later that ensures <code>initialize-round</code> is only called when a new round should begin.</p> <p>Note</p> <p>Without placing <code>initialize-round</code> in <code>Setup</code>, it will be called constantly with each loop iteration. We do not want this! <code>initialize-round</code> should only be called at the start of each round.</p> Code <pre><code>(defloop logic-loop\n  (Setup (initialize-round)))\n</code></pre>"},{"location":"learn/shards/tutorials/yes-no-game/steps/step-3/#selecting-the-images","title":"Selecting the Images","text":"<p>We will use the <code>RandomInt</code> shard to randomly select an index from our <code>.image</code> sequence. The image stored at that index will be displayed in the game.</p> <p>Navigate to <code>initialize-variables</code>. </p> <p>Define the following variables to hold the randomly selected indices:</p> <ul> <li> <p><code>.left-image-index</code></p> </li> <li> <p><code>.right-image-index</code></p> </li> </ul> Code <pre><code>(defshards initialize-variables []\n  0 &gt;= .left-image-index ;; (1)\n  0 &gt;= .right-image-index ;; (2)\n\n  0 &gt;= .total-score\n  1 &gt;= .current-round\n  max-timer &gt;= .time-remaining)\n</code></pre> <ol> <li>The randomly selected index to use for the left image.</li> <li>The randomly selected index to use for the right image.</li> </ol> <p><code>RandomInt</code> requires the user to pass in the maximum number it can select up to. For example, <code>(RandomInt :Max 2)</code> will randomly choose a number from 0 to 1.</p> <p>Count the number of images in the <code>.images</code> sequence and store the value in a variable named <code>.total-images</code>. This value will be passed in as the <code>:Max</code> for <code>RandomInt</code>.</p> Code <pre><code>(defshards initialize-variables []\n  0 &gt;= .left-image-index\n  0 &gt;= .right-image-index\n  (Count .images) &gt;= .total-images ;; (1)\n\n  0 &gt;= .total-score\n  1 &gt;= .current-round\n  max-timer &gt;= .time-remaining)\n</code></pre> <ol> <li><code>Count</code> will count the number of elements in a sequence. It can also count the number of characters in a string, or key-value pairs in a table.</li> </ol> <p>With <code>.total-images</code> as the upper limit for our random index range, we can now use <code>RandomInt</code> to determine our image indices. As the images chosen will change each round, we will select the images in the <code>initialize-round</code> shard.</p> Code <pre><code>(defshards initialize-round []\n  (RandomInt :Max .total-images) &gt; .left-image-index ;; (1)(2)\n  (RandomInt :Max .total-images) &gt; .right-image-index)\n</code></pre> <ol> <li>Randomly selects an index in the .image sequence.</li> <li><code>RandomInt</code> will randomly output a number from 0 to the number before the maximum value specified.</li> </ol> <p>Previously we used a placeholder to always show the first two images stored in <code>.images</code>. With the new logic implemented, we can update our UI code to display randomly selected images instead.</p> <p>Navigate to <code>UI.CentralPanel</code> in the <code>main-game-ui</code> shard.</p> <p>Replace:</p> Code <pre><code>.images (Take 0) (UI.Image)\n.images (Take 1) (UI.Image)\n</code></pre> <p>With:</p> Code <pre><code>.images (Take .left-image-index) (UI.Image) ;; (1)\n.images (Take .right-image-index) (UI.Image)\n</code></pre> <ol> <li>Retrieve the chosen image from the sequence</li> </ol>"},{"location":"learn/shards/tutorials/yes-no-game/steps/step-3/#outcome","title":"Outcome","text":"<p>Congratulations! Your game can now display random images at the start of each round. </p> <p>Try running the code to see how the images change every time the game is run.</p> <p>In the next chapter, we will be adding multiple rounds to your game to increase its playability.</p> Full CodeResult <pre><code>(def total-rounds 10)\n(def max-timer 5)\n\n(defshards load-resources []\n  (LoadImage \"data/cats/cat01.png\") (Push :Name .images)\n  (LoadImage \"data/cats/cat02.png\") (Push :Name .images)\n  (LoadImage \"data/cats/cat03.png\") (Push :Name .images))\n\n(defshards initialize-variables []\n  0 &gt;= .left-image-index\n  0 &gt;= .right-image-index\n  (Count .images) &gt;= .total-images\n\n  0 &gt;= .total-score\n  1 &gt;= .current-round\n  max-timer &gt;= .time-remaining)\n\n(defshards initialize-round []\n  .total-images\n  (RandomInt :Max .total-images) &gt; .left-image-index (Log)\n  (RandomInt :Max .total-images) &gt; .right-image-index (Log))\n\n(defshards main-game-ui []\n  (UI.BottomPanel\n   :Contents (-&gt; \"Are they the same image? Press the UP arrow if YES, and the DOWN arrow if NO.\" (UI.Label)))\n\n  (UI.TopPanel\n   :Contents\n   (-&gt;\n    (UI.Horizontal\n     :Contents\n     (-&gt;\n      \"Score: \" (UI.Label)\n      .total-score (ToString) (UI.Label)\n      (UI.Separator)\n      \"Round: \" (UI.Label)\n      .current-round (ToString) (UI.Label)\n      (UI.Separator)\n      \"Time Left: \" (UI.Label)\n      .time-remaining (ToString) (UI.Label)))))\n\n  (UI.CentralPanel\n   :Contents\n   (-&gt;\n    (UI.Horizontal\n     :Contents\n     (-&gt;\n      (UI.Area\n       :Position (float2 -250.0, 0.0)\n       :Anchor Anchor.Center\n       :Contents\n       (-&gt; .images (Take .left-image-index) (UI.Image)))\n      (UI.Area\n       :Position (float2 250.0, 0.0)\n       :Anchor Anchor.Center\n       :Contents\n       (-&gt; .images (Take .right-image-index) (UI.Image))))))))\n\n(defloop ui-loop\n  (GFX.MainWindow\n   :Title \"Yes-No Game\"\n   :Width 1280 :Height 768\n   :Contents\n   (-&gt;\n    (Setup\n     (GFX.DrawQueue) &gt;= .ui-draw-queue\n     (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n    (| .ui-draw-queue (GFX.ClearQueue))\n    (UI .ui-draw-queue (main-game-ui))\n    (GFX.Render :Steps .render-steps))))\n\n(defloop logic-loop\n  (Setup (initialize-round)))\n\n(defloop game-loop\n  (Setup (load-resources) (initialize-variables))\n  (Branch [ui-loop, logic-loop]))\n\n(defmesh main)\n(schedule main game-loop)\n(run main (/ 1.0 60.0))\n</code></pre> <p> </p> <p> </p>"},{"location":"learn/shards/tutorials/yes-no-game/steps/step-4/","title":"Step 4","text":"<p>Our game wouldn't be much fun if it ended in one round. To improve its playability, we implement multiple rounds.</p> <p>To implement multiple rounds, we will have to:</p> <ol> <li> <p>Add variables to track game states</p> </li> <li> <p>Implement shards to reset these variables</p> </li> </ol>"},{"location":"learn/shards/tutorials/yes-no-game/steps/step-4/#adding-multiple-rounds","title":"Adding Multiple Rounds","text":"<p>For our game to be able to handle multiple rounds and an eventual \"Game Over\", we will need to manage game states.</p> <p>Let us define some variables to help keep track of the game states.  Navigate to <code>initialize-variables</code> and add in the following variables:</p> <ul> <li> <p><code>.new-round</code></p> </li> <li> <p><code>.game-over</code> </p> </li> </ul> <p>Organize your variables by grouping them according to when they will be reset. For example, some variables will be reset at the start of each round, while others are only reset when a new game is started.</p> Code <pre><code>(defshards initialize-variables []\n  ;; Variables to reset each round \n  true &gt;= .new-round ;; (1)\n  max-timer &gt;= .time-remaining\n\n  ;; Variables to reset each game \n  0 &gt;= .total-score\n  1 &gt;= .current-round\n  false &gt;= .game-over ;; (2)\n\n  ;; Other Shared Variables\n  0 &gt;= .left-image-index\n  0 &gt;= .right-image-index\n  (Count .images) &gt;= .total-images\n)\n</code></pre> <ol> <li>Variable that tracks if a new round should be started.</li> <li>Variable that tracks if the game is over.</li> </ol> <p>Next, add code in the <code>logic-loop</code> to check if there should be a new round before executing <code>initialize-round</code>.</p> <p>Remove the <code>Setup</code> shard that was used to prevent the initialization code from running every Loop's iteration. We will be using conditionals instead.</p> Conditionals <p>Conditionals check if a given statement is true or false, and executes different code depending on the result. In the following code, the conditionals used are <code>WhenNot</code> and <code>When</code>.</p> BeforeAfter <pre><code>(defloop logic-loop\n      (Setup (initialize-round)))\n</code></pre> <pre><code>(defloop logic-loop\n  (WhenNot ;; (4)\n   :Predicate (-&gt; .game-over) ;; (1)\n   :Action\n   (-&gt;\n    (When ;; (5)\n     :Predicate (-&gt; .new-round) ;; (2)\n     :Action (-&gt; (initialize-round)))))) ;; (3) \n</code></pre> <ol> <li>If the game is not in a Game Over state...</li> <li>... and it is a new round,</li> <li>... initialize a new round.</li> <li><code>WhenNot</code> will only execute the <code>Action</code> specified when the <code>Predicate</code> is false. </li> <li><code>When</code> will only execute the <code>Action</code> specified when the <code>Predicate</code> is true. Unlike <code>If</code>, it does not have an <code>Else</code> parameter.    </li> </ol>"},{"location":"learn/shards/tutorials/yes-no-game/steps/step-4/#handling-game-states","title":"Handling Game States","text":"<p>At the start of each round, we want to ensure that <code>.new-round</code> and <code>.time-remaining</code> are reset to their original values. Create the shard <code>reset-round-variables</code> to carry out this task.</p> Code <pre><code>(defshards reset-round-variables []\n  false &gt; .new-round\n  max-timer &gt; .time-remaining) \n</code></pre> <p>Do not forget to add <code>reset-round-variables</code> to <code>initialize-round</code>! We need the variables to reset whenever a new round begins.</p> Code <pre><code>(defshards initialize-round []\n  (RandomInt :Max .total-images) &gt; .left-image-index\n  (RandomInt :Max .total-images) &gt; .right-image-index\n  (reset-round-variables))\n</code></pre> <p>When the game ends and a new one begins, we will reset the following values:</p> <ul> <li> <p>Variables that are reset at the start of each round</p> </li> <li> <p>Total score</p> </li> <li> <p>Round counter</p> </li> <li> <p>The Game Over state tracker</p> </li> </ul> <p>Create the <code>reset-game-variables</code> shard to implement this.</p> Code <pre><code>(defshards reset-game-variables []\n  (reset-round-variables)\n  0 &gt; .total-score\n  1 &gt; .current-round\n  false &gt; .game-over)\n</code></pre> <p>You now have variables to track the game state and shards to reset these variables.</p> <p>We want to reset these values at the end of each round or game.</p>"},{"location":"learn/shards/tutorials/yes-no-game/steps/step-4/#ending-a-round","title":"Ending a Round","text":"<p>Let us now create a Looped Wire named <code>end-round</code> to handle the end of each round.</p> <p>The Loop will first check if the current round is final. If it is, it sets the <code>.game-over</code> variable to true. Otherwise, it sets <code>.new-round</code> to true and increments the current round number.</p> Why a Looped Wire? <p>When a Wire ends, any changes made within it are lost. We use a Looped Wire when we want changes within the Wire to persist. </p> <p>For example, in <code>end-round</code>, we use <code>Setup</code> to initialize the variable <code>.new-round-number</code> once. With a Looped Wire, the variable continues to exist as long as the Looped Wire remains running. If we use a Wire, every time <code>.end-round</code> is called, <code>.new-round-number</code> will have to be initialized again.</p> <p>You might wonder - how do we exit the Loop after calling it then? Won't the program be stuck in the Loop indefinitely? The solution to this is in the shard called <code>Step</code> which we will introduce in the following chapter. If you wish to read more about <code>Step</code> and Looped Wires first, do check out our primer here.</p> Code <pre><code>(defloop end-round\n  (Setup 0 &gt;= .new-round-number) ;; (1)\n\n  .current-round (Math.Add 1) ;; (2) \n  &gt; .new-round-number\n\n  (If\n   :Predicate\n   (-&gt; .new-round-number (IsMore total-rounds)) ;; (3)\n   :Then \n   (-&gt; true &gt; .game-over) ;; (4)\n   :Else \n   (-&gt;\n    .new-round-number &gt; .current-round ;; (5) \n    true &gt; .new-round))) ;; (6)\n</code></pre> <ol> <li>Variable to hold the next round's number.</li> <li>Increment the current round by one to get the next round's number.</li> <li>Check if the next round's number exceeds the max number of rounds.</li> <li>If it has exceeded, set the .game-over variable to true.</li> <li>Otherwise set the new round number...</li> <li>... and set the .new-round variable to true.</li> </ol> <p>To end a round, the user has to give an answer or wait for the timer to expire. We will learn to work with user input in the next chapter.</p> <p> </p>"},{"location":"learn/shards/tutorials/yes-no-game/steps/step-5/","title":"Step 5","text":"<p>For our game to engage and interact with users, we need it to be responsive to user input. </p> <p>In this chapter, we will be looking at how user input is handled in Shards.</p>"},{"location":"learn/shards/tutorials/yes-no-game/steps/step-5/#user-input","title":"User Input","text":"<p>User input is managed within the <code>GFX.Window</code> of your game. For this game, the only user input required would be the \u2191 and \u2193 directional key.</p> <p>We can use <code>Inputs.KeyDown</code> to execute code whenever the user presses down on a specified key.</p> Code <pre><code>(defloop ui-loop\n (GFX.MainWindow\n  :Title \"Yes-No Game\"\n  ...\n   (GFX.Render :Steps .render-steps)\n\n   (Inputs.KeyDown ;; (3)\n    :Key \"up\"\n    :Action ()) ;; (1) \n\n   (Inputs.KeyDown\n    :Key \"down\"\n    :Action ())))) ;; (2) \n</code></pre> <ol> <li>This code is executed when the user presses the \u2191 directional key.</li> <li>This code is executed when the user presses the \u2193 directional key.</li> <li><code>Inputs.KeyDown</code> will run the code in its <code>Action</code> parameter when the <code>Key</code> specified is pressed down by the user.</li> </ol> <p>In order to prevent code within the <code>Inputs.Keydown</code> shards from executing whenever the user presses the specified key, we define a variable <code>.input-received</code> to track if we have already received the user's input.</p> <p>Define the variable in <code>initialize-variables</code> and add code to reset it in <code>reset-round-variables</code>.</p> Code <pre><code>(defshards initialize-variables []\n  ;; Variables to reset each round \n  true &gt;= .new-round\n  max-timer &gt;= .time-remaining\n  false &gt;= .input-received ;; (1) \n  ...)\n\n(defshards reset-round-variables []\n  false &gt; .new-round\n  max-timer &gt; .time-remaining\n  false &gt; .input-received) ;; (2) \n</code></pre> <ol> <li>Variable that tracks if an input from the user has been received.</li> <li>Resets the variable tracking whether user input has been received for each round.</li> </ol> <p>Now that we are able to obtain the user's input, we can proceed to check if the user pressed the correct button. </p>"},{"location":"learn/shards/tutorials/yes-no-game/steps/step-5/#checking-the-input","title":"Checking the Input","text":"<p>Based on the images chosen, we can determine whether the user needs to select the \u2191 or \u2193 directional key. </p> <p>In <code>initialize-variables</code>, create a variable named <code>.same-image</code>. This will be used to check if the user pressed the correct key later.</p> Code <pre><code>(defshards initialize-variables []\n  ...\n\n  ;; Other Shared Variables\n  0 &gt;= .left-image-index\n  0 &gt;= .right-image-index\n  (Count .images) &gt;= .total-images\n  true &gt;= .same-image ;; (1) \n)\n</code></pre> <ol> <li>Tracks whether the same image is used.</li> </ol> <p>Navigate to where we chose the images in <code>initialize-round</code>. </p> <p>Check if the chosen images are the same, and assign <code>true</code> or <code>false</code> to <code>.same-image</code> accordingly.</p> Code <pre><code>(defshards initialize-round [] \n  (RandomInt :Max .total-images) &gt; .left-image-index\n  (RandomInt :Max .total-images) &gt; .right-image-index\n\n  (If ;; (1)\n   :Predicate (-&gt; .left-image-index (Is .right-image-index)) ;; (2)\n   :Then (-&gt; true &gt; .same-image)\n   :Else (-&gt; false &gt; .same-image))\n\n  (reset-round-variables))\n</code></pre> <ol> <li><code>If</code> checks the <code>Predicate</code> given and runs the code within <code>Then</code> if it is true. If false, the code within <code>Else</code> is run instead.</li> <li>Check if the images on the left and right are the same or different.</li> </ol> <p>Create a shard named <code>check-answer</code> which will take in the user's input and check it against <code>.same-image</code>.</p> <p>The user is correct if they:</p> <ul> <li> <p>Pressed \u2191 when <code>.same-image</code> is true</p> </li> <li> <p>Pressed \u2193 when <code>.same-image</code> is false</p> </li> </ul> <p>We award them a point by increasing the value of <code>.total-score</code>.</p> <p>Set <code>.input-received</code> to true to prevent further user input, and end the round if <code>.game-over</code> is false.</p> Code <pre><code>(defshards check-answer [yes-input] ;; (1) \n  (When\n   :Predicate (-&gt; .input-received (Is false)) ;; (2)\n   :Action\n   (-&gt;\n    (When\n     :Predicate (-&gt; .same-image (Is yes-input)) ;; (3)\n     :Action (-&gt; (Math.Inc .total-score))) ;; (4)\n\n    true &gt; .input-received ;; (5) \n    (When\n     :Predicate (-&gt; .game-over (IsNot true)) ;; (6)\n     :Action (-&gt; nil (Step end-round)))))) ;; (7)(8)(9)\n</code></pre> <ol> <li>Take in the user's input.</li> <li>Check if a user input has already been received.</li> <li>If the user pressed the \u2191 directional key when the same images are being shown...</li> <li>... increase the user's total score.</li> <li>Prevents this segment of code from running again until it is reset.</li> <li>If it is not Game Over yet...</li> <li>... end the round.</li> <li><code>Step</code> runs a wire inline.</li> <li><code>nil</code> ensures that any previous input (e.g. Bool from <code>true &gt; .input-received</code>) is not propagated into the wire. The first use of a wire defines its input type, and subsequent calls to the wire with different input types will be a violation.</li> </ol> Step vs Do <p>Step behaves similarly to <code>Do</code>, except that it allows you to use a Looped Wire like a function. <code>Step</code> will run one iteration of the Loop before returning control back to the Wire that called it. If you try to use <code>Do</code> on a Loop, the Loop will run indefinitely.</p> <p>Use a stepped Loop when you want a variable within the Loop to persist. When a Wire finishes, any changes made to the variables within it will be lost. A Looped Wire lives on, thereby retaining any changes within it. </p> <p>Check out the primer here for more information.</p> <p>We can now employ the <code>check-answer</code> shard in our <code>Inputs.KeyDown</code> logic.</p> Code <pre><code>(defloop ui-loop\n (GFX.MainWindow\n  :Title \"Yes-No Game\"\n  ...\n   (GFX.Render :Steps .render-steps)\n\n   (Inputs.KeyDown\n    :Key \"up\"\n    :Action (-&gt; (check-answer true))) ;; (1)\n\n   (Inputs.KeyDown\n    :Key \"down\"\n    :Action (-&gt; (check-answer false)))))) ;; (2)\n</code></pre> <ol> <li>Check-answer is called, with true being passed in to indicate that the user chose \"Yes\".</li> <li>Check-answer is called, with false being passed in to indicate that the user chose \"No\".</li> </ol> <p>Cheers! Your game can now receive user input, tabulate the score, and allows players to play up to 10 rounds each time.</p> Full CodeResult <pre><code>(def total-rounds 10)\n(def max-timer 5)\n\n(defshards load-resources []\n  (LoadImage \"data/cats/cat01.png\") (Push :Name .images)\n  (LoadImage \"data/cats/cat02.png\") (Push :Name .images)\n  (LoadImage \"data/cats/cat03.png\") (Push :Name .images))\n\n\n(defshards initialize-variables []\n  ;; Variables to reset each round \n  true &gt;= .new-round\n  max-timer &gt;= .time-remaining\n  false &gt;= .input-received\n\n  ;; Variables to reset each game \n  0 &gt;= .total-score\n  1 &gt;= .current-round\n  false &gt;= .game-over\n\n  ;; Other Shared Variables\n  0 &gt;= .left-image-index\n  0 &gt;= .right-image-index\n  (Count .images) &gt;= .total-images\n  true &gt;= .same-image)\n\n(defshards reset-round-variables []\n  false &gt; .new-round\n  max-timer &gt; .time-remaining\n  false &gt; .input-received)\n\n(defshards reset-game-variables []\n  (reset-round-variables)\n  0 &gt; .total-score\n  1 &gt; .current-round\n  false &gt; .game-over)\n\n(defshards initialize-round []\n  .total-images\n  (RandomInt :Max .total-images) &gt; .left-image-index\n  (RandomInt :Max .total-images) &gt; .right-image-index\n\n  (If\n   :Predicate (-&gt; .left-image-index (Is .right-image-index))\n   :Then (-&gt; true &gt; .same-image)\n   :Else (-&gt; false &gt; .same-image))\n\n  (reset-round-variables))\n\n(defloop end-round\n  (Setup 0 &gt;= .new-round-number)\n\n  .current-round (Math.Add 1)\n  &gt; .new-round-number\n\n  (If\n   :Predicate\n   (-&gt; .new-round-number (IsMore total-rounds))\n   :Then\n   (-&gt; true &gt; .game-over)\n   :Else\n   (-&gt;\n    .new-round-number &gt; .current-round\n    true &gt; .new-round)))\n\n(defshards check-answer [yes-input]\n  (When\n   :Predicate (-&gt; .input-received (Is false))\n   :Action\n   (-&gt;\n    (When\n     :Predicate (-&gt; .same-image (Is yes-input))\n     :Action (-&gt; (Math.Inc .total-score)))\n\n    true &gt; .input-received\n    (When\n     :Predicate (-&gt; .game-over (IsNot true))\n     :Action (-&gt; nil (Step end-round))))))\n\n\n(defshards main-game-ui []\n  (UI.BottomPanel\n   :Contents (-&gt; \"Are they the same image? Press the UP arrow if YES, and the DOWN arrow if NO.\" (UI.Label)))\n\n  (UI.TopPanel\n   :Contents\n   (-&gt;\n    (UI.Horizontal\n     :Contents\n     (-&gt;\n      \"Score: \" (UI.Label)\n      .total-score (ToString) (UI.Label)\n      (UI.Separator)\n      \"Round: \" (UI.Label)\n      .current-round (ToString) (UI.Label)\n      (UI.Separator)\n      \"Time Left: \" (UI.Label)\n      .time-remaining (ToString) (UI.Label)))))\n\n  (UI.CentralPanel\n   :Contents\n   (-&gt;\n    (UI.Horizontal\n     :Contents\n     (-&gt;\n      (UI.Area\n       :Position (float2 -250.0, 0.0)\n       :Anchor Anchor.Center\n       :Contents\n       (-&gt; .images (Take .left-image-index) (UI.Image)))\n      (UI.Area\n       :Position (float2 250.0, 0.0)\n       :Anchor Anchor.Center\n       :Contents\n       (-&gt; .images (Take .right-image-index) (UI.Image))))))))\n\n(defloop ui-loop\n  (GFX.MainWindow\n   :Title \"Yes-No Game\"\n   :Width 1280 :Height 768\n   :Contents\n   (-&gt;\n    (Setup\n     (GFX.DrawQueue) &gt;= .ui-draw-queue\n     (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n    (| .ui-draw-queue (GFX.ClearQueue))\n    (UI .ui-draw-queue (main-game-ui))\n    (GFX.Render :Steps .render-steps)\n\n    (Inputs.KeyDown\n     :Key \"up\"\n     :Action (-&gt; (check-answer true)))\n\n    (Inputs.KeyDown\n     :Key \"down\"\n     :Action (-&gt; (check-answer false))))))\n\n(defloop logic-loop\n  (WhenNot\n   :Predicate (-&gt; .game-over)\n   :Action\n   (-&gt;\n    (When ;; \n     :Predicate (-&gt; .new-round)\n     :Action (-&gt; (initialize-round))))))\n\n\n(defshards initialize-round []\n  .total-images\n  (RandomInt :Max .total-images) &gt; .left-image-index (Log \"left\")\n  (RandomInt :Max .total-images) &gt; .right-image-index (Log \"right\")\n\n  ; Determine if the images on the left and right are the same or different\n  (If\n   :Predicate (-&gt; .left-image-index (Is .right-image-index))\n   :Then (-&gt; true &gt; .same-image)\n   :Else (-&gt; false &gt; .same-image))\n\n  (reset-round-variables))\n\n(defloop game-loop\n  (Setup (load-resources) (initialize-variables))\n  (Branch [ui-loop, logic-loop]))\n\n(defmesh main)\n(schedule main game-loop)\n(run main (/ 1.0 60.0))\n</code></pre> <p></p> <p> </p>"},{"location":"learn/shards/tutorials/yes-no-game/steps/step-6/","title":"Step 6","text":"<p>Let us round up this tutorial by adding in the UI for the Game Over state and adding a Timer for extra challenge.</p> <p>We will be using a <code>UI.Button</code> to help us handle the user input for restarting the game.</p>"},{"location":"learn/shards/tutorials/yes-no-game/steps/step-6/#game-over","title":"Game Over","text":"Code <pre><code>(defshards game-over-ui []\n  (UI.CentralPanel\n   :Contents\n   (-&gt;\n    (UI.Area\n     :Position (float2 0.0, 0.0)\n     :Anchor Anchor.Center\n     :Contents\n     (-&gt;\n      \"GAME OVER\" (UI.Label)\n      (UI.Horizontal\n       :Contents\n       (-&gt;\n        \"Final Score: \" (UI.Label)\n        .total-score (ToString) (UI.Label)\n        \"/\"  (UI.Label)\n        total-rounds (ToString) (UI.Label)))\n\n      (UI.Button ;; (1)\n       :Label \"Play Again!\"\n       :Action (-&gt; (reset-game-variables))))))))\n</code></pre> <ol> <li><code>UI.Button</code> is a UI element that appears as a clickable button with the text passed into its <code>Label</code> parameter displayed on it.</li> </ol> <p>When the button is pressed, we reset the game's variables, including <code>.game-over</code> which will be used to decide what is drawn in our game's window.</p> <p>Navigate to <code>ui-loop</code> and add in <code>.game-over</code> conditionals.</p> BeforeAfter <pre><code>(defloop ui-loop\n (GFX.MainWindow\n  :Title \"Yes-No Game\"\n  ...\n   (| .ui-draw-queue (GFX.ClearQueue))\n   (UI .ui-draw-queue (main-game-ui))\n   (GFX.Render :Steps .render-steps))\n  ...\n</code></pre> <pre><code>(defloop ui-loop\n (GFX.MainWindow\n  :Title \"Yes-No Game\"\n  ...\n   (| .ui-draw-queue (GFX.ClearQueue))\n\n   (If\n    :Predicate (-&gt; .game-over)\n    :Then \n    (-&gt; (UI .ui-draw-queue (game-over-ui))) ;; (1)\n    :Else \n    (-&gt; (UI .ui-draw-queue (main-game-ui)))) ;; (2)\n\n   (GFX.Render :Steps .render-steps)\n  ...\n</code></pre> <ol> <li>Draw the Game Over UI if .game-over is true.</li> <li>Draw the Main Game UI if .game-over is false.</li> </ol> <p>The game will now display the main game area or a game over screen depending on whether <code>.game-over</code> is true.</p>"},{"location":"learn/shards/tutorials/yes-no-game/steps/step-6/#implementing-a-timer","title":"Implementing a Timer","text":"<p>To add additional challenge to the game (for additional fun!), we can impose a time limit on each round.</p> <p>Let us write a shard that decreases the <code>.time-remaining</code> every time it is called. </p> Code <pre><code>(defshards timer-tick []\n  (When\n   :Predicate (-&gt; .game-over (Is false)) ;; (1)\n   :Action\n   (-&gt;\n    (Math.Dec .time-remaining) ;; (2)\n    (When\n     :Predicate (-&gt; .time-remaining (IsLess 0)) ;; (3)\n     :Action (-&gt; nil (Step end-round))))))\n</code></pre> <ol> <li>When the game is still running...</li> <li>... decrease the time remaining by 1.</li> <li>The round is forced to end if the time remaining falls below 0.</li> </ol> <p>We can have <code>timer-tick</code> called every second consistently by using the <code>Once</code> shard. </p> <p>Place it within the <code>logic-loop</code> where we are checking if a new round should be started.</p> Code <pre><code>(defloop logic-loop\n  (Once ;; (1)(2)\n   :Action (-&gt; (timer-tick))\n   :Every 1.0)\n\n  (WhenNot\n   :Predicate (-&gt; .game-over)\n   :Action\n   (-&gt;\n    (When\n     :Predicate (-&gt; .new-round)\n     :Action (-&gt; (initialize-round))))))\n</code></pre> <ol> <li>Runs the timer-tick shard every 1 second.</li> <li><code>Once</code> will run the code in its <code>Action</code> parameter every time the duration specified in its <code>Every</code> parameter has passed.</li> </ol> <p>Note</p> <p>You can adjust the difficulty by changing the value of the <code>max-timer</code> constant we defined at the start.</p>"},{"location":"learn/shards/tutorials/yes-no-game/steps/step-6/#outcome","title":"Outcome","text":"<p>Congratulations on making it to the end!</p> <p>Your game now has 10 rounds, calculates the total score, shows a Game Over screen and lets you play it again at the end. It even has a timer to add a time constraint to each round.</p> <p></p> <p></p> <p>Now that the tutorial is over, why not challenge yourself further by implementing a high-score system? You could also try adding support for a second player! </p> <p>The possibilities are endless with the power of Shards in your hands.</p> <p>The full game script can be found here.</p> <p> </p>"},{"location":"reference/","title":"Index","text":""},{"location":"reference/#fragcolor-reference","title":"Fragcolor reference","text":"<p>Welcome to the Fragcolor reference docs - your go-to source for all things API-related for our various projects.</p> <p>Whether you're a seasoned developer or just starting out, we've designed these docs to be user-friendly and easy to navigate. You'll find all the information you need to get started with our APIs and build amazing creations. From detailed functionality explanations to handy integration tips, we've got it all covered.</p> <p>We hope you find them helpful and we can't wait to see the incredible things you'll build with our APIs.</p> <p>Choose from our projects here:</p> <ul> <li> <p>Shards</p> </li> <li> <p>Rare Engine (Coming Soon!)</p> </li> </ul> <p>Use the search box above if you're looking for something specific.</p> <p> </p>"},{"location":"reference/shards/","title":"Index","text":""},{"location":"reference/shards/#shards-reference","title":"Shards reference","text":"<p>Welcome to the Shards reference docs. This is where you can access comprehensive information about every shard, enum, and Lisp function that has been defined in Shards. </p> <p>Shards is a programming language that helps developers create complex workflows easily. It does this by breaking the code into small functional units called shards, which can be connected with other shards to create bigger workflows. Each shard can be adjusted to meet specific needs by using parameters. These parameters and specific traits of each shard can be found within our API docs.</p> <p>Begin your journey by selecting the section you wish to navigate to:</p> <ul> <li> <p>Overview</p> </li> <li> <p>Shards</p> </li> <li> <p>Enums</p> </li> <li> <p>Lisp functions</p> </li> </ul> <p>Alternatively, you can search for a specific shard or function by utilizing the search bar above.</p> <p> </p>"},{"location":"reference/shards/enums/","title":"Enums","text":"<p>This section serves as a reference guide for all the enum constants available within the Shards programming language. An enum, short for enumeration, is a set of named values, and enum constants are the individual values within that set. In Shards, enums are used to define a fixed set of values that can be used in the program.</p> <p> </p>"},{"location":"reference/shards/enums/Anchor/","title":"Anchor","text":"Value Description <code>TopLeft</code> Top left corner. <code>Left</code> Middle left. <code>BottomLeft</code> Bottom left corner. <code>Top</code> Top middle. <code>Center</code> Center. <code>Bottom</code> Bottom middle. <code>TopRight</code> Top right corner. <code>Right</code> Middle right. <code>BottomRight</code> Bottom right corner."},{"location":"reference/shards/enums/AstType/","title":"AstType","text":"Value Description <code>Bytes</code> Binary AST as Bytes type <code>Json</code> JSON String type AST <code>Object</code> Live Object AST to be used within a live environment"},{"location":"reference/shards/enums/BPP/","title":"BPP","text":"Value Description <code>u8</code> <code>u16</code> <code>f32</code>"},{"location":"reference/shards/enums/BindGroupId/","title":"BindGroupId","text":"Value Description <code>View</code> <code>Draw</code>"},{"location":"reference/shards/enums/BlendFactor/","title":"BlendFactor","text":"Value Description <code>Zero</code> <code>One</code> <code>Src</code> <code>OneMinusSrc</code> <code>SrcAlpha</code> <code>OneMinusSrcAlpha</code> <code>Dst</code> <code>OneMinusDst</code> <code>DstAlpha</code> <code>OneMinusDstAlpha</code> <code>SrcAlphaSaturated</code> <code>Constant</code> <code>OneMinusConstant</code>"},{"location":"reference/shards/enums/BlendOperation/","title":"BlendOperation","text":"Value Description <code>Add</code> <code>Subtract</code> <code>ReverseSubtract</code> <code>Min</code> <code>Max</code>"},{"location":"reference/shards/enums/BranchFailure/","title":"BranchFailure","text":"Value Description <code>Everything</code> <code>Known</code> <code>Ignore</code>"},{"location":"reference/shards/enums/BufferAddressSpace/","title":"BufferAddressSpace","text":"Value Description <code>Uniform</code> <code>Storage</code> <code>StorageRW</code>"},{"location":"reference/shards/enums/BuiltinFeatureId/","title":"BuiltinFeatureId","text":"Value Description <code>Transform</code> Add basic world/view/projection transform <code>BaseColor</code> Add basic color from vertex color and (optional) color texture <code>VertexColorFromNormal</code> Outputs color from vertex color <code>Wireframe</code> Modifies the main color to visualize vertex edges <code>Velocity</code> Outputs object velocity into the velocity global &amp; output <code>AlphaBlend</code> Simple feature that enables alpha blending"},{"location":"reference/shards/enums/BuiltinMeshType/","title":"BuiltinMeshType","text":"Value Description <code>Cube</code> <code>Sphere</code> <code>Plane</code>"},{"location":"reference/shards/enums/ColorMask/","title":"ColorMask","text":"Value Description <code>None</code> <code>Red</code> <code>Green</code> <code>Blue</code> <code>Alpha</code> <code>All</code>"},{"location":"reference/shards/enums/CompareFunction/","title":"CompareFunction","text":"Value Description <code>Undefined</code> <code>Never</code> <code>Less</code> <code>LessEqual</code> <code>Greater</code> <code>GreaterEqual</code> <code>Equal</code> <code>NotEqual</code> <code>Always</code>"},{"location":"reference/shards/enums/ConstraintSpace/","title":"ConstraintSpace","text":"Value Description <code>LocalToBodyCOM</code> <code>WorldSpace</code>"},{"location":"reference/shards/enums/DependencyType/","title":"DependencyType","text":"Value Description <code>Before</code> <code>After</code>"},{"location":"reference/shards/enums/FilterMode/","title":"FilterMode","text":"Value Description <code>Nearest</code> <code>Linear</code>"},{"location":"reference/shards/enums/FontFamily/","title":"FontFamily","text":"Value Description <code>Proportional</code> <code>Monospace</code>"},{"location":"reference/shards/enums/IfExists/","title":"IfExists","text":"Value Description <code>Fail</code> <code>Skip</code> <code>Overwrite</code> <code>Update</code>"},{"location":"reference/shards/enums/Interpolation/","title":"Interpolation","text":"Value Description <code>Linear</code> <code>Step</code> <code>Cubic</code>"},{"location":"reference/shards/enums/LayoutAlign/","title":"LayoutAlign","text":"Value Description <code>Min</code> Left or top alignment for e.g. anchors and layouts. <code>Left</code> Left alignment for e.g. anchors and layouts. <code>Top</code> Top alignment for e.g. anchors and layouts. <code>Center</code> Horizontal or vertical center alignment for e.g. anchors and layouts. <code>Max</code> Right or bottom center alignment for e.g. anchors and layouts. <code>Right</code> Right alignment for e.g. anchors and layouts. <code>Bottom</code> Bottom center alignment for e.g. anchors and layouts."},{"location":"reference/shards/enums/LayoutDirection/","title":"LayoutDirection","text":"Value Description <code>LeftToRight</code> Describes a horizontal layout where its contents are arranged from the left to the right. <code>RightToLeft</code> Describes a horizontal layout where its contents are arranged from the right to the left. <code>TopDown</code> Describes a vertical layout where its contents are arranged from the top to the bottom. <code>BottomUp</code> Describes a vertical layout where its contents are arranged from the bottom to the top."},{"location":"reference/shards/enums/LayoutFrame/","title":"LayoutFrame","text":"Value Description <code>Widgets</code> Use the frame styling for grouping widgets together. <code>SideTopPanel</code> Use the frame styling for a side top panel. <code>CentralPanel</code> Use the frame styling for the central panel. <code>Window</code> Use the frame styling for a window. <code>Menu</code> Use the frame styling for a menu. <code>Popup</code> Use the frame styling for a popup. <code>Canvas</code> Use the frame styling for a canvas to draw on. <code>DarkCanvas</code> Use the frame styling for a dark canvas to draw on."},{"location":"reference/shards/enums/LogLevel/","title":"LogLevel","text":"Value Description <code>Trace</code> <code>Debug</code> <code>Info</code> <code>Warning</code> <code>Error</code>"},{"location":"reference/shards/enums/MLFormats/","title":"MLFormats","text":"Value Description <code>GGUF</code> GGUF <code>SafeTensor</code> SafeTensor"},{"location":"reference/shards/enums/MLModels/","title":"MLModels","text":"Value Description <code>Bert</code> A BERT model."},{"location":"reference/shards/enums/MarkerShape/","title":"MarkerShape","text":"Value Description <code>Circle</code> Display a point as a circle. <code>Diamond</code> Display a point as a diamond. <code>Square</code> Display a point as a square. <code>Cross</code> Display a point as a cross. <code>Plus</code> Display a point as a plus sign. <code>Up</code> Display a point as an arrow pointing upwards. <code>Down</code> Display a point as an arrow pointing downwards. <code>Left</code> Display a point as an arrow pointing to the left. <code>Right</code> Display a point as an arrow pointing to the right. <code>Asterisk</code> Display a point as an asterisk."},{"location":"reference/shards/enums/Mean/","title":"Mean","text":"Value Description <code>Arithmetic</code> <code>Geometric</code> <code>Harmonic</code>"},{"location":"reference/shards/enums/ModifierKey/","title":"ModifierKey","text":"Value Description <code>None</code> <code>Shift</code> <code>Alt</code> <code>Primary</code> <code>Secondary</code>"},{"location":"reference/shards/enums/Order/","title":"Order","text":"Value Description <code>Background</code> Painted behind all floating windows. <code>PanelResizeLine</code> Special layer between panels and windows. <code>Middle</code> Normal moveable windows that you reorder by click. <code>Foreground</code> Popups, menus etc that should always be painted on top of windows. Foreground objects can also have tooltips. <code>Tooltip</code> Things floating on top of everything else, like tooltips. You cannot interact with these. <code>Debug</code> Debug layer, always painted last / on top."},{"location":"reference/shards/enums/OrthographicSizeType/","title":"OrthographicSizeType","text":"Value Description <code>Horizontal</code> <code>Vertical</code> <code>PixelScale</code>"},{"location":"reference/shards/enums/PhysicsDOF/","title":"PhysicsDOF","text":"Value Description <code>None</code> <code>TranslationX</code> <code>TranslationY</code> <code>TranslationZ</code> <code>RotationX</code> <code>RotationY</code> <code>RotationZ</code> <code>Plane2D</code> <code>All</code>"},{"location":"reference/shards/enums/PhysicsDebugShapeColor/","title":"PhysicsDebugShapeColor","text":"Value Description <code>InstanceColor</code> <code>ShapeTypeColor</code> <code>MotionTypeColor</code> <code>SleepColor</code> <code>IslandColor</code> <code>MaterialColor</code>"},{"location":"reference/shards/enums/PhysicsDebugSoftBodyConstraintColor/","title":"PhysicsDebugSoftBodyConstraintColor","text":"Value Description <code>ConstraintType</code> <code>ConstraintGroup</code> <code>ConstraintOrder</code>"},{"location":"reference/shards/enums/PhysicsMotion/","title":"PhysicsMotion","text":"Value Description <code>Static</code> <code>Kinematic</code> <code>Dynamic</code>"},{"location":"reference/shards/enums/PopupLocation/","title":"PopupLocation","text":"Value Description <code>Below</code> Below. <code>Above</code> Above."},{"location":"reference/shards/enums/ProgrammableGraphicsStage/","title":"ProgrammableGraphicsStage","text":"Value Description <code>Vertex</code> <code>Fragment</code>"},{"location":"reference/shards/enums/RequiredAttributes/","title":"RequiredAttributes","text":"Value Description <code>Tangent</code> Require mesh tangents to be available"},{"location":"reference/shards/enums/RunWireMode/","title":"RunWireMode","text":"Value Description <code>Inline</code> <code>Async</code> <code>Stepped</code>"},{"location":"reference/shards/enums/ScrollVisibility/","title":"ScrollVisibility","text":"Value Description <code>AlwaysVisible</code> The scroll bars will always be visible. <code>VisibleWhenNeeded</code> The scroll bars will only be visible when needed <code>AlwaysHidden</code> The scroll bars will always be hidden."},{"location":"reference/shards/enums/ShaderFieldBaseType/","title":"ShaderFieldBaseType","text":"Value Description <code>Bool</code> <code>UInt8</code> <code>Int8</code> <code>UInt16</code> <code>Int16</code> <code>UInt32</code> <code>Int32</code> <code>Float16</code> <code>Float32</code>"},{"location":"reference/shards/enums/ShaderLiteralType/","title":"ShaderLiteralType","text":"Value Description <code>Inline</code> Insert shader code directly into current scope <code>Header</code> Insert shader code into header, where it is defined before all shards shader code"},{"location":"reference/shards/enums/SortMode/","title":"SortMode","text":"Value Description <code>Queue</code> <code>Batch</code> <code>BackToFront</code>"},{"location":"reference/shards/enums/TensorType/","title":"TensorType","text":"Value Description <code>U8</code> An unsigned 8-bit integer tensor. <code>U32</code> An unsigned 32-bit integer tensor. <code>I64</code> A signed 64-bit integer tensor. <code>BF16</code> A brain floating-point 16-bit tensor. <code>F16</code> A floating-point 16-bit tensor. <code>F32</code> A floating-point 32-bit tensor. <code>F64</code> A floating-point 64-bit tensor."},{"location":"reference/shards/enums/TextStyle/","title":"TextStyle","text":"Value Description <code>Small</code> Used when small text is needed. <code>Body</code> Normal labels. Easily readable, doesn't take up too much space. <code>Monospace</code> Same size as [<code>Self::Body</code>], but used when monospace is important (for code snippets, aligning numbers, etc). <code>Button</code> Buttons. Maybe slightly bigger than [<code>Self::Body</code>]. <code>Heading</code> Heading. Probably larger than [<code>Self::Body</code>]."},{"location":"reference/shards/enums/TextWrap/","title":"TextWrap","text":"Value Description <code>Extend</code> Extends the parent widget's width to wrap text. <code>Wrap</code> Wraps text to the width of the parent widget extending the next line. <code>Truncate</code> Truncates text that does not fit within the parent widget."},{"location":"reference/shards/enums/TextureAddressing/","title":"TextureAddressing","text":"Value Description <code>Repeat</code> <code>MirrorRepeat</code> <code>ClampToEdge</code>"},{"location":"reference/shards/enums/TextureDimension/","title":"TextureDimension","text":"Value Description <code>D1</code> <code>D2</code> <code>Cube</code>"},{"location":"reference/shards/enums/TextureFiltering/","title":"TextureFiltering","text":"Value Description <code>Nearest</code> <code>Linear</code>"},{"location":"reference/shards/enums/TextureFormat/","title":"TextureFormat","text":"Value Description <code>R8Unorm</code> <code>R8Snorm</code> <code>R8Uint</code> <code>R8Sint</code> <code>R16Uint</code> <code>R16Sint</code> <code>R16Float</code> <code>RG8Unorm</code> <code>RG8Snorm</code> <code>RG8Uint</code> <code>RG8Sint</code> <code>R32Float</code> <code>R32Uint</code> <code>R32Sint</code> <code>RG16Uint</code> <code>RG16Sint</code> <code>RG16Float</code> <code>RGBA8Unorm</code> <code>RGBA8UnormSrgb</code> <code>RGBA8Snorm</code> <code>RGBA8Uint</code> <code>RGBA8Sint</code> <code>BGRA8Unorm</code> <code>BGRA8UnormSrgb</code> <code>RGB10A2Unorm</code> <code>RG11B10Ufloat</code> <code>RGB9E5Ufloat</code> <code>RG32Float</code> <code>RG32Uint</code> <code>RG32Sint</code> <code>RGBA16Uint</code> <code>RGBA16Sint</code> <code>RGBA16Float</code> <code>RGBA32Float</code> <code>RGBA32Uint</code> <code>RGBA32Sint</code> <code>Stencil8</code> <code>Depth16Unorm</code> <code>Depth24Plus</code> <code>Depth24PlusStencil8</code> <code>Depth32Float</code> <code>Depth32FloatStencil8</code>"},{"location":"reference/shards/enums/TextureSampleType/","title":"TextureSampleType","text":"Value Description <code>Int</code> <code>UInt</code> <code>Float</code> <code>UnfilterableFloat</code> <code>Depth</code>"},{"location":"reference/shards/enums/TextureType/","title":"TextureType","text":"Value Description <code>Default</code> <code>Int</code> <code>UInt</code> <code>UNorm</code> <code>UNormSRGB</code> <code>SNorm</code> <code>Float</code>"},{"location":"reference/shards/enums/Type/","title":"Type","text":"Value Description <code>None</code> <code>Any</code> <code>Bool</code> <code>Int</code> <code>Int2</code> <code>Int3</code> <code>Int4</code> <code>Int8</code> <code>Int16</code> <code>Float</code> <code>Float2</code> <code>Float3</code> <code>Float4</code> <code>Color</code> <code>Wire</code> <code>Shard</code> <code>Bytes</code> <code>String</code> <code>Image</code> <code>Audio</code>"},{"location":"reference/shards/enums/UIProperty/","title":"UIProperty","text":"Value Description <code>RemainingSpace</code> Return the remaining space within an UI widget. (float4) <code>ScreenSize</code> The screen size of the UI. (float2) <code>PixelsPerPoint</code> The amounts of pixels that correspond to 1 UI point. (float) <code>IsAnythingBeingDragged</code> Returns true when anything is being dragged. (bool) <code>CursorPosition</code> The position of the UI cursor <code>IsHovered</code> True if the current UI area is being hovered over. (bool)"},{"location":"reference/shards/enums/WaitUntil/","title":"WaitUntil","text":"Value Description <code>FirstSuccess</code> Will wait until the first success and stop any other pending operation <code>AllSuccess</code> Will wait until all complete, will stop and fail on any failure <code>SomeSuccess</code> Will wait until all complete but won't fail if some of the wires failed"},{"location":"reference/shards/enums/Waveform/","title":"Waveform","text":"Value Description <code>Sine</code> <code>Square</code> <code>Triangle</code> <code>Sawtooth</code>"},{"location":"reference/shards/enums/WindingOrder/","title":"WindingOrder","text":"Value Description <code>CW</code> <code>CCW</code>"},{"location":"reference/shards/enums/WindowFlags/","title":"WindowFlags","text":"Value Description <code>NoTitleBar</code> Do not display the title bar. <code>NoResize</code> Do not allow resizing the window. <code>Scrollbars</code> Display scrollbars. <code>NoCollapse</code> Do not display the collapse button. <code>Immovable</code> Do not allow window movement."},{"location":"reference/shards/lisp/","title":"Lisp Functions","text":"<p>Lisp functions are used in Shards for templating and writing macros.</p> <p>Templates can be defined for a common task that is used frequently in the program. This template can then be reused throughout the program, saving time and effort. This allow developers to create complex code structures that are reusable and easily maintainable. The templates can include placeholders for values that are determined at run-time, making them highly versatile.</p> <p>Select from our list of Lisp functions below to access their API docs:</p> <ul> <li>Collections</li> <li>Macros</li> <li>Operators</li> <li>Standard Output</li> <li>Strings</li> <li>Values</li> </ul> <p> </p>"},{"location":"reference/shards/lisp/collections/","title":"Collections","text":""},{"location":"reference/shards/lisp/collections/#assoc","title":"assoc","text":"<pre><code>(assoc map key val) (assoc map key val &amp; kvs)\n</code></pre> <p>assoc[iate]. When applied to a map, returns a new map of the same (hashed/sorted) type, that contains the mapping of key(s) to val(s). When applied to a vector, returns a new vector that contains val at index. Note - index must be &lt;= (count vector).</p> Code <pre><code>(assoc {} :apples 1 :oranges 3)\n;;=&gt; {:apples 1}\n</code></pre>"},{"location":"reference/shards/lisp/collections/#concat","title":"concat","text":"<pre><code>(concat) (concat x) (concat x y) (concat x y &amp; zs)\n</code></pre> <p>Returns a sequence representing the concatenation of the elements in the supplied colls.</p> Code <pre><code>(concat [\"apple\" \"mango\"] [\"banana\"])\n;; =&gt; (\"apple\" \"mango\" \"banana\")\n</code></pre>"},{"location":"reference/shards/lisp/collections/#conj","title":"conj","text":"<pre><code>(conj coll x) (conj coll x &amp; xs)\n</code></pre> <p>conj[oin]. Returns a new collection with the xs 'added'. The 'addition' may happen at different 'places' depending on the concrete type of coll.</p> Code <pre><code>(conj [\"apple\" \"mango\"] \"cherry\")\n;; =&gt; [\"apple\" \"mango\" \"cherry\"]\n</code></pre>"},{"location":"reference/shards/lisp/collections/#cons","title":"cons","text":"<pre><code>(cons x seq)\n</code></pre> <p>Constructs a list recursively using the pattern <code>(cons element rest-of-list)</code>.</p> Code <pre><code>(cons \"apple\" (cons \"mango\" (cons \"cherry\" nil)))\n;; =&gt; (\"apple\" \"mango\" \"cherry\")\n</code></pre>"},{"location":"reference/shards/lisp/collections/#contains","title":"contains?","text":"<pre><code>(contains? hashmap key)\n</code></pre> <p>Checks whether a hashmap contains a record with the given key. Given key can be either a string or a keyword.</p> Code <pre><code>(contains? {:apples 4} :apples)\n;;=&gt; true\n(contains? {:apples 4} :oranges)\n;;=&gt; false\n</code></pre>"},{"location":"reference/shards/lisp/collections/#count","title":"count","text":"<pre><code>(count coll)\n</code></pre> <p>Counts the number of elements in a coll.</p> Code <pre><code>(count [1 2 4])\n;;=&gt; 3\n</code></pre>"},{"location":"reference/shards/lisp/collections/#dissoc","title":"dissoc","text":"<pre><code>(dissoc map) (dissoc map key) (dissoc map key &amp; ks)\n</code></pre> Code <pre><code>(dissoc {:oranges 2 :apples 3} :apples) ;; =&gt; {:oranges 2}\n</code></pre>"},{"location":"reference/shards/lisp/collections/#empty","title":"empty?","text":"<pre><code>(empty? coll)\n</code></pre> <p>Checks whether coll has no elements.</p> Code <pre><code>(empty? [1 2 3]) ;;=&gt; false\n(empty? []) ;;=&gt; true\n(empty? nil) ;;=&gt; true\n</code></pre>"},{"location":"reference/shards/lisp/collections/#get","title":"get","text":"<pre><code>(get map key) (get map key not-found)\n</code></pre> <p>Returns the value mapped to key, not-found or nil if key not present.</p> Code <pre><code>(get {:apples 1} :apples)\n;; =&gt; 1\n</code></pre>"},{"location":"reference/shards/lisp/collections/#first","title":"first","text":"<pre><code>(first coll)\n</code></pre> <p>Returns the first item in the collection. If coll is nil, returns nil.</p> Code <pre><code>(first [\"apple\" \"mango\"])\n;; =&gt; \"apple\"\n</code></pre>"},{"location":"reference/shards/lisp/collections/#keys","title":"keys","text":"<pre><code>(keys map)\n</code></pre> <p>Gets a list of all the keys from a hashmap.</p> Code <pre><code>(keys {:oranges 2 :apples 3})\n;; =&gt; (:apples :oranges)\n</code></pre>"},{"location":"reference/shards/lisp/collections/#list","title":"list","text":"<pre><code>(list &amp; items)\n</code></pre> <p>Creates a new list containing the items.</p> Code <pre><code>(list 1 2 3)\n;; =&gt; (1 2 3)\n</code></pre>"},{"location":"reference/shards/lisp/collections/#hash-map","title":"hash-map","text":"<pre><code>(hash-map) (hash-map &amp; keyvals)\n</code></pre> <p>Returns a new hash map with supplied mappings. If any keys are equal, they are handled as if by repeated uses of assoc.</p> Code <pre><code>(hash-map :apples 1 :oranges 2)\n;;=&gt; {:apples 1 :oranges 2}\n</code></pre>"},{"location":"reference/shards/lisp/collections/#map","title":"map","text":"<pre><code>(map f coll)\n</code></pre> <p>Returns a sequence consisting of the result of applying f to the first item of coll, followed by applying f to the second item of coll, until coll is exhausted.</p> Code <pre><code>(map inc [1 2 3 4 5])\n;; =&gt; (2 3 4 5 6)\n</code></pre>"},{"location":"reference/shards/lisp/collections/#nth","title":"nth","text":"<pre><code>(nth coll index)\n</code></pre> <p>Returns the value at the index of coll.</p> Code <pre><code>(nth [\"a\" \"b\" \"c\" \"d\"] 0)\n;; =&gt; \"a\"\n</code></pre>"},{"location":"reference/shards/lisp/collections/#rest","title":"rest","text":"<pre><code>(rest coll)\n</code></pre> <p>Returns a possibly empty sequence of the items after the first.</p> Code <pre><code>(rest [\"apple\" \"mango\" \"cherry\"])\n;;=&gt; (\"mango\" \"cherry\")\n(rest []) ;;=&gt; ()\n(rest nil) ;;=&gt; ()\n</code></pre>"},{"location":"reference/shards/lisp/collections/#reverse","title":"reverse","text":"<pre><code>(reverse coll)\n</code></pre> <p>Returns a sequence of the items in coll in reverse order.</p> Code <pre><code>(reverse [\"apple\" \"mango\" \"banana\"])\n;;=&gt; (\"banana\" \"mango\" \"apple\")\n</code></pre>"},{"location":"reference/shards/lisp/collections/#seq","title":"seq","text":"<pre><code>(seq coll)\n</code></pre> <p>Returns a sequence on the collection. If the collection is empty, returns nil. (seq nil) returns nil. <code>seq</code> also works on Strings.</p> Code <pre><code>(seq \"abc\") ;;=&gt; (\"a\" \"b\" \"c\")\n(seq []) ;;=&gt; nil\n(seq nil) ;;=&gt; nil\n</code></pre>"},{"location":"reference/shards/lisp/collections/#vals","title":"vals","text":"<pre><code>(vals map)\n</code></pre> <p>Returns a sequence of the map's values.</p> Code <pre><code>(vals {:apples 3 :mangos 2})\n;;=&gt; (3 2)\n</code></pre>"},{"location":"reference/shards/lisp/collections/#vector","title":"vector","text":"<pre><code>(vector) (vector a) (vector a b) (vector a b c) (vector a b c d) (vector a b c d e) (vector a b c d e f) (vector a b c d e f &amp; args)\n</code></pre> <p>Creates a new vector containing the args.</p> Code <pre><code>(vector \"mango\" \"banana\" \"peach\")\n;;=&gt; [\"mango\" \"banana\" \"peach\"]\n</code></pre> <p> </p>"},{"location":"reference/shards/lisp/macros/","title":"Macros","text":""},{"location":"reference/shards/lisp/macros/#def","title":"def","text":"<p>Defines an alias for a value.</p> <p>This value may be data, the result of an expression, or the return value of a shard.</p> Code <pre><code>;; define an alias for data\n(def sequence1 [2 4 6 8])\n(def string1 \"I'm a string\")\n\n;; define an alias for an evaluated expression result\n(def xresult (* 2 4))\n\n;; define an alias for a shard's return value\n(def my-wire (Wire \"my-wire\"))\n(def my-looped-wire (Wire \"my-looped-wire\" :Looped))\n(def Root (Mesh))\n(def - Math.Subtract)\n</code></pre> See also <ul> <li>defwire</li> <li>defloop</li> <li>defmesh</li> </ul>"},{"location":"reference/shards/lisp/macros/#defshards","title":"defshards","text":"<p>Defines new shards that can be grouped together and inserted into an existing wire program.</p> <p>Note</p> <p>What's a <code>shard</code></p> <p>A <code>defshards</code> shard looks structurally similar to a function (see defn), but unlike a <code>defn</code>, it can contain multiple shards in its body without needing to use <code>-&gt;</code>.</p> <p>During the execution phase, <code>defshards</code> is replaced by its inner shards wherever it's invoked.</p> Code <pre><code>(defshards MsgParms [input]\n    (Msg \"My name is\")\n    (Msg input))\n</code></pre> <p>Just like a function, a <code>defshards</code> shard can be invoked by name and can process input parameters.</p> CodeResult <pre><code>(defmesh main)\n\n(defshards MsgParms [input]\n  (Msg \"My name is\")\n  (Msg input))\n\n(defwire mywire\n  (MsgParms \"Shards\"))\n\n(schedule main mywire)\n\n(run main)\n</code></pre> <pre><code>[info] [2022-05-13 15:31:09.231] [T-4796] [logging.cpp::98] [mywire] My name is\n[info] [2022-05-13 15:31:09.232] [T-4796] [logging.cpp::98] [mywire] Shards\n</code></pre> <p><code>(defshards)</code> can be used in place of a <code>(defn)</code> (function declaration) plus <code>(-&gt;)</code> (shard-container).</p> <p>See the last two code examples in <code>(defn)</code> for a comparison of these use cases.</p>"},{"location":"reference/shards/lisp/macros/#defwire","title":"defwire","text":"<p>Defines a new non-looped wire.</p> Code <pre><code>;; defwire\n(defwire my-wire\n    ;; shards here\n)\n</code></pre> <p>Note</p> <p>What's a <code>wire</code>?</p> <p><code>(defwire &lt;wire-name&gt;)</code> is actually a shorthand for the more verbose non-looped wire definition: <code>(def &lt;wire-name&gt; (Wire \"wire-name\"))</code>.</p> Code <pre><code>;; def + Wire\n(def my-wire\n  (Wire \"my-wire\"\n    ;; shards here\n))\n</code></pre> <p>To run a wire you must first schedule it on a mesh. When you run this mesh, all the wires scheduled on it are executed (in the order of scheduling).</p> <p>A mesh will execute a non-looped wire only once (even though the mesh itself may continue running).</p> CodeResult <pre><code>;; define a mesh (main)\n(defmesh main)\n\n;; define a non-looped wire (wire-hello)\n(defwire wire-hello\n  (Msg \"Hello World!\"))\n\n;; define another non-looped wire (wire-bye)\n(defwire wire-bye\n  (Msg \"Goodbye World\"))\n\n;; schedule the non-looped wires on the mesh\n(schedule main wire-hello)\n(schedule main wire-bye)\n\n;; run all the scheduled wires on the mesh\n(run main)\n</code></pre> <pre><code>[info] [2022-03-07 20:45:35.681] [T-9044] [logging.cpp::94] [wire-hello] Hello World!\n[info] [2022-03-07 20:45:35.678] [T-9044] [logging.cpp::94] [wire-bye] Goodbye World\n</code></pre> <p><code>defwire</code> can also parse and save the wire's input into a variable.</p> CodeResult <pre><code>(defmesh main)\n\n(defwire mywire\n  = .wirevar                      ;; save mywire input to wirevar\n  .wirevar (Log \"wire input\"))    ;; log mywire input to screen\n\n(defwire mainwire\n    \"shards\" (Do mywire))           ;; invoke mywire with an input\n\n(schedule main mainwire)\n\n(run main)\n</code></pre> <pre><code>[trace] [2022-05-12 21:25:49.714] [T-17336] [runtime.cpp::1998] wire mainwire starting\n[info] [2022-05-12 21:25:49.715] [T-17336] [logging.cpp::53] [mywire] wire input: shards\n[debug] [2022-05-12 21:25:49.716] [T-17336] [runtime.cpp::2741] Running cleanup on wire: mainwire users count: 0\n</code></pre> See also <ul> <li>def</li> <li>defloop</li> </ul>"},{"location":"reference/shards/lisp/macros/#defn","title":"defn","text":"<p>Defines a new function.</p> Code <pre><code>(defn fn-name [fn-params] ;; function-name followed by input parameters in '[]'\n    (Msg fn-params)       ;; function body that returns a value\n)\n</code></pre> <p>The function definition consists of the function name followed by its input parameters (<code>fn-params</code>), in <code>[]</code>.</p> <p>If there are no input parameters, the <code>[]</code> remains empty. Multiple input parameters may be passed as a sequence.</p> <p>The processing statements (value/expression/shards) following the <code>[]</code> are the function's body and its evaluation is the function's return value.</p> <p>A function can be invoked by calling it by name and passing its required parameters.</p> <p>Function with no input parameters:</p> CodeResult <pre><code>(defmesh main)\n\n(defn func []\n  (Msg \"I got no parameters\"))    ;; prints string text to screen\n\n(defwire mywire\n  (func))                         ;; function invoked without any parameters\n\n(schedule main mywire)\n\n(run main)\n</code></pre> <pre><code>[info] [2022-05-13 14:04:22.268] [T-1204] [logging.cpp::98] [mywire] I got no parameters\n</code></pre> <p>Function with one input parameter:</p> CodeResult <pre><code>(defmesh main)\n\n(defn func [param]\n  (Msg param))                 ;; prints the parameter to screen\n\n(defwire mywire\n  (func \"The only parameter\")) ;; function invoked with a single parameter\n\n(schedule main mywire)\n\n(run main)\n</code></pre> <pre><code>[info] [2022-05-13 14:03:58.125] [T-21336] [logging.cpp::98] [mywire] The only parameter\n</code></pre> <p>Function with multiple input parameters:</p> CodeResult <pre><code>(defmesh main)\n\n(defn func [param1 param2]\n  (Msg param2))                           ;; prints the 2nd parameter to screen\n\n(defwire mywire\n  (func \"1st parameter\" \"2nd parameter\")) ;; function invoked with multiple parameters\n\n(schedule main mywire)\n\n(run main)\n</code></pre> <pre><code>[info] [2022-05-13 14:03:38.570] [T-11468] [logging.cpp::98] [mywire] 2nd parameter\n</code></pre> <p>A function cannot return multiple values. So if you need to process multiple shards in the function's body then you'll have to either use <code>(defshards)</code> instead of <code>(defn)</code>,</p> CodeResult <pre><code>(defmesh main)\n\n;; defshards groups multiple shards for processing\n(defshards MsgParams [input]\n  (Msg \"name is:\")\n  (Msg input))\n\n(defn letslog [name]\n  ;; defshards takes function input and returns single value\n  (MsgParams name))\n\n(defwire mywire\n  (letslog \"shards\"))\n\n(schedule main mywire)\n\n(run main)\n</code></pre> <pre><code>[info] [2022-05-13 14:44:51.293] [T-16928] [logging.cpp::98] [mywire] name is:\n[info] [2022-05-13 14:44:51.294] [T-16928] [logging.cpp::98] [mywire] shards\n</code></pre> <p>or use <code>(-&gt;)</code> to group and process the multiple shards inside the <code>(defn)</code>:</p> CodeResult <pre><code>(defmesh main)\n\n(defn letslog [name]\n  (-&gt; ;; defshards replaced with `-&gt;`\n    (Msg \"name is:\")\n    ;; multiple shards can now be written down sequentially\n    (Msg name)))\n\n(defwire mywire\n  (letslog \"shards\"))\n\n(schedule main mywire)\n\n(run main)\n</code></pre> <pre><code>[info] [2022-05-13 14:47:44.543] [T-21048] [logging.cpp::98] [mywire] name is:\n[info] [2022-05-13 14:47:44.544] [T-21048] [logging.cpp::98] [mywire] shards\n</code></pre> See also <ul> <li>defshards</li> </ul>"},{"location":"reference/shards/lisp/macros/#defmesh","title":"defmesh","text":"<p>Defines a new <code>mesh</code> on which wires can be scheduled and then run.</p> <p>Note</p> <p>What's a <code>mesh</code>?</p> Code <pre><code>(defmesh main)     ;; define a mesh called 'main'\n</code></pre> <p><code>(defmesh &lt;mesh-name&gt;)</code> is actually a shorthand for the more verbose mesh definition: <code>(def &lt;mesh-name&gt; (Mesh))</code>.</p> Code <pre><code>;; def + Mesh\n(def main (Mesh))   ;; define a mesh named 'main'\n</code></pre> <p>Here's an example that schedules a looped and a non-looped wire on a mesh.</p> CodeResult <pre><code>(defmesh main)              ;; define a mesh (main)\n\n(defloop wire-hi            ;; define a looped wire\n  (Msg \"Hello World!\"))\n\n(defwire wire-bye           ;; define a non-looped wire\n  (Msg \"Goodbye World\"))\n\n(schedule main wire-hi)     ;; schedule looped wire (wire-hi) on this mesh\n\n(schedule main wire-bye)    ;; schedule non-looped wire (wire-hi) on this mesh\n\n(run main)                  ;; run all the scheduled wires on this mesh\n</code></pre> <pre><code>[info] [2022-03-07 22:14:51.730] [T-14836] [logging.cpp::94] [wire-hi] Hello World!\n[info] [2022-03-07 22:14:51.731] [T-14836] [logging.cpp::94] [wire-bye] Goodbye World\n[info] [2022-03-07 22:14:51.760] [T-14836] [logging.cpp::94] [wire-hi] Hello World!\n[info] [2022-03-07 22:14:51.776] [T-14836] [logging.cpp::94] [wire-hi] Hello World!\n[info] [2022-03-07 22:14:51.791] [T-14836] [logging.cpp::94] [wire-hi] Hello World!\n[info] [2022-03-07 22:14:51.823] [T-14836] [logging.cpp::94] [wire-hi] Hello World!\n.\n.\n.\n</code></pre> See also <ul> <li>def</li> </ul>"},{"location":"reference/shards/lisp/macros/#defloop","title":"defloop","text":"<p>Defines a new looped wire.</p> Code <pre><code>;; defloop\n(defloop my-loop       ;; define a looped wire\n  ;; shards here\n)\n</code></pre> <p>Note</p> <p>What's a <code>wire</code>?</p> <p><code>(defloop &lt;wire-name&gt;)</code> is a shorthand for the more verbose looped wire definition: <code>(def &lt;wire-name&gt; (Wire &lt;wire-name&gt;))</code>.</p> Code <pre><code>;; def + Wire\n(def my-loop\n  (Wire \"my-loop\" :Looped\n    ;; shards here\n))\n</code></pre> <p>For a wire to be executed, it must first be scheduled on a <code>mesh</code> and then that mesh needs to run.</p> CodeResult <pre><code>(defmesh main)          ;; define a mesh\n\n(defloop my-loop        ;; define a looped wire\n  (Msg \"Hello World!\"))\n\n(schedule main my-loop)\n\n(run main)              ;; run wires scheduled on this mesh\n</code></pre> <pre><code>[info] [2022-05-13 09:48:01.692] [T-15068] [logging.cpp::98] [my-loop] Hello World!\n[info] [2022-05-13 09:48:01.693] [T-15068] [logging.cpp::98] [my-loop] Hello World!\n[info] [2022-05-13 09:48:01.694] [T-15068] [logging.cpp::98] [my-loop] Hello World!\n.\n.\n.\n</code></pre> <p>A mesh will continue executing a looped wire till the mesh itself stops running (or the wire execution is stopped via a logic condition).</p> CodeResult <pre><code>(defmesh main)              ;; define a mesh\n\n(defloop wire-hi            ;; define a looped wire (wire-hello)\n  (Msg \"Hello World!\"))\n\n(defloop wire-bye           ;; define another looped wire (wire-bye)\n  (Msg \"Goodbye World\"))\n\n(schedule main wire-hi)     ;; schedule the wire (wire-hi) on the mesh\n\n(schedule main wire-bye)    ;; schedule the wire (wire-bye) on the mesh\n\n(run main)                  ;; run all the wires scheduled on this mesh\n</code></pre> <pre><code>[info] [2022-03-07 22:28:54.682] [T-8432] [logging.cpp::94] [wire-hi] Hello World!\n[info] [2022-03-07 22:28:54.682] [T-8432] [logging.cpp::94] [wire-bye] Goodbye World\n[info] [2022-03-07 22:28:54.715] [T-8432] [logging.cpp::94] [wire-hi] Hello World!\n[info] [2022-03-07 22:28:54.715] [T-8432] [logging.cpp::94] [wire-bye] Goodbye World\n[info] [2022-03-07 22:28:54.731] [T-8432] [logging.cpp::94] [wire-hi] Hello World!\n[info] [2022-03-07 22:28:54.732] [T-8432] [logging.cpp::94] [wire-bye] Goodbye World\n.\n.\n.\n</code></pre> See also <ul> <li>def</li> <li>defwire</li> </ul> <p> </p>"},{"location":"reference/shards/lisp/misc/","title":"Miscellaneous functions","text":"<p>Uncategorized</p> <p>This page references all other functions that don't fit in the previous categories. Over time, they might be moved to a different or new category.</p>"},{"location":"reference/shards/lisp/misc/#-","title":"-&gt;","text":"<p>Groups multiple shards together (as if they were a single shard). Also called shard-container.</p> <p>This is useful for cases where you need multiple shards (to transform your data) but is allowed to have only one: for example, as the return value of a function (see function <code>print-messages</code> below).  </p> CodeResult <pre><code>(defn print-messages []\n    (-&gt; \n        (Msg \"Hello World!\")\n        (Msg \"Hello Universe!\")\n    ))\n</code></pre> <pre><code>[info] [2022-07-06 14:14:43.056] [T-2168] [logging.cpp::98] [main] Hello World!\n[info] [2022-07-06 14:14:43.058] [T-2168] [logging.cpp::98] [main] Hello Universe! \n</code></pre>"},{"location":"reference/shards/lisp/misc/#apply","title":"apply","text":"<pre><code>(apply f args) (apply f x args) (apply f x y args) (apply f x y z args)(apply f a b c d &amp; args)\n</code></pre> <p>Applies fn f to the argument list formed by prepending intervening arguments to args.</p> <pre><code>(apply str [\"cherry \" \"banana \" \"apple\"])\n;;=&gt; \"cherry banana apple\"\n\n(apply str \"cherry \" [\"banana \" \"apple\"])\n;;=&gt; \"cherry banana apple\"\n\n(apply str \"cherry \" \"banana \" [\"apple\"])\n;;=&gt; \"cherry banana apple\"\n\n(apply str \"cherry \" \"banana \" \"apple\" [])\n;;=&gt; \"cherry banana apple\"\n</code></pre>"},{"location":"reference/shards/lisp/misc/#atom","title":"atom","text":"<pre><code>(atom x)\n</code></pre> <p>Creates and returns an Atom with an initial value of x and zero or more options (in any order).   An Atom is a data type in Clojure that provides a way to manage shared, synchronous, independent state. An atom is just like any reference type in any other programming language.</p> <pre><code>;; Create new atom\n(def my-atom (atom 0))\n\n;; value under 'my-atom' to be replaced with incremented version\n(swap! my-atom inc)\n;;=&gt; 1\n</code></pre>"},{"location":"reference/shards/lisp/misc/#deref","title":"deref","text":"<pre><code>(deref ref)\n</code></pre> <p>Returns the most current state of the atom.</p> <pre><code>(deref (atom [1 2]))\n;;=&gt; [1 2]\n</code></pre>"},{"location":"reference/shards/lisp/misc/#fn","title":"fn?","text":"<pre><code>(fn? f)\n</code></pre> <p>Return true if f is a function.</p> <pre><code>(fn? String.Join)\n;;=&gt; true\n</code></pre>"},{"location":"reference/shards/lisp/misc/#hex","title":"hex","text":"<pre><code>(hex number)\n</code></pre> <p>Returns a hexadecimal representation for an input number.</p> <pre><code>(hex 2)\n;;=&gt; \"0x0000000000000002\"\n</code></pre>"},{"location":"reference/shards/lisp/misc/#keyword","title":"keyword","text":"<pre><code>(keyword s)\n</code></pre> <p>Returns a keyword with a given s string. Do not use <code>:</code> in the keyword strings, it will be added automatically.</p> <pre><code>(keyword \"foo/bar\")\n;;=&gt; :foo/bar\n</code></pre>"},{"location":"reference/shards/lisp/misc/#macro","title":"macro?","text":"<pre><code>(macro? value)\n</code></pre> <p>Checks if a value is a macro.</p> <pre><code>(macro? defn)\n;;=&gt; true\n</code></pre>"},{"location":"reference/shards/lisp/misc/#meta","title":"meta","text":""},{"location":"reference/shards/lisp/misc/#read-string","title":"read-string","text":"<pre><code>(read-string s)\n</code></pre> <p>Reads one object from the string s.</p> <pre><code>(read-string \"2.3\") ;;=&gt; 2.300000\n\n(read-string \"(+ 1 1)\") ;;=&gt; (+ 1 1)\n</code></pre>"},{"location":"reference/shards/lisp/misc/#readline","title":"readline","text":"<pre><code>(readline prompt)\n</code></pre> <p>Reads a line from stdin and returns it. Accepts prompt string.</p> <pre><code>(readline \"Enter a line: \")\n</code></pre>"},{"location":"reference/shards/lisp/misc/#reset","title":"reset!","text":"<pre><code>(reset! atom newval)\n</code></pre> <p>Sets the value of the atom to newval without regard for the current value. Returns newval.</p> <pre><code>(reset! (atom \"apple\") \"mango\")\n</code></pre>"},{"location":"reference/shards/lisp/misc/#run","title":"run","text":"<p>Executes all the wires that have been scheduled on a given <code>mesh</code>.</p> <p><code>(run &lt;params&gt;)</code> takes two arguments: name of the mesh, and mesh iteration interval (no. of seconds between two mesh iterations).</p> <p>An optional 3rd argument defines the maximum mesh iterations to run. This argument is a debug parameter - do not use it for production.</p> CodeResult <pre><code>;; define a mesh (main)\n(defmesh main)\n;; define a looped wire\n(defloop wire-hi\n    (Msg \"Hello World!\"))\n;; define a non-looped wire\n(defwire wire-bye\n    (Msg \"Goodbye World\"))\n;; schedule both the wires on this mesh\n(schedule main wire-hi)\n(schedule main wire-bye)\n;; run the mesh to execute scheduled wires\n;; time between mesh iterations - 0.02 secs\n;; max mesh iterations allowed - 5\n(run main 0.02 5)\n;; The last two args  may also be passed as mathematical expressions\n;; (run main (/ 1 50) (+ 2 3))\n</code></pre> <pre><code>[info] [2022-03-07 21:42:12.324] [T-18096] [logging.cpp::94] [wire-hi] Hello World!\n[info] [2022-03-07 21:42:12.325] [T-18096] [logging.cpp::94] [wire-bye] Goodbye World\n[info] [2022-03-07 21:42:12.351] [T-18096] [logging.cpp::94] [wire-hi] Hello World!\n[info] [2022-03-07 21:42:12.367] [T-18096] [logging.cpp::94] [wire-hi] Hello World!\n[info] [2022-03-07 21:42:12.397] [T-18096] [logging.cpp::94] [wire-hi] Hello World!\n[info] [2022-03-07 21:42:12.413] [T-18096] [logging.cpp::94] [wire-hi] Hello World!\n</code></pre>"},{"location":"reference/shards/lisp/misc/#schedule","title":"schedule","text":"<p>Queues a wire for execution on a given mesh.</p> <p>Multiple wires can be scheduled on the same <code>mesh</code>. When a mesh is run, all the wires on it are executed.</p> CodeResult <pre><code>;; define a mesh (main)\n(defmesh main)\n;; define a looped wire\n(defloop wire-hi\n    (Msg \"Hello World!\"))\n;; define a non-looped wire\n(defwire wire-bye\n    (Msg \"Goodbye World\"))\n;; schedule both the wires on this mesh\n(schedule main wire-hi)\n(schedule main wire-bye)\n;; run all the scheduled wires on this mesh (main)\n(run main)\n</code></pre> <pre><code>[info] [2022-03-07 21:42:12.324] [T-18096] [logging.cpp::94] [wire-hi] Hello World!\n[info] [2022-03-07 21:42:12.325] [T-18096] [logging.cpp::94] [wire-bye] Goodbye World\n[info] [2022-03-07 21:42:12.351] [T-18096] [logging.cpp::94] [wire-hi] Hello World!\n[info] [2022-03-07 21:42:12.367] [T-18096] [logging.cpp::94] [wire-hi] Hello World!\n[info] [2022-03-07 21:42:12.397] [T-18096] [logging.cpp::94] [wire-hi] Hello World!\n[info] [2022-03-07 21:42:12.413] [T-18096] [logging.cpp::94] [wire-hi] Hello World!\n</code></pre>"},{"location":"reference/shards/lisp/misc/#swap","title":"swap!","text":"<pre><code>(swap! atom f) (swap! atom f x) (swap! atom f x y) (swap! atom f x y &amp; args)\n</code></pre> <p>Atomically swaps the value of atom to be: (apply f current-value-of-atom args). Returns the value that was swapped in.</p> <pre><code>(swap! (atom []) conj \"banana\")\n;;=&gt; [\"banana\"]\n</code></pre>"},{"location":"reference/shards/lisp/misc/#symbol","title":"symbol","text":"<pre><code>(symbol name)\n</code></pre> <p>Convert string name to a symbol.</p> <pre><code>(symbol \"apple\")\n;;=&gt; apple\n</code></pre>"},{"location":"reference/shards/lisp/misc/#throw","title":"throw","text":"<p>Throws Error using input argument as an error message.</p> <pre><code>(throw \"This is an error..\")\n;; Error: \"This is an error..\" Line: 1\n</code></pre>"},{"location":"reference/shards/lisp/misc/#time-ms","title":"time-ms","text":""},{"location":"reference/shards/lisp/misc/#with-meta","title":"with-meta","text":"<pre><code>(with-meta obj m)\n</code></pre> <p>Returns an object of the same type and value as obj, with an object as its metadata.</p> <pre><code>\n</code></pre> <p> </p>"},{"location":"reference/shards/lisp/operators/","title":"Operators","text":"<p>Danger</p> <p>These operators only work on numerical values. Comparing with a string or any other type will produce an error.</p>"},{"location":"reference/shards/lisp/operators/#_1","title":"=","text":"<p>Equality operator. Checks whether two values are equal.</p> CodeResult <pre><code>(= 4 5)\n\n(= \"5\" 5)\n\n(= 5 5)\n\n(= 5 5.0)\n</code></pre> <pre><code>false\n\nError: \"5\" is not a malNumber, line: 3\n\ntrue\n\ntrue\n</code></pre>"},{"location":"reference/shards/lisp/operators/#_2","title":"&lt;","text":"<p>Comparison operator. Checks whether the first value is lesser than the second value.</p> CodeResult <pre><code>(&lt; 4 5)\n\n(&lt; 5 4)\n\n(&lt; 5 5)\n</code></pre> <pre><code>true\n\nfalse\n\nfalse\n</code></pre>"},{"location":"reference/shards/lisp/operators/#_3","title":"&gt;","text":"<p>Comparison operator. Checks whether the first value is greater than the second value.</p> CodeResult <pre><code>(&gt; 4 5)\n\n(&gt; 5 4)\n\n(&gt; 5 5)\n</code></pre> <pre><code>false\n\ntrue\n\nfalse\n</code></pre>"},{"location":"reference/shards/lisp/operators/#_4","title":"&lt;=","text":"<p>Comparison operator. Checks whether the first value is lesser than or equal to the second value.</p> CodeResult <pre><code>(&lt;= 4 5)\n\n(&lt;= 5 4)\n\n(&lt;= 5 5)\n</code></pre> <pre><code>true\n\nfalse\n\ntrue\n</code></pre>"},{"location":"reference/shards/lisp/operators/#_5","title":"&gt;=","text":"<p>Comparison operator. Checks whether the first value is greater than or equal to the second value.</p> CodeResult <pre><code>(&gt;= 4 5)\n\n(&gt;= 5 4)\n\n(&gt;= 5 5)\n</code></pre> <pre><code>false\n\ntrue\n\ntrue\n</code></pre> <p> </p>"},{"location":"reference/shards/lisp/standard-output/","title":"Standard output","text":""},{"location":"reference/shards/lisp/standard-output/#println","title":"println","text":"<p>Prints a variable number of values into the standard output, separated by whitespace. Each collection type follows its own printing rule.</p> CodeOutput <pre><code>(println \"hello\" \"world\")\n\n(println [1 2 3 4])\n(println (vector 1 2 3 4))\n\n(println (list 1 2 3 4))\n\n(println {\"key\" \"value\"})\n(println (hash-map \"key\" \"value\"))\n\n(println {:key1 (vector 1 2 3)} {:key2 (list 1 2 3 4)})\n</code></pre> <pre><code>hello world\n\n[1 2 3 4]\n[1 2 3 4]\n\n(1 2 3 4)\n\n{\"key\" value}\n{\"key\" value}\n\n{:key1 [1 2 3]} {:key2 (1 2 3 4)}\n</code></pre> See also <ul> <li>prn</li> <li>pr-str</li> <li>str</li> </ul>"},{"location":"reference/shards/lisp/standard-output/#prn","title":"prn","text":"<p>Prints a variable number of values into the standard output, separated by whitespace. Each collection type follows its own printing rule. In addition, strings are escaped.</p> CodeOutput <pre><code>(prn \"hello\" \"world\")\n\n(prn [1 2 3 4])\n(prn (vector 1 2 3 4))\n\n(prn (list 1 2 3 4))\n\n(prn {\"key\" \"value\"})\n(prn (hash-map \"key\" \"value\"))\n\n(prn {:key1 (vector 1 2 3)} {:key2 (list 1 2 3 4)})\n</code></pre> <pre><code>\"hello\" \"world\"\n\n[1 2 3 4]\n[1 2 3 4]\n\n(1 2 3 4)\n\n{\"key\" \"value\"}\n{\"key\" \"value\"}\n\n{:key1 [1 2 3]} {:key2 (1 2 3 4)}\n</code></pre> See also <ul> <li>println</li> <li>pr-str</li> <li>str</li> </ul> <p> </p>"},{"location":"reference/shards/lisp/strings/","title":"Strings","text":""},{"location":"reference/shards/lisp/strings/#pr-str","title":"pr-str","text":"<p>Prints a variable number of values into a string, separated by whitespace. Each collection type follows its own printing rule. In addition, strings are escaped.</p> CodeResult <pre><code>(pr-str \"hello\" \"world\")\n\n(pr-str [1 2 3 4])\n(pr-str (vector 1 2 3 4))\n\n(pr-str (list 1 2 3 4))\n\n(pr-str {\"key\" \"value\"})\n(pr-str (hash-map \"key\" \"value\"))\n\n(pr-str {:key1 (vector 1 2 3)} {:key2 (list 1 2 3 4)})\n</code></pre> <pre><code>\"\"hello\" \"world\"\"\n\n\"[1 2 3 4]\"\n\"[1 2 3 4]\"\n\n\"(1 2 3 4)\"\n\n\"{\"key\" \"value\"}\"\n\"{\"key\" \"value\"}\"\n\n\"{:key1 [1 2 3]} {:key2 (1 2 3 4)}\"\n</code></pre> See also <ul> <li>println</li> <li>prn</li> <li>str</li> </ul>"},{"location":"reference/shards/lisp/strings/#slurp","title":"slurp","text":"<p>Reads the content of a file into a string. The path can be absolute or relative to the script.</p> Code <pre><code>(slurp \"file.txt\")\n</code></pre>"},{"location":"reference/shards/lisp/strings/#str","title":"str","text":"<p>Prints a variable number of values into a string, without whitespace separation. Each collection type follows its own printing rule.</p> CodeResult <pre><code>(str \"hello\" \"world\")\n\n(str [1 2 3 4])\n(str (vector 1 2 3 4))\n\n(str (list 1 2 3 4))\n\n(str {\"key\" \"value\"})\n(str (hash-map \"key\" \"value\"))\n\n(str {:key1 (vector 1 2 3)} {:key2 (list 1 2 3 4)})\n</code></pre> <pre><code>\"helloworld\"\n\n\"[1 2 3 4]\"\n\"[1 2 3 4]\"\n\n\"(1 2 3 4)\"\n\n\"{\"key\" value}\"\n\"{\"key\" value}\"\n\n\"{:key1 [1 2 3]}{:key2 (1 2 3 4)}\"\n</code></pre> See also <ul> <li>println</li> <li>pr-str</li> <li>prn</li> </ul> <p> </p>"},{"location":"reference/shards/lisp/values/","title":"Values","text":"<p>Info</p> <p>All these functions have an alias starting with an uppercase character.</p> <p>In other words, <code>(int 42)</code> and <code>(Int 42)</code> are both valid and represent the same value.</p>"},{"location":"reference/shards/lisp/values/#bytes","title":"bytes","text":"<p>Represents the raw bytes value of a string.</p> Code <pre><code>(bytes \"string\")\n</code></pre>"},{"location":"reference/shards/lisp/values/#color","title":"color","text":"<p>Represents an RGBA color where each component is within the [0, 255] range.</p> Code <pre><code>(color 255 255 255 255)\n</code></pre>"},{"location":"reference/shards/lisp/values/#context-var","title":"context-var","text":"<p>Creates a contextual variable with the given name.</p> Note <p>The uppercase alias for this function is <code>(ContextVar)</code>.</p> Code <pre><code>(context-var \"myVar\")\n</code></pre>"},{"location":"reference/shards/lisp/values/#float","title":"float","text":"<p>Represents a floating point number.</p> Code <pre><code>(float 3.14)\n</code></pre>"},{"location":"reference/shards/lisp/values/#float2","title":"float2","text":"<p>Represents a vector of 2 floating point numbers.</p> Code <pre><code>(float2 -1.0 1.0)\n</code></pre>"},{"location":"reference/shards/lisp/values/#float3","title":"float3","text":"<p>Represents a vector of 3 floating point numbers.</p> Code <pre><code>(float3 -1.0 0.0 1.0)\n</code></pre>"},{"location":"reference/shards/lisp/values/#float4","title":"float4","text":"<p>Represents a vector of 4 floating point numbers.</p> Code <pre><code>(float4 1.0 1.0 1.0 0.0)\n</code></pre>"},{"location":"reference/shards/lisp/values/#int","title":"int","text":"<p>Represents a signed integer.</p> Code <pre><code>(int 1)\n</code></pre>"},{"location":"reference/shards/lisp/values/#int2","title":"int2","text":"<p>Represents a vector of 2 signed integers.</p> Code <pre><code>(int2 1 -2)\n</code></pre>"},{"location":"reference/shards/lisp/values/#int3","title":"int3","text":"<p>Represents a vector of 3 signed integers.</p> Code <pre><code>(int3 1 2 3)\n</code></pre>"},{"location":"reference/shards/lisp/values/#int4","title":"int4","text":"<p>Represents a vector of 4 signed integers.</p> Code <pre><code>(int4 1 2 3 4)\n</code></pre>"},{"location":"reference/shards/lisp/values/#string","title":"string","text":"<p>Represents a string.</p> Code <pre><code>(string \"Hello World!\")\n</code></pre> <p> </p>"},{"location":"reference/shards/overview/","title":"Overview","text":"<p>An overview of the different areas covered by Shards.</p>"},{"location":"reference/shards/overview/#math","title":"Math","text":"<p>Various shards exist to allow for the execution of Mathematical calculations.</p> <p>Basic mathematical operations can be done with the following shards:</p> <ul> <li> <p>Math.Add (Addition)</p> </li> <li> <p>Math.Subtract (Subtraction)</p> </li> <li> <p>Math.Multiply (Multiplication)</p> </li> <li> <p>Math.Divide (Division)</p> </li> </ul> <p>Some shards encapsulate a few operations to help reduce code verbosity and promote simpler code. For example, Math.Inc can be used to simply increase a variable's value by 1, removing the need to specify the operand and reassigning the new value back to the variable.</p> <ul> <li> <p>Math.Inc (Increase value by 1)</p> </li> <li> <p>Math.Dec (Decrease value by 1)</p> </li> <li> <p>Math.Lerp (Linearly interpolate between two values)</p> </li> </ul> <p>More complex operations can also be executed with shards such as:</p> <ul> <li> <p>Math.Exp (Exponential)</p> </li> <li> <p>Math.Mod (Modulus)</p> </li> <li> <p>Math.Pow (Power)</p> </li> <li> <p>Math.Sqrt (Square root)</p> </li> </ul>"},{"location":"reference/shards/overview/#strings","title":"Strings","text":"<p>These shards allow you to work with strings and text in Shards.</p> <ul> <li> <p>AppendTo (Append to a string)</p> </li> <li> <p>PrependTo (Prepend to a string)</p> </li> <li> <p>String.Contains (Searches for a string)</p> </li> <li> <p>String.Join (Combines strings)</p> </li> <li> <p>String.ToLower (Converts to lower case)</p> </li> <li> <p>String.ToUpper (Converts to upper case)</p> </li> <li> <p>String.Trim (Trims a string)</p> </li> </ul>"},{"location":"reference/shards/overview/#collections","title":"Collections","text":"<p>Collections are used to group multiple items into a single element. There exists various shards that can be used to facilitate working with collections.</p> <p>Shards to create collections:</p> <ul> <li> <p>Sequence</p> </li> <li> <p>Table</p> </li> </ul> <p>Shards to work with collections:</p> <ul> <li> <p>AppendTo (Append to a collection)</p> </li> <li> <p>PrependTo (Prepend to a collection)</p> </li> <li> <p>Sort (Sort a collection)</p> </li> <li> <p>Take (Extract elements from a collection)</p> </li> <li> <p>Push (Adds new elements to the back of a collection)</p> </li> </ul>"},{"location":"reference/shards/overview/#flow","title":"Flow","text":"<p>Flow shards allow you to manipulate the flow of your Shards program.</p> <p>Shards to run another Wire in-line:</p> <ul> <li> <p>Do (Flow stays on the new Wire if paused)</p> </li> <li> <p>Step (Flow returns to original Wire if paused)</p> </li> </ul> <p>Shards to schedule another Wire:</p> <ul> <li> <p>Detach (Schedules original Wire)</p> </li> <li> <p>Spawn (Schedules a clone)</p> </li> <li> <p>Branch (Schedules Wires on a Submesh)</p> </li> </ul> <p>Shards to control the flow of Wires:</p> <ul> <li> <p>Start</p> </li> <li> <p>Resume</p> </li> <li> <p>Stop</p> </li> </ul> <p>Shards to run code in bulk:</p> <ul> <li> <p>Expand (Creates copies of a Wire)</p> </li> <li> <p>TryMany (Creates clones for each input to try)</p> </li> </ul> <p>For more information on Shards Flow, check out the primer guide here.</p>"},{"location":"reference/shards/overview/#shaders","title":"Shaders","text":"<p>Shader shards allow you to write shader code and create material effects in your program.</p> <p>Shards to aid shader writing: </p> <ul> <li> <p>Shader.Literal</p> </li> <li> <p>Shader.ReadBuffer</p> </li> <li> <p>Shader.SampleTexture</p> </li> <li> <p>Shader.WriteOutput</p> </li> </ul>"},{"location":"reference/shards/overview/#graphics","title":"Graphics","text":"<p>Graphics shards fall under the GFX shards family and are used to create and render objects to your program.</p> <p>The base of the graphic shards:</p> <ul> <li> <p>GFX.Drawable (An object to be drawn)</p> </li> <li> <p>GFX.View (The camera view)</p> </li> <li> <p>GFX.gITF (Loads a model from a file)</p> </li> </ul> <p>Shards to set parameters to your drawables:</p> <ul> <li> <p>GFX.Texture (Converts an image)</p> </li> <li> <p>GFX.Material (Creates a reusable setting)</p> </li> </ul> <p>Shards to control what is or will be drawn:</p> <ul> <li> <p>GFX.DrawQueue (Records <code>Draw</code> commands)</p> </li> <li> <p>GFX.ClearQueue (Clears the <code>Draw</code> queue)</p> </li> <li> <p>GFX.Draw (Adds <code>Drawable</code>s into the RenderQueue)</p> </li> <li> <p>GFX.Feature (Allows for customizable shaders)</p> </li> </ul>"},{"location":"reference/shards/overview/#ui","title":"UI","text":"<p>UI shards allow you to customize and render User Interfaces in Shards.</p> <p>Shards to define the segments in your interface:</p> <ul> <li> <p>UI.CentralPanel</p> </li> <li> <p>UI.TopPanel</p> </li> <li> <p>UI.LeftPanel</p> </li> <li> <p>UI.RightPanel</p> </li> <li> <p>UI.BottomPanel</p> </li> </ul> <p>Shards to organize UI elements on your interface:</p> <ul> <li> <p>UI.Horizontal (Horizontal layout)</p> </li> <li> <p>UI.Group (Groups content together)</p> </li> <li> <p>UI.Grid (Organizes content in a grid)</p> </li> <li> <p>UI.Frame (Groups content in a frame)</p> </li> <li> <p>UI.Indent</p> </li> <li> <p>UI.Space </p> </li> <li> <p>UI.Separator </p> </li> <li> <p>UI.ScrollArea</p> </li> <li> <p>UI.Scope</p> </li> </ul> <p>Shards to add UI elements to your interface:</p> <ul> <li> <p>UI.CodeEditor (Code segment)</p> </li> <li> <p>UI.Image</p> </li> <li> <p>UI.Hyperlink</p> </li> <li> <p>UI.Label (Text)</p> </li> <li> <p>UI.Link</p> </li> <li> <p>UI.MenuBar</p> </li> <li> <p>UI.ProgressBar</p> </li> <li> <p>UI.Spinner (Spinning loading widget)</p> </li> </ul> <p>Shards to capture User Input:</p> <ul> <li> <p>UI.Button</p> </li> <li> <p>UI.Checkbox</p> </li> <li> <p>UI.ColorInput (Color picker)</p> </li> <li> <p>UI.Combo (Drop-down menu)</p> </li> <li> <p>UI.FloatSlider (Numeric slider)</p> </li> <li> <p>UI.FloatInput (Numeric input)</p> </li> <li> <p>UI.RadioButton</p> </li> </ul> <p>Shards to draw graphs:</p> <ul> <li> <p>UI.Plot</p> </li> <li> <p>UI.PlotBar</p> </li> <li> <p>UI.PlotPoints</p> </li> </ul> <p>To customize the User Interface:</p> <ul> <li>UI.Style</li> </ul> <p>Additional UI controls:</p> <ul> <li>UI.Reset</li> </ul>"},{"location":"reference/shards/overview/#inputs","title":"Inputs","text":"<p>Inputs shards allow you to capture mouse and keyboard inputs and bind actions to them.</p> <p>Keyboard Captures:</p> <ul> <li> <p>Inputs.KeyDown</p> </li> <li> <p>Inputs.KeyUp</p> </li> </ul> <p>Mouse Captures:</p> <ul> <li> <p>Inputs.MouseDown</p> </li> <li> <p>Inputs.MousePos</p> </li> <li> <p>Inputs.MouseUp</p> </li> </ul>"},{"location":"reference/shards/overview/#physics","title":"Physics","text":"<p>Physics shards allow you to realize physics concepts in your Shards program.</p> <p>Shards to simulate objects:</p> <ul> <li> <p>Physics.Ball</p> </li> <li> <p>Physics.Cuboid</p> </li> <li> <p>Physics.DynamicBody</p> </li> <li> <p>Physics.KinematicBody</p> </li> <li> <p>Physics.StaticBody</p> </li> </ul> <p>Shards to simulate force:</p> <ul> <li> <p>Physics.Impulse</p> </li> <li> <p>Physics.Simulation</p> </li> </ul> <p>Shards to aid Physics calculations:</p> <ul> <li>Physics.CastRay</li> </ul>"},{"location":"reference/shards/overview/#conversion","title":"Conversion","text":"<p>These shards are used for converting between data types.</p> <p>For type conversions:</p> <ul> <li> <p>ToInt</p> </li> <li> <p>ToFloat</p> </li> <li> <p>ToString</p> </li> <li> <p>StringToBytes and BytesToString</p> </li> </ul> <p>Note</p> <p>ToBytes and FromBytes serializes and deserializes values to a  Shard specific format. Do not use them interchangeably with <code>StringToBytes</code> and <code>BytesToString</code>!</p> <p>For converting between vector types:</p> <ul> <li> <p>ToInt2</p> </li> <li> <p>ToInt3</p> </li> <li> <p>ToFloat2</p> </li> <li> <p>ToFloat3</p> </li> </ul> <p>Note</p> <p>To construct vectors out of components, you can employ the type's keyword.</p> <p>For example, you can use <code>(float2 x y)</code> to create a vector with the values <code>x</code> and <code>y</code>.</p> <p> </p>"},{"location":"reference/shards/shards/","title":"Shards","text":"<p>This section contains a reference for all the shards distributed with Shards.</p>"},{"location":"reference/shards/shards/#how-to-read","title":"How to read","text":"<p>Let's look at the description for <code>String.Join</code> as an example:</p> Name - Description Default Type <code>&lt;input&gt;</code> A sequence of string values that will be joined together. <code>[\u00a0String\u00a0]</code> <code>&lt;output&gt;</code> A string consisting of all the elements of the sequence delimited by the separator. <code>String</code> <code>Separator</code> The string to use as a separator. <code>\"\"</code> <code>String</code> <p>The first thing you will see on every shard page is this table.</p> <p>The first two entries in the table describe what inputs a shard will accept and what kind of values it will output.</p>"},{"location":"reference/shards/shards/#input","title":"&lt;input&gt;","text":"<p>In this case, the <code>String.Join</code> shard accepts a sequence of <code>Strings</code> as an input - written as <code>[String]</code>. A sequence is identified by its enclosing square brackets.</p>"},{"location":"reference/shards/shards/#output","title":"&lt;output&gt;","text":"<p>The output will be a single <code>String</code>.</p>"},{"location":"reference/shards/shards/#parameters","title":"Parameters","text":"<p>After the input and output of the shard, the parameters are listed. The <code>String.Join</code> shard requires a <code>Separator</code> parameter that is a <code>String</code>. When the parameter is not specified, the default value will be <code>\"\"</code>.</p>"},{"location":"reference/shards/shards/#optional-parameters","title":"Optional parameters","text":"Name - Description Default Type <code>Window</code> None or a window variable we wish to use as a relative origin. <code>None</code> <code>Object</code> <p>Occasionally you will see a  icon next to a parameter. This means that the parameter is optional and its value can be left unset.</p> <p>When a variable is not optional and its default value is not <code>None</code>, you should set the parameter on the shard.</p>"},{"location":"reference/shards/shards/#type-descriptions","title":"Type descriptions","text":"<p>The type column shows the expected types for input, output, or parameter:</p> Name Type <code>Values</code> <code>String Float</code> <code>Sequence</code> <code>[ String Float ]</code> <code>Table</code> <code>{ String Float }</code> <code>Variables</code> <code>&amp;String &amp;Float</code> <code>SequenceVariable</code> <code>&amp;[ Float4 ]</code> <p>Multiple different types in a row indicate that any of the types listed are accepted.</p> <p>When placed within <code>[ square brackets ]</code>, this means that a Sequence of those types is accepted.</p> <p>When placed within <code>{ curly brackets }</code>, this means that a Table of those types as values is accepted.</p> <p>When a value is prefixed with an <code>&amp;ampersand</code>, this means that a variable / ContextVar of that type is accepted.</p>"},{"location":"reference/shards/shards/#further-reading","title":"Further reading","text":"<p>See the Types page for more information about types.</p> <p>When placed within <code>{ curly brackets }</code>, this means that a Table of those types as values is accepted.</p> <p>When a value is prefixed with an <code>&amp;ampersand</code>, this means that a variable / ContextVar of that type is accepted.</p> <p> </p>"},{"location":"reference/shards/shards/types/","title":"Types","text":"<p>This section documents all the valid data types that are accepted by various shards either as their input value or as a parameter value. These data types also apply to the output created by any shard.</p> <p>Valid data types for every shard are listed under the <code>Type</code> column of their Parameters, Input, and Output sections (types are enclosed within parentheses and if multiple types apply then they are separated by a space).</p> Compound types <p>While this section lists the simple (or primitive) data types, you can combine these to create compound data types. For example, combining <code>Int</code>, <code>String</code>, and <code>Seq</code>, can give you a sequence of sequences <code>[ [ Any ] ]</code>, a sequence of integers and strings <code>[ Int String ]</code>), and so on.</p> Why types? <p>Types are helpful as they reduce errors in programming. They are also very useful in visual programming as type-matching can be used to reduce the dropdown options when prompting a user on what shard to use next (depending on which shard's input type matches with the current shard's output type).</p> <p>Note</p> <p>While all the following types are available internally to various shards, only a few are currently accessible in the Shards scripting environment. Consequently, only these types have keywords/aliases.</p>"},{"location":"reference/shards/shards/types/#any","title":"Any","text":"<p>Type Any indicates that all data types are allowed.</p> <p>For example, Any as the allowed data type for input and <code>:Value</code> parameter of shard <code>(All)</code> means that <code>(All)</code> accepts and compares across all data types.</p> <pre><code>[1]\n(All :Value [(Any)])\n</code></pre> <p><code>(All)</code> compares the input and<code>:Value</code> parameter values and returns <code>true</code> only if both the value and data type of these entities is equal/same.</p> CodeOutput <pre><code>[4 5 6] (All :Value [4 5 6])\n(Log)   ;; value and type match =&gt; true\n\n\"I'm a string\" &gt;= .var1\n\"I'm a string\" &gt;= .var2\n.var1 (All :Value .var2)\n(Log)   ;; value and type match =&gt; true\n\n\"I'm a string\" &gt;= .var3\n\"I'm a different string\" &gt;= .var4\n.var3 (All :Value .var4)\n(Log)   ;; value mismatch =&gt; false\n\n(Float 4.0) &gt;= .var5\n(Int 4) &gt;= .var6\n.var5 (All :Value .var6)\n(Log)   ;; type mismatch =&gt; false\n</code></pre> <pre><code>[info] [2022-07-22 13:05:25.848] [T-18072] [logging.cpp::55] [mywire] true\n[info] [2022-07-22 13:05:25.861] [T-18072] [logging.cpp::55] [mywire] true\n[info] [2022-07-22 13:05:25.862] [T-18072] [logging.cpp::55] [mywire] false\n[info] [2022-07-22 13:05:25.864] [T-18072] [logging.cpp::55] [mywire] false\n</code></pre>"},{"location":"reference/shards/shards/types/#sequence","title":"Sequence","text":"<p>Type Sequence is a collection of values that can be accessed directly via indexes (since items are indexed by contiguous integers).</p> <p>It is also called a vector or an array. A Sequence's items are accessible by index. Example of a Sequence type would be: <code>[43 6 1]</code>.</p>"},{"location":"reference/shards/shards/types/#audio","title":"Audio","text":"<p>Type Audio is uncompressed audio data.</p> <p>Examples of shards that use this type are <code>(Audio.Oscillator)</code>, <code>(Audio.ReadFile)</code>, and <code>(Audio.WriteFile)</code> all of which generate Audio type data as their output.</p> Supported formats <p>Shards supports the audio formats WAV, MP3, OGG, and FLAC.</p>"},{"location":"reference/shards/shards/types/#bool","title":"Bool","text":"<p>Type Bool allows only two values - <code>true</code> or <code>false</code>. In that sense, it can be thought of as a special case of an Enum data type.</p> <p>Consider the shard <code>(Is)</code>. This shard compares its input and the value in the <code>:Value</code> parameter for equality and returns <code>true</code> if values are equal, otherwise <code>false</code> if values are not equal. Examples:</p> CodeOutput <pre><code>100 (Is :Value (* 10 10))\n(Log)   ;; Is equal =&gt; true\n\n[20] (Is :Value 20)\n(Log)   ;; Is not equal =&gt; false\n</code></pre> <pre><code>[info] [2022-07-22 18:38:24.383] [T-25360] [logging.cpp::55] [mywire] true\n[info] [2022-07-22 18:38:24.395] [T-25360] [logging.cpp::55] [mywire] false\n</code></pre>"},{"location":"reference/shards/shards/types/#bytes","title":"Bytes","text":"<p>Type Bytes represents binary data.</p> <p>Note</p> <p>Has keyword <code>bytes</code> and alias <code>Bytes</code>.</p> <p>A byte is made up of 8 bits (for example, <code>10111010</code>) and a Bytes type is an sequence of such bytes: <code>[11110001 10110111 10000111]</code></p> Bits and Bytes <p>Bits are how data is stored in a computer at the level of electrical circuits. A bit can have only two values (1 or 0, representing the circuit is on or off) - hence the name binary data. A group of eight bits make a byte: <code>11111111</code>, <code>10101010</code>, etc. Since a bit can have only two values, a Byte can represent a total of 256 numbers (2^8): 0 to 255.</p> <p>Shards like <code>(ToBytes)</code>,  <code>(BytesToString)</code>, <code>(BytesToInts)</code>, etc, all use the type Bytes either for their input or their output.</p>"},{"location":"reference/shards/shards/types/#color","title":"Color","text":"<p>Type Color represents an RGBA color format and is constructed from four unsigned 8 bit integers (one each for the R, G, B, and A values).</p> <p>Note</p> <p>Has keyword <code>color</code> and alias <code>Color</code>.</p> <p>Each of the R, G, B, and A values range from 0 to 255. R, G, and B stand for red, blue, and green components of the color. A represents the alpha channel property (how opaqe a pixel is - 0 is fully transparent, 255 is fully opaque).</p> <p>The shard <code>(ToColor)</code> converts its input into a Color type.</p> CodeOutput <pre><code>(int4 255 10 10 257) (ToColor)\n(Log)    ;; if input &gt; 255, 256 is subtracted from it =&gt; 255, 10, 10, 1\n\n[23 45 56 78] (ToColor)\n(Log)   ;; input in range 0-255 so =&gt; 23, 45, 56, 78\n\n\"Hello\" (ToColor)\n(Log)   ;; non-numeric input so =&gt; 0, 0, 0, 0\n</code></pre> <pre><code>[info] [2022-07-26 19:08:24.520] [T-24408] [logging.cpp::55] [mywire] 255, 10, 10, 1\n[info] [2022-07-26 19:08:24.533] [T-24408] [logging.cpp::55] [mywire] 23, 45, 56, 78\n[info] [2022-07-26 19:08:24.534] [T-24408] [logging.cpp::55] [mywire] 0, 0, 0, 0\n</code></pre>"},{"location":"reference/shards/shards/types/#contextvar","title":"ContextVar","text":"<p>Type ContextVar represents a contextual variable (i.e., a variable that is in scope for the shard processing this data).</p> <p>Note</p> <p>Has keyword <code>context-var</code> and alias <code>ContextVar</code>.</p> <p>The shard <code>(Math.Inc)</code> accepts only ContextVar type numeric data (i.e., a variable that holds numeric data) into its <code>:Value</code> parameter, and increments it by 1.</p> CodeOutput <pre><code>11 &gt;= .intvar                   ;; .intvar is of type `ContextVar`\n(Math.Inc .intvar)\n.intvar (Log)                   ;; =&gt; 12\n\n(Float2 4.5 5.7) &gt;= .floatvar   ;; .floatvar is of type `ContextVar`\n(Math.Inc .floatvar)\n.floatvar (Log)                 ;; =&gt; (5.5, 6.7)\n</code></pre> <pre><code>[info] [2022-07-26 19:30:22.837] [T-27800] [logging.cpp::55] [mywire] 12\n[info] [2022-07-26 19:30:22.843] [T-27800] [logging.cpp::55] [mywire] (5.5, 6.7)\n</code></pre>"},{"location":"reference/shards/shards/types/#enum","title":"Enum","text":"<p>Enum stands for enumerated data type.</p> <p>Note</p> <p>Has keyword <code>enum</code> and alias <code>Enum</code>.</p> <p>The value that you pass to an enumerated variable can only take certain 'states' or named constant values.</p> <p>For an overview of all enums and valid values check the Enums page</p> <p>For example, in <code>(Math.Mean)</code> the value for <code>:Kind</code> parameter needs to be of type Mean.</p> <pre><code>(Math.Mean :Kind Mean)\n</code></pre> <p><code>(Math.Mean)</code> computes the mean of a sequence of floating-point numbers. But there are three kinds of means - Arithmetic mean, Geometric mean, and Harmonic mean.</p> <p>So the parameter <code>:Kind</code> is defined as an enum variable with these three fixed states : <code>:Kind = {Arithmtic mean, Geometric mean, Harmonic mean}</code></p> <p>And hence <code>:Kind</code> expects a value that matches one of its possible states. In other words the value you pass in for <code>:Kind</code> needs to be an enumerated data type.</p> <p>In simple terms it just means that you pass in one of the allowed named constant values. Anything else will fail validation.</p> CodeOutput <pre><code>[2.0 10.0]\n(Math.Mean :Kind Mean.Arithmetic)\n(Log)   ;; AM =&gt; 6\n\n[2.0 10.0]\n(Math.Mean :Kind Mean.Geometric)\n(Log)   ;; GM =&gt; 4.47214\n\n[2.0 10.0]\n(Math.Mean :Kind Mean.Harmonic)\n(Log)   ;; HM =&gt; 3.33333\n\n[2.0 10.0]\n(Math.Mean\n;; AM is default, anything else will throw error\n    ;; :Kind 123\n    )\n(Log)   ;; AM =&gt; 6\n</code></pre> <pre><code>[info] [2022-07-22 15:35:00.868] [T-15316] [logging.cpp::55] [mywire] 6\n[info] [2022-07-22 15:35:00.881] [T-15316] [logging.cpp::55] [mywire] 4.47214\n[info] [2022-07-22 15:35:00.882] [T-15316] [logging.cpp::55] [mywire] 3.33333\n[info] [2022-07-22 15:35:00.883] [T-15316] [logging.cpp::55] [mywire] 6\n</code></pre>"},{"location":"reference/shards/shards/types/#float","title":"Float","text":"<p>Type Float defines a 64-bit signed floating point number.</p> <p>Note</p> <p>Has keyword <code>float</code> and alias <code>Float</code>.</p> <p>Floating point means it has the capability to store a decimal point and hence supports decimal numbers.</p> <p>64 bits of memory allows this data type to support a very large range of positive and negative decimal numbers (16 significant decimal digits and an exponent range of \u2212383 to +384).</p> <p>A Float value looks like this: <code>(float 2.53)</code>. It may also be represented without the keyword <code>float</code>, with just the floating-point value: <code>2.53</code>.</p> <p><code>(Math.Add)</code> is an example of a shard that uses this data type for its input, output, and <code>:Operand</code> parameter.</p> CodeOutput <pre><code>(float 2.4) (Math.Add (float 1.43))\n(Log)   ;; float output =&gt; 3.83\n\n2.4 (Math.Add 1.43)\n(Log)   ;; float output =&gt; 3.83\n</code></pre> <pre><code>[info] [2022-07-22 22:06:32.856] [T-20204] [logging.cpp::55] [mywire] 3.83\n[info] [2022-07-22 22:06:32.873] [T-20204] [logging.cpp::55] [mywire] 3.83\n</code></pre>"},{"location":"reference/shards/shards/types/#float2","title":"Float2","text":"<p>Type Float2 defines a vector of two Float type numbers.</p> <p>Note</p> <p>Has keyword <code>float2</code> and alias <code>Float2</code>.</p> <p>A vector can be thought of as a group or list of items that are considered together for processing.</p> <p>A Float2 type value looks like this: <code>(float2 3.4 -5.0)</code>.</p> <p><code>(Math.Add)</code> is an example of a shard that uses this data type for its input, output, and <code>:Operand</code> parameter.</p> CodeOutput <pre><code>(float2 4.1 5.0) (Math.Add (float2 6.3 9.2))\n(Log)   ;; float2 output =&gt; (10.4, 14.2)\n</code></pre> <pre><code>[info] [2022-07-22 22:10:00.688] [T-24616] [logging.cpp::55] [mywire] (10.4, 14.2)\n</code></pre>"},{"location":"reference/shards/shards/types/#float3","title":"Float3","text":"<p>Type Float3 defines a vector of three 32-bit signed floating point numbers.</p> <p>Note</p> <p>Has keyword <code>float3</code> and alias <code>Float3</code>.</p> <p>Floating point means it has the capability to store a decimal point and hence supports decimal numbers.</p> <p>32 bits of memory allows this data type to support a large range of positive and negative decimal numbers (7 significant decimal digits and an exponent range of \u2212101 to +90).</p> <p>A Float3 type value looks like this: <code>(float3 2.9 -4.23 7.83)</code>.</p> <p><code>(Math.Add)</code> is an example of a shard that uses this data type for its input, output, and <code>:Operand</code> parameter.</p> CodeOutput <pre><code>(float3 1.2 3.4 5.6) (Math.Add (float3 6.5 4.3 2.1))\n(Log)   ;; float3 output =&gt; (7.7, 7.7, 7.7)\n</code></pre> <pre><code>[info] [2022-07-22 22:19:36.923] [T-16128] [logging.cpp::55] [mywire] (7.7, 7.7, 7.7)\n</code></pre>"},{"location":"reference/shards/shards/types/#float4","title":"Float4","text":"<p>Type Float4 is like type Float3 but is a vector of four 32-bit signed floating point numbers instead.</p> <p>Note</p> <p>Has keyword <code>float4</code> and alias <code>Float4</code>.</p> <p>A Float4 type value looks like this: <code>(float4 -8.84 38.2 4.7 0.4)</code>.</p> <p><code>(Math.Add)</code> is an example of a shard that uses this data type for its input, output, and <code>:Operand</code> parameter.</p> CodeOutput <pre><code>(float4 3.1 6.4 9.2 4.6)\n(Math.Add (float4 6.8 3.5 0.9 5.3))\n(Log)   ;; Int4 output =&gt; (9.9, 9.9, 9.9, 9.9)\n</code></pre> <pre><code>[info] [2022-07-22 22:23:24.076] [T-25152] [logging.cpp::55] [mywire] (9.9, 9.9, 10.1, 9.9)\n</code></pre>"},{"location":"reference/shards/shards/types/#image","title":"Image","text":"<p>Type Image is uncompressed image data.</p> <p>A shard that uses this type is <code>(StripAlpha)</code>. This takes an Image type input, strips out its alpha (transparency) channel, and outputs an Image type (transformed image).</p> Supported formats <p>Shards supports the image formats PNG and SVG.</p>"},{"location":"reference/shards/shards/types/#int","title":"Int","text":"<p>Type Int defines a 64-bit signed integer.</p> <p>Note</p> <p>Has keyword <code>int</code> and alias <code>Int</code>.</p> <p>64 bits of memory allows this data type to store integer values ranging from -9,223,372,036,854,775,808 to +9,223,372,036,854,775,807 (no decimals).</p> <p>An Int value looks like this: <code>(int 2)</code>. It may also be represented without the keyword <code>int</code>, with just the integer value: <code>2</code>.</p> <p><code>(Math.Add)</code> is an example of a shard that uses this data type for its input, output, and <code>:Operand</code> parameter.</p> CodeOutput <pre><code>(int 3) (Math.Add (int 2))\n(Log)   ;; int output =&gt; 5\n\n3 (Math.Add 2)\n(Log)   ;; int output =&gt; 5\n</code></pre> <pre><code>[info] [2022-07-22 21:20:18.771] [T-4568] [logging.cpp::55] [mywire] 5\n[info] [2022-07-22 21:20:18.782] [T-4568] [logging.cpp::55] [mywire] 5\n</code></pre>"},{"location":"reference/shards/shards/types/#int2","title":"Int2","text":"<p>Type Int2 defines a vector of two Int type numbers.</p> <p>Note</p> <p>Has keyword <code>int2</code> and alias <code>Int2</code>.</p> <p>A vector can be thought of as a group or list of items that are considered together for processing.</p> <p>An Int2 type value looks like this: <code>(int2 3 -5)</code>.</p> <p><code>(Math.Add)</code> is an example of a shard that uses this data type for its input, output, and <code>:Operand</code> parameter.</p> CodeOutput <pre><code>(int2 4 5) (Math.Add (int2 6 9))\n(Log)   ;; int2 output =&gt; (10, 14)\n</code></pre> <pre><code>[info] [2022-07-22 21:22:26.381] [T-17748] [logging.cpp::55] [mywire] (10, 14)\n</code></pre>"},{"location":"reference/shards/shards/types/#int3","title":"Int3","text":"<p>Type Int3 defines a vector of three 32-bit signed integers.</p> <p>Note</p> <p>Has keyword <code>int3</code> and alias <code>Int3</code>.</p> <p>32 bits of memory for each number allows this data type to store integer values ranging from -2147483648 to +2147483647 (no decimals).</p> <p>An Int3 type value looks like this: <code>(int3 2 4 -4)</code>.</p> <p><code>(Math.Add)</code> is an example of a shard that uses this data type for its input, output, and <code>:Operand</code> parameter.</p> CodeOutput <pre><code>(int3 1 10 99) (Math.Add (int3 99 90 1))\n(Log)   ;; int3 output =&gt; (100, 100, 100)\n</code></pre> <pre><code>[info] [2022-07-22 21:24:38.132] [T-25580] [logging.cpp::55] [mywire] (100, 100, 100)\n</code></pre>"},{"location":"reference/shards/shards/types/#int4","title":"Int4","text":"<p>Type Int4 is like type Int3 but is a vector of four 32-bit signed integers instead.</p> <p>Note</p> <p>Has keyword <code>int4</code> and alias <code>Int4</code>.</p> <p>An Int4 type value looks like this: <code>(int4 1 -4 0 3)</code>.</p> <p><code>(Math.Add)</code> is an example of a shard that uses this data type for its input, output, and <code>:Operand</code> parameter.</p> CodeOutput <pre><code>(int4 3 6 9 4)\n(Math.Add (int4 6 3 0 5))\n(Log)   ;; int4 output =&gt; (9, 9, 9, 9)\n</code></pre> <pre><code>[info] [2022-07-22 21:27:58.115] [T-20884] [logging.cpp::55] [mywire] (9, 9, 9, 9)\n</code></pre>"},{"location":"reference/shards/shards/types/#int8","title":"Int8","text":"<p>Type Int8 defines a vector of eight 16-bit signed integers.</p> <p>16 bits of memory for each number allows this data type to store integer values ranging from \u221232,768 to +32,767 (no decimals).</p> <p>The shard <code>(Math.Add)</code> accepts Int8 as input and as its <code>:Operand</code>. The shard adds these up outputs the sum as another vector of 8 integers or Int8 data type.</p>"},{"location":"reference/shards/shards/types/#int16","title":"Int16","text":"<p>Type Int16 defines a vector of sixteen 8-bit signed integers.</p> <p>8 bits of memory for each number allows this data type to store integer values ranging from \u2212128 to +127 (no decimals).</p> <p>The shard <code>(Math.Add)</code> accepts Int16 as input and as its <code>:Operand</code>. The shard adds these up outputs the sum as another vector of 16 integers or Int16 data type.</p>"},{"location":"reference/shards/shards/types/#none","title":"None","text":"<p>Type None indicates that no data type is expected. This implies that no value is expected.</p> <p>For example, None as one of the valid data types for <code>:Max</code> parameter in shard <code>(RandomInt)</code> means that setting a value for this parameter is not mandatory.</p> <pre><code>(RandomInt :Max [(None) (Int) (ContextVar [(Int)])])\n</code></pre> <p><code>(RandomInt)</code> generates a random integer and the <code>:Max</code> parameter is the upper limit (not inclusive) of the value that can be generated. So it makes sense to have None as one of the valid types for this <code>:Max</code> parameter for cases when you do not want an upper limit on the random integer (though in this case the system will inherently set the upper limit to the maximum value a 64-bit signed integer can hold: 9,223,372,036,854,775,807).</p> CodeOutput <pre><code>(RandomInt 8)\n(Log)   ;; max int that can be generated is 7\n\n(RandomInt)\n(Log)   ;; now upper limit subject to max capacity of a 64-bit signed integer\n</code></pre> <pre><code>[info] [2022-07-22 13:45:03.282] [T-19992] [logging.cpp::55] [mywire] 4\n[info] [2022-07-22 13:45:03.293] [T-19992] [logging.cpp::55] [mywire] 311828859\n</code></pre>"},{"location":"reference/shards/shards/types/#object","title":"Object","text":"<p>Type Object is an opaque data type in Shards.</p> <p>Opacity in a data type means that the structure of this kind of data is not defined in an interface and is visible only to shards that use this type. What this also implies is that the internal structure of this data type will vary from shard to shard.</p> <p>For example, the <code>:Socket</code> parameter object of <code>(WS.ReadString)</code> is different from the output object of <code>(GFX.DrawQueue)</code>, even though both are of type Object.</p>"},{"location":"reference/shards/shards/types/#path","title":"Path","text":"<p>Type Path is String type data that is expected to contain a valid path (your operating system or local machine) for loading resources like script files, images, audio files etc.</p> <p>Note</p> <p>Has keyword <code>path</code> and alias <code>Path</code>.</p> <p>A valid Path type data string would look like this: <code>\"../../external/sample-models/Avocado.glb\"</code></p> <p>Note</p> <p>For shards this type is the same as String type as far as type validations are concerned (when you execute your script Shards first checks the types before running your code). However, if the path-string passed is invalid, malformed, or missing the resource to be loaded, the shard will complain with an error message at runtime (i.e., when your code actually runs).</p> <p>A shard that uses this type is <code>(Process.Run)</code>. This shard takes a Path type in its <code>:Executable</code> parameter.</p>"},{"location":"reference/shards/shards/types/#set","title":"Set","text":"<p>Type Set is a collection of unique values.</p> <p>It's different from other collections like Seq and Sequence, both of which can contain non-unique or duplicate items.</p> <p>An example of a Set type data would be <code>(22 3 378 4)</code>.</p>"},{"location":"reference/shards/shards/types/#seq","title":"Seq","text":"<p>Type Seq is a collection of values that can be accessed sequentially (i.e., they're iterable).</p> <p>Note</p> <p>Has keyword <code>seq</code>.</p> <p>Also called a sequence. An example of Seq type would be <code>[7 2 54 42]</code>.</p> <p>The shard <code>(Take)</code> works on this type. This shard can access Seq elements by their position.</p> CodeOutput <pre><code>[7 2 54 42] (Take 2)\n(Log)   ;; print the 2nd element =&gt; 54\n</code></pre> <pre><code>[info] [2022-07-26 22:24:48.918] [T-20928] [logging.cpp::55] [mywire] 54\n</code></pre>"},{"location":"reference/shards/shards/types/#shard","title":"Shard","text":"<p>The type Shard (also called ShardRef) represents a shard being passed as data.</p> <p>This type is an important aspect of the homoiconicity feature (i.e., code/data interchangeability) in Shards.</p> <p>Note</p> <p>What's a <code>shard</code>?</p> <p>The shard <code>(ForEach)</code> expects a value with the type Shard for its <code>:Apply</code> parameter (the other option being a sequence of Shard type values, i.e., a <code>Wire</code> type).</p> <p><code>(ForEach)</code> then applies this shard (or sequence of shards) on its input to transform it into its output.</p>"},{"location":"reference/shards/shards/types/#shard_1","title":"[ Shard ]","text":"<p>When more that one shard is accepted it is indicated as a sequence of shards, any description can be turned into a sequence of shards by wrapping it with <code>(-&gt; )</code>, for example:</p> <pre><code>(GiveMeShard :ParameterName (-&gt;\n            (Shard1 ...)\n            (Shard2 ...)\n            (Shard3 ...)))\n</code></pre>"},{"location":"reference/shards/shards/types/#string","title":"String","text":"<p>Type String represents string data (any data enclosed within double quotes).</p> <p>Note</p> <p>Has keyword <code>string</code> and alias <code>String</code>.</p> <p>A String value looks like this: <code>(string \"Hello @Tom!\")</code>. It may also be represented without the keyword <code>string</code>, with just the data within double quotes: <code>\"Hello @Tom!\"</code>.</p> <p>An example of a shard that processes String type data is <code>(String.ToUpper)</code>. This shard takes a String and converts it into its upper case version.</p> CodeOutput <pre><code>(string \"Hello World!\") (String.ToUpper)\n(Log)   ;; upper case version =&gt; HELLO WORLD!\n\n\"Bye Universe!\" (String.ToUpper)\n(Log)   ;; upper case version =&gt; BYE UNIVERSE!\n</code></pre> <pre><code>[info] [2022-07-26 19:38:14.813] [T-18168] [logging.cpp::55] [mywire] Bytes: 0x20440058720 size: 11\n</code></pre>"},{"location":"reference/shards/shards/types/#table","title":"Table","text":"<p>Type Table is a collection of key/value pairs.</p> <p>Its also known as map, data dictionary, or associative array. An example of a Table type would be: <code>{:key1 \"Hello\" :key2 \"World\"}</code>.</p> CodeOutput <pre><code>{:k1 123} &gt;= .tabvar    ;; .tabvar is type `Table` now\n.tabvar (ExpectTable)\n(Log)                   ;; `ExpectTable` outputs `Table` type  =&gt;   {k1: 123}\n</code></pre> <pre><code>[info] [2022-07-26 22:46:17.194] [T-26104] [logging.cpp::55] [mywire] {k1: 123}\n</code></pre>"},{"location":"reference/shards/shards/types/#wire","title":"Wire","text":"<p>Type Wire represents a wire being passed as data.</p> <p>Note</p> <p>Has keyword <code>Wire</code>.</p> <p>A Wire type thus consists of a sequence of shards (which make up the wire), their shared state (memory) context, name of the wire, and other properties that enable operations on the wire like scheduling it on a mesh, starting/stopping/pausing the wire, etc.</p> <p>Note</p> <p>What's a <code>wire</code>?</p> <p>For example, the shard <code>(Stop)</code> accepts Wire type data in its <code>:Wire</code> parameter and stops that wire's execution if its currently running.</p> <p> </p>"},{"location":"reference/shards/shards/Animation/Duration/","title":"Animation.Duration","text":"Name - Description Default Type <code>&lt;input&gt;</code> The animation to get the duration of. <code>[{Path: [String] Frames: [{Time: Float Value: Any none: Any}]}]</code> <code>&lt;output&gt;</code> The total length of the animation in seconds. <code>Float</code> <p>Outputs the total duration of the animation in seconds.</p> <p> </p>"},{"location":"reference/shards/shards/Animation/Interpolated/","title":"Animation.Interpolated","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value to interpolate. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code> <code>&lt;output&gt;</code> The interpolated value. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code> <code>Duration</code> Duration of interpolation <code>none</code> <code>Float</code><code>Var(Float)</code> <p>Whenever the input value is changed, this shard will interpolate between the old value and the new value over the duration of the animation and output the result.</p> <p> </p>"},{"location":"reference/shards/shards/Animation/Play/","title":"Animation.Play","text":"Name - Description Default Type <code>&lt;input&gt;</code> The current time of the animation (in seconds) to play <code>Float</code> <code>&lt;output&gt;</code> The interpolated animation data at each frame of the animation <code>[{Path: [String] Value: Any}]</code> <code>Animation</code> The animation to play. <code>none</code> <code>Var([{Path: [String] Frames: [{Time: Float Value: Any none: Any}]}])</code><code>[{Path: [String] Frames: [{Time: Float Value: Any none: Any}]}]</code> <p>Evaluates and interpolates the animation of the glTF model specified in the Animation parameter. The output of this shard is applied to the glTF model to play animations.</p> <p> </p>"},{"location":"reference/shards/shards/Animation/Timer/","title":"Animation.Timer","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input of this shard is ignored. <code>&lt;output&gt;</code> Outputs the current time of the animation timer <code>Float</code> <code>Animation</code> The Animation object to take the duration from. <code>none</code> <code>Var([{Path: [String] Frames: [{Time: Float Value: Any none: Any}]}])</code><code>[{Path: [String] Frames: [{Time: Float Value: Any none: Any}]}]</code> <code>Duration</code> The duration of the timer, the timer will loop or stop after reaching this value. <code>none</code> <code>Float</code><code>Var(Float)</code> <code>Looped</code> If set to true, the timer will loop after reaching the target time <code>true</code> <code>Bool</code><code>Var(Bool)</code> <code>Rate</code> The playback rate <code>1</code> <code>Float</code><code>Var(Float)</code> <code>Offset</code> Timer offset <code>none</code> <code>Float</code><code>Var(Float)</code> <code>Action</code> The shards to execute whenever the shard reached the specified duration. <code>none</code> <code>Shard</code><code>[Shard]</code> <code>Variable</code> The variable to store the current time of the timer in. <code>none</code> <code>Var(Float)</code> <p>This shard sets a duration (either taken form the animation object in the Animation Parameter or specified in the Duration parameter) and executes the shards specified in the Action parameter whenever that duration is reached.</p> <p> </p>"},{"location":"reference/shards/shards/Argon2id/Hash/","title":"Argon2id.Hash","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>String</code> <code>&lt;output&gt;</code> <code>String</code> <code>MemoryCost</code> The amount of memory to use in KiB. Default is 8192 (8 MB). <code>8192</code> <code>Int</code> <code>TimeCost</code> The number of iterations to perform. Default is 4. <code>4</code> <code>Int</code> <code>Parallelism</code> The degree of parallelism to use. Default is 1. <code>1</code> <code>Int</code> <p>Hashes a password using the Argon2id algorithm.</p> <p> </p>"},{"location":"reference/shards/shards/Argon2id/Verify/","title":"Argon2id.Verify","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>String</code> <code>&lt;output&gt;</code> <code>Bool</code> <code>Hash</code> The Argon2id hash to verify against. <code>none</code> <code>String</code><code>Var(String)</code> <p>Verifies a password against an Argon2id hash.</p> <p> </p>"},{"location":"reference/shards/shards/Assert/Is/","title":"Assert.Is","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input can be of any type. <code>Any</code> <code>&lt;output&gt;</code> The output will be the input (passthrough). <code>Any</code> <code>Value</code> The value to test against for equality. <code>none</code> <code>Any</code> <code>Break</code> If we should trigger a debug breakpoint on failure. <code>false</code> <code>Bool</code> <p>This assertion is used to check whether the input is equal to a given value.</p>"},{"location":"reference/shards/shards/Assert/Is/#details","title":"Details","text":"<p>If the assertion is satisfied (i.e., the input is equal to or same as the <code>:Value</code> parameter) the program will is allowed to continue (control passes to the next shard), irrespective of the <code>:Break</code> parameter .</p> <p>However, if the assertion fails, the program - aborts with an error dump if the <code>:Break</code> parameter is set to <code>true</code> - logs an assertion validation error but continues running (control passes to the next wire scheduled on the mesh).</p> <p>Since this shard can precisely control the conditions under which a program is allowed to run or is to be aborted, it's effective for writing (inline) unit test cases with it.</p> <p>See also</p> <ul> <li><code>Assert.IsAlmost</code></li> <li><code>Assert.IsNot</code></li> </ul>"},{"location":"reference/shards/shards/Assert/Is/#examples","title":"Examples","text":"CodeOutput <pre><code>;; :Break = `true`, assertion true\n;; =&gt; log no errors and don't abort program\n8\n(Assert.Is\n ;:Value\n 8\n ;:Break\n true)\n</code></pre> <pre><code>\n</code></pre> CodeOutput <pre><code>;; :Break = `true`, assertion false\n;; =&gt; abort the program\n7\n(Maybe\n (Assert.Is\n  ;:Value\n  8\n  ;:Break\n  ;; uncomment next line to abort program on run\n  ;true\n  ))\n</code></pre> <pre><code>\n</code></pre> CodeOutput <pre><code>;; :Break = `false`, assertion true\n;; =&gt; log no errors and don't abort program\n8\n(Assert.Is\n ;:Value\n 8\n ;:Break\n false)\n</code></pre> <pre><code>\n</code></pre> CodeOutput <pre><code>;; :Break = `false`, assertion false\n;; =&gt; log assertion error but don't abort program\n7\n(Maybe\n (Assert.Is\n  ;:Value\n  8\n  ;:Break\n  false))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/Assert/IsAlmost/","title":"Assert.IsAlmost","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input can be of any number type or a sequence of such types. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Int</code><code>Int2</code><code>Int3</code><code>Int4</code><code>Int8</code><code>Int16</code><code>[Any]</code> <code>&lt;output&gt;</code> The output will be the input (passthrough). <code>Any</code> <code>Value</code> The value to test against for almost equality. <code>none</code> <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Int</code><code>Int2</code><code>Int3</code><code>Int4</code><code>Int8</code><code>Int16</code><code>[Any]</code><code>Var(Float Float2 Float3 Float4 Int Int2 Int3 Int4 Int8 Int16 [Any])</code> <code>Abort</code> If we should abort the process on failure. <code>false</code> <code>Bool</code> <code>Threshold</code> The smallest difference to be considered equal. Should be greater than zero. <code>1.19209e-07</code> <code>Float</code><code>Int</code> <p>This assertion is used to check whether the input is almost equal to a given value.</p>"},{"location":"reference/shards/shards/Assert/IsAlmost/#details","title":"Details","text":"<p>For non-decimal values (e.g. <code>Int</code>), <code>:Epsilon</code> is ignored and this shard acts as <code>Assert.Is</code>.</p> <p>See also</p> <ul> <li><code>Assert.Is</code></li> <li><code>Assert.IsNot</code></li> </ul>"},{"location":"reference/shards/shards/Assert/IsAlmost/#examples","title":"Examples","text":"CodeOutput <pre><code>;; :Break = `true`, assertion true\n;; =&gt; log no errors and don't abort program\n8\n(Assert.IsAlmost\n ;:Value\n 7\n ;:Break\n true\n ;:Epsilon\n 1)\n</code></pre> <pre><code>\n</code></pre> CodeOutput <pre><code>;; :Break = `true`, assertion false\n;; =&gt; abort the program\n7.0\n(Maybe\n (Assert.IsAlmost\n  ;:Value\n  8.0\n  ;:Break\n  ;; uncomment next line to abort program on run\n  ;true\n  ))\n</code></pre> <pre><code>\n</code></pre> CodeOutput <pre><code>;; :Break = `false`, assertion true\n;; =&gt; log no errors and don't abort program\n8.0\n(Assert.IsAlmost\n ;:Value\n 8.0\n ;:Break\n false)\n</code></pre> <pre><code>\n</code></pre> CodeOutput <pre><code>;; :Break = `false`, assertion false\n;; =&gt; log assertion error but don't abort program\n8.0\n(Maybe\n (Assert.IsAlmost\n  ;:Value\n  7.999\n  ;:Break\n  false\n  ;:Epsilon\n  0.0001))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/Assert/IsNot/","title":"Assert.IsNot","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input can be of any type. <code>Any</code> <code>&lt;output&gt;</code> The output will be the input (passthrough). <code>Any</code> <code>Value</code> The value to test against for equality. <code>none</code> <code>Any</code> <code>Break</code> If we should trigger a debug breakpoint on failure. <code>false</code> <code>Bool</code> <p>This assertion is used to check whether the input is different from a given value.</p>"},{"location":"reference/shards/shards/Assert/IsNot/#details","title":"Details","text":"<p>In this shard it's the inequality that's asserted. This means the assertion is considered successful if input to this shard does not match the <code>:Value</code> parameter of this shard.</p> <p>The rest of behaviour of this shard (including the impact of the value of the <code>:Break</code> parameter) is identical to <code>Assert.Is</code>.</p> <p>Just like <code>Assert.Is</code>, this shard too can be used for writing (inline) unit test cases.</p> <p>See also</p> <ul> <li><code>Assert.Is</code></li> <li><code>Assert.IsAlmost</code></li> </ul>"},{"location":"reference/shards/shards/Assert/IsNot/#examples","title":"Examples","text":"CodeOutput <pre><code>;; :Break = `true`, assertion true\n;; =&gt; log no errors and don't abort program\n8\n(Assert.IsNot\n ;:Value\n 16\n ;:Break\n true)\n</code></pre> <pre><code>\n</code></pre> CodeOutput <pre><code>;; :Break = `true`, assertion false\n;; =&gt; abort the program\n8\n(Maybe\n (Assert.IsNot\n  ;:Value\n  8\n  ;:Break\n  ;; uncomment next line to abort program on run\n  ;true\n  ))\n</code></pre> <pre><code>\n</code></pre> CodeOutput <pre><code>;; :Break = `false`, assertion true\n;; =&gt; log no errors and don't abort program\n8\n(Assert.IsNot\n ;:Value\n 16\n ;:Break\n false)\n</code></pre> <pre><code>\n</code></pre> CodeOutput <pre><code>;; :Break = `false`, assertion false\n;; =&gt; log assertion error but don't abort program\n8\n(Maybe\n (Assert.IsNot\n  ;:Value\n  8\n  ;:Break\n  false))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/Assert/IsStatic/","title":"Assert.IsStatic","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>&lt;output&gt;</code> <code>Any</code> <code>Value</code> Any value to check for being static (non-var) <code>none</code> <code>Any</code> <p>Asserts that a value is static at run-time</p> <p> </p>"},{"location":"reference/shards/shards/Assert/IsVariable/","title":"Assert.IsVariable","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>&lt;output&gt;</code> <code>Any</code> <code>Value</code> Any value to check for being a variable <code>none</code> <code>Any</code> <p>Asserts that a value is a variable at run-time</p> <p> </p>"},{"location":"reference/shards/shards/Audio/Channel/","title":"Audio.Channel","text":"Name - Description Default Type <code>&lt;input&gt;</code> Any input type is accepted. The input will be passed to the code specified in the Shards parameter. <code>Any</code> <code>&lt;output&gt;</code> Outputs the output of the code specified in the Shards parameter. <code>Any</code> <code>InputBus</code> The an integer representing the input bus number. 0 represents the audio device's Analog-to-Digital Converter (ADC). <code>0</code> <code>Int</code> <code>InputChannels</code> A list of input channel indices to be used as input for the code specified in the Shards parameter. <code>none</code> <code>[Int]</code> <code>OutputBus</code> The output bus number. 0 represents the audio device's Digital-to-Analog Converter (DAC). <code>0</code> <code>Int</code> <code>OutputChannels</code> The list of output channel indices where the processed audio output from the code in the Shards parameter will be written. <code>none</code> <code>[Int]</code> <code>Volume</code> A float value representing the volume level of this channel. Accepts values between 0.0 (mute) and 1.0 (full volume). <code>0.7</code> <code>Float</code><code>Var(Float)</code> <code>Shards</code> The code that will process the audio data. <code>none</code> <code>Shard</code><code>[Shard]</code> <p>Experimental/unstable</p> <p>This API is experimental and might produce unexpected results or crash.</p> <p>This shard represents an audio channel in the mesh. It manages the routing and processing of audio data between input and output buses, applies volume control, and executes custom audio processing shards. Audio.Channel works in conjunction with Audio.Device to handle audio processing within the shards system.</p> <p> </p>"},{"location":"reference/shards/shards/Audio/Cones/","title":"Audio.Cones","text":"Name - Description Default Type <code>&lt;input&gt;</code> A float3 vector with each element representing the respective cone properties: innerAngleInRadians (the angle within which the sound is at full volume), outerAngleInRadians (the angle at which the sound starts to attenuate), and outerGain (the volume multiplier for sounds outside the outer angle). <code>Float3</code> <code>&lt;output&gt;</code> Outputs the input value, passed through unchanged. <code>Float3</code> <code>Sound</code> The sound object to manipulate <code>none</code> <code>Object</code><code>Var(Object)</code> <p>The Audio.Cones shard sets the sound cone properties for a 3D sound object. Sound cones are used to create directional audio effects, where the volume of the sound changes based on the angle between the sound's direction and the listener's position. It takes the Sound object, created by Audio.Sound that is specified in the Sound parameter, and sets its cone properties using the float3 vector(a vector with 3 float elements) provided as input. The first float value in the float3 vector represents the inner angle in radians, the second float value represents the outer angle in radians, and the third float value represents the outer gain. This shard is particularly useful for creating directional audio effects in 3D environments and is typically used in conjunction with Audio.Engine, Audio.Sound, Audio.Position, and Audio.Direction. Do note that the Spatialized parameter on Audio.Sound should be set to true when initializing a sound object meant for 3D audio.</p> <p> </p>"},{"location":"reference/shards/shards/Audio/Device/","title":"Audio.Device","text":"Name - Description Default Type <code>&lt;input&gt;</code> Any input type is accepted. The input value will pass through unchanged. <code>Any</code> <code>&lt;output&gt;</code> Outputs the input value, passed through unchanged. <code>Any</code> <code>InputChannels</code> Sets the number of audio input channels for the device. <code>none</code> <code>Int</code> <code>OutputChannels</code> Sets the number of audio output channels for the device. <code>none</code> <code>Int</code> <code>SampleRate</code> Specifies the sample rate of the audio device, in Hertz (Hz). A value of 0 means the device's default sample rate will be used. <code>none</code> <code>Int</code> <code>BufferSize</code> Specifies the size of the audio buffer used by the device. Note: This may be interpreted as a maximum value on some platforms. A value of 0 means the device's default buffer size will be used. <code>none</code> <code>Int</code> <p>Experimental/unstable</p> <p>This API is experimental and might produce unexpected results or crash.</p> <p>This shard initializes an audio device in the mesh. This device sets up the audio context, manages input and output channels, and handles the audio processing loop which is necessary for processing and playing audio in the shards system. In essence, the Audio.Device provides the underlying audio system, and can be used with other shards like Audio.ReadFile and Audio.Channel to process and play audio.</p> <p> </p>"},{"location":"reference/shards/shards/Audio/Direction/","title":"Audio.Direction","text":"Name - Description Default Type <code>&lt;input&gt;</code> A float3 vector representing the new direction (x, y, z components) of the sound. This vector should be normalized (have a magnitude of 1). <code>Float3</code> <code>&lt;output&gt;</code> Outputs the input value, passed through unchanged. <code>Float3</code> <code>Sound</code> The sound object to manipulate <code>none</code> <code>Object</code><code>Var(Object)</code> <p>The Audio.Direction shard sets the direction of a sound object in 3D audio space. It takes the Sound object, created by Audio.Sound that is specified in the Sound parameter, and sets its direction to the 3D vector with x y z coordinates, represented as a float3 vector(a vector with 3 float elements), that is provided as input. The x coordinate represents its direction along the x-axis, the y coordinate represents its direction along the y-axis, and the z coordinate represents its direction along the z-axis. The float3 vector input should also be normalized so that it has a magnitude of 1. This shard is particularly useful for creating directional audio effects in 3D environments and is typically used in conjunction with Audio.Engine, Audio.Sound, and Audio.Position to manage 3D audio positioning and orientation. Do note that the Spatialized parameter on Audio.Sound should be set to true when initializing a sound object meant for 3D audio.</p> <p> </p>"},{"location":"reference/shards/shards/Audio/Engine/","title":"Audio.Engine","text":"Name - Description Default Type <code>&lt;input&gt;</code> Any input type is accepted. The input value will pass through unchanged. <code>Any</code> <code>&lt;output&gt;</code> Outputs the input value, passed through unchanged. <code>Any</code> <p>This shard initializes an audio engine in the mesh, and this enables audio playback and processing capabilites. It manages resources, handles audio mixing, and provides spatial audio functionality. The Audio.Engine is used in conjunction with other audio shards like Audio.Sound, Audio.Play and Audio.Pause to create a complete audio system to process and play audio.</p> <p> </p>"},{"location":"reference/shards/shards/Audio/Oscillator/","title":"Audio.Oscillator","text":"Name - Description Default Type <code>&lt;input&gt;</code> Accepts a float value representing the frequency of the waveform in Hertz (Hz). <code>Float</code> <code>&lt;output&gt;</code> Outputs audio data as an Audio chunk, containing the generated waveform samples. <code>Audio</code> <code>Type</code> The waveform type to oscillate (Sine, Square, Triangle or Sawtooth). <code>Waveform::Sine</code> <code>Waveform</code> <code>Amplitude</code> A float representing the waveform amplitude. <code>0.4</code> <code>Float</code><code>Var(Float)</code> <code>Channels</code> An int representing the number of desired output audio channels. <code>2</code> <code>Int</code> <code>SampleRate</code> An int representing desired output sampling rate. Ignored if this shard is inside an Audio.Channel. <code>44100</code> <code>Int</code> <code>Samples</code> An int representing desired number of samples in the output. Ignored if this shard is inside an Audio.Channel. <code>1024</code> <code>Int</code> <p>Experimental/unstable</p> <p>This API is experimental and might produce unexpected results or crash.</p> <p>This shard generates audio waveforms. It can produce various types of waveforms such as sine, square, triangle, and sawtooth. The Oscillator is typically used within an Audio.Channel and can be controlled by other shards to create dynamic audio effects or synthesize sounds.</p> <p> </p>"},{"location":"reference/shards/shards/Audio/Pan/","title":"Audio.Pan","text":"Name - Description Default Type <code>&lt;input&gt;</code> A float value representing the new pan position. -1.0 is full left, 0.0 is center, and 1.0 is full right. Values outside of this range will be clamped to the nearest extreme. <code>Float</code> <code>&lt;output&gt;</code> Outputs the input value, passed through unchanged. <code>Float</code> <code>Sound</code> The sound object to manipulate <code>none</code> <code>Object</code><code>Var(Object)</code> <p>The Audio.Pan shard adjusts the stereo panning of a sound object in the mesh, allowing for dynamic control over the spatial positioning of individual sound objects during playback. It takes the Sound object, created by Audio.Sound that is specified in the Sound parameter, and sets the pan position to the float value provided as input (-1.0 being full left and 1.0 being full right). It's typically used in conjunction with Audio.Engine, Audio.Sound, Audio.Start, and other audio shards to manage audio playback and create spatial audio effects.</p> <p> </p>"},{"location":"reference/shards/shards/Audio/Pause/","title":"Audio.Pause","text":"Name - Description Default Type <code>&lt;input&gt;</code> Accepts a Sound object created by the Audio.Sound shard. <code>Object</code> <code>&lt;output&gt;</code> Outputs the same Sound object that was input, allowing for further manipulation. <code>Object</code> <p>The Audio.Pause shard pauses playback of a sound object in the mesh. It takes a Sound object which was created by Audio.Sound and played by Audio.Start and pauses its playback. This shard is typically used in conjunction with Audio.Engine, Audio.Sound, Audio.Start, and Audio.Stop to manage audio playback and control.</p> <p> </p>"},{"location":"reference/shards/shards/Audio/Pitch/","title":"Audio.Pitch","text":"Name - Description Default Type <code>&lt;input&gt;</code> A float value representing the new pitch. 1.0 being the original pitch. <code>Float</code> <code>&lt;output&gt;</code> Outputs the input value, passed through unchanged. <code>Float</code> <code>Sound</code> The sound object to manipulate <code>none</code> <code>Object</code><code>Var(Object)</code> <p>The Audio.Pitch shard adjusts the pitch of a sound object in the mesh, thus allowing for dynamic control over the pitch of individual sound objects during playback. It takes the Sound object, created by Audio.Sound that is specified in the Sound parameter, and sets the pitch to the float value provided as input. 1.0 being the original pitch, values greater than 1.0 will increase the pitch, while values between 0 and 1.0 will decrease the pitch. 0.5, for example, will lower the pitch by one octave, while 2.0 will raise it by one octave. It's typically used in conjunction with Audio.Engine, Audio.Sound, Audio.Start, and other audio shards to manage audio playback and create pitch-based effects.</p> <p> </p>"},{"location":"reference/shards/shards/Audio/Position/","title":"Audio.Position","text":"Name - Description Default Type <code>&lt;input&gt;</code> A float3 vector representing the new 3D position (x, y, z coordinates) of the sound. <code>Float3</code> <code>&lt;output&gt;</code> Outputs the input value, passed through unchanged. <code>Float</code> <code>Sound</code> The sound object to manipulate <code>none</code> <code>Object</code><code>Var(Object)</code> <p>The Audio.Position shard sets the 3D position of a sound object in the audio space. It takes the Sound object, created by Audio.Sound, that is specified in the Sound parameter, and sets its position to the 3D coordinates represented as a float3 vector(a vector with 3 float elements) provided as input. This shard is particularly useful for creating spatial audio effects and is typically used in conjunction with Audio.Engine, Audio.Sound, and Audio.Direction to manage 3D audio positioning and orientation. Do note that the Spatialized parameter on Audio.Sound should be set to true when initializing a sound object meant for 3D audio.</p> <p> </p>"},{"location":"reference/shards/shards/Audio/ReadFile/","title":"Audio.ReadFile","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input of this shard is ignored. <code>&lt;output&gt;</code> Outputs audio data as an Audio chunk, containing the sample rate, number of samples, number of channels, and the audio samples. <code>Audio</code> <code>Source</code> The audio file or bytes to read from (wav,ogg,mp3,flac). <code>none</code> <code>String</code><code>Var(String)</code><code>Bytes</code><code>Var(Bytes)</code> <code>Channels</code> An int representing the number of desired output audio channels. <code>none</code> <code>Int</code> <code>SampleRate</code> An int representing the desired output sampling rate. <code>none</code> <code>Int</code> <code>Samples</code> An int representing the desired number of samples in the output. <code>none</code> <code>Int</code> <code>Looped</code> A boolean value indicating whether the audio file should be played in loop or should stop the wire when it ends. <code>none</code> <code>Bool</code> <code>From</code> A float value representing the starting time in seconds. <code>none</code> <code>Float</code><code>Var(Float)</code> <code>To</code> A float value representing the end time in seconds. <code>none</code> <code>Float</code><code>Var(Float)</code> <p>Experimental/unstable</p> <p>This API is experimental and might produce unexpected results or crash.</p> <p>This shard reads audio data from a file or memory buffer. It supports various audio formats including wav, ogg, mp3, and flac. Audio.ReadFile is designed to be used in conjunction with Audio.Device and Audio.Channel to process and play audio in the shards system. It provides the audio data that can be further processed or played through the audio device.</p> <p> </p>"},{"location":"reference/shards/shards/Audio/Sound/","title":"Audio.Sound","text":"Name - Description Default Type <code>&lt;input&gt;</code> Accepts a string representing the path to the audio file or asset to be loaded. <code>String</code> <code>&lt;output&gt;</code> Outputs a Sound object that can be used with other audio shards. <code>Object</code> <code>Spatialized</code> If the sound should have 3D audio capabilities. <code>none</code> <code>Bool</code> <p>The Audio.Sound shard initializes a sound object in the mesh. It loads an audio file and prepares it for playback. This shard is used in conjunction with other audio shards like Audio.Start, Audio.Pause, and Audio.Stop to control audio playback. It supports spatialization for 3D audio positioning and can be used with various audio effect shards for further processing. Do note that the Spatialized parameter on Audio.Sound should be set to true when initializing a sound object meant for 3D audio (if it is to be manipulated by Audio.Direction, Audio.Position, Audio.Velocity or Audio.Cones).</p> <p> </p>"},{"location":"reference/shards/shards/Audio/Start/","title":"Audio.Start","text":"Name - Description Default Type <code>&lt;input&gt;</code> Accepts a Sound object created by the Audio.Sound shard. <code>Object</code> <code>&lt;output&gt;</code> Outputs the same Sound object that was input, allowing for further manipulation. <code>Object</code> <code>Looped</code> If the sound should be played in loop or should stop the wire when it ends and play only once. <code>none</code> <code>Bool</code> <p>The Audio.Start shard begins playback of a sound object in the mesh. It takes a Sound object created by Audio.Sound and starts playing it and also allows control over whether the sound should loop or play once. It's typically used in conjunction with Audio.Engine, Audio.Sound, Audio.Pause, and Audio.Stop to manage audio playback.</p> <p> </p>"},{"location":"reference/shards/shards/Audio/Stop/","title":"Audio.Stop","text":"Name - Description Default Type <code>&lt;input&gt;</code> Accepts a Sound object created by the Audio.Sound shard. <code>Object</code> <code>&lt;output&gt;</code> Outputs the same Sound object that was input, allowing for further manipulation. <code>Object</code> <p>The Audio.Stop shard stops playback of a sound object in the mesh. It takes a Sound object which was created by Audio.Sound and played with Audio.Start and stops its playback, resetting the playback position to the beginning. This shard is typically used in conjunction with Audio.Engine, Audio.Sound, Audio.Start, and Audio.Pause to manage audio playback and control.</p> <p> </p>"},{"location":"reference/shards/shards/Audio/Velocity/","title":"Audio.Velocity","text":"Name - Description Default Type <code>&lt;input&gt;</code> A float3 vector representing the new velocity (each float element representing the velocity along the x, y, and z axes respectively) of the sound in units per second. <code>Float3</code> <code>&lt;output&gt;</code> Outputs the input value, passed through unchanged. <code>Float3</code> <code>Sound</code> The sound object to manipulate <code>none</code> <code>Object</code><code>Var(Object)</code> <p>The Audio.Velocity shard sets the velocity of a 3D sound object in the audio space. It takes the Sound object, created by Audio.Sound that is specified in the Sound parameter, and sets its velocity to the 3D vector, represented as a float3 vector(a vector with 3 float elements), provided as input. The first element in the float3 vector represents the velocity along the x-axis, the second element represents the velocity along the y-axis, and the third element represents the velocity along the z-axis. This shard is particularly useful for creating doppler effects and is typically used in conjunction with Audio.Engine, Audio.Sound, Audio.Position, and Audio.Direction to manage 3D audio positioning and movement. Do note that the Spatialized parameter on Audio.Sound should be set to true when initializing a sound object meant for 3D audio.</p> <p> </p>"},{"location":"reference/shards/shards/Audio/Volume/","title":"Audio.Volume","text":"Name - Description Default Type <code>&lt;input&gt;</code> A float value representing the new volume level. 0.0 is silence, 1.0 is full volume, and values above 1.0 can be used for amplification. <code>Float</code> <code>&lt;output&gt;</code> Outputs the input value, passed through unchanged. <code>Float</code> <code>Sound</code> The sound object to manipulate <code>none</code> <code>Object</code><code>Var(Object)</code> <p>The Audio.Volume shard adjusts the volume of a sound object in the mesh, thus allowing for the dynamic control over the volume of individual sound objects during playback. It takes the Sound object, created by Audio.Sound specified in the Sound parameter, and sets the volume to the float value provided as input. It's typically used in conjunction with Audio.Engine, Audio.Sound, Audio.Start, and other audio shards to manage audio playback and control.</p> <p> </p>"},{"location":"reference/shards/shards/Audio/WriteFile/","title":"Audio.WriteFile","text":"Name - Description Default Type <code>&lt;input&gt;</code> Accepts audio data as an Audio chunk, containing the sample rate, number of samples, number of channels, and the audio samples. <code>Audio</code> <code>&lt;output&gt;</code> Outputs the same audio data as the input, allowing for further processing in the audio chain. <code>Audio</code> <code>File</code> The audio file to read from (wav,ogg,mp3,flac). <code>none</code> <code>String</code><code>Var(String)</code> <code>Channels</code> An int representing the number of desired output audio channels. <code>2</code> <code>Int</code> <code>SampleRate</code> An int representing the desired number of samples in the output. <code>44100</code> <code>Int</code> <p>Experimental/unstable</p> <p>This API is experimental and might produce unexpected results or crash.</p> <p>This shard writes audio data to WAV format file.</p> <p> </p>"},{"location":"reference/shards/shards/BigInt/Abs/","title":"BigInt.Abs","text":"Name - Description Default Type <code>&lt;input&gt;</code> Big integer represented as bytes. <code>Bytes</code> <code>&lt;output&gt;</code> The resulting big integer with an absolute value, represented as bytes. <code>Bytes</code> <p>This shard computes the absolute value of a big integer.</p>"},{"location":"reference/shards/shards/BigInt/Abs/#examples","title":"Examples","text":"CodeOutput <pre><code>1 (BigInt) = .expected\n\n-1 (BigInt)\n(BigInt.Abs)\n(BigInt.Is .expected) (Assert.Is true true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/BigInt/Add/","title":"BigInt.Add","text":"Name - Description Default Type <code>&lt;input&gt;</code> Any valid big integer(s) represented as bytes supported by this operation. <code>Bytes</code><code>[Bytes]</code> <code>&lt;output&gt;</code> Outputs the result of the operation as a big integer or sequence of big integers represented as bytes. <code>Bytes</code><code>[Bytes]</code> <code>Operand</code> The big integer to add to the input as bytes. <code>0</code> <code>Var(Bytes)</code><code>Var([Bytes])</code> <p>This shard adds the input big integer to the big integer specified in the Operand parameter and outputs the result.</p>"},{"location":"reference/shards/shards/BigInt/Add/#examples","title":"Examples","text":"CodeOutput <pre><code>7 (BigInt) = .expected\n4 (BigInt) = .operand\n\n3 (BigInt)\n(BigInt.Add\n ;:Operand\n .operand)\n(BigInt.Is .expected) (Assert.Is true true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/BigInt/And/","title":"BigInt.And","text":"Name - Description Default Type <code>&lt;input&gt;</code> Any valid big integer(s) represented as bytes supported by this operation. <code>Bytes</code><code>[Bytes]</code> <code>&lt;output&gt;</code> Outputs the result of the AND operation as a big integer represented as bytes. <code>Bytes</code><code>[Bytes]</code> <code>Operand</code> The second big integer to perform the AND operation with. <code>0</code> <code>Var(Bytes)</code><code>Var([Bytes])</code> <p>This shard performs a bitwise AND operation on the input big integer with the big integer specified in the Operand parameter and outputs the result. A bitwise AND operation is a binary operation that compares each bit of the binary representations of two numbers and outputs 1 if the bits are 1 and 0 otherwise. The resulting number is a big integer representation of the 1s and 0s concatenated.</p>"},{"location":"reference/shards/shards/BigInt/And/#examples","title":"Examples","text":"CodeOutput <pre><code>2 (BigInt) = .expected\n3 (BigInt) = .operand\n\n6 (BigInt)\n(BigInt.And\n ;:Operand\n .operand)\n(BigInt.Is .expected) (Assert.Is true true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/BigInt/Divide/","title":"BigInt.Divide","text":"Name - Description Default Type <code>&lt;input&gt;</code> Any valid big integer(s) represented as bytes supported by this operation. <code>Bytes</code><code>[Bytes]</code> <code>&lt;output&gt;</code> Outputs the result of the operation as a big integer or sequence of big integers represented as bytes. <code>Bytes</code><code>[Bytes]</code> <code>Operand</code> The big integer to divide the big integer input with. <code>0</code> <code>Var(Bytes)</code><code>Var([Bytes])</code> <p>This shard divides the input big integer by the big integer specified in the Operand parameter and outputs the result.</p>"},{"location":"reference/shards/shards/BigInt/Divide/#examples","title":"Examples","text":"CodeOutput <pre><code>4 (BigInt) = .expected\n2 (BigInt) = .operand\n\n8 (BigInt)\n(BigInt.Divide\n ;:Operand\n .operand)\n(BigInt.Is .expected) (Assert.Is true true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/BigInt/FromFloat/","title":"BigInt.FromFloat","text":"Name - Description Default Type <code>&lt;input&gt;</code> Floating point number. <code>Float</code> <code>&lt;output&gt;</code> Big integer represented as bytes. <code>Bytes</code> <code>ShiftedBy</code> The shift is of the decimal point, i.e. of powers of ten, and is to the left if n is negative or to the right if n is positive. <code>0</code> <code>Int</code> <p>This shard converts a floating point number to a big integer.</p>"},{"location":"reference/shards/shards/BigInt/FromFloat/#examples","title":"Examples","text":"CodeOutput <pre><code>42 (BigInt) = .expected\n\n42.1 (BigInt.FromFloat)\n(BigInt.Is .expected) (Assert.Is true true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/BigInt/Is/","title":"BigInt.Is","text":"Name - Description Default Type <code>&lt;input&gt;</code> Big integer represented as bytes. <code>Bytes</code> <code>&lt;output&gt;</code> Outputs true if the input big integer is equal to the big integer specified in the Operand parameter and false otherwise. <code>Bool</code> <code>Operand</code> The big integer to compare against represented as bytes. <code>none</code> <code>Var(Bytes)</code> <p>This shard checks if the input big integer is equal to the operand.</p>"},{"location":"reference/shards/shards/BigInt/Is/#examples","title":"Examples","text":"CodeOutput <pre><code>11 (BigInt) = .expected\n\n11 (BigInt)\n(BigInt.Is\n ;:Operand\n .expected)\n(Assert.Is true true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/BigInt/IsLess/","title":"BigInt.IsLess","text":"Name - Description Default Type <code>&lt;input&gt;</code> Big integer represented as bytes. <code>Bytes</code> <code>&lt;output&gt;</code> Outputs true if the input big integer is less than the big integer specified in the Operand parameter and false otherwise. <code>Bool</code> <code>Operand</code> The big integer to compare against represented as bytes. <code>none</code> <code>Var(Bytes)</code> <p>This shard checks if the input big integer is less than the operand.</p>"},{"location":"reference/shards/shards/BigInt/IsLess/#examples","title":"Examples","text":"CodeOutput <pre><code>11 (BigInt) = .expected\n\n9 (BigInt)\n(BigInt.IsLess\n ;:Operand\n .expected)\n(Assert.Is true true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/BigInt/IsLessEqual/","title":"BigInt.IsLessEqual","text":"Name - Description Default Type <code>&lt;input&gt;</code> Big integer represented as bytes. <code>Bytes</code> <code>&lt;output&gt;</code> Outputs true if the input big integer is less than or equal to the big integer specified in the Operand parameter and false otherwise. <code>Bool</code> <code>Operand</code> The big integer to compare against represented as bytes. <code>none</code> <code>Var(Bytes)</code> <p>This shard checks if the input big integer is less than or equal to the operand.</p>"},{"location":"reference/shards/shards/BigInt/IsLessEqual/#examples","title":"Examples","text":"CodeOutput <pre><code>11 (BigInt) = .expected\n\n9 (BigInt)\n(BigInt.IsLessEqual\n ;:Operand\n .expected)\n(Assert.Is true true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/BigInt/IsMore/","title":"BigInt.IsMore","text":"Name - Description Default Type <code>&lt;input&gt;</code> Big integer represented as bytes. <code>Bytes</code> <code>&lt;output&gt;</code> Outputs true if the input big integer is greater than the big integer specified in the Operand parameter and false otherwise. <code>Bool</code> <code>Operand</code> The big integer to compare against represented as bytes. <code>none</code> <code>Var(Bytes)</code> <p>This shard checks if the input big integer is greater than the operand.</p>"},{"location":"reference/shards/shards/BigInt/IsMore/#examples","title":"Examples","text":"CodeOutput <pre><code>11 (BigInt) = .expected\n\n12 (BigInt)\n(BigInt.IsMore\n ;:Operand\n .expected)\n(Assert.Is true true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/BigInt/IsMoreEqual/","title":"BigInt.IsMoreEqual","text":"Name - Description Default Type <code>&lt;input&gt;</code> Big integer represented as bytes. <code>Bytes</code> <code>&lt;output&gt;</code> Outputs true if the input big integer is greater than or equal to the big integer specified in the Operand parameter and false otherwise. <code>Bool</code> <code>Operand</code> The big integer to compare against represented as bytes. <code>none</code> <code>Var(Bytes)</code> <p>This shard checks if the input big integer is greater than or equal to the operand.</p>"},{"location":"reference/shards/shards/BigInt/IsMoreEqual/#examples","title":"Examples","text":"CodeOutput <pre><code>11 (BigInt) = .expected\n\n12 (BigInt)\n(BigInt.IsMoreEqual\n ;:Operand\n .expected)\n(Assert.Is true true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/BigInt/IsNot/","title":"BigInt.IsNot","text":"Name - Description Default Type <code>&lt;input&gt;</code> Big integer represented as bytes. <code>Bytes</code> <code>&lt;output&gt;</code> Outputs true if the input big integer is not equal to the big integer specified in the Operand parameter and false otherwise. <code>Bool</code> <code>Operand</code> The big integer to compare against represented as bytes. <code>none</code> <code>Var(Bytes)</code> <p>This shard checks if the input big integer is not equal to the operand.</p>"},{"location":"reference/shards/shards/BigInt/IsNot/#examples","title":"Examples","text":"CodeOutput <pre><code>11 (BigInt) = .expected\n\n9 (BigInt)\n(BigInt.IsNot\n ;:Operand\n .expected)\n(Assert.Is true true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/BigInt/Max/","title":"BigInt.Max","text":"Name - Description Default Type <code>&lt;input&gt;</code> Any valid big integer(s) represented as bytes supported by this operation. <code>Bytes</code><code>[Bytes]</code> <code>&lt;output&gt;</code> Outputs the larger of the two input big integers. <code>Bytes</code><code>[Bytes]</code> <code>Operand</code> The big integer to compare the input with. <code>0</code> <code>Var(Bytes)</code><code>Var([Bytes])</code> <p>This shard compares the input big integer with the big integer specified in the Operand parameter and outputs the larger of the two.</p>"},{"location":"reference/shards/shards/BigInt/Max/#examples","title":"Examples","text":"CodeOutput <pre><code>7 (BigInt) = .expected\n4 (BigInt) = .operand\n\n7 (BigInt)\n(BigInt.Max\n ;:Operand\n .operand)\n(BigInt.Is .expected) (Assert.Is true true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/BigInt/Min/","title":"BigInt.Min","text":"Name - Description Default Type <code>&lt;input&gt;</code> Any valid big integer(s) represented as bytes supported by this operation. <code>Bytes</code><code>[Bytes]</code> <code>&lt;output&gt;</code> Outputs the smaller of the two input big integers. <code>Bytes</code><code>[Bytes]</code> <code>Operand</code> The big integer to compare the input with. <code>0</code> <code>Var(Bytes)</code><code>Var([Bytes])</code> <p>This shard compares the input big integer with the big integer specified in the Operand parameter and outputs the smaller of the two.</p>"},{"location":"reference/shards/shards/BigInt/Min/#examples","title":"Examples","text":"CodeOutput <pre><code>4 (BigInt) = .expected\n4 (BigInt) = .operand\n\n7 (BigInt)\n(BigInt.Min\n ;:Operand\n .operand)\n(BigInt.Is .expected) (Assert.Is true true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/BigInt/Mod/","title":"BigInt.Mod","text":"Name - Description Default Type <code>&lt;input&gt;</code> Any valid big integer(s) represented as bytes supported by this operation. <code>Bytes</code><code>[Bytes]</code> <code>&lt;output&gt;</code> Outputs the result of the operation as a big integer or sequence of big integers represented as bytes. <code>Bytes</code><code>[Bytes]</code> <code>Operand</code> The big integer to compute the modulus with respect to. <code>0</code> <code>Var(Bytes)</code><code>Var([Bytes])</code> <p>This shard computes the modulus of the input big integer with respect to the big integer specified in the Operand parameter and outputs the result.</p>"},{"location":"reference/shards/shards/BigInt/Mod/#examples","title":"Examples","text":"CodeOutput <pre><code>3 (BigInt) = .expected\n10 (BigInt) = .operand\n\n13 (BigInt)\n(BigInt.Mod\n ;:Operand\n .operand)\n(BigInt.Is .expected) (Assert.Is true true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/BigInt/Multiply/","title":"BigInt.Multiply","text":"Name - Description Default Type <code>&lt;input&gt;</code> Any valid big integer(s) represented as bytes supported by this operation. <code>Bytes</code><code>[Bytes]</code> <code>&lt;output&gt;</code> Outputs the result of the operation as a big integer or sequence of big integers represented as bytes. <code>Bytes</code><code>[Bytes]</code> <code>Operand</code> The big integer to multiply the big integer input with. <code>0</code> <code>Var(Bytes)</code><code>Var([Bytes])</code> <p>This shard multiplies the input big integer with the big integer specified in the Operand parameter and outputs the result.</p>"},{"location":"reference/shards/shards/BigInt/Multiply/#examples","title":"Examples","text":"CodeOutput <pre><code>24 (BigInt) = .expected\n3 (BigInt) = .operand\n\n8 (BigInt)\n(BigInt.Multiply\n ;:Operand\n .operand)\n(BigInt.Is .expected) (Assert.Is true true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/BigInt/Or/","title":"BigInt.Or","text":"Name - Description Default Type <code>&lt;input&gt;</code> Any valid big integer(s) represented as bytes supported by this operation. <code>Bytes</code><code>[Bytes]</code> <code>&lt;output&gt;</code> Outputs the result of the OR operation as a big integer represented as bytes. <code>Bytes</code><code>[Bytes]</code> <code>Operand</code> The second big integer to perform the OR operation with. <code>0</code> <code>Var(Bytes)</code><code>Var([Bytes])</code> <p>This shard performs a bitwise OR operation on the input big integer with the big integer specified in the Operand parameter and outputs the result. A bitwise OR operation is a binary operation that compares each bit of the binary representations of two numbers and outputs 1 if the either or both bits are 1 and 0 if both bits are 0. The resulting number is a big integer representation of the 1s and 0s concatenated.</p>"},{"location":"reference/shards/shards/BigInt/Or/#examples","title":"Examples","text":"CodeOutput <pre><code>7 (BigInt) = .expected\n3 (BigInt) = .operand\n\n6 (BigInt)\n(BigInt.Or\n ;:Operand\n .operand)\n(BigInt.Is .expected) (Assert.Is true true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/BigInt/Pow/","title":"BigInt.Pow","text":"Name - Description Default Type <code>&lt;input&gt;</code> Big integer represented as bytes. <code>Bytes</code> <code>&lt;output&gt;</code> Outputs the BigInt result of the operation as bytes. <code>Bytes</code> <code>Operand</code> The power to which the input big integer will be raised. This must be a non-negative integer. <code>none</code> <code>Int</code><code>Var(Int)</code> <p>This shard raises the input big integer to the power of the exponent specified in the  Operand parameter.</p>"},{"location":"reference/shards/shards/BigInt/Pow/#examples","title":"Examples","text":"CodeOutput <pre><code>8 (BigInt) = .expected\n\n2 (BigInt)\n(BigInt.Pow\n ;:Operand\n 3)\n(BigInt.Is .expected) (Assert.Is true true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/BigInt/Shift/","title":"BigInt.Shift","text":"Name - Description Default Type <code>&lt;input&gt;</code> Big integer represented as bytes. <code>Bytes</code> <code>&lt;output&gt;</code> Outputs the big integer with its decimal point shifted represented as bytes. <code>Bytes</code> <code>By</code> The number of decimal places to shift the input big integer by. A positive number shifts the decimal point to the right, while a negative number shifts it to the left. <code>0</code> <code>Int</code><code>Var(Int)</code> <p>This shard shifts the decimal point of the input big integer by the amount specified in the By parameter.</p>"},{"location":"reference/shards/shards/BigInt/Shift/#examples","title":"Examples","text":"CodeOutput <pre><code>4200 (BigInt) = .expected\n\n42 (BigInt)\n(BigInt.Shift\n ;:By\n 2)\n(BigInt.Is .expected) (Assert.Is true true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/BigInt/Sqrt/","title":"BigInt.Sqrt","text":"Name - Description Default Type <code>&lt;input&gt;</code> Big integer represented as bytes. <code>Bytes</code> <code>&lt;output&gt;</code> Outputs the square root of the input big integer represented as bytes. <code>Bytes</code> <p>This shard computes the square root of the input big integer represented as bytes.</p>"},{"location":"reference/shards/shards/BigInt/Sqrt/#examples","title":"Examples","text":"CodeOutput <pre><code>2 (BigInt) = .expected\n\n4 (BigInt)\n(BigInt.Sqrt)\n(BigInt.Is .expected) (Assert.Is true true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/BigInt/Subtract/","title":"BigInt.Subtract","text":"Name - Description Default Type <code>&lt;input&gt;</code> Any valid big integer(s) represented as bytes supported by this operation. <code>Bytes</code><code>[Bytes]</code> <code>&lt;output&gt;</code> Outputs the result of the operation as a big integer or sequence of big integers represented as bytes. <code>Bytes</code><code>[Bytes]</code> <code>Operand</code> The big integer to subtract from the input as bytes. <code>0</code> <code>Var(Bytes)</code><code>Var([Bytes])</code> <p>This shard subtracts the input big integer from the big integer specified in the Operand parameter and outputs the result.</p>"},{"location":"reference/shards/shards/BigInt/Subtract/#examples","title":"Examples","text":"CodeOutput <pre><code>5 (BigInt) = .expected\n2 (BigInt) = .operand\n\n7 (BigInt)\n(BigInt.Subtract\n ;:Operand\n .operand)\n(BigInt.Is .expected) (Assert.Is true true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/BigInt/ToBytes/","title":"BigInt.ToBytes","text":"Name - Description Default Type <code>&lt;input&gt;</code> Big integer to convert, represented as bytes. <code>Bytes</code> <code>&lt;output&gt;</code> <code>Bytes</code> <code>Bits</code> The desired bit length for the output to take. If set to 0, the output will be the minimum number of bytes required to represent the big integer. <code>0</code> <code>Int</code> <p>This shard converts a big integer value into a bytes representaion with the specified bit length set in the Bits parameter. If set to 0, the output will be the minimum number of bytes required to represent the big integer. If set to a positive number, the output will be padded with leading zeros to match the specified bit length. An error is thrown if the number requires more bits than specified.</p>"},{"location":"reference/shards/shards/BigInt/ToBytes/#examples","title":"Examples","text":"CodeOutput <pre><code>42 (BigInt)\n(BigInt.ToBytes\n ;:Bits\n 16)\n(ToHex)\n(Assert.Is \"0x002a\" true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/BigInt/ToFloat/","title":"BigInt.ToFloat","text":"Name - Description Default Type <code>&lt;input&gt;</code> The big integer to convert, represented as bytes. <code>Bytes</code> <code>&lt;output&gt;</code> Floating point number representation of the big integer value. <code>Float</code> <code>ShiftedBy</code> The number of decimal places to shift the input big integer by. A positive number shifts the decimal point to the right, while a negative number shifts it to the left. <code>0</code> <code>Int</code> <p>This shard converts the input big integer value to a floating point number.</p>"},{"location":"reference/shards/shards/BigInt/ToFloat/#examples","title":"Examples","text":"CodeOutput <pre><code>3 (BigInt)\n(BigInt.ToFloat\n ;:ShiftedBy\n 1)\n(Assert.Is (float 30.0) true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/BigInt/ToHex/","title":"BigInt.ToHex","text":"Name - Description Default Type <code>&lt;input&gt;</code> Big integer to convert, represented as bytes. <code>Int</code><code>Bytes</code><code>String</code> <code>&lt;output&gt;</code> Outputs the hexadecimal representation of the input big integer value. <code>String</code> <p>This shard converts the input big integer value to its hexadecimal representation.</p>"},{"location":"reference/shards/shards/BigInt/ToHex/#examples","title":"Examples","text":"CodeOutput <pre><code>42 (BigInt)\n(BigInt.ToHex)\n(Assert.Is \"0x2a\" true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/BigInt/ToInt/","title":"BigInt.ToInt","text":"Name - Description Default Type <code>&lt;input&gt;</code> The big integer to convert, represented as bytes. <code>Bytes</code> <code>&lt;output&gt;</code> Integer representation of the big integer value. <code>Int</code> <p>This shard converts the input big integer value to an integer.</p>"},{"location":"reference/shards/shards/BigInt/ToInt/#examples","title":"Examples","text":"CodeOutput <pre><code>42 (BigInt)\n(BigInt.ToInt)\n(Assert.Is (int 42) true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/BigInt/ToString/","title":"BigInt.ToString","text":"Name - Description Default Type <code>&lt;input&gt;</code> Big integer represented as bytes. <code>Bytes</code> <code>&lt;output&gt;</code> String representation of the big integer value. <code>String</code> <p>Converts the value to a string representation.</p>"},{"location":"reference/shards/shards/BigInt/ToString/#examples","title":"Examples","text":"CodeOutput <pre><code>42 (BigInt) (BigInt.Shift 20)\n(BigInt.ToString)\n(Assert.Is \"4200000000000000000000\" true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/BigInt/Xor/","title":"BigInt.Xor","text":"Name - Description Default Type <code>&lt;input&gt;</code> Any valid big integer(s) represented as bytes supported by this operation. <code>Bytes</code><code>[Bytes]</code> <code>&lt;output&gt;</code> Outputs the result of the XOR operation as a big integer represented as bytes. <code>Bytes</code><code>[Bytes]</code> <code>Operand</code> The second big integer to perform the XOR operation with. <code>0</code> <code>Var(Bytes)</code><code>Var([Bytes])</code> <p>This shard performs a bitwise XOR operation on the input big integer with the big integer specified in the Operand parameter and outputs the result. A bitwise XOR operation is a binary operation that compares each bit of the binary representations of two numbers and outputs 1 if the bits are different and 0 if they are the same. The resulting number is a big integer representation of the 1s and 0s concatenated.</p>"},{"location":"reference/shards/shards/BigInt/Xor/#examples","title":"Examples","text":"CodeOutput <pre><code>5 (BigInt) = .expected\n3 (BigInt) = .operand\n\n6 (BigInt)\n(BigInt.Xor\n ;:Operand\n .operand)\n(BigInt.Is .expected) (Assert.Is true true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/Brotli/Compress/","title":"Brotli.Compress","text":"Name - Description Default Type <code>&lt;input&gt;</code> The byte array to compress. <code>Bytes</code> <code>&lt;output&gt;</code> The compressed byte array. <code>Bytes</code> <code>Quality</code> Compression quality, higher is better but slower, valid values from 1 to 11. <code>11</code> <code>Int</code> <p>This shard compresses the input byte array using the Brotli algorithm and outputs the smaller compressed byte array. The size of the resulting byte array and the speed of compression can be controlled using the Quality parameter.</p> <p> </p>"},{"location":"reference/shards/shards/Brotli/Decompress/","title":"Brotli.Decompress","text":"Name - Description Default Type <code>&lt;input&gt;</code> The compressed byte array to decompress. <code>Bytes</code> <code>&lt;output&gt;</code> The reverted uncompressed byte array. <code>Bytes</code> <p>This shard decompresses the input byte array that has been previously compressed using the Brotli.Compress shard.</p> <p> </p>"},{"location":"reference/shards/shards/Bytes/Join/","title":"Bytes.Join","text":"Name - Description Default Type <code>&lt;input&gt;</code> The sequence of strings or byte array to concatenate. <code>[String Bytes]</code> <code>&lt;output&gt;</code> The concatenated string or bytes represented as a byte array. <code>Bytes</code> <p>This shard will concatenate a sequence of strings or bytes into a single string or byte array and output it as a byte array.</p> <p> </p>"},{"location":"reference/shards/shards/CRDT/Apply/","title":"CRDT.Apply","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Bytes</code> <code>&lt;output&gt;</code> <code>Bytes</code> <code>CRDT</code> The CRDT instance to apply the operation to. <code>none</code> <code>Var(Object)</code> <p>Applies an operation to a CRDT instance.</p> <p> </p>"},{"location":"reference/shards/shards/CRDT/Delete/","title":"CRDT.Delete","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Any</code> <code>&lt;output&gt;</code> <code>Bytes</code> <code>CRDT</code> The CRDT instance to delete from. <code>none</code> <code>Var(Object)</code> <code>Key</code> The key to delete from the CRDT instance. <code>none</code> <code>Any</code> <p>Deletes the value at the specified key in the CRDT instance.</p> <p> </p>"},{"location":"reference/shards/shards/CRDT/Get/","title":"CRDT.Get","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>&lt;output&gt;</code> <code>Any</code> <code>CRDT</code> The CRDT instance to read from. <code>none</code> <code>Var(Object)</code> <code>Key</code> The key to read from the CRDT instance. <code>none</code> <code>Any</code> <p>Retrieves the value at the specified key in the CRDT instance.</p> <p> </p>"},{"location":"reference/shards/shards/CRDT/Load/","title":"CRDT.Load","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Bytes</code> <code>&lt;output&gt;</code> <code>Bytes</code> <code>CRDT</code> The CRDT instance to load into. <code>none</code> <code>Var(Object)</code> <p>Loads a serialized CRDT into a CRDT instance.</p> <p> </p>"},{"location":"reference/shards/shards/CRDT/Merge/","title":"CRDT.Merge","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Any</code> <code>&lt;output&gt;</code> <code>Any</code> <code>Into</code> The CRDT instance to merge into. <code>none</code> <code>Var(Object)</code> <code>Other</code> The other CRDT instance to merge. <code>none</code> <code>Var(Object)</code> <p>Merges two CRDT instances.</p> <p> </p>"},{"location":"reference/shards/shards/CRDT/Open/","title":"CRDT.Open","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>&lt;output&gt;</code> <code>Object</code> <code>ClientID</code> The local client id. <code>0</code> <code>Int16</code><code>Var(Int16)</code><code>Bytes</code><code>Var(Bytes)</code> <p>Opens an empty CRDT document, returning the CRDT instance.</p> <p> </p>"},{"location":"reference/shards/shards/CRDT/Save/","title":"CRDT.Save","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>&lt;output&gt;</code> <code>Bytes</code> <code>CRDT</code> The CRDT instance to save. <code>none</code> <code>Var(Object)</code> <p>Serializes a CRDT instance.</p> <p> </p>"},{"location":"reference/shards/shards/CRDT/Set/","title":"CRDT.Set","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Any</code> <code>&lt;output&gt;</code> <code>Bytes</code> <code>CRDT</code> The CRDT instance to edit. <code>none</code> <code>Var(Object)</code> <code>Key</code> The key to update in the CRDT instance. <code>none</code> <code>Any</code> <p>Updates or adds a value in the CRDT instance at the specified key, returning the updated CRDT.</p> <p> </p>"},{"location":"reference/shards/shards/CRDT/State/","title":"CRDT.State","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>&lt;output&gt;</code> <code>Bytes</code> <code>CRDT</code> The CRDT instance to extract the state from. <code>none</code> <code>Var(Object)</code> <p>Extracts the whole state of the CRDT as a state vector.</p> <p> </p>"},{"location":"reference/shards/shards/CSV/Read/","title":"CSV.Read","text":"Name - Description Default Type <code>&lt;input&gt;</code> A multiline string in CSV format. <code>String</code> <code>&lt;output&gt;</code> A sequence of rows, with each row being a sequence of strings. <code>[[String]]</code> <code>NoHeader</code> Whether the shard should parse the first row as data, instead of header. <code>false</code> <code>Bool</code> <code>Separator</code> The character to use as fields separator. <code>\",\"</code> <code>String</code> <p>Reads a CSV string and outputs the data as a sequence of strings in a sequence of rows.</p> <p> </p>"},{"location":"reference/shards/shards/CSV/Write/","title":"CSV.Write","text":"Name - Description Default Type <code>&lt;input&gt;</code> A sequence of rows, with each row being a sequence of strings. <code>[[String]]</code> <code>&lt;output&gt;</code> A multiline string in CSV format. <code>String</code> <code>NoHeader</code> Whether the shard should parse the first row as data, instead of header. <code>false</code> <code>Bool</code> <code>Separator</code> The character to use as fields separator. <code>\",\"</code> <code>String</code> <p>Reads a sequence of strings in a sequence of rows and outputs the data as a CSV string.</p> <p> </p>"},{"location":"reference/shards/shards/ChaChaPoly/Decrypt/","title":"ChaChaPoly.Decrypt","text":"Name - Description Default Type <code>&lt;input&gt;</code> The encrypted byte array to decrypt. <code>Bytes</code> <code>&lt;output&gt;</code> The decrypted byte array. <code>Bytes</code> <code>Key</code> The private key to be used to encrypt/decrypt the input. Must be 32 bytes long. <code>none</code> <code>Bytes</code><code>Var(Bytes)</code> <p>This shard decrypts an input ChaCha20-Poly1305 encrypted byte array using the provided key (provided in the Key parameter). It then outputs the decrypted byte array.</p> <p> </p>"},{"location":"reference/shards/shards/ChaChaPoly/Encrypt/","title":"ChaChaPoly.Encrypt","text":"Name - Description Default Type <code>&lt;input&gt;</code> The string or byte array to encrypt. <code>String</code><code>Bytes</code> <code>&lt;output&gt;</code> The encrypted byte array. <code>Bytes</code> <code>Key</code> The private key to be used to encrypt/decrypt the input. Must be 32 bytes long. <code>none</code> <code>Bytes</code><code>Var(Bytes)</code> <p>This shard takes the input string or byte array and encrypts it using the ChaCha20-Poly1305 algorithm with the provided key (provided in the Key parameter). It then outputs the encrypted byte array.</p> <p> </p>"},{"location":"reference/shards/shards/DB/Backup/","title":"DB.Backup","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Any</code> <code>&lt;output&gt;</code> <code>Any</code> <code>Destination</code> The destination database filename. <code>none</code> <code>String</code><code>Var(String)</code> <code>Database</code> The optional sqlite database filename. <code>none</code> <code>String</code><code>Var(String)</code> <code>Pages</code> The number of pages to copy at once. <code>none</code> <code>Int</code><code>Var(Int)</code> <code>Unthrottled</code> If true, the backup will not be throttled and it might lock the DB while copying. <code>none</code> <code>Bool</code>"},{"location":"reference/shards/shards/DB/LoadExtension/","title":"DB.LoadExtension","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Any</code> <code>&lt;output&gt;</code> <code>Any</code> <code>Path</code> The path to the extension to load. <code>\"my-extension\"</code> <code>String</code><code>Var(String)</code> <code>Database</code> The optional sqlite database filename. <code>\"shards.db\"</code> <code>String</code><code>Var(String)</code> <code>EntryPoint</code> The entry point of the extension. <code>none</code> <code>String</code><code>Var(String)</code> <code>ReadOnly</code> If true, the database will be opened in read only mode. <code>false</code> <code>Bool</code><code>Var(Bool)</code>"},{"location":"reference/shards/shards/DB/Query/","title":"DB.Query","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>[Any]</code> <code>&lt;output&gt;</code> <code>{Any}</code><code>[Any]</code> <code>Query</code> The database query to execute every activation. <code>none</code> <code>String</code><code>Var(String)</code> <code>Database</code> The optional sqlite database filename. <code>none</code> <code>String</code><code>Var(String)</code> <code>AsRows</code> Return the result as rows. <code>none</code> <code>Bool</code> <code>Retry</code> Retry the query if the database was locked. <code>none</code> <code>Bool</code> <code>ReadOnly</code> If true, the database will be opened in read only mode. <code>none</code> <code>Bool</code><code>Var(Bool)</code>"},{"location":"reference/shards/shards/DB/RawQuery/","title":"DB.RawQuery","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>String</code> <code>&lt;output&gt;</code> <code>String</code> <code>Database</code> The optional sqlite database filename. <code>none</code> <code>String</code><code>Var(String)</code> <code>ReadOnly</code> If true, the database will be opened in read only mode. <code>none</code> <code>Bool</code><code>Var(Bool)</code>"},{"location":"reference/shards/shards/DB/Transaction/","title":"DB.Transaction","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Any</code> <code>&lt;output&gt;</code> <code>Any</code> <code>Queries</code> The Shards logic executing various DB queries. <code>none</code> <code>Shard</code><code>[Shard]</code> <code>Database</code> The optional sqlite database filename. <code>none</code> <code>String</code><code>Var(String)</code>"},{"location":"reference/shards/shards/DSP/FFT/","title":"DSP.FFT","text":"Name - Description Default Type <code>&lt;input&gt;</code> The time-domain representation of an audio to be converted. Can be a float sequence, float2 sequence or a sound object. <code>[Float]</code><code>[Float2]</code><code>Audio</code> <code>&lt;output&gt;</code> The frequency-domain representation of the audio as a float2 sequence. <code>[Float2]</code> <p>Experimental/unstable</p> <p>This API is experimental and might produce unexpected results or crash.</p> <p>This shard performs a Fast Fourier Transform (FFT) on the input. It takes the time-domain representation of an audio (represented as a sounds object, float sequence or float2 sequence) and outputs its frequency-domain representation as a float2 sequence.</p> <p> </p>"},{"location":"reference/shards/shards/DSP/IFFT/","title":"DSP.IFFT","text":"Name - Description Default Type <code>&lt;input&gt;</code> The frequency-domain representation of an audio to be converted. <code>[Float2]</code> <code>&lt;output&gt;</code> The time-domain representation of the audio as a float sequence, float2 sequence or an audio object (determined by the Audio and Complex parameters). <code>[Float]</code><code>[Float2]</code><code>Audio</code> <code>Audio</code> If the output should be an Audio chunk. <code>false</code> <code>Bool</code> <code>Complex</code> If the output should be complex numbers (only if not Audio). <code>false</code> <code>Bool</code> <p>Experimental/unstable</p> <p>This API is experimental and might produce unexpected results or crash.</p> <p>This shard performs an Inverse Fast Fourier Transform (IFFT) on the input. It takes the frequency-domain representation of an audio (represented as a float2 sequence) and outputs its time-domain representation (as a float sequence, float2 sequence or an audio object.)</p> <p> </p>"},{"location":"reference/shards/shards/Date/Format/","title":"Date.Format","text":"Name - Description Default Type <code>&lt;input&gt;</code> An epoch timestamp (seconds after epoch). <code>Int</code> <code>&lt;output&gt;</code> A formatted readable string. <code>String</code> <code>Format</code> The actual formatting string, see full docs: https://docs.rs/chrono/0.4.19/chrono/format/strftime/index.html#specifiers <code>\"%a %b %e %T %Y\"</code> <code>String</code> <p>Reads an epoch timestamps and formats it into a readable string.</p> <p> </p>"},{"location":"reference/shards/shards/Debug/Break/","title":"Debug.Break","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input can be of any type. <code>Any</code> <code>&lt;output&gt;</code> The output will be the input (passthrough). <code>Any</code>"},{"location":"reference/shards/shards/Debug/DumpEnv/","title":"Debug.DumpEnv","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Any</code> <code>&lt;output&gt;</code> <code>Any</code> <p>Dumps the variable environment during compose</p> <p> </p>"},{"location":"reference/shards/shards/Debug/Noop/","title":"Debug.Noop","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Any</code> <code>&lt;output&gt;</code> <code>Any</code> <code>Tag</code> Any tag to identify this debug shard <code>none</code> <code>Any</code> <code>Inspect</code> Anything to visualize <code>none</code> <code>Any</code> <p>A shard that can be set to break in the debugger at a specific location</p> <p> </p>"},{"location":"reference/shards/shards/Desktop/Bounds/","title":"Desktop.Bounds","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Object</code> <code>&lt;output&gt;</code> <code>Int2</code>"},{"location":"reference/shards/shards/Desktop/CaptureFrame/","title":"Desktop.CaptureFrame","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Any</code> <code>&lt;output&gt;</code> <code>Any</code>"},{"location":"reference/shards/shards/Desktop/CursorBitmap/","title":"Desktop.CursorBitmap","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>&lt;output&gt;</code> <code>Image</code>"},{"location":"reference/shards/shards/Desktop/GetMousePos/","title":"Desktop.GetMousePos","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>&lt;output&gt;</code> <code>Int2</code> <code>Window</code> None or a window variable we wish to use as relative origin. <code>none</code> <code>Var(Object)</code>"},{"location":"reference/shards/shards/Desktop/HasWindow/","title":"Desktop.HasWindow","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>&lt;output&gt;</code> <code>Bool</code> <code>Title</code> The title of the window to look for. <code>\"\"</code> <code>String</code> <code>Class</code> An optional and platform dependent window class. <code>\"\"</code> <code>String</code>"},{"location":"reference/shards/shards/Desktop/IsForeground/","title":"Desktop.IsForeground","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Object</code> <code>&lt;output&gt;</code> <code>Bool</code>"},{"location":"reference/shards/shards/Desktop/LastInput/","title":"Desktop.LastInput","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>&lt;output&gt;</code> <code>Float</code>"},{"location":"reference/shards/shards/Desktop/LeftClick/","title":"Desktop.LeftClick","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Int2</code> <code>&lt;output&gt;</code> <code>Int2</code> <code>Window</code> None or a window variable we wish to use as relative origin. <code>none</code> <code>Var(Object)</code> <code>Natural</code> Small pauses will be injected after click events down &amp; up. <code>true</code> <code>Bool</code>"},{"location":"reference/shards/shards/Desktop/MiddleClick/","title":"Desktop.MiddleClick","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Int2</code> <code>&lt;output&gt;</code> <code>Int2</code> <code>Window</code> None or a window variable we wish to use as relative origin. <code>none</code> <code>Var(Object)</code> <code>Natural</code> Small pauses will be injected after click events down &amp; up. <code>true</code> <code>Bool</code>"},{"location":"reference/shards/shards/Desktop/Move/","title":"Desktop.Move","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Object</code> <code>&lt;output&gt;</code> <code>Object</code> <code>X</code> The desired horizontal coordinates. <code>0</code> <code>Int</code> <code>Y</code> The desired vertical coordinates. <code>0</code> <code>Int</code>"},{"location":"reference/shards/shards/Desktop/MoveMouse/","title":"Desktop.MoveMouse","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Int2</code> <code>&lt;output&gt;</code> <code>Int2</code> <code>Window</code> None or a window variable we wish to use as relative origin. <code>none</code> <code>Var(Object)</code>"},{"location":"reference/shards/shards/Desktop/NotForeground/","title":"Desktop.NotForeground","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Object</code> <code>&lt;output&gt;</code> <code>Bool</code>"},{"location":"reference/shards/shards/Desktop/PID/","title":"Desktop.PID","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Object</code> <code>&lt;output&gt;</code> <code>Int</code>"},{"location":"reference/shards/shards/Desktop/Pixel/","title":"Desktop.Pixel","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Int2</code> <code>&lt;output&gt;</code> <code>Color</code> <code>Window</code> The window variable name to use as coordinate origin. <code>none</code> <code>Var(Object)</code>"},{"location":"reference/shards/shards/Desktop/Pixels/","title":"Desktop.Pixels","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Int4</code> <code>&lt;output&gt;</code> <code>Image</code> <code>Window</code> The window variable name to use as coordinate origin. <code>none</code> <code>Var(Object)</code>"},{"location":"reference/shards/shards/Desktop/Resize/","title":"Desktop.Resize","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Object</code> <code>&lt;output&gt;</code> <code>Object</code> <code>Width</code> The desired width. <code>0</code> <code>Int</code> <code>Height</code> The desired height. <code>0</code> <code>Int</code>"},{"location":"reference/shards/shards/Desktop/RightClick/","title":"Desktop.RightClick","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Int2</code> <code>&lt;output&gt;</code> <code>Int2</code> <code>Window</code> None or a window variable we wish to use as relative origin. <code>none</code> <code>Var(Object)</code> <code>Natural</code> Small pauses will be injected after click events down &amp; up. <code>true</code> <code>Bool</code>"},{"location":"reference/shards/shards/Desktop/ScrollHorizontal/","title":"Desktop.ScrollHorizontal","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Float</code> <code>&lt;output&gt;</code> <code>Float</code> <code>Window</code> None or a window variable we wish to use as relative origin. <code>none</code> <code>Var(Object)</code>"},{"location":"reference/shards/shards/Desktop/ScrollVertical/","title":"Desktop.ScrollVertical","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Float</code> <code>&lt;output&gt;</code> <code>Float</code> <code>Window</code> None or a window variable we wish to use as relative origin. <code>none</code> <code>Var(Object)</code>"},{"location":"reference/shards/shards/Desktop/SendKeyEvent/","title":"Desktop.SendKeyEvent","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Int2</code> <code>&lt;output&gt;</code> <code>Int2</code> <code>Window</code> None or a window variable if we wish to send the event only to a specific target window. <code>none</code> <code>Var(Object)</code>"},{"location":"reference/shards/shards/Desktop/SendKeyEvent/#sends-the-input-key-event","title":"Sends the input key event.","text":""},{"location":"reference/shards/shards/Desktop/SendKeyEvent/#the-input-of-this-shard-will-be-a-int2","title":"The input of this shard will be a Int2.","text":"<ul> <li>The first integer will be 0 for Key down/push events and 1 for Key up/release events.</li> <li>The second integer will the scancode of the key.</li> </ul>"},{"location":"reference/shards/shards/Desktop/SetBorderless/","title":"Desktop.SetBorderless","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Object</code> <code>&lt;output&gt;</code> <code>Object</code>"},{"location":"reference/shards/shards/Desktop/SetClickthrough/","title":"Desktop.SetClickthrough","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Object</code> <code>&lt;output&gt;</code> <code>Object</code>"},{"location":"reference/shards/shards/Desktop/SetForeground/","title":"Desktop.SetForeground","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Object</code> <code>&lt;output&gt;</code> <code>Object</code>"},{"location":"reference/shards/shards/Desktop/SetMousePos/","title":"Desktop.SetMousePos","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Int2</code> <code>&lt;output&gt;</code> <code>Int2</code> <code>Window</code> None or a window variable we wish to use as relative origin. <code>none</code> <code>Var(Object)</code>"},{"location":"reference/shards/shards/Desktop/SetTimerResolution/","title":"Desktop.SetTimerResolution","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Int</code> <code>&lt;output&gt;</code> <code>Int</code>"},{"location":"reference/shards/shards/Desktop/SetTitle/","title":"Desktop.SetTitle","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Object</code> <code>&lt;output&gt;</code> <code>Object</code> <code>Title</code> The title of the window to look for. <code>\"\"</code> <code>String</code>"},{"location":"reference/shards/shards/Desktop/SetTopmost/","title":"Desktop.SetTopmost","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Object</code> <code>&lt;output&gt;</code> <code>Object</code>"},{"location":"reference/shards/shards/Desktop/Size/","title":"Desktop.Size","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Object</code> <code>&lt;output&gt;</code> <code>Int2</code>"},{"location":"reference/shards/shards/Desktop/Tap/","title":"Desktop.Tap","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Int2</code> <code>&lt;output&gt;</code> <code>Int2</code> <code>Window</code> None or a window variable we wish to use as relative origin. <code>none</code> <code>Var(Object)</code> <code>Long</code> A big delay will be injected after tap down to simulate a long tap. <code>false</code> <code>Bool</code> <code>Natural</code> Small pauses will be injected after tap events down &amp; up. <code>true</code> <code>Bool</code>"},{"location":"reference/shards/shards/Desktop/UnsetClickthrough/","title":"Desktop.UnsetClickthrough","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Object</code> <code>&lt;output&gt;</code> <code>Object</code>"},{"location":"reference/shards/shards/Desktop/UnsetTopmost/","title":"Desktop.UnsetTopmost","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Object</code> <code>&lt;output&gt;</code> <code>Object</code>"},{"location":"reference/shards/shards/Desktop/WaitKeyEvent/","title":"Desktop.WaitKeyEvent","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>&lt;output&gt;</code> <code>Int2</code>"},{"location":"reference/shards/shards/Desktop/WaitKeyEvent/#pauses-the-wire-and-waits-for-keyboard-events","title":"Pauses the wire and waits for keyboard events.","text":""},{"location":"reference/shards/shards/Desktop/WaitKeyEvent/#the-output-of-this-shard-will-be-a-int2","title":"The output of this shard will be a Int2.","text":"<ul> <li>The first integer will be 0 for Key down/push events and 1 for Key up/release events.</li> <li>The second integer will the scancode of the key.</li> </ul>"},{"location":"reference/shards/shards/Desktop/WaitWindow/","title":"Desktop.WaitWindow","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>&lt;output&gt;</code> <code>Object</code> <code>Title</code> The title of the window to look for. <code>\"\"</code> <code>String</code> <code>Class</code> An optional and platform dependent window class. <code>\"\"</code> <code>String</code>"},{"location":"reference/shards/shards/ECDSA/PublicKey/","title":"ECDSA.PublicKey","text":"Name - Description Default Type <code>&lt;input&gt;</code> The private key to generate the public key from. <code>Bytes</code> <code>&lt;output&gt;</code> The public key generated from the private key. <code>Bytes</code> <code>Compressed</code> Indicates if the output PublicKey should be in compressed format. <code>false</code> <code>Bool</code> <p>Generates the public key from the private key using the ECDSA algorithm.</p> <p> </p>"},{"location":"reference/shards/shards/ECDSA/Recover/","title":"ECDSA.Recover","text":"Name - Description Default Type <code>&lt;input&gt;</code> The message hash to recover the public key from. <code>Bytes</code> <code>&lt;output&gt;</code> The public key recovered from the signature and message. <code>Bytes</code> <code>Signature</code> The signature generated from signing the input message with the private key. <code>none</code> <code>Bytes</code><code>Var(Bytes)</code> <code>Compressed</code> Indicates if the output PublicKey should be in compressed format. <code>false</code> <code>Bool</code> <p>Recovers the public key from the signature and message using the ECDSA algorithm.</p> <p> </p>"},{"location":"reference/shards/shards/ECDSA/Seed/","title":"ECDSA.Seed","text":"Name - Description Default Type <code>&lt;input&gt;</code> The seed to generate the private key from. <code>String</code> <code>&lt;output&gt;</code> The private key generated from the seed. <code>Bytes</code> <code>Compressed</code> Indicates if the output PublicKey should be in compressed format. <code>false</code> <code>Bool</code> <p>Generates the private key from the seed using the ECDSA algorithm.</p> <p> </p>"},{"location":"reference/shards/shards/ECDSA/Sign/","title":"ECDSA.Sign","text":"Name - Description Default Type <code>&lt;input&gt;</code> The message hash to sign with the private key, must be 32 bytes. <code>Bytes</code> <code>&lt;output&gt;</code> The signature generated from signing the input message with the private key. <code>Bytes</code> <code>Key</code> The private key used to sign the hashed message input. <code>none</code> <code>Bytes</code><code>Var(Bytes)</code> <p>Signs a message with the private key using the ECDSA algorithm.</p> <p> </p>"},{"location":"reference/shards/shards/EDN/Eval/","title":"EDN.Eval","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Any</code> <code>&lt;output&gt;</code> <code>Any</code> <code>Global</code> If true the script will be evaluated in the global root thread environment, if false a new child environment will be created. <code>true</code> <code>Bool</code> <code>Prefix</code> The prefix (similar to namespace) to add when setting and getting variables when evaluating this script. <code>none</code> <code>String</code><code>Var(String)</code>"},{"location":"reference/shards/shards/Ed25519/PublicKey/","title":"Ed25519.PublicKey","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Bytes</code> <code>&lt;output&gt;</code> <code>Bytes</code> <p>Extracts the public key from an Ed25519 signing key</p> <p> </p>"},{"location":"reference/shards/shards/Ed25519/Sign/","title":"Ed25519.Sign","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Bytes</code> <code>&lt;output&gt;</code> <code>Bytes</code> <code>Key</code> The private key to be used to sign the message input. <code>none</code> <code>Bytes</code><code>Var(Bytes)</code> <p>Signs a message using the Ed25519 signature algorithm.</p> <p> </p>"},{"location":"reference/shards/shards/Ed25519/Verify/","title":"Ed25519.Verify","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Bytes</code> <code>&lt;output&gt;</code> <code>Bool</code> <code>Key</code> The public key of the keypair that signed the message. This will be used to verify the signature. <code>none</code> <code>Bytes</code><code>Var(Bytes)</code> <code>Message</code> The message that was signed to produce the signature. This is the original plain bytes message that the signature was created for. <code>none</code> <code>Bytes</code><code>Var(Bytes)</code> <p>Verifies an Ed25519 signature</p> <p> </p>"},{"location":"reference/shards/shards/Events/Check/","title":"Events.Check","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>&lt;output&gt;</code> <code>Bool</code> <code>Name</code> The name of the event dispatcher to use. <code>none</code> <code>String</code><code>Var(String)</code> <code>ID</code> The optional ID to use to differentiate events with the same name. <code>none</code> <code>Int</code><code>Var(Int)</code>"},{"location":"reference/shards/shards/Events/Emit/","title":"Events.Emit","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Any</code> <code>&lt;output&gt;</code> <code>Any</code> <code>Name</code> The name of the event dispatcher to use. <code>none</code> <code>String</code><code>Var(String)</code> <code>ID</code> The optional ID to use to differentiate events with the same name. <code>none</code> <code>Int</code><code>Var(Int)</code>"},{"location":"reference/shards/shards/Events/Receive/","title":"Events.Receive","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>&lt;output&gt;</code> <code>[Any]</code> <code>Name</code> The name of the event dispatcher to use. <code>none</code> <code>String</code><code>Var(String)</code> <code>ID</code> The optional ID to use to differentiate events with the same name. <code>none</code> <code>Int</code><code>Var(Int)</code>"},{"location":"reference/shards/shards/Events/Send/","title":"Events.Send","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Any</code> <code>&lt;output&gt;</code> <code>Any</code> <code>Name</code> The name of the event dispatcher to use. <code>none</code> <code>String</code><code>Var(String)</code> <code>ID</code> The optional ID to use to differentiate events with the same name. <code>none</code> <code>Int</code><code>Var(Int)</code>"},{"location":"reference/shards/shards/Events/Update/","title":"Events.Update","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Any</code> <code>&lt;output&gt;</code> <code>Any</code> <code>Name</code> The name of the event dispatcher to use. <code>none</code> <code>String</code><code>Var(String)</code> <code>ID</code> The optional ID to use to differentiate events with the same name. <code>none</code> <code>Int</code><code>Var(Int)</code>"},{"location":"reference/shards/shards/FS/Absolute/","title":"FS.Absolute","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>String</code> <code>&lt;output&gt;</code> <code>String</code>"},{"location":"reference/shards/shards/FS/Copy/","title":"FS.Copy","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>String</code> <code>&lt;output&gt;</code> <code>String</code> <code>Destination</code> The destination path, can be a file or a directory. <code>none</code> <code>String</code><code>Var(String)</code> <code>Behavior</code> What to do when the destination already exists. <code>IfExists::Fail</code> <code>IfExists</code>"},{"location":"reference/shards/shards/FS/CreateDirectories/","title":"FS.CreateDirectories","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>String</code> <code>&lt;output&gt;</code> <code>String</code>"},{"location":"reference/shards/shards/FS/Extension/","title":"FS.Extension","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>String</code> <code>&lt;output&gt;</code> <code>String</code>"},{"location":"reference/shards/shards/FS/FileDialog/","title":"FS.FileDialog","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>&lt;output&gt;</code> <code>String</code><code>[String]</code> <code>Filters</code> To filter files based on extensions. <code>none</code> <code>[[String]]</code><code>Var([[String]])</code> <code>FilterNames</code> For each filter, gives the name to show of the filter. <code>none</code> <code>[String]</code><code>Var([String])</code> <code>CurrentDir</code> Set the current directory <code>none</code> <code>String</code><code>Var(String)</code> <code>Multiple</code> To select multiple files instead of just one. <code>false</code> <code>Bool</code> <code>Folder</code> To select a folder instead of a file. <code>false</code> <code>Bool</code><code>Var(Bool)</code> <p>Creates a file dialog to open files</p>"},{"location":"reference/shards/shards/FS/FileDialog/#examples","title":"Examples","text":"CodeOutput <pre><code>; pick any file\n(FS.FileDialog)\n(Log \"file path\")\n\n; pick any file from the parent directory\n(FS.FileDialog :CurrentDir \"..\")\n(Log \"file path\")\n\n; pick only .edn and .log file\n(FS.FileDialog :Filters [\"edn\" \"log\"])\n(Log \"file path\")\n\n; pick any folder\n(FS.FileDialog :Folder true)\n(Log \"folder path\")\n</code></pre> <pre><code>\n</code></pre> CodeOutput <pre><code>; pick any files\n(FS.FileDialog :Multiple true)\n(Log \"file paths\")\n\n; pick any files from the parent directory\n(FS.FileDialog :CurrentDir \"..\" :Multiple true)\n(Log \"file paths\")\n\n; pick only .edn and .log files\n(FS.FileDialog :Filters [\"edn\" \"log\"] :Multiple true)\n(Log \"file paths\")\n\n; pick any folders\n(FS.FileDialog :Folder true :Multiple true)\n(Log \"folder paths\")\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/FS/Filename/","title":"FS.Filename","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>String</code> <code>&lt;output&gt;</code> <code>String</code> <code>NoExtension</code> If the extension should be stripped from the result. <code>false</code> <code>Bool</code>"},{"location":"reference/shards/shards/FS/IsDirectory/","title":"FS.IsDirectory","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>String</code> <code>&lt;output&gt;</code> <code>Bool</code>"},{"location":"reference/shards/shards/FS/IsFile/","title":"FS.IsFile","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>String</code> <code>&lt;output&gt;</code> <code>Bool</code>"},{"location":"reference/shards/shards/FS/Iterate/","title":"FS.Iterate","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>String</code> <code>&lt;output&gt;</code> <code>[String]</code> <code>Recursive</code> If the iteration should be recursive, following sub-directories. <code>true</code> <code>Bool</code>"},{"location":"reference/shards/shards/FS/Join/","title":"FS.Join","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>[String]</code> <code>&lt;output&gt;</code> <code>String</code>"},{"location":"reference/shards/shards/FS/LastWriteTime/","title":"FS.LastWriteTime","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>String</code> <code>&lt;output&gt;</code> <code>Int</code>"},{"location":"reference/shards/shards/FS/Parent/","title":"FS.Parent","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>String</code> <code>&lt;output&gt;</code> <code>String</code>"},{"location":"reference/shards/shards/FS/Read/","title":"FS.Read","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>String</code> <code>&lt;output&gt;</code> <code>Bytes</code><code>String</code> <code>Bytes</code> If the output should be SHType::Bytes instead of SHType::String. <code>false</code> <code>Bool</code>"},{"location":"reference/shards/shards/FS/RelativeTo/","title":"FS.RelativeTo","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>String</code> <code>&lt;output&gt;</code> <code>String</code> <code>BasePath</code> The base path to make the input path relative to <code>none</code> <code>String</code><code>Var(String)</code>"},{"location":"reference/shards/shards/FS/Remove/","title":"FS.Remove","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>String</code> <code>&lt;output&gt;</code> <code>Bool</code>"},{"location":"reference/shards/shards/FS/RemoveAll/","title":"FS.RemoveAll","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>String</code> <code>&lt;output&gt;</code> <code>Int</code>"},{"location":"reference/shards/shards/FS/Rename/","title":"FS.Rename","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>String</code> <code>&lt;output&gt;</code> <code>String</code> <code>NewName</code> The new name for the file <code>none</code> <code>String</code><code>Var(String)</code>"},{"location":"reference/shards/shards/FS/SaveFileDialog/","title":"FS.SaveFileDialog","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>&lt;output&gt;</code> <code>String</code> <code>Filters</code> To filter files based on extensions. <code>none</code> <code>[String]</code><code>Var([String])</code> <code>CurrentDir</code> Set the current directory <code>none</code> <code>String</code><code>Var(String)</code>"},{"location":"reference/shards/shards/FS/SaveFileDialog/#examples","title":"Examples","text":"CodeOutput <pre><code>; pick any file\n(FS.SaveFileDialog)\n(Log \"save file path\")\n\n; pick any file from the parent directory\n(FS.SaveFileDialog :CurrentDir \"..\")\n(Log \"save file path\")\n\n; pick only .edn and .log file\n(FS.SaveFileDialog :Filters [\"edn\" \"log\"])\n(Log \"save file path\")\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/FS/SetWriteTime/","title":"FS.SetWriteTime","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>String</code> <code>&lt;output&gt;</code> <code>String</code> <code>Time</code> The new time to set as last write time <code>none</code> <code>Int</code><code>Var(Int)</code>"},{"location":"reference/shards/shards/FS/Watch/","title":"FS.Watch","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>String</code> <code>&lt;output&gt;</code> <code>[{Any}]</code> <p>A directory watcher</p> <p> </p>"},{"location":"reference/shards/shards/FS/Write/","title":"FS.Write","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>String</code> <code>&lt;output&gt;</code> <code>String</code> <code>Contents</code> The string or bytes to write as the file's contents. <code>none</code> <code>String</code><code>Bytes</code><code>Var(String)</code><code>Var(Bytes)</code> <code>Overwrite</code> Overwrite the file if it already exists. <code>false</code> <code>Bool</code> <code>Append</code> If we should append Contents to an existing file. <code>false</code> <code>Bool</code>"},{"location":"reference/shards/shards/GFX/","title":"GFX","text":"<p>Here you'll find all the shards related to graphics and rendering.</p> <p>For a basic example, check out the GFX.Render shard documentation.</p> <p> </p>"},{"location":"reference/shards/shards/GFX/Buffer/","title":"GFX.Buffer","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Any</code> <code>&lt;output&gt;</code> <code>GFX.Buffer</code> <code>Type</code> The type descriptor of the buffer <code>none</code> <code>{Any}</code> <code>AddressSpace</code> The address space to use the buffer with <code>none</code> <code>BufferAddressSpace</code> <p>Creates a new graphics buffer </p> <p> </p>"},{"location":"reference/shards/shards/GFX/BuiltinFeature/","title":"GFX.BuiltinFeature","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input of this shard is ignored. <code>&lt;output&gt;</code> The feature object for use in a rendering pass. <code>GFX.Feature</code> <code>Id</code> Builtin feature id. <code>BuiltinFeatureId::Transform</code> <code>BuiltinFeatureId</code> <p>This shard creates the ready-made feature object of the feature specified in the ID parameter, for use in a rendering pass.</p>"},{"location":"reference/shards/shards/GFX/BuiltinFeature/#details","title":"Details","text":"<p>This shard generates features with preset behavior, the behavior depends on the Id.</p>"},{"location":"reference/shards/shards/GFX/BuiltinFeature/#built-in-feature-ids","title":"Built-in Feature Ids","text":""},{"location":"reference/shards/shards/GFX/BuiltinFeature/#transform","title":"Transform","text":"<p>This Feature implements basic world/view/projection transform.</p> <p>Here are the entry points that are defined and can be added as dependencies by your own features.</p>"},{"location":"reference/shards/shards/GFX/BuiltinFeature/#initlocalposition-vertex","title":"<code>initLocalPosition</code> (vertex)","text":"<p>Sets the <code>localPosition</code> (float4) global from the vertex position.</p>"},{"location":"reference/shards/shards/GFX/BuiltinFeature/#initscreenposition-vertex","title":"<code>initScreenPosition</code> (vertex)","text":"<p>Sets the <code>screenPosition</code> global (float4) to the transformed vertex position (<code>=proj*view*world*&lt;vertex&gt;</code>).</p>"},{"location":"reference/shards/shards/GFX/BuiltinFeature/#writeposition-vertex","title":"<code>writePosition</code> (vertex)","text":"<p>Writes <code>screenPosition</code> global to <code>position</code> output.</p>"},{"location":"reference/shards/shards/GFX/BuiltinFeature/#initworldnormal-vertex","title":"<code>initWorldNormal</code> (vertex)","text":"<p>Transforms the object normal and writes the transformed result into the <code>worldNormal</code> global (float3). If the mesh doesn't have vertex normals, the normal will be <code>(0.0, 0.0, 1.0)</code>.</p>"},{"location":"reference/shards/shards/GFX/BuiltinFeature/#writenormal-vertex","title":"<code>writeNormal</code> (vertex)","text":"<p>Writes <code>worldNormal</code> global into <code>worldNormal</code> output.</p>"},{"location":"reference/shards/shards/GFX/BuiltinFeature/#basecolor","title":"BaseColor","text":"<p>This Feature adds a per-object shader parameter with the name <code>baseColor</code> and a texture parameter with the same name.</p> <p>Here are the entry points that are defined and can be added as dependencies by your own features.</p>"},{"location":"reference/shards/shards/GFX/BuiltinFeature/#initcolor-vertex","title":"<code>initColor</code> (vertex)","text":"<p>This vertex shader entry point sets up the <code>color</code> global (float4) with the vertex color from the mesh if it has been set. If the mesh doesn't have a vertex color, it'll be white with alpha 1.0.</p>"},{"location":"reference/shards/shards/GFX/BuiltinFeature/#writecolor-vertex","title":"<code>writeColor</code> (vertex)","text":"<p>Writes <code>color</code> global to <code>color</code> output.</p>"},{"location":"reference/shards/shards/GFX/BuiltinFeature/#readcolor-fragment","title":"<code>readColor</code> (fragment)","text":"<p>Reads <code>color</code> input into <code>color</code> global (float4).</p>"},{"location":"reference/shards/shards/GFX/BuiltinFeature/#texturecolor-fragment","title":"<code>textureColor</code> (fragment)","text":"<p>Reads the texture color from the <code>baseColor</code> texture and multiplies it with the current <code>color</code> global. It does nothing if the texture does not exist.</p>"},{"location":"reference/shards/shards/GFX/BuiltinFeature/#writecolor-fragment","title":"<code>writeColor</code> (fragment)","text":"<p>Writes <code>color</code> global to <code>color</code> output. <code>color</code> is the default name for the main color output from the fragment shader.</p>"},{"location":"reference/shards/shards/GFX/BuiltinFeature/#vertexcolorfromnormal","title":"VertexColorFromNormal","text":"<p>This Feature outputs the mesh normal as a per-vertex color output.</p> <p>Use for debugging.</p>"},{"location":"reference/shards/shards/GFX/BuiltinFeature/#wireframe","title":"Wireframe","text":"<p>This Feature changes how objects are rendered so that their edges are highlighted. Very basic, with a fixed edge width and color.</p> <p>Use for debugging.</p>"},{"location":"reference/shards/shards/GFX/BuiltinFeature/#velocity","title":"Velocity","text":"<p>This Feature outputs per-object velocity into a <code>velocity</code> output and <code>velocity</code> global. For usage with effects that require a velocity buffer such as motion blur or temporal anti-aliasing.</p> <p> </p>"},{"location":"reference/shards/shards/GFX/BuiltinMesh/","title":"GFX.BuiltinMesh","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input of this shard is ignored. <code>&lt;output&gt;</code> The output is a mesh object. <code>GFX.Mesh</code> <code>Type</code> The type of object to make. <code>BuiltinMeshType::Cube</code> <code>BuiltinMeshType</code> <p>This shard creates the ready-made mesh object of the shape defined in the Type parameter.</p> <p> </p>"},{"location":"reference/shards/shards/GFX/ClearQueue/","title":"GFX.ClearQueue","text":"Name - Description Default Type <code>&lt;input&gt;</code> The drawable queue object to clear. <code>GFX.DrawQueue</code> <code>&lt;output&gt;</code> None. <p>Removes all drawable objects from the input drawable queue.</p> <p> </p>"},{"location":"reference/shards/shards/GFX/CopyPass/","title":"GFX.CopyPass","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input of this shard is ignored. <code>&lt;output&gt;</code> The render pass object for use in a render pipeline. <code>GFX.PipelineStep</code> <code>Name</code> A name for this pass, to aid in debugging <code>none</code> <code>String</code> <code>Outputs</code> The outputs to render into <code>none</code> <code>[{Any}]</code><code>Var([{Any}])</code> <code>OutputScale</code> The scale that the output should be rendered as <code>{main: none}</code> <code>Any</code> <code>Inputs</code> The names of the render pass objects to modify as a sequence of strings. <code>none</code> <code>[String]</code><code>Var([String])</code> <p>This shard creates a render pass object that is meant for transferring render data from one stage of the render pipeline to the next. It is also able to make changes to the render data specified in the Inputs parameter, like changing its texture format or down sampling the texture. It makes these changes through its Outputs and OutputScale parameters.</p> <p> </p>"},{"location":"reference/shards/shards/GFX/Draw/","title":"GFX.Draw","text":"Name - Description Default Type <code>&lt;input&gt;</code> The drawable object (or sequence of drawable objects) to add to the draw queue. <code>GFX.Drawable</code><code>[GFX.Drawable]</code> <code>&lt;output&gt;</code> Outputs the input value, passed through unchanged. <code>GFX.Drawable</code><code>[GFX.Drawable]</code> <code>Queue</code> The queue object to add the drawable object to. <code>none</code> <code>Var(GFX.DrawQueue)</code> <p>This shard takes the input drawable object (or sequence of drawable objects) and adds them to the draw queue (created by GFX.DrawQueue) specified in the Queue parameter.</p>"},{"location":"reference/shards/shards/GFX/Draw/#details","title":"Details","text":"<p>Draw takes a Drawable and adds a render command for it to a RenderQueue.</p>"},{"location":"reference/shards/shards/GFX/Draw/#default-queue","title":"Default queue","text":"<p>If no render queue is specified, it goes to a global default queue.</p> <p> </p>"},{"location":"reference/shards/shards/GFX/DrawQueue/","title":"GFX.DrawQueue","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input of this shard is ignored. <code>&lt;output&gt;</code> The drawable queue object. <code>GFX.DrawQueue</code> <code>AutoClear</code> When enabled, automatically clears the queue after items have been rendered <code>true</code> <code>Bool</code> <code>Threaded</code> When enabled, output unique queue references to be able to use them with channels <code>false</code> <code>Bool</code> <code>Trace</code> Enables debug tracing on this queue <code>false</code> <code>Bool</code> <p>Creates a new drawable queue object to add drawables to (using GFX.Draw).</p> <p> </p>"},{"location":"reference/shards/shards/GFX/Drawable/","title":"GFX.Drawable","text":"Name - Description Default Type <code>&lt;input&gt;</code> The transformation matrix of the drawable object to adopt. <code>[Float4](4)</code> <code>&lt;output&gt;</code> The drawable object. <code>GFX.Drawable</code> <code>Mesh</code> The mesh to use for this drawable. <code>none</code> <code>Var(GFX.Mesh)</code> <code>Material</code> The material <code>none</code> <code>Var(GFX.Material)</code> <code>Params</code> Shader parameters for this drawable <code>none</code> <code>{GFX.Texture2D GFX.TextureCube Var(GFX.Buffer) [Float4](4) Float4 Float3 Float2 Float Int Int2 Int3 Int4 Var(GFX.Texture2D GFX.TextureCube Var(GFX.Buffer) [Float4](4) Float4 Float3 Float2 Float Int Int2 Int3 Int4)}</code><code>Var({GFX.Texture2D GFX.TextureCube Var(GFX.Buffer) [Float4](4) Float4 Float3 Float2 Float Int Int2 Int3 Int4 Var(GFX.Texture2D GFX.TextureCube Var(GFX.Buffer) [Float4](4) Float4 Float3 Float2 Float Int Int2 Int3 Int4)})</code> <code>Features</code> Features to attach to this drawable <code>none</code> <code>[GFX.Feature]</code><code>Var([GFX.Feature])</code> <p>This shard creates a drawable object that can be added to a drawables queue for the render pipeline.</p>"},{"location":"reference/shards/shards/GFX/Drawable/#details","title":"Details","text":"<p>The Drawable shard defines an instance of a drawn object. It usually has a transform (in world space) and a mesh to draw.</p>"},{"location":"reference/shards/shards/GFX/Drawable/#params","title":"Params","text":"<p>The <code>Params</code> parameter contains a table of values that will be passed to the shader when this drawable is rendered.</p> <p>Info</p> <p>See GFX.Feature about where shader parameters are defined and used.</p>"},{"location":"reference/shards/shards/GFX/Drawable/#constantdynamic","title":"Constant/Dynamic","text":"<p>Shader parameters and the drawable transform can be set as either constant parameters or dynamic ones.</p>"},{"location":"reference/shards/shards/GFX/Drawable/#constant-parameters","title":"Constant parameters","text":"<p>Constant parameters are passed through the input table. They are read and stay the same until this function is called again.</p> <pre><code>{:Mesh .mesh :Transform .transform} (GFX.Drawable) &gt;= .my-drawable\n</code></pre>"},{"location":"reference/shards/shards/GFX/Drawable/#dynamic-parameters","title":"Dynamic parameters","text":"<p>Dynamic parameters are passed as parameters to the shard. You can set the same fields as you can when setting constant parameters, with the exception of the mesh. The variables are referenced by the <code>Drawable</code> so that changes in their value will be reflect in the rendered result.</p> <pre><code>.. &gt;= .dynamic-color\n.. &gt;= .dynamic-transform\n{:Mesh .mesh} (Drawable :Transform .dynamic-transform :Params {:baseColor .dynamic-color}) &gt;= .my-drawable\n</code></pre>"},{"location":"reference/shards/shards/GFX/Drawable/#intended-usage","title":"Intended usage","text":"<p>To avoid re-creating Drawables for objects with minor or no changes, you should set up Drawables from within a Setup block and pass their dynamic parameters to the shard.</p> <pre><code>; Only done once\n(Setup\n  ... = .const-transform\n  (Float4 1.0) &gt;= .dynamic-color\n  {:Mesh .mesh :Transform .const-transform} (Drawable :Params {:baseColor .dynamic-color}) &gt;= .my-drawable)\n\n; Update color every time this wire runs\n... &gt; .dynamic-color\n</code></pre> <p> </p>"},{"location":"reference/shards/shards/GFX/DrawablePass/","title":"GFX.DrawablePass","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input of this shard is ignored. <code>&lt;output&gt;</code> The render pass object for use in a render pipeline. <code>GFX.PipelineStep</code> <code>Name</code> A name for this pass, to aid in debugging <code>none</code> <code>String</code> <code>Queue</code> The drawables queue to get drawables from. <code>none</code> <code>Var(GFX.DrawQueue)</code> <code>Features</code> Features to attach to this drawable <code>none</code> <code>[GFX.Feature]</code><code>Var([GFX.Feature])</code> <code>Outputs</code> The outputs to render into <code>none</code> <code>[{Any}]</code><code>Var([{Any}])</code> <code>OutputScale</code> The scale that the output should be rendered as <code>{main: none}</code> <code>Any</code> <code>Sort</code> The sorting mode to use to sort the drawables. The default sorting behavior is to sort by optimal batching. <code>none</code> <code>SortMode</code><code>Var(SortMode)</code> <code>IgnoreDrawableFeatures</code> Ignore any features on drawables and only use the features specified in this pass. <code>none</code> <code>Bool</code> <p>This shard creates a render pass object, meant for rendering drawable objects, using the drawables from the drawables queue (specified in the Queue parameter) and the sequence of features objects (specified in the Features parameter).</p>"},{"location":"reference/shards/shards/GFX/DrawablePass/#details","title":"Details","text":"<p>A step that can be passed to Render. When processed it will take all Drawables from the referenced DrawQueue and draw them.</p> <p>Features specified on the DrawablePass will be applied to all objects that are drawn as part of that pass.</p> <p> </p>"},{"location":"reference/shards/shards/GFX/EffectPass/","title":"GFX.EffectPass","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input of this shard is ignored. <code>&lt;output&gt;</code> The render pass object for use in a render pipeline. <code>GFX.PipelineStep</code> <code>Name</code> A name for this pass, to aid in debugging <code>none</code> <code>String</code> <code>Outputs</code> The outputs to render into <code>[{Name: color}]</code> <code>[{Any}]</code><code>Var([{Any}])</code> <code>OutputScale</code> The scale that the output should be rendered as <code>{main: none}</code> <code>Any</code> <code>Inputs</code> <code>none</code> <code>[String]</code><code>Var([String])</code> <code>EntryPoint</code> <code>none</code> <code>[Shard]</code><code>Var([Shard])</code> <code>Params</code> Shader parameters for this drawable <code>none</code> <code>{GFX.Texture2D GFX.TextureCube Var(GFX.Buffer) [Float4](4) Float4 Float3 Float2 Float Int Int2 Int3 Int4 Var(GFX.Texture2D GFX.TextureCube Var(GFX.Buffer) [Float4](4) Float4 Float3 Float2 Float Int Int2 Int3 Int4)}</code><code>Var({GFX.Texture2D GFX.TextureCube Var(GFX.Buffer) [Float4](4) Float4 Float3 Float2 Float Int Int2 Int3 Int4 Var(GFX.Texture2D GFX.TextureCube Var(GFX.Buffer) [Float4](4) Float4 Float3 Float2 Float Int Int2 Int3 Int4)})</code> <code>Features</code> Features to attach to this drawable <code>none</code> <code>[GFX.Feature]</code><code>Var([GFX.Feature])</code> <code>ComposeWith</code> Any table of values that need to be injected into this feature's shaders <code>none</code> <code>{Any}</code><code>Var({Any})</code> <p>This shard creates a render pass object designed for applying post processing effects or full-screen rendering techniques.</p> <p> </p>"},{"location":"reference/shards/shards/GFX/EndFrame/","title":"GFX.EndFrame","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Any</code> <code>&lt;output&gt;</code> The input to this shard is passed through as its output. <code>Any</code> <p>Explicitly end frame rendering, this is done automatically inside MainWindow. This shards is only needed when you want to end a frame earlier inside MainWindow</p> <p> </p>"},{"location":"reference/shards/shards/GFX/Feature/","title":"GFX.Feature","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input of this shard is ignored. <code>&lt;output&gt;</code> The feature object for use in a rendering pass. <code>GFX.Feature</code> <code>Shaders</code> A list of shader entry points <code>none</code> <code>[{Any}]</code> <code>ComposeWith</code> Any table of values that need to be injected into this feature's shaders <code>none</code> <code>{Any}</code><code>Var({Any})</code> <code>State</code> The table of render state flags to override <code>none</code> <code>{Any}</code><code>Var({Any})</code> <code>ViewGenerators</code> A collection of callbacks that will be run to generate per-view shader parameters during rendering. These parameters are added to the view buffer. <code>none</code> <code>Wire</code><code>[Wire]</code><code>[Shard]</code><code>[[Shard]]</code> <code>DrawableGenerators</code> A collection of callbacks that will be run to generate per-drawable shader parameters during rendering <code>none</code> <code>Wire</code><code>[Wire]</code><code>[Shard]</code><code>[[Shard]]</code> <code>Params</code> The parameters to add to the object buffer and expose to shaders, these default values can later be modified by the Params parameter in GFX.Material or GFX.Drawable. <code>none</code> <code>{GFX.Texture2D GFX.TextureCube Var(GFX.Buffer) [Float4](4) Float4 Float3 Float2 Float Int Int2 Int3 Int4 Var(GFX.Texture2D GFX.TextureCube Var(GFX.Buffer) [Float4](4) Float4 Float3 Float2 Float Int Int2 Int3 Int4) {Any}}</code><code>Var({GFX.Texture2D GFX.TextureCube Var(GFX.Buffer) [Float4](4) Float4 Float3 Float2 Float Int Int2 Int3 Int4 Var(GFX.Texture2D GFX.TextureCube Var(GFX.Buffer) [Float4](4) Float4 Float3 Float2 Float Int Int2 Int3 Int4) {Any}})</code> <code>BlockParams</code> Custom bindings to expose to shaders <code>none</code> <code>{Any}</code> <code>RequiredAttributes</code> The parameters to expose to shaders, these default values can later be overriden by materials or drawable Params <code>none</code> <code>[RequiredAttributes]</code> <code>UniqueVariables</code> List of variables that should be made unique <code>none</code> <code>[String]</code> <p>This shard creates a feature object based on what was provided in the different parameters.</p>"},{"location":"reference/shards/shards/GFX/Feature/#details","title":"Details","text":"<p>A Feature can be thought of as an extension or plugin to the rendering logic.</p> <p>A Feature may have various components:</p> <ul> <li>Blend State (Alpha, Additive, ...)</li> <li>Depth Testing</li> <li>Vertex/Fragment shaders</li> </ul> <p>For a more extensive description about shaders, see Shaders.</p> <p>Features can be used in various locations: - Attached to a GFX.DrawablePass - Attached to a GFX.EffectPass</p> <p> </p>"},{"location":"reference/shards/shards/GFX/MainWindow/","title":"GFX.MainWindow","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>&lt;output&gt;</code> <code>Object</code> <code>Title</code> The title of the window to create. <code>\"Shards Window\"</code> <code>String</code> <code>Width</code> The width of the window to create. In pixels and DPI aware. <code>1280</code> <code>Int</code> <code>Height</code> The height of the window to create. In pixels and DPI aware. <code>720</code> <code>Int</code> <code>Contents</code> The main input loop of this window. <code>none</code> <code>Shard</code><code>[Shard]</code> <code>DetachRenderer</code> When enabled, no default graphics renderer will be available in the contents wire. <code>false</code> <code>Bool</code> <code>HandleCloseEvent</code> When set to false; the close event will not be handled and abort the wire the window is running in. True by default. <code>true</code> <code>Bool</code> <code>UseDisplayScaling</code> When enabled, the window size will be scaled using the OS's provided scaling value. True by default. <code>true</code> <code>Bool</code>"},{"location":"reference/shards/shards/GFX/Material/","title":"GFX.Material","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input of this shard is ignored. <code>&lt;output&gt;</code> Outputs the material created as a material object. <code>GFX.Material</code> <code>Params</code> Shader parameters for this drawable <code>none</code> <code>{GFX.Texture2D GFX.TextureCube Var(GFX.Buffer) [Float4](4) Float4 Float3 Float2 Float Int Int2 Int3 Int4 Var(GFX.Texture2D GFX.TextureCube Var(GFX.Buffer) [Float4](4) Float4 Float3 Float2 Float Int Int2 Int3 Int4)}</code><code>Var({GFX.Texture2D GFX.TextureCube Var(GFX.Buffer) [Float4](4) Float4 Float3 Float2 Float Int Int2 Int3 Int4 Var(GFX.Texture2D GFX.TextureCube Var(GFX.Buffer) [Float4](4) Float4 Float3 Float2 Float Int Int2 Int3 Int4)})</code> <code>Features</code> Features to attach to this drawable <code>none</code> <code>[GFX.Feature]</code><code>Var([GFX.Feature])</code> <p>This shard creates a material from the given parameters and features.</p>"},{"location":"reference/shards/shards/GFX/Material/#details","title":"Details","text":""},{"location":"reference/shards/shards/GFX/Mesh/","title":"GFX.Mesh","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input table containing Vertices and Indices keys with the relevent values to construct the mesh object. <code>{Vertices: [Float2 Float3 Float4 Color] Indices: [Int]}</code> <code>&lt;output&gt;</code> The created mesh object. <code>GFX.Mesh</code> <code>Layout</code> The names for each vertex attribute. The sequence provided will also be the pattern that dictates how the sequence value of the Vertices key in the input table will be interpreted. <code>none</code> <code>[String]</code> <code>WindingOrder</code> Determines which side of the triangle is considered the front face. <code>none</code> <code>WindingOrder</code> <p>This shard creates a mesh object using the data provided in the Vertices and Indices keys of the input table.</p> <p> </p>"},{"location":"reference/shards/shards/GFX/MoveWindow/","title":"GFX.MoveWindow","text":"Name - Description Default Type <code>&lt;input&gt;</code> The position to move the window to. The first element represents the x-coordinate and the second represents the y-coordinate. <code>Int2</code> <code>&lt;output&gt;</code> Outputs the input value, passed through unchanged. <code>Int2</code> <code>Window</code> The window to move. <code>none</code> <code>Var(Object)</code> <p>This shard moves the window specified in the Window parameter to the position specified in the input.</p> <p> </p>"},{"location":"reference/shards/shards/GFX/QueueDrawables/","title":"GFX.QueueDrawables","text":"Name - Description Default Type <code>&lt;input&gt;</code> The drawable queue to retrieve the drawable objects from. <code>GFX.DrawQueue</code> <code>&lt;output&gt;</code> A sequence of drawable objects. <code>[GFX.Drawable]</code> <p>Retrieves the drawable objects from the input drawable queue and outputs it as a sequence of drawable objects.</p> <p> </p>"},{"location":"reference/shards/shards/GFX/ReadBuffer/","title":"GFX.ReadBuffer","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Any</code> <code>&lt;output&gt;</code> <code>Bool</code> <code>Buffer</code> The buffer to read <code>none</code> <code>Var(GFX.Buffer)</code> <code>Var</code> The variable to read the data into <code>none</code> <code>Var({Any})</code> <code>Wait</code> Wait for read to complete <code>false</code> <code>Bool</code> <p>Creates a new graphics buffer </p> <p> </p>"},{"location":"reference/shards/shards/GFX/ReadTexture/","title":"GFX.ReadTexture","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>GFX.Texture2D</code><code>GFX.TextureCube</code> <code>&lt;output&gt;</code> <code>Image</code> <code>Wait</code> Wait for read to complete <code>false</code> <code>Bool</code> <p>Adds a render step that reads back the rendered textures into a images, the returned images </p> <p> </p>"},{"location":"reference/shards/shards/GFX/Render/","title":"GFX.Render","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input of this shard is ignored. <code>&lt;output&gt;</code> This shard outputs none. <code>Steps</code> Sequence of render pass objects to process. <code>none</code> <code>Var([GFX.PipelineStep])</code><code>[GFX.PipelineStep]</code> <code>View</code> The view to render. If no view object is provided, the default view will be used. <code>none</code> <code>Var(GFX.View)</code> <p>This shard takes the sequence of render pass objects specified in the Steps parameter, processes it sequentially, and renders the final scene based on the view object specified in the View parameter.</p>"},{"location":"reference/shards/shards/GFX/Render/#details","title":"Details","text":"<p>This function should be used only once per rendered frame.</p> <p>It takes a View or sequence of Views that represent the main camera as a parameter.</p> Info <p>If neither <code>:View</code> nor <code>:Views</code> is specified, the renderer will use a default view with both identity view and projection matrices.</p> <p>The <code>:Steps</code> parameter contains the list of rendering operations to perform. This can be a sequence of objects created by one of the following:</p> <ul> <li>DrawablePass</li> <li>EffectPass</li> </ul>"},{"location":"reference/shards/shards/GFX/Render/#default-queue","title":"Default queue","text":"<p>If no render queue is specified, this command reads from a global default queue.</p>"},{"location":"reference/shards/shards/GFX/Render/#examples","title":"Examples","text":"CodeOutput <pre><code>(defshards spin-transform [t location]\n  t\n  (| (Math.Multiply 0.2) (Math.AxisAngleX) (Math.Rotation) &gt;= .rotX)\n  (| (Math.Multiply 0.7) (Math.AxisAngleY) (Math.Rotation) &gt;= .rotY)\n  (| (Math.Multiply 0.9) (Math.AxisAngleZ) (Math.Rotation) &gt;= .rotZ)\n  location (Math.Translation) (Math.MatMul .rotX) (Math.MatMul .rotY) (Math.MatMul .rotZ))\n\n(def timestep (/ 1.0 120.0))\n\n(GFX.MainWindow\n:Contents\n(-&gt;\n(Setup\n  ; Keep track of the time variable\n 0.0 &gt;= .time\n\n  ; Load the built-in cube mesh\n (GFX.BuiltinMesh :Type BuiltinMeshType.Cube) &gt;= .mesh\n\n  ; Declare transform variable\n (Float3 0 0 0) (Math.Translation) &gt;= .transform\n\n  ; The queue that will contain the draw commands (just the cube)\n  ; By default this queue it automatically cleared after it has been processed\n (GFX.DrawQueue) &gt;= .queue\n\n  ; Define a pass that renders the cube, with the built-in color and camera transform behaviour\n (GFX.BuiltinFeature BuiltinFeatureId.Transform) &gt;&gt; .features\n (GFX.BuiltinFeature  BuiltinFeatureId.BaseColor) &gt;&gt; .features\n (GFX.DrawablePass :Features .features :Queue .queue) &gt;&gt; .render-steps\n\n  ; Setup the camera\n {:Position (Float3 0 0 8) :Target (Float3 0 0 0)} (Math.LookAt) &gt;= .view-transform\n (GFX.View :View .view-transform) &gt;= .view)\n\n; Rotate the cube's transform\n.time (Math.Add timestep) &gt; .time\n(spin-transform .time (Float3 0.0 0 0))\n\n; Update and retrieve the drawable\n; Note that the transform is the input \n(GFX.Drawable :Mesh .mesh :Params {:baseColor (Float4 0 1 0 1)}) &gt;= .drawable\n\n; Add drawable to the queue\n.drawable (GFX.Draw .queue)\n\n; Render everyghing\n(GFX.Render :View .view :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/GFX/RenderInto/","title":"Macro Syntax Error","text":"<p>File: <code>reference/shards/shards/GFX/RenderInto.md</code></p> <p>Line 8 in Markdown file: unexpected '}' <pre><code>| `Textures` | :fontawesome-solid-circle-plus:{title=\"Optional\"}  | The textures to render into to create. | `none` | [`{{Any} Var(GFX.Texture2D)}`](../../types/#table) |\n</code></pre></p>"},{"location":"reference/shards/shards/GFX/RenderTarget/","title":"GFX.RenderTarget","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Any</code> <code>&lt;output&gt;</code> <code>GFX.RenderTarget</code> <code>Attachments</code> The list of attachements to create. <code>none</code> <code>{{ String }}</code> <p>Groups a collection of textures into a render target that can be rendered into</p> <p> </p>"},{"location":"reference/shards/shards/GFX/RenderTargetTexture/","title":"GFX.RenderTargetTexture","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>GFX.RenderTarget</code> <code>&lt;output&gt;</code> <code>GFX.Texture2D</code> <code>Name</code> Name of the attachment to retrieve <code>none</code> <code>String</code> <p>Retrieve a named attachment from a render target</p> <p> </p>"},{"location":"reference/shards/shards/GFX/Renderer/","title":"GFX.Renderer","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Any</code> <code>&lt;output&gt;</code> <code>Any</code> <code>Window</code> The window to run the renderer on. <code>none</code> <code>Var(Object)</code> <code>Contents</code> The main input loop of this window. <code>none</code> <code>Shard</code><code>[Shard]</code> <code>IgnoreCompilationErrors</code> When enabled, shader or pipeline compilation errors will be ignored and either use fallback rendering or not render at all. <code>false</code> <code>Bool</code> <code>Debug</code> Enable debug visualization mode. <code>none</code> <code>Bool</code><code>Var(Bool)</code>"},{"location":"reference/shards/shards/GFX/ResizeWindow/","title":"GFX.ResizeWindow","text":"Name - Description Default Type <code>&lt;input&gt;</code> The size to resize the window to. The first element represents the width and the second represents the height. <code>Int2</code> <code>&lt;output&gt;</code> Outputs the input value, passed through unchanged. <code>Int2</code> <code>Window</code> The window to resize <code>none</code> <code>Var(Object)</code> <p>This shard resizes the window specified in the Window parameter to the dimensions specified in the input.</p> <p> </p>"},{"location":"reference/shards/shards/GFX/Texture/","title":"GFX.Texture","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Image</code><code>Any</code> <code>&lt;output&gt;</code> <code>GFX.Texture2D</code><code>GFX.TextureCube</code> <code>InterpretAs</code> Type to interpret image data as. (From image only, Default: UNormSRGB for RGBA8 images, UNorm for other formats) <code>none</code> <code>TextureType</code> <code>Format</code> The format to use to create the texture. The texture will be usable as a render target. (Render target only) <code>none</code> <code>TextureFormat</code><code>Var(TextureFormat)</code> <code>Resolution</code> The resolution of the texture to create. (Render target only) <code>none</code> <code>Int2</code><code>Var(Int2)</code> <code>MipLevels</code> The number of mip levels to create. (Render target only) <code>none</code> <code>Int</code><code>Var(Int)</code> <code>Dimension</code> The type of texture to create. (Render target only) <code>none</code> <code>TextureDimension</code> <code>Addressing</code> For sampling, sets the address modes. <code>none</code> <code>TextureAddressing</code><code>[TextureAddressing]</code> <code>Filtering</code> For sampling, sets the filter mode. <code>none</code> <code>TextureFiltering</code> <code>Label</code> Debug label for this object. <code>none</code> <code>String</code><code>Var(String)</code> <p>Creates a texture from an image. Or as a render target</p> <p> </p>"},{"location":"reference/shards/shards/GFX/UIPass/","title":"GFX.UIPass","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input of this shard is ignored. <code>&lt;output&gt;</code> The render pass object. <code>GFX.PipelineStep</code> <code>Queue</code> The drawables queue to get the UI drawable objects from. <code>none</code> <code>Var(GFX.DrawQueue)</code> <code>Name</code> A name for this pass, to aid in debugging <code>none</code> <code>String</code> <p>This shard creates a render pass object designed for rendering UI using the UI drawable objects from the drawables queue specified in the Queue parameter.</p>"},{"location":"reference/shards/shards/GFX/UIPass/#details","title":"Details","text":"<p>Defines a render step for rendering UI.</p> <p>Check the examples on some of the UI shards for how to use this step, for example UI.Label</p> <p> </p>"},{"location":"reference/shards/shards/GFX/UIScaleFactor/","title":"GFX.UIScaleFactor","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>&lt;output&gt;</code> <code>Float</code> <code>Window</code> The window to get the UI scaling factor of. <code>none</code> <code>Var(Object)</code> <p>Outputs the scaling factor for UI as determined by the operating system.</p> <p> </p>"},{"location":"reference/shards/shards/GFX/View/","title":"GFX.View","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input of this shard is ignored. <code>Any</code> <code>&lt;output&gt;</code> The view object created. <code>GFX.View</code> <code>View</code> The view matrix. <code>none</code> <code>Var([Float4](4))</code> <code>Fov</code> The vertical field of view. (In radians. Implies perspective projection) <code>none</code> <code>Float</code><code>Var(Float)</code> <code>OrthographicSizeType</code> The type of orthographic size. (Implies orthographic projection) <code>none</code> <code>OrthographicSizeType</code> <code>OrthographicSize</code> The orthographic size. (Implies orthographic projection) <code>none</code> <code>Float</code><code>Var(Float)</code> <code>Near</code> Near clipping distance <code>none</code> <code>Float</code><code>Var(Float)</code> <code>Far</code> Far clipping distance <code>none</code> <code>Float</code><code>Var(Float)</code> <p>This shard creates and manages a view object, which defines and controls the view or camera settings for a rendering pipeline.</p> <p> </p>"},{"location":"reference/shards/shards/GFX/ViewMatrix/","title":"GFX.ViewMatrix","text":"Name - Description Default Type <code>&lt;input&gt;</code> A view object created by GFX.View. <code>GFX.View</code> <code>&lt;output&gt;</code> A 4x4 matrix representing the view object's view matrix. <code>[Float4](4)</code> <p>This shard takes the input view object and outputs its view matrix, which represents the camera's position and orientation in the world space.</p> <p> </p>"},{"location":"reference/shards/shards/GFX/ViewProjectionMatrix/","title":"GFX.ViewProjectionMatrix","text":"Name - Description Default Type <code>&lt;input&gt;</code> A view object created by GFX.View. <code>GFX.View</code> <code>&lt;output&gt;</code> A 4x4 matrix representing the view object's combined view-projection matrix. <code>[Float4](4)</code> <code>ViewSize</code> The size of the screen this view is being used with <code>none</code> <code>Float2</code><code>Var(Float2)</code> <p>This shard takes the input view object and outputs its combined view-projection matrix, which encapsulates both the view position and orientation(view matrix) and its orthographic projection(projection matrix).</p> <p> </p>"},{"location":"reference/shards/shards/GFX/ViewRange/","title":"GFX.ViewRange","text":"Name - Description Default Type <code>&lt;input&gt;</code> A view object created by GFX.View. <code>GFX.View</code> <code>&lt;output&gt;</code> A float2 representing the view's near and far clipping range. <code>Float2</code> <p>This shard takes the input view object and outputs a float2 representing the view's near and far clipping range. The first value in the float2 represents the near clipping range while the second value represents the far clipping range.</p> <p> </p>"},{"location":"reference/shards/shards/GFX/Viewport/","title":"GFX.Viewport","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input of this shard is ignored. <code>&lt;output&gt;</code> Outputs the dimensions of the current viewport as an int4. <code>Int4</code> <p>This shard outputs the dimensions of the current viewport as an int4</p> <p> </p>"},{"location":"reference/shards/shards/GFX/WindowInsets/","title":"GFX.WindowInsets","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input of this shard is ignored. <code>&lt;output&gt;</code> The window inset values as a float4. <code>Float4</code> <code>Window</code> The window to get the insets of. <code>none</code> <code>Var(Object)</code> <p>Retrieves the window inset values when rendering on mobile devices and screens with a keep-out area.</p> <p> </p>"},{"location":"reference/shards/shards/GFX/WindowPosition/","title":"GFX.WindowPosition","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input of this shard is ignored. <code>&lt;output&gt;</code> Outputs the position of the window as an int2. The first element represents the x-coordinate and the second represents the y-coordinate. <code>Int2</code> <code>Window</code> The window to get the position of. <code>none</code> <code>Var(Object)</code> <p>This shard outputs the position of the window specified in the Window parameter.</p> <p> </p>"},{"location":"reference/shards/shards/GFX/WindowSize/","title":"GFX.WindowSize","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input of this shard is ignored. <code>&lt;output&gt;</code> Outputs the dimensions of the window as an int2. The first element represents the width and the second represents the height. <code>Int2</code> <code>Window</code> The window to get the size of. <code>none</code> <code>Var(Object)</code> <p>This shard outputs the dimensions of the window specified in the Window parameter.</p> <p> </p>"},{"location":"reference/shards/shards/GFX/WriteBuffer/","title":"GFX.WriteBuffer","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Any</code> <code>&lt;output&gt;</code> <code>Any</code> <code>Buffer</code> The buffer <code>none</code> <code>Var(GFX.Buffer)</code> <code>RuntimeLength</code> The length of the runtime sized array of the buffer, if any <code>none</code> <code>Int</code><code>Var(Int)</code> <p>Creates a new graphics buffer </p> <p> </p>"},{"location":"reference/shards/shards/GFX/glTF/","title":"GFX.glTF","text":"Name - Description Default Type <code>&lt;input&gt;</code> This shard can take 2 different types of input. It can take a 4x4 transformation for the glTF model to adopt. Or, it can accept a table which contain the transformation matrix and additional information to modify the materials of the glTF model. <code>[Float4](4)</code><code>{transform: [Float4](4) none: Any}</code> <code>&lt;output&gt;</code> Outputs the drawable object. <code>GFX.Drawable</code> <code>Path</code> The path to load the model from <code>none</code> <code>String</code><code>Var(String)</code> <code>Bytes</code> The bytes to load the model from <code>none</code> <code>Bytes</code><code>Var(Bytes)</code> <code>Copy</code> Reference to another glTF model to copy <code>none</code> <code>Var(GFX.Drawable)</code> <code>Params</code> Shader parameters for this drawable <code>none</code> <code>{GFX.Texture2D GFX.TextureCube Var(GFX.Buffer) [Float4](4) Float4 Float3 Float2 Float Int Int2 Int3 Int4 Var(GFX.Texture2D GFX.TextureCube Var(GFX.Buffer) [Float4](4) Float4 Float3 Float2 Float Int Int2 Int3 Int4)}</code><code>Var({GFX.Texture2D GFX.TextureCube Var(GFX.Buffer) [Float4](4) Float4 Float3 Float2 Float Int Int2 Int3 Int4 Var(GFX.Texture2D GFX.TextureCube Var(GFX.Buffer) [Float4](4) Float4 Float3 Float2 Float Int Int2 Int3 Int4)})</code> <code>Features</code> Features to attach to this drawable <code>none</code> <code>[GFX.Feature]</code><code>Var([GFX.Feature])</code> <code>AnimationController</code> The animation controller <code>none</code> <code>Shard</code><code>[Shard]</code> <code>WrapRootNode</code> Wrap the root node so animations applied to it still work <code>none</code> <code>Bool</code> <p>This shard takes the glTF model (specified either in the Path, Bytes or Copy parameter) and outputs a drawable object which can be subsequently added to the drawables queue for the render pipline.</p>"},{"location":"reference/shards/shards/GFX/glTF/#details","title":"Details","text":"<p>Loads a glTF model from a file. Outputs a <code>GFX.DrawableHierarchy</code> that can be passed to Draw.</p>"},{"location":"reference/shards/shards/GFX/glTF/#static-file","title":"Static file","text":"<p>Loaded when the Wire containing it is warmed up.</p> <pre><code>{:Transform ...} (GFX.glTF :Path \"pathToModel.glb\") &gt;= .drawable\n</code></pre>"},{"location":"reference/shards/shards/GFX/glTF/#dynamic-file","title":"Dynamic file","text":"<p>Loaded when activated. You should cache the result inside a Setup shard.</p> <pre><code>{:Transform ... :Path .path} (GFX.glTF) &gt;= .drawable\n</code></pre>"},{"location":"reference/shards/shards/GFX/glTF/#raw-bytes","title":"Raw bytes","text":"<p>Loaded when activated. You should cache the result inside a Setup shard.</p> <pre><code>{:Transform ... :Bytes .gltf-data} (GFX.glTF) &gt;= .drawable\n</code></pre>"},{"location":"reference/shards/shards/GFX/glTF/#duplicate-existing-model","title":"Duplicate existing model","text":"<p>Experimental/unstable</p> <p>This API is experimental and might produce unexpected results or crash.</p> <p>Generate another <code>GFX.DrawableHierarchy</code> from an existing <code>GFX.DrawableHierarchy</code></p> <pre><code>... (GFX.glTF ...) &gt;= .other-gltf-drawable\n{:Transform ... :Copy .other-gltf-drawable} (GFX.glTF) &gt;= .drawable\n</code></pre> <p> </p>"},{"location":"reference/shards/shards/GLTF/PackGLB/","title":"GLTF.PackGLB","text":"Name - Description Default Type <code>&lt;input&gt;</code> Path to the glTF file to convert. <code>String</code> <code>&lt;output&gt;</code> Outputs the GLB bytes of the converted glTF file. <code>Bytes</code> <p>This shard takes the glTF file (specified by the input file path) and converts it into GLB format.</p> <p> </p>"},{"location":"reference/shards/shards/GUI/","title":"GUI","text":"<p>Obsolete</p> <p>This API is obsolete and might be removed at any time. Consider using <code>UI</code> instead.</p> <p> </p>"},{"location":"reference/shards/shards/General/Abs/","title":"Abs","text":"Name - Description Default Type <code>&lt;input&gt;</code> The numeric value or a sequence of numeric values to get the absolute value of. <code>Int</code><code>Int2</code><code>Int3</code><code>Int4</code><code>Int8</code><code>Int16</code><code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <code>&lt;output&gt;</code> Outputs the absolute value of the input. <code>Int</code><code>Int2</code><code>Int3</code><code>Int4</code><code>Int8</code><code>Int16</code><code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <p>This shard outputs the absolute value of the input.</p> <p> </p>"},{"location":"reference/shards/shards/General/Acos/","title":"Acos","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input float or sequence of floats to calculate the inverse cosine of. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <code>&lt;output&gt;</code> Outputs the angle in radians whose cosine is the input value. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <p>This shard calculates the inverse cosine of the given input, where the input is the cosine value. The output is the angle in radians whose cosine is the input value.</p> <p> </p>"},{"location":"reference/shards/shards/General/Add/","title":"Add","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value or the sequence of values to add the value specified in the Operand parameter to. <code>Int</code><code>Int2</code><code>Int3</code><code>Int4</code><code>Int8</code><code>Int16</code><code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <code>&lt;output&gt;</code> This shard outputs the result of the addition. <code>Int</code><code>Int2</code><code>Int3</code><code>Int4</code><code>Int8</code><code>Int16</code><code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <code>Operand</code> The value or sequence of values to add to the input. <code>0</code> <code>Int</code><code>Var(Int)</code><code>Int2</code><code>Var(Int2)</code><code>Int3</code><code>Var(Int3)</code><code>Int4</code><code>Var(Int4)</code><code>Int8</code><code>Var(Int8)</code><code>Int16</code><code>Var(Int16)</code><code>Float</code><code>Var(Float)</code><code>Float2</code><code>Var(Float2)</code><code>Float3</code><code>Var(Float3)</code><code>Float4</code><code>Var(Float4)</code><code>Color</code><code>Var(Color)</code><code>[Any]</code><code>Var([Any])</code> <p>This shard adds the input value to the value provided in the Operand parameter.</p> <p> </p>"},{"location":"reference/shards/shards/General/And/","title":"And","text":"Name - Description Default Type <code>&lt;input&gt;</code> If true, the flow continues; otherwise, it stops. <code>Bool</code> <code>&lt;output&gt;</code> The output of this shard will be the input of the current conditional flow or wire. <code>Bool</code> <p>If the input of the preceding shard is true, the flow continues; otherwise, the flow stops. This shard is typically used within conditional flows (e.g., If, When) to chain conditions. Note: Outside a conditional flow, it might restart the current wire, which can be used as a trick in certain scenarios.</p>"},{"location":"reference/shards/shards/General/And/#examples","title":"Examples","text":"CodeOutput <pre><code>false (And) false\n(Assert.Is false :Break true)\n\nfalse (And) true\n(Assert.Is false :Break true)\n\ntrue (And) false\n(Assert.Is false :Break true)\n\ntrue (And) true\n(Assert.Is true :Break true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/General/AppendTo/","title":"AppendTo","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value to append to the collection. <code>Any</code> <code>&lt;output&gt;</code> The input to this shard is passed through as its output. <code>Any</code> <code>Collection</code> The collection to add the input to. <code>none</code> <code>Var([Any])</code><code>Var(String)</code><code>Var(Bytes)</code> <p>Appends the input to the context variable passed to <code>:Collection</code>.</p>"},{"location":"reference/shards/shards/General/AppendTo/#details","title":"Details","text":"<p><code>AppendTo</code> appends (i.e., adds to the end) its input to the variable it receives in its <code>:Collection</code> parameter. </p> <p>This shard works on string and sequence variables.</p> <p>The input to this shard is also passed through as its output.</p> <p>See also</p> <ul> <li><code>Drop</code></li> <li><code>Pop</code></li> <li><code>Push</code></li> <li><code>Set</code></li> <li><code>Update</code></li> </ul>"},{"location":"reference/shards/shards/General/AppendTo/#examples","title":"Examples","text":"CodeOutput <pre><code>;; append element to sequence\n[1 2 3] &gt;= .seq\n4 (AppendTo .seq)    ;; appends element to sequence\n.seq (Log)           ;; updated sequence =&gt; [1, 2, 3, 4]\n\n;; append character to string\n\"Hell\" &gt;= .str\n\"o\" (AppendTo .str)  ;; appends character to string\n.str (Log)           ;; updated string =&gt; Hello\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/General/Asin/","title":"Asin","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input float or sequence of floats to calculate the inverse sine of. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <code>&lt;output&gt;</code> Outputs the angle in radians whose sine is the input value. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <p>This shard calculates the inverse sine of the given input, where the input is the sine value. The output is the angle in radians whose sine is the input value.</p> <p> </p>"},{"location":"reference/shards/shards/General/Assoc/","title":"Assoc","text":"Name - Description Default Type <code>&lt;input&gt;</code> Input sequence that defines which element in the target sequence or table needs to be updated and with what value. Should have even number of elements. <code>[Any]</code> <code>&lt;output&gt;</code> Modified array or table. Has the same type as the array or table on which Assoc was applied. <code>[Any]</code> <code>Name</code> The name of the sequence or table to be updated. <code>\"\"</code> <code>String</code><code>Var(Any)</code> <code>Key</code> Table key for the value that is to be updated. Parameter applicable if target is table. <code>none</code> <code>Any</code> <code>Global</code> If the variable is or should be available to all the wires in the same mesh. The default value (false) makes the variable local to the wire. <code>false</code> <code>Bool</code> <p>Updates a sequence (array) or a table (associative array/ dictionary) on the basis of an input sequence.</p>"},{"location":"reference/shards/shards/General/Assoc/#details","title":"Details","text":"<p>This shard can be used to update specific member elements within a sequence or a table with new values.</p> <p>The input sequence identifies which elements are to be updated and their new/ updated values. To achieve this, the member elements of this input sequence are parsed in pairs. The 1st element of each pair gives the index of the target element to update, and the 2nd element of that pair gives the new value for the target element. Due to this, the input sequence must always contain an even number of elements.</p>"},{"location":"reference/shards/shards/General/Assoc/#examples","title":"Examples","text":"CodeOutput <pre><code>;; Update a sequence (needs to be mutable!)\n[10 20] &gt;= .sequence\n(Log) ;; prints original target sequence =&gt; [10 20]\n[0 2 1 3] (Assoc .sequence) ;; input sequence updates target sequence [index-0 ele =&gt; 2, index-1 ele =&gt; 3]\n.sequence (Log) ;; prints updated target sequence =&gt; [2 3] \n.sequence (Assert.Is [2 3] true)\n</code></pre> <pre><code>\n</code></pre> CodeOutput <pre><code>;; Update a global-var table (Global = true; table available to all the wires in the same mesh)\n{:key1 [10 20] :key2 [30 40]} (Set .tableG :Global true)\n(Log) ;; prints original table =&gt; {:key1 [10 20] :key2 [30 40]}\n[0 2 1 3] (Assoc .tableG \"key1\") ;; input sequence updates value of key \"key1\" in table\n.tableG (Log) ;; prints updated table =&gt; {:key1 [2 3] :key2 [30 40]}\n.tableG (Assert.Is {:key1 [2 3] :key2 [30 40]} true)\n</code></pre> <pre><code>\n</code></pre> CodeOutput <pre><code>;; Update a local-variable table (:Global = false, table available to only this wire in the mesh)\n{:key1 [10 20] :key2 [30 40]} &gt;= .table ; (needs to be mutable!)\n(Log) ;; prints original table =&gt; {:key1 [10 20] :key2 [30 40]}\n[0 2 1 3] (Assoc .table \"key2\") ;; input sequence updates value of key \"key2\" in table\n.table (Log) ;; prints updated table =&gt; {:key1 [10 20] :key2 [2 3]}\n.table (Assert.Is {:key1 [10 20] :key2 [2 3]} true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/General/Atan/","title":"Atan","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input float or sequence of floats to calculate the inverse tangent of. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <code>&lt;output&gt;</code> Outputs the angle in radians whose tangent is the input value. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <p>This shard calculates the inverse tangent of the given input, where the input is the tangent value. The output is the angle in radians whose tangent is the input value.</p> <p> </p>"},{"location":"reference/shards/shards/General/Await/","title":"Await","text":"Name - Description Default Type <code>&lt;input&gt;</code> Must match the input types of the first shard in the sequence. <code>Any</code> <code>&lt;output&gt;</code> Will match the output types of the first shard of the sequence. <code>Any</code> <code>Shards</code> The shards to activate. <code>none</code> <code>Shard</code><code>[Shard]</code> <p>Executes a shard or a sequence of shards asynchronously and awaits their completion.</p>"},{"location":"reference/shards/shards/General/Await/#details","title":"Details","text":"<p><code>(Await)</code> runs its shards (or sequence of shards) as a separate task that is sent directly to the thread pool, while the rest of the program continues executing (via other scheduled threads). Once this <code>(Await)</code> task thread completes its execution the result of the execution of these inner shards is made available to the program.</p> <p>This is called asynchronous computation and is used to prevent resource intensive processing (like downloading a large file data from an http server) from holding up the execution of the rest of the program.</p> <p>Note</p> <p><code>(Await)</code> has an alias <code>(||)</code> which is more convenient to use. <code>||</code> also removes the need to use <code>(-&gt;)</code> as, unlike <code>(Await)</code>, it doesn't require the parameter shards to be grouped together.</p>"},{"location":"reference/shards/shards/General/Await/#examples","title":"Examples","text":"CodeOutput <pre><code>;; Asynchronous execution of shards (using keyword `Await`)\n;; Printing order of messages not consistent across program runs --\n;; -- as asynchronous shards might complete at different times\n(defmesh mesh)\n\n(defloop await-wire\n(Await\n  ;:Shards\n  (-&gt;\n    (Msg \"Message 1\")\n    ;; messages might print in any order (1/2/3, 1/3/2, 3/2/1, etc.)\n    (Msg \"Message 2\")\n    ;; messages might print in any order (1/2/3, 1/3/2, 3/2/1, etc.)\n  )))\n\n(defloop my-wire\n    (Msg \"Message 3\")\n    ;; messages might print in any order (1/2/3, 1/3/2, 3/2/1, etc.)\n    )\n\n(schedule mesh await-wire)\n(schedule mesh my-wire)\n(run mesh 1 1)\n</code></pre> <pre><code>\n</code></pre> CodeOutput <pre><code>;; Asynchronous execution of shards (using alias `||`)\n;; Printing order of messages not consistent across program runs --\n;; -- as asynchronous shards might complete at different times\n(defmesh mesh)\n\n(defloop await-wire\n(||\n  ;:Shards\n    (Msg \"Message 1\")\n    ;; messages might print in any order (1/2/3, 1/3/2, 3/2/1, etc.)\n    (Msg \"Message 2\")\n    ;; messages might print in any order (1/2/3, 1/3/2, 3/2/1, etc.)\n  ))\n\n(defloop my-wire\n    (Msg \"Message 3\")\n    ;; messages might print in any order (1/2/3, 1/3/2, 3/2/1, etc.)\n    )\n\n(schedule mesh await-wire)\n(schedule mesh my-wire)\n(run mesh 1 1)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/General/BigInt/","title":"BigInt","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input value to convert to a big integer. <code>Int</code><code>Float</code><code>String</code><code>Bytes</code> <code>&lt;output&gt;</code> Big integer represented as bytes. <code>Bytes</code> <p>Converts various input types to a big integer represented as bytes. Big integers are signed and can be of arbitrary size. This allows for users to work with numbers that are too large to be represented by standard integer types.</p> <p> </p>"},{"location":"reference/shards/shards/General/BitSwap32/","title":"BitSwap32","text":"Name - Description Default Type <code>&lt;input&gt;</code> Takes a 32-bit integer value. <code>Int</code> <code>&lt;output&gt;</code> Outputs the reversed bytes as an integer. <code>Int</code> <p>This shard takes a 32-bit integer, reverses their order of its bytes, and outputs the result as an integer. This is useful for converting between different endianness formats.</p> <p> </p>"},{"location":"reference/shards/shards/General/BitSwap64/","title":"BitSwap64","text":"Name - Description Default Type <code>&lt;input&gt;</code> Takes a 64-bit integer value. <code>Int</code> <code>&lt;output&gt;</code> Outputs the reversed bytes as an integer. <code>Int</code> <p>This shard takes a 64-bit integer, reverses their order of its bytes, and outputs the result as an integer. This is useful for converting between different endianness formats.</p> <p> </p>"},{"location":"reference/shards/shards/General/Branch/","title":"Branch","text":"Name - Description Default Type <code>&lt;input&gt;</code> Any input type is accepted. The input value will pass through unchanged. <code>Any</code> <code>&lt;output&gt;</code> Outputs the input value, passed through unchanged. <code>Any</code> <code>Wires</code> The Wires to schedule and run on this branch. <code>none</code> <code>Wire</code><code>[Wire]</code> <code>FailureBehavior</code> The policy to take when some of the Wires running on this branch fail. <code>BranchFailure::Everything</code> <code>BranchFailure</code> <code>CaptureAll</code> If all of the existing variables should be copied onto the branch created, regardless if they are used or not. <code>false</code> <code>Bool</code> <code>Mesh</code> The Behavior to branch from. If none provided, it will branch from the Behavior that the current Wire is on. <code>Mesh 0x0000018354DD9E20</code> <code>Mesh</code> <p>Creates a branch from the specified Behavior and schedules all the Wires specified. Every time this shard is called, it will progress the state of all the Wires specified asynchronously and continue execution of the current Wire. This shard is like a mass Step, where it Steps all the Wires specified.</p>"},{"location":"reference/shards/shards/General/Branch/#examples","title":"Examples","text":"CodeOutput <pre><code>(defwire c1\n  .msg1 (Log))\n\n(defwire c2\n  .msg2 (Log))\n\n(defwire branch\n  \"Hello\" = .msg1\n  \"World\" = .msg2\n  (Branch [c1 c2]))\n\n(Do branch)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/General/Broadcast/","title":"Broadcast","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Any</code> <code>&lt;output&gt;</code> <code>Any</code> <code>Name</code> The name of the channel. <code>\"\"</code> <code>String</code> <code>Type</code> The optional explicit (and unsafe because of that) we produce. <code>none</code> <code>Type</code>"},{"location":"reference/shards/shards/General/Browse/","title":"Browse","text":"Name - Description Default Type <code>&lt;input&gt;</code> The URL to navigate to. <code>String</code> <code>&lt;output&gt;</code> Outputs the input value, passed through unchanged. <code>String</code> <p>This shard will open the URL string input in the current system's default web browser.</p> <p> </p>"},{"location":"reference/shards/shards/General/BytesBuffer/","title":"BytesBuffer","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Int</code> <code>&lt;output&gt;</code> <code>Bytes</code>"},{"location":"reference/shards/shards/General/BytesToInts/","title":"BytesToInts","text":"Name - Description Default Type <code>&lt;input&gt;</code> Takes a byte array as input. <code>Bytes</code> <code>&lt;output&gt;</code> Outputs the input bytes represented as a sequence of integers. <code>[Int]</code> <p>Convert bytes into a sequence of integers. Each byte is interpreted as an integer and stored in the sequence.</p> <p> </p>"},{"location":"reference/shards/shards/General/BytesToString/","title":"BytesToString","text":"Name - Description Default Type <code>&lt;input&gt;</code> Accepts a byte array as input. Each byte in the sequence is interpreted as a character. <code>Bytes</code> <code>&lt;output&gt;</code> The output is a string created from the input sequence of bytes. <code>String</code> <p>Converts a sequence of bytes into a string. Each byte in the sequence is interpreted as a character in the resulting string.</p> <p> </p>"},{"location":"reference/shards/shards/General/CaptureLog/","title":"CaptureLog","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input is ignored. This shard captures log messages based on specified parameters. <code>&lt;output&gt;</code> A sequence of captured log messages. <code>[String]</code> <code>Size</code> The maximum number of logs to retain. <code>8</code> <code>Int</code> <code>MinLevel</code> The minimum level of logs to capture. <code>\"debug\"</code> <code>String</code> <code>Pattern</code> The pattern used to format the logs. <code>\"%^[%l]%$ [%Y-%m-%d %T.%e] [T-%t] [%s::%#] %v\"</code> <code>String</code> <code>Suspend</code> Suspend execution until new logs are available. <code>false</code> <code>Bool</code> <p>Captures log messages based on specified parameters, such as the number of messages to retain, the minimum log level, and the log format pattern. It can optionally suspend execution until new log messages are available.</p>"},{"location":"reference/shards/shards/General/CaptureLog/#examples","title":"Examples","text":"CodeOutput <pre><code>(Msg \"Hello shards!\")\n(CaptureLog\n :Size 24\n :MinLevel \"info\"\n :Pattern \"%^[%l]%$ [%Y-%m-%d %T.%e] %v\")\n(ExpectStringSeq)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/General/Ceil/","title":"Ceil","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input float or sequence of floats to round up. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <code>&lt;output&gt;</code> Outputs the input rounded up to the nearest integer (as a float). <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <p>This shard rounds up the input to the nearest integer.</p> <p> </p>"},{"location":"reference/shards/shards/General/Clamp/","title":"Clamp","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value to clamp. <code>Int</code><code>Int2</code><code>Int3</code><code>Int4</code><code>Int8</code><code>Int16</code><code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code> <code>&lt;output&gt;</code> The clamped value. <code>Int</code><code>Int2</code><code>Int3</code><code>Int4</code><code>Int8</code><code>Int16</code><code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code> <code>Min</code> The lower bound of the range <code>none</code> <code>Int</code><code>Var(Int)</code><code>Int2</code><code>Var(Int2)</code><code>Int3</code><code>Var(Int3)</code><code>Int4</code><code>Var(Int4)</code><code>Int8</code><code>Var(Int8)</code><code>Int16</code><code>Var(Int16)</code><code>Float</code><code>Var(Float)</code><code>Float2</code><code>Var(Float2)</code><code>Float3</code><code>Var(Float3)</code><code>Float4</code><code>Var(Float4)</code><code>Color</code><code>Var(Color)</code><code>[Any]</code><code>Var([Any])</code> <code>Max</code> The upper bound of the range <code>none</code> <code>Int</code><code>Var(Int)</code><code>Int2</code><code>Var(Int2)</code><code>Int3</code><code>Var(Int3)</code><code>Int4</code><code>Var(Int4)</code><code>Int8</code><code>Var(Int8)</code><code>Int16</code><code>Var(Int16)</code><code>Float</code><code>Var(Float)</code><code>Float2</code><code>Var(Float2)</code><code>Float3</code><code>Var(Float3)</code><code>Float4</code><code>Var(Float4)</code><code>Color</code><code>Var(Color)</code><code>[Any]</code><code>Var([Any])</code> <p>This shard ensures the input value falls within the specified range. If the value falls below the minimum, the Min value is returned. If the value exceeds the maximum, the Max value is returned. Otherwise, the value is returned unchanged.</p> <p> </p>"},{"location":"reference/shards/shards/General/Clear/","title":"Clear","text":"Name - Description Default Type <code>&lt;input&gt;</code> Any input is ignored. <code>Any</code> <code>&lt;output&gt;</code> The input is passed through as the output. <code>Any</code> <code>Name</code> The name of the variable. <code>\"\"</code> <code>String</code><code>Var(Any)</code> <code>Key</code> The key of the value to read from the table (parameter applicable only if the target variable is a table). <code>none</code> <code>Any</code> <code>Global</code> If the variable is available to all of the wires in the same mesh. <code>false</code> <code>Bool</code> <p>Clears all elements from the sequence or table passed to it. Applicable only to sequences and tables. For sequences, this operation is very fast as Shards recycles memory extensively. If the variable does not exist or the type is not a sequence or table, it simply passes through without failing.</p>"},{"location":"reference/shards/shards/General/Clear/#details","title":"Details","text":"<p><code>Clear</code> removes all the elements of the sequence that has been passed to it in the <code>:Name</code> parameter.</p> <p>This shard works on both sequences and tables. Parameter <code>:Key</code> applies only to tables.</p> <p>Since variables may be locally scoped (created with <code>(:Global false)</code>; exists only for current wire) or globally scoped (created with <code>(:Global true)</code>; exists for all wires of that mesh), both parameters <code>:Global</code> and <code>:Name</code> are used in combination to identify the correct variable to clear. </p> <p>Any input to this shard is ignored and instead passed through as its output.</p> <p>See also</p> <ul> <li><code>Drop</code></li> <li><code>DropFront</code></li> <li><code>Erase</code></li> <li><code>Pop</code></li> <li><code>PopFront</code></li> <li><code>Remove</code></li> </ul>"},{"location":"reference/shards/shards/General/Clear/#examples","title":"Examples","text":"CodeOutput <pre><code>[1 2 3] &gt;= .seq                     ;; create local sequence\n[4 5 6] &gt;== .seq                    ;; create global sequence with same name\n\n(Get .seq) (Log)                    ;; read local sequence  =&gt; [1, 2, 3]\n(Get .seq :Global true) (Log)       ;; read global sequence =&gt; [4, 5, 6]\n\n;; clear local sequence\n(Clear :Name .seq)                  ;; clear local sequence\n(Get .seq) (Log)                    ;; local sequence cleared =&gt; []  \n(Get .seq :Global true) (Log)       ;; same-name global sequence intact =&gt; [4, 5, 6]  \n\n100 (AppendTo .seq)                 ;; append something to local sequence\n(Get .seq) (Log)                    ;; local sequence no more empty =&gt; [100]\n\n;; clear the same-named global sequence\n(Clear :Name .seq :Global true )    ;; clear global sequence\n(Get .seq :Global true) (Log)       ;; global sequence cleared =&gt; []\n(Get .seq) (Log)                    ;; local sequence intact =&gt; [100]  \n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/General/Comment/","title":"Comment","text":"Name - Description Default Type <code>&lt;input&gt;</code> Input is ignored. <code>Any</code> <code>&lt;output&gt;</code> Passes the input value through. <code>Any</code> <code>Text</code> The comment's text. <code>\"\"</code> <code>String</code> <p>A comment shard that does nothing.</p> <p> </p>"},{"location":"reference/shards/shards/General/Complete/","title":"Complete","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Any</code> <code>&lt;output&gt;</code> <code>Any</code> <code>Name</code> The name of the channel. <code>\"\"</code> <code>String</code>"},{"location":"reference/shards/shards/General/Cond/","title":"Cond","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value that will be passed to each predicate and action to execute. <code>Any</code> <code>&lt;output&gt;</code> The input of the shard if <code>Passthrough</code> is <code>true</code>; otherwise, the output of the action of the first matching condition. <code>Any</code> <code>Wires</code> A sequence of shards, interleaving condition test predicate and action to execute if the condition matches. <code>none</code> <code>[Shard [Shard] None]</code> <code>Passthrough</code> The output of this shard will be its input. <code>true</code> <code>Bool</code> <code>Threading</code> Will not short circuit after the first true test expression. The threaded value gets used in only the action and not the test part of the clause. <code>false</code> <code>Bool</code> <p>Takes a sequence of conditions and predicates. Evaluates each condition one by one and if one matches, executes the associated action.</p>"},{"location":"reference/shards/shards/General/Cond/#examples","title":"Examples","text":"CodeOutput <pre><code>0.5\n(Cond\n [(-&gt; (IsMore 0.7)) (-&gt; \"fast\")\n  (-&gt; (IsLess 0.3)) (-&gt; \"slow\")\n  ; last case acts as default\n  (-&gt; true) (-&gt; \"normal\")]\n ;:Passthrough\n false)\n(Assert.Is \"normal\" true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/General/Const/","title":"Const","text":"Name - Description Default Type <code>&lt;input&gt;</code> Any input is ignored. <code>&lt;output&gt;</code> The declared constant value. <code>Any</code> <code>Value</code> The constant value to insert in the wire. <code>none</code> <code>Any</code> <p>Declares an un-named constant value (of any data type).</p>"},{"location":"reference/shards/shards/General/Const/#details","title":"Details","text":"<p><code>Const</code> declares a constant value (of any data type) by passing it into the parameter <code>:Value</code>. Such a value is usually declared for use as input in other shards.</p> <p>A constant value declared with <code>Const</code> is un-named i.e., it is not assigned to any variable or allocated any alias. Hence it cannot be invoked or referred to later. To create named constants see <code>Ref</code>.</p> <p>You can even skip this shard and pass the constant value directly but internally it will be translated to a <code>Const</code>shard that outputs this constant value. However, it's good practice to use this keyword in while passing constants in Shards programs.</p> <p>You can also use <code>(Const nil)</code> to overwrite/nullify (since <code>nil</code> stands for null data) the input to the subsequent shard, if required (see the last code sample).</p> <p>Input field is ignored and the output of this shard is the constant value defined by it.</p> <p>See also</p> <ul> <li><code>Ref</code></li> <li><code>Set</code></li> </ul>"},{"location":"reference/shards/shards/General/Const/#examples","title":"Examples","text":"CodeOutput <pre><code>;; declare an int with `Const` and consume in `Math.Multiply`\n(Const :Value 2) \n(Math.Multiply 4) (Log)         ;; =&gt; 8\n\n;; declare an int without `Const` and consume in `Math.Multiply`\n2 (Math.Multiply 4) (Log)       ;; =&gt; 8\n\n;; declare a string with `Const`\n(Const \"Hello World!\") (Log)    ;; =&gt; \"Hello World!\"\n\n;; declare a sequence with `Const`\n(Const [\"A\" \"B\" \"C\"]) (Log)     ;; =&gt; [\"A\" \"B\" \"C\"]\n\n;; declare a Float4 with `Const`\n(Const (Float4 1 2 3 4)) (Log)  ;; =&gt; (Float4 1 2 3 4)\n\n;; declare a table with `Const`\n(Const {\"key1\" 10 \"key2\" 20.0})\n(Log)                           ;; =&gt; {\"key1\" 10 \"key2\" 20.0}\n\n;; nullifying the input to a shard with (Const nil)\n\"Hello World\"                   ;; string input for Log\n(Const nil)                     ;; nulls the string input\n(Log)                           ;; Log gets no input =&gt; None\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/General/Consume/","title":"Consume","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Any</code> <code>&lt;output&gt;</code> <code>Any</code> <code>Name</code> The name of the channel. <code>\"\"</code> <code>String</code> <code>Type</code> The expected type to receive. <code>none</code> <code>Type</code> <code>Buffer</code> The amount of values to buffer before outputting them. <code>1</code> <code>Int</code>"},{"location":"reference/shards/shards/General/Convolve/","title":"Convolve","text":"Name - Description Default Type <code>&lt;input&gt;</code> The image to extract patches from. <code>Image</code> <code>&lt;output&gt;</code> The extracted patch as an image. <code>Image</code> <code>Radius</code> The radius of the kernel, e.g. 1 = 1x1; 2 = 3x3; 3 = 5x5 and so on. <code>1</code> <code>Int</code> <code>Step</code> How many pixels to advance the centre of the patch extracted each activation. <code>1</code> <code>Int</code> <p>This shard extracts a patch from an image of dimensions specified in the Radius parameter and outputs the extracted patch as an image. Everytime the shard is subsequently called, the centre of the patch to extract is advanced by the number of pixels specified in the Step parameter.</p> <p> </p>"},{"location":"reference/shards/shards/General/Cos/","title":"Cos","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input float or sequence of floats to calculate the cosine of. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <code>&lt;output&gt;</code> Outputs the cosine of the input. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <p>This shard calculates the cosine of the given input, where the input is the angle in radians.</p> <p> </p>"},{"location":"reference/shards/shards/General/Count/","title":"Count","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input of this shard is ignored. <code>&lt;output&gt;</code> Outputs the count of characters, elements, or key-value pairs in the specified variable. If the variable type does not match, it outputs 0. <code>Int</code> <code>Name</code> The name of the variable. <code>\"\"</code> <code>String</code><code>Var(Any)</code> <code>Key</code> The key of the value to read from the table (parameter applicable only if the target variable is a table). <code>none</code> <code>Any</code> <code>Global</code> If the variable is available to all of the wires in the same mesh. <code>false</code> <code>Bool</code> <p>This shard counts the sequence, string or table variable specified in the Name parameter. If the variable specified is a string, it will count the number of characters. If the variable specified is a sequence, it will count the number of elements. If the variable specified is a table, it will count the number of key-value pairs.</p>"},{"location":"reference/shards/shards/General/Count/#details","title":"Details","text":"<p><code>Count</code> parses the value passed to it in the <code>:Name</code> parameter, and returns the count of characters, elements, or key-value pairs depending on whether the data type passed to it was a string, a sequence, or a table. </p> <p>If this shard is applied to a number it returns zero as the count. </p> <p>This shard works on both sequences and tables. Parameter <code>:Key</code> applies only to tables.</p> <p>Since variables may be locally scoped (created with <code>(:Global false)</code>; exists only for current wire) or globally scoped (created with <code>(:Global true)</code>; exists for all wires of that mesh), both parameters <code>:Global</code> and <code>:Name</code> are used in combination to identify the correct variable to count. </p> <p>Input field is ignored and the output of this shard is the count value in <code>Int</code> type.</p>"},{"location":"reference/shards/shards/General/Count/#examples","title":"Examples","text":"CodeOutput <pre><code>;; counting in locally scoped variables\n\"Shards\" &gt;= .string\n(Count :Name .string) (Log)     ;; no. of characters =&gt; 6 \n[10 20 30] &gt;= .sequence\n(Count .sequence) (Log)         ;; no. of elements =&gt; 3        \n{\"k1\" 11 \"k2\" 22} &gt;= .table\n(Count .table) (Log)            ;; no. of key-value pairs =&gt; 2\n12345 &gt;= .number\n(Count .number) (Log)           ;; zero count for numbers =&gt; 0\n\n;; counting in same-name local and global variables\n\"Local Shards\" &gt;= .stringvar    ;; create a local variable   \n\"Global Shards\" &gt;== .stringvar  ;; create a same-name global variable   \n(Count .stringvar )\n(Log)                           ;; characters in local var =&gt; 12\n(Count .stringvar :Global true)\n(Log)                           ;; characters in global var =&gt; 13\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/General/DShard/","title":"DShard","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>&lt;output&gt;</code> <code>Name</code> The name of the shard to transform into. <code>\"\"</code> <code>String</code> <code>Parameters</code> The parameters to pass to the new shard. <code>[]</code> <code>[Any]</code> <p>This shard is a dynamic shard that will transform into the shard specified in the Name parameter at runtime. This shard can be used in conjunction with Mutate and Evolve to create complex genetic algorithm implementations.</p> <p> </p>"},{"location":"reference/shards/shards/General/Dec/","title":"Dec","text":"Name - Description Default Type <code>&lt;input&gt;</code> The float or integer (or sequence of floats or integers) to decrease by 1. <code>Any</code> <code>&lt;output&gt;</code> The input decreased by 1. <code>Any</code> <code>Value</code> The value to apply the operation to. <code>none</code> <code>Var(Int)</code><code>Var(Int2)</code><code>Var(Int3)</code><code>Var(Int4)</code><code>Var(Int8)</code><code>Var(Int16)</code><code>Var(Float)</code><code>Var(Float2)</code><code>Var(Float3)</code><code>Var(Float4)</code><code>Var(Color)</code><code>Var([Any])</code> <p>Decreases the input by 1.</p> <p> </p>"},{"location":"reference/shards/shards/General/DegreesToRadians/","title":"DegreesToRadians","text":"Name - Description Default Type <code>&lt;input&gt;</code> Takes a float value representing an angle in degrees. <code>Float</code> <code>&lt;output&gt;</code> Outputs a float value representing the input angle in radians. <code>Float</code> <p>This shard converts the input angle from degrees to radians. The conversion is done using the formula: radians = degrees * (\u03c0 / 180).</p> <p> </p>"},{"location":"reference/shards/shards/General/DemultiplyAlpha/","title":"DemultiplyAlpha","text":"Name - Description Default Type <code>&lt;input&gt;</code> The image to apply the demultiplication of alpha channels to. <code>Image</code> <code>&lt;output&gt;</code> The image as a result of the application of the demultiplication of alpha channels. <code>Image</code> <p>Applies the demultiplication of alpha channels of an image to its RGB channels. Does nothing if the image has already been demultiplied or never been premultiplied in Shards. This mainly applies to PNG images.</p> <p> </p>"},{"location":"reference/shards/shards/General/Detach/","title":"Detach","text":"Name - Description Default Type <code>&lt;input&gt;</code> Any input type is accepted. The input of this shard will be given as input for the specified Wire <code>Any</code> <code>&lt;output&gt;</code> Outputs the input value, passed through unchanged. <code>Any</code> <code>Wire</code> The wire to execute. <code>none</code> <code>Wire</code><code>String</code> <code>Restart</code> If true, the specified wire will restart whenever the shard is called, even if it is already running. <code>false</code> <code>Bool</code> <p>Schedules and executes the specified Wire asynchronously. The current Wire will continue its execution independently of the specified Wire. Unlike Spawn, only one unique copy of the specified Wire can be scheduled using Detach. Future calls of Detach that schedules the same Wire will be ignored unless the specified Wire is Stopped or ends naturally.</p>"},{"location":"reference/shards/shards/General/Detach/#examples","title":"Examples","text":"CodeOutput <pre><code>(defwire\n  hello\n  (Msg \"Hello\"))\n\n(Detach\n ;:Wire\n hello)\n(Step hello)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/General/Div/","title":"Div","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value or the sequence of values to divide the value specified in the Operand parameter with. <code>Int</code><code>Int2</code><code>Int3</code><code>Int4</code><code>Int8</code><code>Int16</code><code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <code>&lt;output&gt;</code> This shard outputs the result of the division. <code>Int</code><code>Int2</code><code>Int3</code><code>Int4</code><code>Int8</code><code>Int16</code><code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <code>Operand</code> The value or sequence of values to divide the input by. <code>0</code> <code>Int</code><code>Var(Int)</code><code>Int2</code><code>Var(Int2)</code><code>Int3</code><code>Var(Int3)</code><code>Int4</code><code>Var(Int4)</code><code>Int8</code><code>Var(Int8)</code><code>Int16</code><code>Var(Int16)</code><code>Float</code><code>Var(Float)</code><code>Float2</code><code>Var(Float2)</code><code>Float3</code><code>Var(Float3)</code><code>Float4</code><code>Var(Float4)</code><code>Color</code><code>Var(Color)</code><code>[Any]</code><code>Var([Any])</code> <p>This shard divides the input value by the value provided in the Operand parameter.</p> <p> </p>"},{"location":"reference/shards/shards/General/Do/","title":"Do","text":"Name - Description Default Type <code>&lt;input&gt;</code> Any input type is accepted. The input of this shard will be given as input for the specified Wire <code>Any</code> <code>&lt;output&gt;</code> The output of this shard will be the output of the Wire that is executed. <code>Any</code> <code>Wire</code> The Wire to execute inline. <code>none</code> <code>Wire</code><code>String</code> <p>Schedules and executes the specified Wire inline of the current Wire. The specified Wire needs to complete its execution before the current Wire continues its execution. This means that a pause in execution of the child Wire will also pause the parent Wire.</p>"},{"location":"reference/shards/shards/General/Do/#examples","title":"Examples","text":"CodeOutput <pre><code>(def logicWire\n  (Wire\n   \"dologic\"\n   (IsMore 10) (Or) (IsLess 0)))\n\n-10\n(Do logicWire)\n(Assert.Is true true)\n\n5\n(Do \"dologic\")\n(Assert.IsNot true true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/General/DoMany/","title":"DoMany","text":"Name - Description Default Type <code>&lt;input&gt;</code> This shard takes a sequence of values as input. Each value from the sequence is provided as input to its corresponding copy of the scheduled Wire. The total number of copies of the specified Wire scheduled, will be the same as the number of elements in the sequence provided. <code>[Any]</code> <code>&lt;output&gt;</code> This shard outputs the output of all the scheduled copies in a sequence. <code>[Any]</code> <code>Wire</code> The wire to run many times sequentially. <code>none</code> <code>Wire</code><code>[Shard]</code> <code>ComposeSync</code> Compose new wires synchronously. <code>false</code> <code>Bool</code> <p>This shard takes a sequence of values as input, schedules multiple copies of a specified Wire and executes them sequentially. Each value from the sequence is provided as input to its corresponding copy of the specified Wire. The shard then outputs a sequence of values containing the output of all copies of the specified Wire.</p> <p> </p>"},{"location":"reference/shards/shards/General/Drop/","title":"Drop","text":"Name - Description Default Type <code>&lt;input&gt;</code> Any input is ignored. <code>Any</code> <code>&lt;output&gt;</code> The input is passed through as the output. <code>Any</code> <code>Name</code> The name of the variable. <code>\"\"</code> <code>String</code><code>Var(Any)</code> <code>Key</code> The key of the value to read from the table (parameter applicable only if the target variable is a table). <code>none</code> <code>Any</code> <code>Global</code> If the variable is available to all of the wires in the same mesh. <code>false</code> <code>Bool</code> <p>Drops the last element of the sequence variable. Works only on sequences. If the variable is not a sequence, it simply passes through without failing.</p>"},{"location":"reference/shards/shards/General/Drop/#details","title":"Details","text":"<p><code>Drop</code> drops (removes) the last element of the sequence variable that has been passed to in the <code>:Name</code> parameter. </p> <p>This shard works on both sequences and tables. Parameter <code>:Key</code> applies only to tables.</p> <p>Since variables may be locally scoped (created with <code>(:Global false)</code>; exists only for current wire) or globally scoped (created with <code>(:Global true)</code>; exists for all wires of that mesh), both parameters <code>:Global</code> and <code>:Name</code> are used in combination to identify the correct variable to drop elements from.</p> <p>Any input to this shard is ignored and instead passed through as its output.</p> <p>See also</p> <ul> <li><code>AppendTo</code></li> <li><code>Clear</code></li> <li><code>DropFront</code></li> <li><code>Erase</code></li> <li><code>Pop</code></li> <li><code>PopFront</code></li> <li><code>Remove</code></li> </ul>"},{"location":"reference/shards/shards/General/Drop/#examples","title":"Examples","text":"CodeOutput <pre><code>;; drop last element from a local sequence\n[10 20 30 40] &gt;= .seq           ;; create a local sequence\n(Get .seq) (Log)                ;; local sequence =&gt; [10, 20, 30, 40]\n(Drop :Name .seq)               ;; drops the last element i.e., 40\n(Get .seq) (Log)                ;; updated sequence =&gt; [10, 20, 30]\n\n;; drop last element from a same-name global sequence\n[11 21 31 41] &gt;== .seq          ;; create a same-name global sequence\n(Get .seq :Global true) (Log)   ;; local sequence =&gt; [11, 21, 31, 41]\n(Drop :Name .seq)               ;; drops the last element i.e., 41\n(Get .seq :Global true) (Log)   ;; updated sequence =&gt; [11, 21, 31]\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/General/DropFront/","title":"DropFront","text":"Name - Description Default Type <code>&lt;input&gt;</code> Any input is ignored. <code>Any</code> <code>&lt;output&gt;</code> The input is passed through as the output. <code>Any</code> <code>Name</code> The name of the variable. <code>\"\"</code> <code>String</code><code>Var(Any)</code> <code>Key</code> The key of the value to read from the table (parameter applicable only if the target variable is a table). <code>none</code> <code>Any</code> <code>Global</code> If the variable is available to all of the wires in the same mesh. <code>false</code> <code>Bool</code> <p>Drops the first element of the sequence variable. Works only on sequences. If the variable is not a sequence, it simply passes through without failing.</p>"},{"location":"reference/shards/shards/General/DropFront/#details","title":"Details","text":"<p><code>DropFront</code> drops (removes) the first element of the sequence variable that has been passed to in the <code>:Name</code> parameter. </p> <p>This shard works on both sequences and tables. Parameter <code>:Key</code> applies only to tables.</p> <p>Since variables may be locally scoped (created with <code>(:Global false)</code>; exists only for current wire) or globally scoped (created with <code>(:Global true)</code>; exists for all wires of that mesh), both parameters <code>:Global</code> and <code>:Name</code> are used in combination to identify the correct variable to drop elements from.</p> <p>Any input to this shard is ignored and instead passed through as its output.</p> <p>See also</p> <ul> <li><code>Clear</code></li> <li><code>Drop</code></li> <li><code>Erase</code></li> <li><code>Pop</code></li> <li><code>PopFront</code></li> <li><code>PrependTo</code></li> <li><code>Remove</code></li> </ul>"},{"location":"reference/shards/shards/General/DropFront/#examples","title":"Examples","text":"CodeOutput <pre><code>;; drop first element from a local sequence\n[10 20 30 40] &gt;= .seq           ;; create a local sequence\n(Get .seq) (Log)                ;; local sequence =&gt; [10, 20, 30, 40]\n(DropFront :Name .seq)          ;; drops the first element i.e., 10\n(Get .seq) (Log)                ;; updated sequence =&gt; [20 30 40]\n\n;; drop first element from a same-name global sequence\n[11 21 31 41] &gt;== .seq          ;; create a same-name global sequence\n(Get .seq :Global true) (Log)   ;; local sequence =&gt; [11, 21, 31, 41]\n(DropFront .seq :Global true)   ;; drops the first element i.e., 11\n(Get .seq :Global true) (Log)   ;; updated sequence =&gt; [21, 31, 41]\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/General/Env/","title":"Env","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>String</code> <code>&lt;output&gt;</code> <code>String</code> <p>Get environment variables.</p> <p> </p>"},{"location":"reference/shards/shards/General/Erase/","title":"Erase","text":"Name - Description Default Type <code>&lt;input&gt;</code> Any input is ignored. <code>Any</code> <code>&lt;output&gt;</code> The input to this shard is passed through as its output. <code>Any</code> <code>Indices</code> One or multiple indices to filter from a sequence. <code>none</code> <code>Any</code><code>Var(Any)</code> <code>Name</code> The name of the variable. <code>\"\"</code> <code>String</code><code>Var(Any)</code> <code>Key</code> The key of the value to erase from the table (nested table). <code>none</code> <code>Any</code> <code>Global</code> If the variable is or should be available to all of the wires in the same mesh. <code>false</code> <code>Bool</code> <p>Deletes an index or indices from a sequence or a key or keys from a table.</p>"},{"location":"reference/shards/shards/General/Erase/#details","title":"Details","text":"<p><code>Erase</code> deletes single or multiple elements (from sequences) and key-value pairs (from tables). </p> <p>For a sequence, this shard expects the index (or a sequence of indices in descending order) of the element(s) to be erased, followed by the name of the sequence variable in the <code>:Name</code> parameter.</p> <p>For a table, this shard expects the key (or a sequence of keys) of the key-value pair(s) to be erased, followed by the name of the table variable in the <code>:Name</code> parameter. </p> <p>This shard works on both sequences and tables. Parameter <code>:Key</code> applies only to tables.</p> <p>Since variables may be locally scoped (created with <code>(:Global false)</code>; exists only for current wire) or globally scoped (created with <code>(:Global true)</code>; exists for all wires of that mesh), both parameters <code>:Global</code> and <code>:Name</code> are used in combination to identify the correct variable to erase. </p> <p>Any input to this shard is ignored and instead passed through as its output.</p> <p>See also</p> <ul> <li><code>Clear</code></li> <li><code>Drop</code></li> <li><code>DropFront</code></li> <li><code>Pop</code></li> <li><code>PopFront</code></li> <li><code>Remove</code></li> </ul>"},{"location":"reference/shards/shards/General/Erase/#examples","title":"Examples","text":"CodeOutput <pre><code>;; erase single element from sequence\n[100 200 300 400] &gt;= .seq1\n(Erase [1] :Name .seq1)\n(Log \"output\")                          ;; =&gt; output: [100 200 300 400]      \n.seq1 (Log \".seq1\")                     ;; =&gt; seq1: [100, 300, 400]\n\n;; erase multiple elements from sequence\n[100 200 300 400] &gt;= .seq2\n(Erase [2 0] :Name .seq2)\n.seq2 (Log)                             ;; =&gt; [200, 400]\n\n;; erase single key-value pair from table        \n{:k1 10 :k2 20 :k3 30} &gt;= .tab1\n(Erase \"k2\" :Name .tab1)\n.tab1 (Log)                             ;; =&gt; {:k3 30, :k1 10}\n\n;; erase multiple key-value pairs from table\n{:k1 100 :k2 200 :k3 300} &gt;= .tab2\n(Erase [\"k3\" \"k1\"] .tab2)\n.tab2 (Log)                             ;; =&gt; {:k2 200}\n\n;; erase from same-name local and global sequences\n[1 2 3] &gt;= .seq                         ;; create local sequence\n[1 2 3] &gt;== .seq                        ;; create same-name global sequence\n(Erase [2 0] .seq)                      ;; erase from local sequence\n(Get .seq) (Log)                        ;; =&gt; [2]\n(Erase [1] .seq :Global true)           ;; erase from same-name global sequence\n(Get .seq :Global true) (Log)           ;; =&gt; [1, 3]\n\n;; erase from same-name local and global tables\n{:k1 1 :k2 2 :k3 3} &gt;= .tab             ;; create local table   \n{:k1 1 :k2 2 :k3 3} &gt;== .tab            ;; create same-name global table   \n(Erase [\"k3\" \"k1\"] .tab)                ;; erase from local table\n(Get .tab) (Log)                        ;; =&gt; {:k2 2}\n(Erase [\"k2\"] .tab :Global true)        ;; erase from same-name global table\n(Get .tab :Global true) (Log)           ;; =&gt; {:k3 3 :k1 1}\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/General/Evolve/","title":"Evolve","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input of this shard is ignored. <code>Any</code> <code>&lt;output&gt;</code> This shard outputs a [Type::Float Type::Wire] pair. This pair represents the wire configuration from the current generation that scored the best fitness score and the fitness score itself. <code>[Float Wire]</code> <code>Wire</code> The wire to optimize and evolve. <code>none</code> <code>Wire</code> <code>Fitness</code> The fitness wire to run at the end of the main wire evaluation and using its last output; should output a Float fitness value. <code>none</code> <code>Wire</code> <code>Population</code> The population size. <code>64</code> <code>Int</code> <code>Mutation</code> The rate of mutation, 0.1 = 10%. <code>0.2</code> <code>Float</code> <code>Crossover</code> The rate of crossover, 0.1 = 10%. <code>0.2</code> <code>Float</code> <code>Extinction</code> The rate of extinction, 0.1 = 10%. <code>0.1</code> <code>Float</code> <code>Elitism</code> The rate of elitism, 0.1 = 10%. <code>0.1</code> <code>Float</code> <code>Threads</code> The number of cpu threads to use. <code>2</code> <code>Int</code> <code>Coroutines</code> The number of coroutines to run on each thread. <code>8</code> <code>Int</code> <p>This shard uses genetic algorithm to evolve and change the configuration of the wire specified in the Wire parameter. The evolved wires are given a score based on the fitness wire specified in the Fitness Wire parameter. The shard then outputs the best wire and its fitness score. This shard should be used in conjunction with the Mutant shard.</p> <p> </p>"},{"location":"reference/shards/shards/General/Exit/","title":"Exit","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Int</code> <code>&lt;output&gt;</code>"},{"location":"reference/shards/shards/General/Expand/","title":"Expand","text":"Name - Description Default Type <code>&lt;input&gt;</code> This shard takes a value of any type as input. This value is provided as input to every scheduled copy of the specified Wire. <code>Any</code> <code>&lt;output&gt;</code> Depending on the Policy specified the shard will return a different output. WaitUntil::FirstSuccess will return the output of the first successful Wire. WaitUntil::SomeSuccess return a sequence with all the output from all the copies of the specified Wire. WaitUntil::FirstSuccess will either stop execution of the current Wire if any of the copies fail or return a sequence with all the output from all the copies of the specified Wire. <code>[Any]</code> <code>Size</code> The number of copies of the specified Wire to schedule. <code>10</code> <code>Int</code> <code>Wire</code> The Wire to copy and schedule. <code>none</code> <code>Wire</code><code>[Shard]</code> <code>Policy</code> The execution policy for the shard to abide by. A copied Wire is only deemed successful if it did not have an internal failure (eg.through Assert) <code>WaitUntil::AllSuccess</code> <code>WaitUntil</code> <code>Threads</code> The number of cpu threads to use. Number specified can not be lower than 1. <code>0</code> <code>Int</code> <p>Schedules (n) number of copies of the specified Wire, where (n) is the number specified in the Size parameter. The parent Wire will wait until all the scheduled copies have ended and will either return a sequence of values outputs of all the copied Wires or the output of the first Wire that succeeds. Once done, it will continue with its own execution.</p>"},{"location":"reference/shards/shards/General/Expand/#examples","title":"Examples","text":"CodeOutput <pre><code>21\n(Expand\n :Size 10\n :Wire (defwire wide-test (Math.Multiply 2))\n :Threads 5)\n(Assert.Is [42 42 42 42 42 42 42 42 42 42] true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/General/Expect/","title":"Expect","text":"Name - Description Default Type <code>&lt;input&gt;</code> Input of any type is accepted. <code>Any</code> <code>&lt;output&gt;</code> The input value unchanged if it matches the expected type. <code>Any</code> <code>Type</code> The type to expect <code>none</code> <code>Type</code> <code>Unsafe</code> When set to true, it will skip type comparison. Generally unsafe but it can improve performance. Only set to true if you are certain that the input type matches the expected type. <code>false</code> <code>Bool</code> <p>Checks if the input value matches the expected type specified by the 'Type' parameter. The shard outputs the input value unchanged if it is of the appropriate type, the shard will trigger an error, preventing further execution. The 'Unsafe' parameter can be set to skip deep type hashing and comparison to improve performance.</p> <p> </p>"},{"location":"reference/shards/shards/General/ExpectAudio/","title":"ExpectAudio","text":"Name - Description Default Type <code>&lt;input&gt;</code> Input of any type is accepted. <code>Any</code> <code>&lt;output&gt;</code> Outputs the input value unchanged if it is of type Audio. <code>Audio</code> <p>Checks the input value if it is an Audio file. The shard outputs the input value unchanged if it is of the appropriate type; otherwise, the shard will trigger an error, preventing further execution.</p> <p> </p>"},{"location":"reference/shards/shards/General/ExpectAudioSeq/","title":"ExpectAudioSeq","text":"Name - Description Default Type <code>&lt;input&gt;</code> This shard accepts a sequence of values. <code>Any</code> <code>&lt;output&gt;</code> Outputs the input value unchanged if it is a sequence of Audio data. <code>[Audio]</code> <code>Unsafe</code> When set to true, it will skip type comparison. Generally unsafe but it can improve performance. Only set to true if you are certain that the input type matches the expected type. <code>false</code> <code>Bool</code> <p>Checks if the input value is a sequence of Audio files. The shard outputs the input value unchanged if it is of the appropriate type; otherwise, the shard will trigger an error, preventing further execution.</p> <p> </p>"},{"location":"reference/shards/shards/General/ExpectBool/","title":"ExpectBool","text":"Name - Description Default Type <code>&lt;input&gt;</code> Input of any type is accepted. <code>Any</code> <code>&lt;output&gt;</code> Outputs the input value unchanged if it is of type Bool. <code>Bool</code> <p>Checks the input value if it is a Boolean. The shard outputs the input value unchanged if it is of the appropriate type; otherwise, the shard will trigger an error, preventing further execution.</p> <p> </p>"},{"location":"reference/shards/shards/General/ExpectBoolSeq/","title":"ExpectBoolSeq","text":"Name - Description Default Type <code>&lt;input&gt;</code> This shard accepts a sequence of values. <code>Any</code> <code>&lt;output&gt;</code> Outputs the input value unchanged if it is a sequence of Booleans. <code>[Bool]</code> <code>Unsafe</code> When set to true, it will skip type comparison. Generally unsafe but it can improve performance. Only set to true if you are certain that the input type matches the expected type. <code>false</code> <code>Bool</code> <p>Checks if the input value is a sequence of Bools. The shard outputs the input value unchanged if it is of the appropriate type; otherwise, the shard will trigger an error, preventing further execution.</p> <p> </p>"},{"location":"reference/shards/shards/General/ExpectBytes/","title":"ExpectBytes","text":"Name - Description Default Type <code>&lt;input&gt;</code> Input of any type is accepted. <code>Any</code> <code>&lt;output&gt;</code> Outputs the input value unchanged if it is of type Bytes. <code>Bytes</code> <p>Checks the input value if it is of type Bytes. The shard outputs the input value unchanged if it is of the appropriate type; otherwise, the shard will trigger an error, preventing further execution.</p> <p> </p>"},{"location":"reference/shards/shards/General/ExpectBytesSeq/","title":"ExpectBytesSeq","text":"Name - Description Default Type <code>&lt;input&gt;</code> This shard accepts a sequence of values. <code>Any</code> <code>&lt;output&gt;</code> Outputs the input value unchanged if it is a sequence of Bytes. <code>[Bytes]</code> <code>Unsafe</code> When set to true, it will skip type comparison. Generally unsafe but it can improve performance. Only set to true if you are certain that the input type matches the expected type. <code>false</code> <code>Bool</code> <p>Checks if the input value is a sequence of Bytes. The shard outputs the input value unchanged if it is of the appropriate type; otherwise, the shard will trigger an error, preventing further execution.</p> <p> </p>"},{"location":"reference/shards/shards/General/ExpectColor/","title":"ExpectColor","text":"Name - Description Default Type <code>&lt;input&gt;</code> Input of any type is accepted. <code>Any</code> <code>&lt;output&gt;</code> Outputs the input value unchanged if it is of type Color. <code>Color</code> <p>Checks the input value if it is vector of four color channels (RGBA). The shard outputs the input value unchanged if it is of the appropriate type; otherwise, the shard will trigger an error, preventing further execution.</p> <p> </p>"},{"location":"reference/shards/shards/General/ExpectColorSeq/","title":"ExpectColorSeq","text":"Name - Description Default Type <code>&lt;input&gt;</code> This shard accepts a sequence of values. <code>Any</code> <code>&lt;output&gt;</code> Outputs the input value unchanged if it is a sequence of Color vectors. <code>[Color]</code> <code>Unsafe</code> When set to true, it will skip type comparison. Generally unsafe but it can improve performance. Only set to true if you are certain that the input type matches the expected type. <code>false</code> <code>Bool</code> <p>Checks if the input value is a sequence of Color vectors. The shard outputs the input value unchanged if it is of the appropriate type; otherwise, the shard will trigger an error, preventing further execution.</p> <p> </p>"},{"location":"reference/shards/shards/General/ExpectFloat/","title":"ExpectFloat","text":"Name - Description Default Type <code>&lt;input&gt;</code> Input of any type is accepted. <code>Any</code> <code>&lt;output&gt;</code> Outputs the input value unchanged if it is of type Float. <code>Float</code> <p>Checks the input value if it is of type Float. The shard outputs the input value unchanged if it is of the appropriate type; otherwise, it will fail.</p> <p> </p>"},{"location":"reference/shards/shards/General/ExpectFloat2/","title":"ExpectFloat2","text":"Name - Description Default Type <code>&lt;input&gt;</code> Input of any type is accepted. <code>Any</code> <code>&lt;output&gt;</code> Outputs the input value unchanged if it is of type Float2. <code>Float2</code> <p>Checks the input value if it is a vector with two Float elements. The shard outputs the input value unchanged if it is of the appropriate type; otherwise, the shard will trigger an error, preventing further execution.</p> <p> </p>"},{"location":"reference/shards/shards/General/ExpectFloat2Seq/","title":"ExpectFloat2Seq","text":"Name - Description Default Type <code>&lt;input&gt;</code> This shard accepts a sequence of values. <code>Any</code> <code>&lt;output&gt;</code> Outputs the input value unchanged if it is a sequence of Float2 vectors. <code>[Float2]</code> <code>Unsafe</code> When set to true, it will skip type comparison. Generally unsafe but it can improve performance. Only set to true if you are certain that the input type matches the expected type. <code>false</code> <code>Bool</code> <p>Checks if the input value is a sequence of Float2 vectors. The shard outputs the input value unchanged if it is of the appropriate type; otherwise, the shard will trigger an error, preventing further execution.</p> <p> </p>"},{"location":"reference/shards/shards/General/ExpectFloat3/","title":"ExpectFloat3","text":"Name - Description Default Type <code>&lt;input&gt;</code> Input of any type is accepted. <code>Any</code> <code>&lt;output&gt;</code> Outputs the input value unchanged if it is of type Float3. <code>Float3</code> <p>Checks the input value if it is a vector with three Float elements. The shard outputs the input value unchanged if it is of the appropriate type; otherwise, the shard will trigger an error, preventing further execution.</p> <p> </p>"},{"location":"reference/shards/shards/General/ExpectFloat3Seq/","title":"ExpectFloat3Seq","text":"Name - Description Default Type <code>&lt;input&gt;</code> This shard accepts a sequence of values. <code>Any</code> <code>&lt;output&gt;</code> Outputs the input value unchanged if it is a sequence of Float3 vectors. <code>[Float3]</code> <code>Unsafe</code> When set to true, it will skip type comparison. Generally unsafe but it can improve performance. Only set to true if you are certain that the input type matches the expected type. <code>false</code> <code>Bool</code> <p>Checks if the input value is a sequence of Float3 vectors. The shard outputs the input value unchanged if it is of the appropriate type; otherwise, the shard will trigger an error, preventing further execution.</p> <p> </p>"},{"location":"reference/shards/shards/General/ExpectFloat4/","title":"ExpectFloat4","text":"Name - Description Default Type <code>&lt;input&gt;</code> Input of any type is accepted. <code>Any</code> <code>&lt;output&gt;</code> Outputs the input value unchanged if it is of type Float4. <code>Float4</code> <p>Checks the input value if it is a vector with float Float elements. The shard outputs the input value unchanged if it is of the appropriate type; otherwise, the shard will trigger an error, preventing further execution.</p> <p> </p>"},{"location":"reference/shards/shards/General/ExpectFloat4Seq/","title":"ExpectFloat4Seq","text":"Name - Description Default Type <code>&lt;input&gt;</code> This shard accepts a sequence of values. <code>Any</code> <code>&lt;output&gt;</code> Outputs the input value unchanged if it is a sequence of Floats4 vectors. <code>[Float4]</code> <code>Unsafe</code> When set to true, it will skip type comparison. Generally unsafe but it can improve performance. Only set to true if you are certain that the input type matches the expected type. <code>false</code> <code>Bool</code> <p>Checks if the input value is a sequence of Float4 vectors. The shard outputs the input value unchanged if it is of the appropriate type; otherwise, the shard will trigger an error, preventing further execution.</p> <p> </p>"},{"location":"reference/shards/shards/General/ExpectFloatSeq/","title":"ExpectFloatSeq","text":"Name - Description Default Type <code>&lt;input&gt;</code> This shard accepts a sequence of values. <code>Any</code> <code>&lt;output&gt;</code> Outputs the input value unchanged if it is a sequence of Floats. <code>[Float]</code> <code>Unsafe</code> When set to true, it will skip type comparison. Generally unsafe but it can improve performance. Only set to true if you are certain that the input type matches the expected type. <code>false</code> <code>Bool</code> <p>Checks if the input value is a sequence of Floats. The shard outputs the input value unchanged if it is of the appropriate type; otherwise, the shard will trigger an error, preventing further execution.</p> <p> </p>"},{"location":"reference/shards/shards/General/ExpectImage/","title":"ExpectImage","text":"Name - Description Default Type <code>&lt;input&gt;</code> Input of any type is accepted. <code>Any</code> <code>&lt;output&gt;</code> Outputs the input value unchanged if it is of type Image. <code>Image</code> <p>Checks the input value if it is an Image file. The shard outputs the input value unchanged if it is of the appropriate type; otherwise, the shard will trigger an error, preventing further execution.</p> <p> </p>"},{"location":"reference/shards/shards/General/ExpectImageSeq/","title":"ExpectImageSeq","text":"Name - Description Default Type <code>&lt;input&gt;</code> This shard accepts a sequence of values. <code>Any</code> <code>&lt;output&gt;</code> Outputs the input value unchanged if it is a sequence of Images. <code>[Image]</code> <code>Unsafe</code> When set to true, it will skip type comparison. Generally unsafe but it can improve performance. Only set to true if you are certain that the input type matches the expected type. <code>false</code> <code>Bool</code> <p>Checks if the input value is a sequence of Images files. The shard outputs the input value unchanged if it is of the appropriate type; otherwise, the shard will trigger an error, preventing further execution.</p> <p> </p>"},{"location":"reference/shards/shards/General/ExpectInt/","title":"ExpectInt","text":"Name - Description Default Type <code>&lt;input&gt;</code> Input of any type is accepted. <code>Any</code> <code>&lt;output&gt;</code> Outputs the input value unchanged if it is of type Int. <code>Int</code> <p>Checks the input value if it is of type Int. The shard outputs the input value unchanged if it is of the appropriate type; otherwise, the shard will trigger an error, preventing further execution.</p> <p> </p>"},{"location":"reference/shards/shards/General/ExpectInt16/","title":"ExpectInt16","text":"Name - Description Default Type <code>&lt;input&gt;</code> Input of any type is accepted. <code>Any</code> <code>&lt;output&gt;</code> Outputs the input value unchanged if it is of type Int16 <code>Int16</code> <p>Checks the input value if it is a vector with sixteen Int elements. The shard outputs the input value unchanged if it is of the appropriate type; otherwise, the shard will trigger an error, preventing further execution.</p> <p> </p>"},{"location":"reference/shards/shards/General/ExpectInt16Seq/","title":"ExpectInt16Seq","text":"Name - Description Default Type <code>&lt;input&gt;</code> This shard accepts a sequence of values. <code>Any</code> <code>&lt;output&gt;</code> Outputs the input value unchanged if it is a sequence of Int16 vectors. <code>[Int16]</code> <code>Unsafe</code> When set to true, it will skip type comparison. Generally unsafe but it can improve performance. Only set to true if you are certain that the input type matches the expected type. <code>false</code> <code>Bool</code> <p>Checks if the input value is a sequence of Int16 vectors. The shard outputs the input value unchanged if it is of the appropriate type; otherwise, the shard will trigger an error, preventing further execution.</p> <p> </p>"},{"location":"reference/shards/shards/General/ExpectInt2/","title":"ExpectInt2","text":"Name - Description Default Type <code>&lt;input&gt;</code> Input of any type is accepted. <code>Any</code> <code>&lt;output&gt;</code> Outputs the input value unchanged if it is of type Int2. <code>Int2</code> <p>Checks the input value if it is a vector with two Int elements. The shard outputs the input value unchanged if it is of the appropriate type; otherwise, the shard will trigger an error, preventing further execution.</p> <p> </p>"},{"location":"reference/shards/shards/General/ExpectInt2Seq/","title":"ExpectInt2Seq","text":"Name - Description Default Type <code>&lt;input&gt;</code> This shard accepts a sequence of values. <code>Any</code> <code>&lt;output&gt;</code> Outputs the input value unchanged if it is a sequence of Int2 vectors. <code>[Int2]</code> <code>Unsafe</code> When set to true, it will skip type comparison. Generally unsafe but it can improve performance. Only set to true if you are certain that the input type matches the expected type. <code>false</code> <code>Bool</code> <p>Checks if the input value is a sequence of Int2 vectors. The shard outputs the input value unchanged if it is of the appropriate type; otherwise, the shard will trigger an error, preventing further execution.</p> <p> </p>"},{"location":"reference/shards/shards/General/ExpectInt3/","title":"ExpectInt3","text":"Name - Description Default Type <code>&lt;input&gt;</code> Input of any type is accepted. <code>Any</code> <code>&lt;output&gt;</code> Outputs the input value unchanged if it is of type Int3. <code>Int3</code> <p>Checks the input value if it is a vector with three Int elements. The shard outputs the input value unchanged if it is of the appropriate type; otherwise, the shard will trigger an error, preventing further execution.</p> <p> </p>"},{"location":"reference/shards/shards/General/ExpectInt3Seq/","title":"ExpectInt3Seq","text":"Name - Description Default Type <code>&lt;input&gt;</code> This shard accepts a sequence of values. <code>Any</code> <code>&lt;output&gt;</code> Outputs the input value unchanged if it is a sequence of Int3 vectors. <code>[Int3]</code> <code>Unsafe</code> When set to true, it will skip type comparison. Generally unsafe but it can improve performance. Only set to true if you are certain that the input type matches the expected type. <code>false</code> <code>Bool</code> <p>Checks if the input value is a sequence of Int3 vectors. The shard outputs the input value unchanged if it is of the appropriate type; otherwise, the shard will trigger an error, preventing further execution.</p> <p> </p>"},{"location":"reference/shards/shards/General/ExpectInt4/","title":"ExpectInt4","text":"Name - Description Default Type <code>&lt;input&gt;</code> Input of any type is accepted. <code>Any</code> <code>&lt;output&gt;</code> Outputs the input value unchanged if it is of type Int4. <code>Int4</code> <p>Checks the input value if it is a vector with four Int elements. The shard outputs the input value unchanged if it is of the appropriate type; otherwise, the shard will trigger an error, preventing further execution.</p> <p> </p>"},{"location":"reference/shards/shards/General/ExpectInt4Seq/","title":"ExpectInt4Seq","text":"Name - Description Default Type <code>&lt;input&gt;</code> This shard accepts a sequence of values. <code>Any</code> <code>&lt;output&gt;</code> Outputs the input value unchanged if it is a sequence of Int4 vectors. <code>[Int4]</code> <code>Unsafe</code> When set to true, it will skip type comparison. Generally unsafe but it can improve performance. Only set to true if you are certain that the input type matches the expected type. <code>false</code> <code>Bool</code> <p>Checks if the input value is a sequence of Int4 vectors. The shard outputs the input value unchanged if it is of the appropriate type; otherwise, the shard will trigger an error, preventing further execution.</p> <p> </p>"},{"location":"reference/shards/shards/General/ExpectInt8/","title":"ExpectInt8","text":"Name - Description Default Type <code>&lt;input&gt;</code> Input of any type is accepted. <code>Any</code> <code>&lt;output&gt;</code> Outputs the input value unchanged if it is of type Int8. <code>Int8</code> <p>Checks the input value if it is a vector with eight Int elements. The shard outputs the input value unchanged if it is of the appropriate type; otherwise, the shard will trigger an error, preventing further execution.</p> <p> </p>"},{"location":"reference/shards/shards/General/ExpectInt8Seq/","title":"ExpectInt8Seq","text":"Name - Description Default Type <code>&lt;input&gt;</code> This shard accepts a sequence of values. <code>Any</code> <code>&lt;output&gt;</code> Outputs the input value unchanged if it is a sequence of Int8 vectors. <code>[Int8]</code> <code>Unsafe</code> When set to true, it will skip type comparison. Generally unsafe but it can improve performance. Only set to true if you are certain that the input type matches the expected type. <code>false</code> <code>Bool</code> <p>Checks if the input value is a sequence of Int8 vectors. The shard outputs the input value unchanged if it is of the appropriate type; otherwise, the shard will trigger an error, preventing further execution.</p> <p> </p>"},{"location":"reference/shards/shards/General/ExpectIntSeq/","title":"ExpectIntSeq","text":"Name - Description Default Type <code>&lt;input&gt;</code> This shard accepts a sequence of values. <code>Any</code> <code>&lt;output&gt;</code> Outputs the input value unchanged if it is a sequence of Ints. <code>[Int]</code> <code>Unsafe</code> When set to true, it will skip type comparison. Generally unsafe but it can improve performance. Only set to true if you are certain that the input type matches the expected type. <code>false</code> <code>Bool</code> <p>Checks if the input value is a sequence of Ints. The shard outputs the input value unchanged if it is of the appropriate type; otherwise, the shard will trigger an error, preventing further execution.</p> <p> </p>"},{"location":"reference/shards/shards/General/ExpectLike/","title":"ExpectLike","text":"Name - Description Default Type <code>&lt;input&gt;</code> Input of any type is accepted. <code>Any</code> <code>&lt;output&gt;</code> Outputs the input value unchanged if it matches the expected type. <code>Any</code> <code>TypeOf</code> The type of the constant given here will be checked against this shard's input. <code>none</code> <code>Any</code> <code>OutputOf</code> Evaluates the output type of the given expression. That type of the output will be checked against this shard's input. <code>none</code> <code>Shard</code><code>[Shard]</code> <code>Unsafe</code> When set to true, it will skip type comparison. Generally unsafe but it can improve performance. Only set to true if you are certain that the input type matches the expected type. <code>false</code> <code>Bool</code> <p>Checks if the input value matches the type of the value provided in the TypeOf parameter or the output type of the given expression in the OutputOf parameter. The shard outputs the input value unchanged if it is of the appropriate type; otherwise, the shard will trigger an error, preventing further execution. Note that it can only compare with either one of the parameters, not both; an error will be thrown if both are provided. The 'Unsafe' parameter can be set to skip deep type hashing and comparison to improve performance.</p> <p> </p>"},{"location":"reference/shards/shards/General/ExpectNone/","title":"ExpectNone","text":"Name - Description Default Type <code>&lt;input&gt;</code> Input of any type is accepted. <code>Any</code> <code>&lt;output&gt;</code> Outputs the input value unchanged if it is of type None. <p>Checks the input value if it is none. The shard outputs the input value unchanged if it is of the appropriate type; otherwise, the shard will trigger an error, preventing further execution.</p> <p> </p>"},{"location":"reference/shards/shards/General/ExpectSeq/","title":"ExpectSeq","text":"Name - Description Default Type <code>&lt;input&gt;</code> Input of any type is accepted. <code>Any</code> <code>&lt;output&gt;</code> Outputs the input value unchanged if it is a sequence. <code>[Any]</code> <p>Checks if the input value is a sequence; otherwise, the shard will trigger an error, preventing further execution.</p> <p> </p>"},{"location":"reference/shards/shards/General/ExpectString/","title":"ExpectString","text":"Name - Description Default Type <code>&lt;input&gt;</code> Input of any type is accepted. <code>Any</code> <code>&lt;output&gt;</code> Outputs the input value unchanged if it is of type String. <code>String</code> <p>Checks the input value if it is a String. The shard outputs the input value unchanged if it is of the appropriate type; otherwise, the shard will trigger an error, preventing further execution.</p> <p> </p>"},{"location":"reference/shards/shards/General/ExpectStringSeq/","title":"ExpectStringSeq","text":"Name - Description Default Type <code>&lt;input&gt;</code> This shard accepts a sequence of values. <code>Any</code> <code>&lt;output&gt;</code> Outputs the input value unchanged if it is a sequence of Strings. <code>[String]</code> <code>Unsafe</code> When set to true, it will skip type comparison. Generally unsafe but it can improve performance. Only set to true if you are certain that the input type matches the expected type. <code>false</code> <code>Bool</code> <p>Checks if the input value is a sequence of Strings. The shard outputs the input value unchanged if it is of the appropriate type; otherwise, the shard will trigger an error, preventing further execution.</p> <p> </p>"},{"location":"reference/shards/shards/General/ExpectTable/","title":"ExpectTable","text":"Name - Description Default Type <code>&lt;input&gt;</code> Input of any type is accepted. <code>Any</code> <code>&lt;output&gt;</code> Outputs the input value unchanged if it is of type Table. <code>{}</code> <p>Checks the input value if it is a Table. The shard outputs the input value unchanged if it is of the appropriate type; otherwise, the shard will trigger an error, preventing further execution.</p> <p> </p>"},{"location":"reference/shards/shards/General/ExpectWire/","title":"ExpectWire","text":"Name - Description Default Type <code>&lt;input&gt;</code> Input of any type is accepted. <code>Any</code> <code>&lt;output&gt;</code> Outputs the input value unchanged if it is of type Wire. <code>Wire</code> <p>Checks the input value if it is a Wire. The shard outputs the input value unchanged if it is of the appropriate type; otherwise, the shard will trigger an error, preventing further execution.</p> <p> </p>"},{"location":"reference/shards/shards/General/ExpectWireSeq/","title":"ExpectWireSeq","text":"Name - Description Default Type <code>&lt;input&gt;</code> This shard accepts a sequence of values. <code>Any</code> <code>&lt;output&gt;</code> Outputs the input value unchanged if it is a sequence of Wires. <code>[Wire]</code> <code>Unsafe</code> When set to true, it will skip type comparison. Generally unsafe but it can improve performance. Only set to true if you are certain that the input type matches the expected type. <code>false</code> <code>Bool</code> <p>Checks if the input value is a sequence of Wires. The shard outputs the input value unchanged if it is of the appropriate type; otherwise, the shard will trigger an error, preventing further execution.</p> <p> </p>"},{"location":"reference/shards/shards/General/Extend/","title":"Extend","text":"Name - Description Default Type <code>&lt;input&gt;</code> The sequence to be appended to the target sequence. <code>[Any]</code> <code>&lt;output&gt;</code> The input sequence (pass-through). <code>[Any]</code> <code>Target</code> The mutable sequence to extend. <code>none</code> <code>Var([Any])</code> <p>Extends the mutable sequence parameter with the elements of the input sequence.</p> <p> </p>"},{"location":"reference/shards/shards/General/Fail/","title":"Fail","text":"Name - Description Default Type <code>&lt;input&gt;</code> The error message to cancel the flow with. <code>String</code> <code>&lt;output&gt;</code> This shard does not produce an output as it cancels the flow. <p>Stops the current flow and cancels the execution with the provided error message. This shard is used to signal an error and halt the execution of the current wire.</p> <p> </p>"},{"location":"reference/shards/shards/General/FastSqrt/","title":"FastSqrt","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input float or sequence of floats to calculate the square root of. This value must be a positive number or sequence of positive numbers. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <code>&lt;output&gt;</code> Outputs the square root of the input. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <p>This shard calculates the square root of the given input.</p> <p> </p>"},{"location":"reference/shards/shards/General/FillAlpha/","title":"FillAlpha","text":"Name - Description Default Type <code>&lt;input&gt;</code> The 3 channel image to convert. <code>Image</code> <code>&lt;output&gt;</code> The converted 4 channel image with the alpha channel filled. <code>Image</code> <p>This shard takes an image with 3-channels(RGB) and converts it to a 4-channel(RGBA) image with the alpha channel set to 255.</p> <p> </p>"},{"location":"reference/shards/shards/General/Flatten/","title":"Flatten","text":"Name - Description Default Type <code>&lt;input&gt;</code> This shard will take a sequence or a table with nested values. <code>Any</code> <code>&lt;output&gt;</code> This shard will return a single sequence with all of values, nested values and keys of the input as elements. <code>Any</code> <p>This shard will take a sequence with nested values (eg. a sequence of sequences or a sequence of tables) and create a single sequence with all of values, nested values and keys as elements.</p> <p> </p>"},{"location":"reference/shards/shards/General/FloatsToImage/","title":"FloatsToImage","text":"Name - Description Default Type <code>&lt;input&gt;</code> Takes a sequence of floats as input and converts it into an image. The sequence length must be equal to Width x Height x Channels. <code>[Float]</code> <code>&lt;output&gt;</code> This shard outputs and image. <code>Image</code> <code>Width</code> The width of the output image. <code>16</code> <code>Int</code> <code>Height</code> The height of the output image. <code>16</code> <code>Int</code> <code>Channels</code> The channels of the output image. <code>1</code> <code>Int</code> <p>Converts a sequence of floats into an image. The image dimensions (width and height) and the number of channels are specified by the appropriate parameters.</p> <p> </p>"},{"location":"reference/shards/shards/General/Floor/","title":"Floor","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input float or sequence of floats to round down. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <code>&lt;output&gt;</code> Outputs the input rounded down to the nearest integer (as a float). <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <p>This shard rounds down the input to the nearest integer.</p> <p> </p>"},{"location":"reference/shards/shards/General/Flush/","title":"Flush","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Any</code> <code>&lt;output&gt;</code> <code>Any</code> <code>Name</code> The name of the channel. <code>\"\"</code> <code>String</code>"},{"location":"reference/shards/shards/General/FlushLog/","title":"FlushLog","text":"Name - Description Default Type <code>&lt;input&gt;</code> Any input type is accepted. The input value will pass through unchanged. <code>Any</code> <code>&lt;output&gt;</code> Outputs the input value, passed through unchanged. <code>Any</code> <p>This shard flushes the log buffer to the console. This ensures that any pending log messages are immediately written to the console.</p> <p> </p>"},{"location":"reference/shards/shards/General/ForEach/","title":"ForEach","text":"Name - Description Default Type <code>&lt;input&gt;</code> Sequence/table whose elements or key-value pairs need to be processed. <code>[Any]</code><code>{Any}</code> <code>&lt;output&gt;</code> Outputs the input value, passed through unchanged. <code>[Any]</code><code>{Any}</code> <code>Apply</code> The processing logic (in the form of a shard or sequence of shards) to apply to the input sequence/table. <code>none</code> <code>Shard</code><code>[Shard]</code> <p>Processes every element or key-value pair of a sequence/table with the shards specified in the <code>Apply</code> parameter. Note that this shard is able to use the $0 and $1 internal variables, as well as $i for the current index.</p>"},{"location":"reference/shards/shards/General/ForEach/#examples","title":"Examples","text":"CodeOutput <pre><code>;; ForEach on a sequence: processes every element in seq order\n[2 4 8 10]\n(ForEach\n (-&gt;\n  (| (Math.Multiply 10)\n     (Log))  ;; =&gt; 20, 40, 80, 100\n  (| (Math.Multiply 100)\n     (Log))  ;; =&gt; 200, 400, 800, 1000\n  ))\n</code></pre> <pre><code>\n</code></pre> CodeOutput <pre><code>;; ForEach on a table: processes every key in alphabetic order\n{\"Name\" \"Universe\" \"Age\" \"13.8B Yrs\"}\n(ForEach ;; receives each key/value pair as a sequence in alphabetic order of key\n (-&gt;\n  (| (Slice 0 1 1) ;; seq =&gt; every element starting from 0 till 0 =&gt; key of that pair\n     (Log))  ;; =&gt; [\"Age\"], [\"Name\"]\n  (| (Slice 1 2 1) ;; seq =&gt; every element starting from 1 till 1 =&gt; value of that pair\n     (Log))  ;; =&gt; [\"13.8 B Yrs\"], [\"Universe\"]\n  ))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/General/ForRange/","title":"ForRange","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input value is not used and will pass through unchanged. <code>Any</code> <code>&lt;output&gt;</code> The output of this shard will be its input. <code>Any</code> <code>From</code> The initial iteration value (inclusive). <code>0</code> <code>Int</code><code>Var(Int)</code> <code>To</code> The final iteration value (inclusive). <code>1</code> <code>Int</code><code>Var(Int)</code> <code>Action</code> The action to perform at each iteration. The current iteration value will be passed as input. <code>none</code> <code>Shard</code><code>[Shard]</code> <p>Executes a series of shards while an iteration value is within a specified range.</p>"},{"location":"reference/shards/shards/General/ForRange/#examples","title":"Examples","text":"CodeOutput <pre><code>;; Sum all positive integers below 1000\n0 &gt;= .sum\n\n(ForRange\n 1 999\n (-&gt; (Math.Add .sum) &gt; .sum))\n\n.sum (Assert.Is 499500 true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/General/FreeCamera/","title":"FreeCamera","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>[Float4](4)</code> <code>&lt;output&gt;</code> <code>[Float4](4)</code> <code>FlySpeed</code> Controls fly speed with the keyboard <code>none</code> <code>Float</code><code>Var(Float)</code> <code>ScrollSpeed</code> Controls middle mouse movement speed <code>none</code> <code>Float</code><code>Var(Float)</code> <code>PanSpeed</code> Controls middle mouse pan speed <code>none</code> <code>Float</code><code>Var(Float)</code> <code>LookSpeed</code> Controls right mouse look speed <code>none</code> <code>Float</code><code>Var(Float)</code> <p>Provides editor free camera controls</p> <p> </p>"},{"location":"reference/shards/shards/General/FromBase58/","title":"FromBase58","text":"Name - Description Default Type <code>&lt;input&gt;</code> The base58 encoded string to decode. <code>String</code> <code>&lt;output&gt;</code> Outputs the decoded byte array. <code>Bytes</code> <p>This shard decodes the base58 encoded string and outputs it as a decoded byte array.</p> <p> </p>"},{"location":"reference/shards/shards/General/FromBase64/","title":"FromBase64","text":"Name - Description Default Type <code>&lt;input&gt;</code> A Base64 encoded string to be decoded. <code>String</code> <code>&lt;output&gt;</code> The decoded bytes from the input Base64 string. <code>Bytes</code> <p>Decodes a Base64 encoded string to its original byte representation.</p> <p> </p>"},{"location":"reference/shards/shards/General/FromBytes/","title":"FromBytes","text":"Name - Description Default Type <code>&lt;input&gt;</code> This shard will take a byte array. <code>Bytes</code> <code>&lt;output&gt;</code> This shard will return the original value converted back to its original type. <code>Any</code> <p>This shard takes a serialized binary representation of a value and convert it back to its original type.</p> <p> </p>"},{"location":"reference/shards/shards/General/FromJson/","title":"FromJson","text":"Name - Description Default Type <code>&lt;input&gt;</code> A JSON string to be parsed. <code>String</code> <code>&lt;output&gt;</code> Outputs the contents of the input JSON string as the appropriate type. <code>Any</code> <code>Pure</code> If the input string is generic pure json rather then shards flavored json. <code>true</code> <code>Bool</code> <p>This shard parses a JSON string and outputs its contents as the appropriate type.</p> <p> </p>"},{"location":"reference/shards/shards/General/FromLEB128/","title":"FromLEB128","text":"Name - Description Default Type <code>&lt;input&gt;</code> The LEB128 encoded byte array to decode. <code>Bytes</code> <code>&lt;output&gt;</code> Outputs the decoded integer. <code>Int</code> <code>Signed</code> If the integer to encode/decode is signed and can be negative. <code>false</code> <code>Bool</code> <p>This shard decodes the LEB128 encoded byte array and outputs it as an integer (signed or unsigned depending on what was specified in the Signed parameter).</p> <p> </p>"},{"location":"reference/shards/shards/General/Get/","title":"Get","text":"Name - Description Default Type <code>&lt;input&gt;</code> Any input is ignored. <code>&lt;output&gt;</code> The output is the value read from the specified variable. <code>Any</code> <code>Name</code> The name of the variable. <code>\"\"</code> <code>String</code><code>Var(Any)</code> <code>Key</code> The key of the value to read from the table (parameter applicable only if the target variable is a table). <code>none</code> <code>Any</code> <code>Global</code> If the variable is available to all of the wires in the same mesh. <code>false</code> <code>Bool</code> <code>Default</code> The default value used if the variable is not set, the key is not present, or there is a type mismatch. <code>none</code> <code>Any</code> <p>Reads the value of the specified variable.</p>"},{"location":"reference/shards/shards/General/Get/#details","title":"Details","text":"<p><code>Get</code>is used read the value of an existing variable. All sorts of variables that can be created by <code>Set</code>, can be read by <code>Get</code>. </p> <p>The <code>:Name</code> parameter should contain the name of the variable that's being read. If the variable is a string/numeric variable or a sequence it will be read directly. But for a table to be read its key should be passed in the parameter <code>:Key</code>. This will allow <code>Get</code> to access the particular key in the table and read it's value.</p> <p>The <code>:Default</code> parameter specifies a value to return in case the variable being read doesn't yeild a valid value, or the sequence is malformed, or the required key is missing from the table, etc. This allows the program to continue processing even if some expected data is missing.</p> <p>Since variables may be locally scoped (created with <code>(:Global false)</code>; exists only for current wire) or globally scoped (created with <code>(:Global true)</code>; exists for all wires of that mesh), both parameters <code>:Global</code> and <code>:Name</code> are used in combination to identify the correct variable to read.</p> <p>Any input to this shard is ignored and its output contains the value of the variable read by <code>Get</code>.</p> <p>Note</p> <p><code>Get</code> has an alias <code>??</code>. This symbol represents the logical operator <code>OR</code>. Hence, <code>??</code> functions as an alias for <code>Get</code> with a default value. For example, <code>.var1 ?? 40</code> means <code>.var1 or 40</code> and this is effectively an alias for <code>(Get .var1 :Default 40)</code>. See the code examples at the end to understand how this alias is used.</p> <p>See also</p> <ul> <li><code>Const</code></li> <li><code>Ref</code></li> <li><code>Sequence</code></li> <li><code>Set</code></li> <li><code>Table</code></li> </ul>"},{"location":"reference/shards/shards/General/Get/#examples","title":"Examples","text":"CodeOutput <pre><code>;; create a mutable string variable and get its value\n\"Hello\" (Set :Name .svar)           ;; set value\n(Get :Name .svar) &gt;= .gotSvar       ;; get value and store it\n.gotSvar (Log \"gotten value\")       ;; =&gt; gotten value: Hello\n\n;; create an immutable numeric variable and get its value\n100 (Ref :Name .nvar)               ;; set value\n(Get :Name .nvar) &gt;= .gotNvar       ;; modify numeric variable\n.gotNvar (Log \"gotten value\")       ;; =&gt; gotten value: 100\n\n;; create a mutable sequence and get it\n[10 20 30] (Set :Name .sequence)\n(Get .sequence) (Log)               ;; =&gt; [10, 20, 30]\n\n;; create an empty sequence and try reading it with the :Default failsafe\n[] (Set :Name .seqEmpty)\n(Get .seqEmpty\n    :Default \"Void\") (Log)          ;; =&gt; Void\n\n;; create a table and get one of it's key-values pairs\n[\"a\" \"b\"] (Set :Name \"table\" :Key \"key1\")\n(Get .table :Key \"key1\") (Log)      ;; =&gt; [a, b]\n\n;; create a table and try to get a non-existent key-value using the :Default parameter\n[\"a\" \"b\"] (Set :Name \"table\" :Key \"key1\")\n(Get .table \n    :Key \"key2\"\n    :Default \"Key missing\") (Log)   ;; =&gt; \"Key missing\"\n\n;; Using a `Get` alias\n\n;; `??` is `OR` hence alias for `(Get :Default ...)`\n;; try getting a non-existent key-value again\n[\"a\" \"b\"] (Set :Name .tableA :Key \"key1\")\n(Get .tableA :Key \"key2\") ?? \"Key still missing\"\n(Log)                               ;; =&gt; \"Key still missing\"\n\n;; create mutable local/global variables and get their values\n\"Local\" (Set .str)                 ;; create local variable\n\"Global\" (Set .str :Global true)   ;; create same-name global variable\n(Get .str) (Log)                   ;; get local variable =&gt; \"Local\"\n(Get .str :Global true) (Log)      ;; get same-name global variable =&gt; \"Global\"\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/General/GetImagePixel/","title":"GetImagePixel","text":"Name - Description Default Type <code>&lt;input&gt;</code> The position of the pixel to obtain the colour value of, represented as an int2 vector. The first element of the vector represents the x coordinate, and the second element represents the y coordinate. <code>Int2</code> <code>&lt;output&gt;</code> The colour(RGBA) values of the pixel at the specified position as a int4 or float4 vector. The first element of the vector represents the red value, the second element represents the green value, the third element represents the blue value, and the fourth element represents the alpha value. <code>Int4</code><code>Float4</code> <code>Position</code> The position of the pixel to retrieve <code>none</code> <code>Image</code><code>Var(Image)</code> <code>AsInteger</code> Read the pixel as an integer <code>false</code> <code>Bool</code> <code>Default</code> When specified, out of bounds or otherwise failed reads will outputs this value instead of failing <code>none</code> <code>Float4</code><code>Int4</code> <p>This shard analyzes the image(specified in the Image parameter) and outputs the colour value(RGBA) of the pixel at the specified position.</p> <p> </p>"},{"location":"reference/shards/shards/General/Hash/","title":"Hash","text":"Name - Description Default Type <code>&lt;input&gt;</code> Input of any type is accepted. <code>Any</code> <code>&lt;output&gt;</code> This shard outputs the input's hashed value as an int2 (a sequence with 2 integers as elements) with 64-bit integer elements. <code>Int2</code> <p>This shard takes any input type, hashes them using the XXH128 hashing algorithm and outputs their 128-bit hash value as an int2 (a sequence with 2 integers as elements).</p> <p> </p>"},{"location":"reference/shards/shards/General/HexToBytes/","title":"HexToBytes","text":"Name - Description Default Type <code>&lt;input&gt;</code> Accepts a hexadecimal string as input. The input may optionally start with '0x' or '0X'. <code>String</code> <code>&lt;output&gt;</code> The decoded byte array from the input hexadecimal string. <code>Bytes</code> <p>Converts a hexadecimal string to its original byte array representation.</p> <p> </p>"},{"location":"reference/shards/shards/General/Highest/","title":"Highest","text":"Name - Description Default Type <code>&lt;input&gt;</code> A sequence of elements of any type. <code>[Any]</code> <code>&lt;output&gt;</code> Outputs the element with the highest value. <code>Any</code> <p>Takes a sequence and outputs the element with the highest value.</p> <p> </p>"},{"location":"reference/shards/shards/General/If/","title":"If","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value that will be passed to the predicate. <code>Any</code> <code>&lt;output&gt;</code> The input of the shard if <code>Passthrough</code> is <code>true</code>; otherwise, the output of the action that was performed (i.e. <code>Then</code> or <code>Else</code>). <code>Any</code> <code>Predicate</code> The predicate to evaluate in order to trigger <code>Then</code> (when <code>true</code>) or <code>Else</code> (when <code>false</code>). <code>none</code> <code>Shard</code><code>[Shard]</code> <code>Then</code> The shards to activate when <code>Predicate</code> is <code>true</code>. <code>none</code> <code>Shard</code><code>[Shard]</code> <code>Else</code> The shards to activate when <code>Predicate</code> is <code>false</code>. <code>none</code> <code>Shard</code><code>[Shard]</code> <code>Passthrough</code> The output of this shard will be its input. <code>false</code> <code>Bool</code> <p>Evaluates a predicate and executes an action.</p>"},{"location":"reference/shards/shards/General/If/#examples","title":"Examples","text":"CodeOutput <pre><code>5\n(If\n ;:Predicate\n (IsLess 2)\n ;:Then\n (Msg \"lesser than 2\")\n ;:Else\n (Msg \"equal or greater than 2\"))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/General/ImageToBytes/","title":"ImageToBytes","text":"Name - Description Default Type <code>&lt;input&gt;</code> Accepts an image as input. <code>Image</code> <code>&lt;output&gt;</code> The input image represented as a byte array. <code>Bytes</code> <p>Converts an image into a byte array.</p> <p> </p>"},{"location":"reference/shards/shards/General/ImageToFloats/","title":"ImageToFloats","text":"Name - Description Default Type <code>&lt;input&gt;</code> Takes an image as input. <code>Image</code> <code>&lt;output&gt;</code> Outputs the input image represented as a seqeunce of floats. <code>[Float]</code> <p>Convert an image into a sequence of floats. Each pixel in the image is converted to a float value between 0 and 1 and stored in the sequence.</p> <p> </p>"},{"location":"reference/shards/shards/General/Inc/","title":"Inc","text":"Name - Description Default Type <code>&lt;input&gt;</code> The float or integer (or sequence of floats or integers) to increase by 1. <code>Any</code> <code>&lt;output&gt;</code> The input increased by 1. <code>Any</code> <code>Value</code> The value to apply the operation to. <code>none</code> <code>Var(Int)</code><code>Var(Int2)</code><code>Var(Int3)</code><code>Var(Int4)</code><code>Var(Int8)</code><code>Var(Int16)</code><code>Var(Float)</code><code>Var(Float2)</code><code>Var(Float3)</code><code>Var(Float4)</code><code>Var(Color)</code><code>Var([Any])</code> <p>Increases the input by 1.</p> <p> </p>"},{"location":"reference/shards/shards/General/IndexOf/","title":"IndexOf","text":"Name - Description Default Type <code>&lt;input&gt;</code> The sequence to search through. <code>[Any]</code> <code>&lt;output&gt;</code> The index of the item or a sequence of indices. <code>[Int]</code><code>Int</code> <code>Item</code> The item to find the index of from the input, if it's a sequence it will try to match all the items in the sequence, in sequence. <code>none</code> <code>Any</code> <code>All</code> If true will return a sequence with all the indices of Item, empty sequence if not found. <code>false</code> <code>Bool</code> <code>Predicate</code> Optional shards to use for more complex matching. <code>none</code> <code>Shard</code><code>[Shard]</code> <p>This shard will search the input sequence for the index of an item or a pattern of items (specified in the Item parameter) and return its index(or a sequence of indices).</p> <p> </p>"},{"location":"reference/shards/shards/General/Input/","title":"Input","text":"Name - Description Default Type <code>&lt;input&gt;</code> No input is required. <code>&lt;output&gt;</code> The input value of the wire. <code>Any</code> <p>The input value of the wire.</p> <p> </p>"},{"location":"reference/shards/shards/General/Insert/","title":"Insert","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value to prepend to the collection. <code>Any</code> <code>&lt;output&gt;</code> The input to this shard is passed through as its output. <code>Any</code> <code>Index</code> The collection to add the input to. <code>none</code> <code>Int</code><code>Var(Int)</code> <code>Collection</code> The collection to add the input to. <code>none</code> <code>Var([Any])</code><code>Var(String)</code><code>Var(Bytes)</code> <p>Prepends the input to the context variable passed to <code>Collection</code>.</p> <p> </p>"},{"location":"reference/shards/shards/General/IntsToBytes/","title":"IntsToBytes","text":"Name - Description Default Type <code>&lt;input&gt;</code> Accepts sequence of integers as input. <code>[Int]</code> <code>&lt;output&gt;</code> A byte array representing the sequence of integers. <code>Bytes</code> <p>Converts a sequence of integers into a byte array. Each integer in the sequence is serialized into its binary representation and concatenated into the resulting byte array.</p> <p> </p>"},{"location":"reference/shards/shards/General/Is/","title":"Is","text":"Name - Description Default Type <code>&lt;input&gt;</code> Input of any type is accepted. <code>Any</code> <code>&lt;output&gt;</code> Outputs true if the input is equal to the operand and false otherwise. <code>Bool</code> <code>Value</code> The value to check against. <code>0</code> <code>Any</code> <p>Checks if the input is equal to the operand.</p>"},{"location":"reference/shards/shards/General/Is/#details","title":"Details","text":"<p>This shard compares the input to its <code>:Value</code> parameter and outputs <code>true</code> if they are equal or same, else outputs <code>false</code>.</p> <p>If the input and <code>:Value</code> parameter have different data types they will be assessed as inequal by default even if they are numerically equal (for example <code>int 5</code> is not equal to <code>float 5.0</code>).</p> <p>Note that for two sequences to be considered equal or identical they must both contain the same elements and in the same order.</p> <p>For two tables to be considered equal/identical they must both contain the same key/value pairs but the order of these pairs is irrelevant.</p> <p>See also</p> <ul> <li><code>IsNot</code></li> </ul>"},{"location":"reference/shards/shards/General/Is/#examples","title":"Examples","text":"CodeOutput <pre><code>;; string comparison\n\"hello\" (String.ToUpper) (Is \"HELLO\")\n(Assert.Is true :Break true)\n\n;; integer comparison\n2 (Math.Add 3) (Is 5)\n(Assert.Is true :Break true)\n\n;; float comparison\n4.0 (Is (+ 1.0 3.0))\n(Assert.Is true :Break true)\n\n;; sequence comparison\n[1 2 3] (Is [1 2 3])\n(Assert.Is true :Break true)\n\n;; table comparison 1\n{:key1 [10 20] :key2 [30]} (Is {:key1 [10 20] :key2 [30]})\n(Assert.Is true :Break true)\n\n;; table comparison 2\n{:key2 [30] :key1 [10 20]} (Is {:key1 [10 20] :key2 [30]})\n(Assert.Is true :Break true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/General/IsAll/","title":"IsAll","text":"Name - Description Default Type <code>&lt;input&gt;</code> Input of any type is accepted. For types without inherent value (e.g., None, Bool), a lexicographical comparison is used. <code>Any</code> <code>&lt;output&gt;</code> Outputs true if all elements in the input are equal to the specified value and false otherwise. <code>Bool</code> <code>Value</code> The value to check against. Note: This shard will not evaluate variables nested within sequences and tables. If you need to compare them against such variables, wrap them in parentheses, so that they are evaluated first. Example: Value:([your-variable]) instead of Value:your-variable. <code>0</code> <code>Any</code> <p>Checks if all elements in the input are equal to the given value. It outputs true if all elements are equal and false otherwise.</p> <p> </p>"},{"location":"reference/shards/shards/General/IsAllLess/","title":"IsAllLess","text":"Name - Description Default Type <code>&lt;input&gt;</code> Input of any type is accepted. For types without inherent value (e.g., None, Bool), a lexicographical comparison is used. <code>Any</code> <code>&lt;output&gt;</code> Outputs true if all elements in the input are less than the specified value and false otherwise. <code>Bool</code> <code>Value</code> The value to check against. Note: This shard will not evaluate variables nested within sequences and tables. If you need to compare them against such variables, wrap them in parentheses, so that they are evaluated first. Example: Value:([your-variable]) instead of Value:your-variable. <code>0</code> <code>Any</code> <p>Checks if all elements in the input are less than the given value. It outputs true if all elements are less and false otherwise.</p> <p> </p>"},{"location":"reference/shards/shards/General/IsAllLessEqual/","title":"IsAllLessEqual","text":"Name - Description Default Type <code>&lt;input&gt;</code> Input of any type is accepted. For types without inherent value (e.g., None, Bool), a lexicographical comparison is used. <code>Any</code> <code>&lt;output&gt;</code> Outputs true if all elements in the input are less than or equal to the specified value and false otherwise. <code>Bool</code> <code>Value</code> The value to check against. Note: This shard will not evaluate variables nested within sequences and tables. If you need to compare them against such variables, wrap them in parentheses, so that they are evaluated first. Example: Value:([your-variable]) instead of Value:your-variable. <code>0</code> <code>Any</code> <p>Checks if all elements in the input are less than or equal to the given value. It outputs true if all elements are less or equal and false otherwise.</p> <p> </p>"},{"location":"reference/shards/shards/General/IsAllMore/","title":"IsAllMore","text":"Name - Description Default Type <code>&lt;input&gt;</code> Input of any type is accepted. For types without inherent value (e.g., None, Bool), a lexicographical comparison is used. <code>Any</code> <code>&lt;output&gt;</code> Outputs true if all elements in the input are greater than the specified value and false otherwise. <code>Bool</code> <code>Value</code> The value to check against. Note: This shard will not evaluate variables nested within sequences and tables. If you need to compare them against such variables, wrap them in parentheses, so that they are evaluated first. Example: Value:([your-variable]) instead of Value:your-variable. <code>0</code> <code>Any</code> <p>Checks if all elements in the input are greater than the given value. It outputs true if all elements are greater and false otherwise.</p> <p> </p>"},{"location":"reference/shards/shards/General/IsAllMoreEqual/","title":"IsAllMoreEqual","text":"Name - Description Default Type <code>&lt;input&gt;</code> Input of any type is accepted. For types without inherent value (e.g., None, Bool), a lexicographical comparison is used. <code>Any</code> <code>&lt;output&gt;</code> Outputs true if all elements in the input are greater than or equal to the specified value and false otherwise. <code>Bool</code> <code>Value</code> The value to check against. Note: This shard will not evaluate variables nested within sequences and tables. If you need to compare them against such variables, wrap them in parentheses, so that they are evaluated first. Example: Value:([your-variable]) instead of Value:your-variable. <code>0</code> <code>Any</code> <p>Checks if all elements in the input are greater than or equal to the given value. It outputs true if all elements are greater or equal and false otherwise.</p> <p> </p>"},{"location":"reference/shards/shards/General/IsAllNot/","title":"IsAllNot","text":"Name - Description Default Type <code>&lt;input&gt;</code> Input of any type is accepted. For types without inherent value (e.g., None, Bool), a lexicographical comparison is used. <code>Any</code> <code>&lt;output&gt;</code> Outputs true if all elements in the input are not equal to the specified value and false otherwise. <code>Bool</code> <code>Value</code> The value to check against. Note: This shard will not evaluate variables nested within sequences and tables. If you need to compare them against such variables, wrap them in parentheses, so that they are evaluated first. Example: Value:([your-variable]) instead of Value:your-variable. <code>0</code> <code>Any</code> <p>Checks if all elements in the input are not equal to the given value. It outputs true if all elements are not equal and false otherwise.</p> <p> </p>"},{"location":"reference/shards/shards/General/IsAlmost/","title":"IsAlmost","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input can be of any number type or a sequence of such types. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Int</code><code>Int2</code><code>Int3</code><code>Int4</code><code>Int8</code><code>Int16</code><code>[Any]</code> <code>&lt;output&gt;</code> true if the input is almost equal to the given value; otherwise, false. <code>Bool</code> <code>Value</code> The value to test against for almost equality. <code>none</code> <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Int</code><code>Int2</code><code>Int3</code><code>Int4</code><code>Int8</code><code>Int16</code><code>[Any]</code> <code>Threshold</code> The smallest difference to be considered equal. Should be greater than zero. <code>1.19209e-07</code> <code>Float</code><code>Int</code> <p>Checks whether the input is almost equal to a given value.</p>"},{"location":"reference/shards/shards/General/IsAlmost/#examples","title":"Examples","text":"CodeOutput <pre><code>;; integer comparison\n199 (Math.Add 300) (IsAlmost 500 :Threshold 1)\n(Assert.Is true :Break true)\n\n;; float comparison\n4.0 (IsAlmost (+ 0.9999 3.0) :Threshold 0.0001)\n(Assert.Is true :Break true)\n\n;; sequence comparison\n[1 2 3.14] (IsAlmost [1 2 3.14])\n(Assert.Is true :Break true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/General/IsAny/","title":"IsAny","text":"Name - Description Default Type <code>&lt;input&gt;</code> Input of any type is accepted. For types without inherent value (e.g., None, Bool), a lexicographical comparison is used. <code>Any</code> <code>&lt;output&gt;</code> Outputs true if any element in the input is equal to the specified value and false otherwise. <code>Bool</code> <code>Value</code> The value to check against. Note: This shard will not evaluate variables nested within sequences and tables. If you need to compare them against such variables, wrap them in parentheses, so that they are evaluated first. Example: Value:([your-variable]) instead of Value:your-variable. <code>0</code> <code>Any</code> <p>Checks if any element in the input is equal to the given value. It outputs true if any element is equal and false otherwise.</p> <p> </p>"},{"location":"reference/shards/shards/General/IsAnyLess/","title":"IsAnyLess","text":"Name - Description Default Type <code>&lt;input&gt;</code> Input of any type is accepted. For types without inherent value (e.g., None, Bool), a lexicographical comparison is used. <code>Any</code> <code>&lt;output&gt;</code> Outputs true if any element in the input is less than the specified value and false otherwise. <code>Bool</code> <code>Value</code> The value to check against. Note: This shard will not evaluate variables nested within sequences and tables. If you need to compare them against such variables, wrap them in parentheses, so that they are evaluated first. Example: Value:([your-variable]) instead of Value:your-variable. <code>0</code> <code>Any</code> <p>Checks if any element in the input is less than the given value. It outputs true if any element is less and false otherwise.</p> <p> </p>"},{"location":"reference/shards/shards/General/IsAnyLessEqual/","title":"IsAnyLessEqual","text":"Name - Description Default Type <code>&lt;input&gt;</code> Input of any type is accepted. For types without inherent value (e.g., None, Bool), a lexicographical comparison is used. <code>Any</code> <code>&lt;output&gt;</code> Outputs true if any element in the input is less than or equal to the specified value and false otherwise. <code>Bool</code> <code>Value</code> The value to check against. Note: This shard will not evaluate variables nested within sequences and tables. If you need to compare them against such variables, wrap them in parentheses, so that they are evaluated first. Example: Value:([your-variable]) instead of Value:your-variable. <code>0</code> <code>Any</code> <p>Checks if any element in the input is less than or equal to the given value. It outputs true if any element is less or equal and false otherwise.</p> <p> </p>"},{"location":"reference/shards/shards/General/IsAnyMore/","title":"IsAnyMore","text":"Name - Description Default Type <code>&lt;input&gt;</code> Input of any type is accepted. For types without inherent value (e.g., None, Bool), a lexicographical comparison is used. <code>Any</code> <code>&lt;output&gt;</code> Outputs true if any element in the input is greater than the specified value and false otherwise. <code>Bool</code> <code>Value</code> The value to check against. Note: This shard will not evaluate variables nested within sequences and tables. If you need to compare them against such variables, wrap them in parentheses, so that they are evaluated first. Example: Value:([your-variable]) instead of Value:your-variable. <code>0</code> <code>Any</code> <p>Checks if any element in the input is greater than the given value. It outputs true if any element is greater and false otherwise.</p> <p> </p>"},{"location":"reference/shards/shards/General/IsAnyMoreEqual/","title":"IsAnyMoreEqual","text":"Name - Description Default Type <code>&lt;input&gt;</code> Input of any type is accepted. For types without inherent value (e.g., None, Bool), a lexicographical comparison is used. <code>Any</code> <code>&lt;output&gt;</code> Outputs true if any element in the input is greater than or equal to the specified value and false otherwise. <code>Bool</code> <code>Value</code> The value to check against. Note: This shard will not evaluate variables nested within sequences and tables. If you need to compare them against such variables, wrap them in parentheses, so that they are evaluated first. Example: Value:([your-variable]) instead of Value:your-variable. <code>0</code> <code>Any</code> <p>Checks if any element in the input is greater than or equal to the given value. It outputs true if any element is greater or equal and false otherwise.</p> <p> </p>"},{"location":"reference/shards/shards/General/IsAnyNot/","title":"IsAnyNot","text":"Name - Description Default Type <code>&lt;input&gt;</code> Input of any type is accepted. For types without inherent value (e.g., None, Bool), a lexicographical comparison is used. <code>Any</code> <code>&lt;output&gt;</code> Outputs true if any element in the input is not equal to the specified value and false otherwise. <code>Bool</code> <code>Value</code> The value to check against. Note: This shard will not evaluate variables nested within sequences and tables. If you need to compare them against such variables, wrap them in parentheses, so that they are evaluated first. Example: Value:([your-variable]) instead of Value:your-variable. <code>0</code> <code>Any</code> <p>Checks if any element in the input is not equal to the given value. It outputs true if any element is not equal and false otherwise.</p> <p> </p>"},{"location":"reference/shards/shards/General/IsAudio/","title":"IsAudio","text":"Name - Description Default Type <code>&lt;input&gt;</code> Input of any type is accepted. <code>Any</code> <code>&lt;output&gt;</code> Outputs true if the input value is of type Audio, and false otherwise. <code>Bool</code> <p>Checks the input value if it is an Audio file. The shard will return true if the input is of the appropriate type, and false otherwise.</p> <p> </p>"},{"location":"reference/shards/shards/General/IsBool/","title":"IsBool","text":"Name - Description Default Type <code>&lt;input&gt;</code> Input of any type is accepted. <code>Any</code> <code>&lt;output&gt;</code> Outputs true if the input value is of type Bool, and false otherwise. <code>Bool</code> <p>Checks the input value if it is a Boolean. The shard will return true if the input is of the appropriate type, and false otherwise.</p> <p> </p>"},{"location":"reference/shards/shards/General/IsBytes/","title":"IsBytes","text":"Name - Description Default Type <code>&lt;input&gt;</code> Input of any type is accepted. <code>Any</code> <code>&lt;output&gt;</code> Outputs true if the input value is of type Bytes, and false otherwise. <code>Bool</code> <p>Checks the input value if it is of type Bytes. The shard will return true if the input is of the appropriate type, and false otherwise.</p> <p> </p>"},{"location":"reference/shards/shards/General/IsColor/","title":"IsColor","text":"Name - Description Default Type <code>&lt;input&gt;</code> Input of any type is accepted. <code>Any</code> <code>&lt;output&gt;</code> Outputs true if the input value is of type Color, and false otherwise. <code>Bool</code> <p>Checks the input value if it is vector of four color channels (RGBA). The shard will return true if the input is of the appropriate type, and false otherwise.</p> <p> </p>"},{"location":"reference/shards/shards/General/IsFalse/","title":"IsFalse","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value to check against. <code>Bool</code> <code>&lt;output&gt;</code> <code>true</code> if the input is <code>false</code>; otherwise, <code>false</code>. <code>Bool</code> <p>Gets whether the input is <code>false</code>.</p> <p> </p>"},{"location":"reference/shards/shards/General/IsFloat/","title":"IsFloat","text":"Name - Description Default Type <code>&lt;input&gt;</code> Input of any type is accepted. <code>Any</code> <code>&lt;output&gt;</code> Outputs true if the input value is of type Float, and false otherwise. <code>Bool</code> <p>Checks the input value if it is of type Float. The shard will return true if the input is of the appropriate type, and false otherwise.</p> <p> </p>"},{"location":"reference/shards/shards/General/IsFloat2/","title":"IsFloat2","text":"Name - Description Default Type <code>&lt;input&gt;</code> Input of any type is accepted. <code>Any</code> <code>&lt;output&gt;</code> Outputs true if the input value is of type Float2, and false otherwise. <code>Bool</code> <p>Checks the input value if it is a vector with two Float elements. The shard will return true if the input is of the appropriate type, and false otherwise.</p> <p> </p>"},{"location":"reference/shards/shards/General/IsFloat3/","title":"IsFloat3","text":"Name - Description Default Type <code>&lt;input&gt;</code> Input of any type is accepted. <code>Any</code> <code>&lt;output&gt;</code> Outputs true if the input value is of type Float3, and false otherwise. <code>Bool</code> <p>Checks the input value if it is a vector with three Float elements. The shard will return true if the input is of the appropriate type, and false otherwise.</p> <p> </p>"},{"location":"reference/shards/shards/General/IsFloat4/","title":"IsFloat4","text":"Name - Description Default Type <code>&lt;input&gt;</code> Input of any type is accepted. <code>Any</code> <code>&lt;output&gt;</code> Outputs true if the input value is of type Float4, and false otherwise. <code>Bool</code> <p>Checks the input value if it is a vector with float Float elements. The shard will return true if the input is of the appropriate type, and false otherwise.</p> <p> </p>"},{"location":"reference/shards/shards/General/IsImage/","title":"IsImage","text":"Name - Description Default Type <code>&lt;input&gt;</code> Input of any type is accepted. <code>Any</code> <code>&lt;output&gt;</code> Outputs true if the input value is of type Image, and false otherwise. <code>Bool</code> <p>Checks the input value if it is an Image file. The shard will return true if the input is of the appropriate type, and false otherwise.</p> <p> </p>"},{"location":"reference/shards/shards/General/IsInt/","title":"IsInt","text":"Name - Description Default Type <code>&lt;input&gt;</code> Input of any type is accepted. <code>Any</code> <code>&lt;output&gt;</code> Outputs true if the input value is of type Int, and false otherwise. <code>Bool</code> <p>Checks the input value if it is of type Int. The shard will return true if the input value is of type Int, and false otherwise.</p> <p> </p>"},{"location":"reference/shards/shards/General/IsInt16/","title":"IsInt16","text":"Name - Description Default Type <code>&lt;input&gt;</code> Input of any type is accepted. <code>Any</code> <code>&lt;output&gt;</code> Outputs true if the input value is of type Int16, and false otherwise. <code>Bool</code> <p>Checks the input value if it is a vector of 16 Int elements. The shard will return true if the input is of the appropriate type, and false otherwise.</p> <p> </p>"},{"location":"reference/shards/shards/General/IsInt2/","title":"IsInt2","text":"Name - Description Default Type <code>&lt;input&gt;</code> Input of any type is accepted. <code>Any</code> <code>&lt;output&gt;</code> Outputs true if the input value is of type Int2, and false otherwise. <code>Bool</code> <p>Checks the input value if it is a vector of 2 Int elements. The shard will return true if the input is of the appropriate type, and false otherwise.</p> <p> </p>"},{"location":"reference/shards/shards/General/IsInt3/","title":"IsInt3","text":"Name - Description Default Type <code>&lt;input&gt;</code> Input of any type is accepted. <code>Any</code> <code>&lt;output&gt;</code> Outputs true if the input value is of type Int3, and false otherwise. <code>Bool</code> <p>Checks the input value if it is a vector of 3 Int elements. The shard will return true if the input is of the appropriate type, and false otherwise.</p> <p> </p>"},{"location":"reference/shards/shards/General/IsInt4/","title":"IsInt4","text":"Name - Description Default Type <code>&lt;input&gt;</code> Input of any type is accepted. <code>Any</code> <code>&lt;output&gt;</code> Outputs true if the input value is of type Int4, and false otherwise. <code>Bool</code> <p>Checks the input value if it is a vector of 4 Int elements. The shard will return true if the input is of the appropriate type, and false otherwise.</p> <p> </p>"},{"location":"reference/shards/shards/General/IsInt8/","title":"IsInt8","text":"Name - Description Default Type <code>&lt;input&gt;</code> Input of any type is accepted. <code>Any</code> <code>&lt;output&gt;</code> Outputs true if the input value is of type Int8, and false otherwise. <code>Bool</code> <p>Checks the input value if it is a vector of 8 Int elements. The shard will return true if the input is of the appropriate type, and false otherwise.</p> <p> </p>"},{"location":"reference/shards/shards/General/IsLess/","title":"IsLess","text":"Name - Description Default Type <code>&lt;input&gt;</code> Input of any type is accepted. <code>Any</code> <code>&lt;output&gt;</code> Outputs true if the input is less than the operand and false otherwise. <code>Bool</code> <code>Value</code> The value to check against. <code>0</code> <code>Any</code> <p>Checks if the input is less than the operand.</p>"},{"location":"reference/shards/shards/General/IsLess/#details","title":"Details","text":"<p>This shard compares the input to its <code>:Value</code> parameter and outputs <code>true</code> if the input value is less than the value of its <code>:Value</code> parameter, else it outputs <code>false</code>.</p> <p>For a valid comparison, the input and <code>:Value</code> parameter must have identical data types. A comparison across different data types will throw a validation error.</p> <p>This shard can be used to compare simple data types like stings, integers, floats, etc. However, complex data types like sequences or tables cannot be meaningfully compared for the lesser-than/greater-than attribute. Using this shard on such complex data types will give unexpected and meaningless results.</p> <p>See also</p> <ul> <li><code>IsLessEqual</code></li> <li><code>IsMore</code></li> <li><code>IsMoreEqual</code></li> </ul>"},{"location":"reference/shards/shards/General/IsLess/#examples","title":"Examples","text":"CodeOutput <pre><code>;; string comparison\n\"a\" (IsLess \"z\")\n(Assert.Is true :Break true)\n\n;; integer comparison\n2 (IsLess 5)\n(Assert.Is true :Break true)\n\n;; float comparison\n2.0 (IsLess (+ 1.0 3.0))\n(Assert.Is true :Break true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/General/IsLessEqual/","title":"IsLessEqual","text":"Name - Description Default Type <code>&lt;input&gt;</code> Input of any type is accepted. <code>Any</code> <code>&lt;output&gt;</code> Outputs true if the input is less than or equal to the operand and false otherwise. <code>Bool</code> <code>Value</code> The value to check against. <code>0</code> <code>Any</code> <p>Checks if the input is less than or equal to the operand.</p>"},{"location":"reference/shards/shards/General/IsLessEqual/#details","title":"Details","text":"<p>This shard compares the input to its <code>:Value</code> parameter and outputs <code>true</code> if the input value is less than or equal to the value of its <code>:Value</code> parameter, else it outputs <code>false</code>.</p> <p>For a valid comparison, the input and <code>:Value</code> parameter must have identical data types. A comparison across different data types will throw a validation error.</p> <p>This shard can be used to compare simple data types like stings, integers, floats, etc. However, complex data types like sequences or tables cannot be meaningfully compared for the lesser-than/greater-than attribute. Using this shard on such complex data types will give unexpected and meaningless results.</p> <p>See also</p> <ul> <li><code>IsLess</code></li> <li><code>IsMore</code></li> <li><code>IsMoreEqual</code></li> </ul>"},{"location":"reference/shards/shards/General/IsLessEqual/#examples","title":"Examples","text":"CodeOutput <pre><code>;; string comparison\n\"a\" (IsLessEqual \"z\")\n(Assert.Is true :Break true)\n\n;; integer comparison\n2 (IsLessEqual 5)\n(Assert.Is true :Break true)\n\n;; float comparison\n4.0 (IsLessEqual (+ 1.0 3.0))\n(Assert.Is true :Break true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/General/IsMore/","title":"IsMore","text":"Name - Description Default Type <code>&lt;input&gt;</code> Input of any type is accepted. <code>Any</code> <code>&lt;output&gt;</code> Outputs true if the input is greater than the operand and false otherwise. <code>Bool</code> <code>Value</code> The value to check against. <code>0</code> <code>Any</code> <p>Checks if the input is greater than the operand.</p>"},{"location":"reference/shards/shards/General/IsMore/#details","title":"Details","text":"<p>This shard compares the input to its <code>:Value</code> parameter and outputs <code>true</code> if the input value is more than the value of its <code>:Value</code> parameter, else it outputs <code>false</code>.</p> <p>For a valid comparison, the input and <code>:Value</code> parameter must have identical data types. A comparison across different data types will throw a validation error.</p> <p>This shard can be used to compare simple data types like stings, integers, floats, etc. However, complex data types like sequences or tables cannot be meaningfully compared for the lesser-than/greater-than attribute. Using this shard on such complex data types will give unexpected and meaningless results.</p> <p>See also</p> <ul> <li><code>IsLess</code></li> <li><code>IsLessEqual</code></li> <li><code>IsMoreEqual</code></li> </ul>"},{"location":"reference/shards/shards/General/IsMore/#examples","title":"Examples","text":"CodeOutput <pre><code>;; string comparison\n\"z\" (IsMore \"a\")\n(Assert.Is true :Break true)\n\n;; integer comparison\n5 (IsMore 2)\n(Assert.Is true :Break true)\n\n;; float comparison\n5.0 (IsMore (+ 1.0 3.0))\n(Assert.Is true :Break true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/General/IsMoreEqual/","title":"IsMoreEqual","text":"Name - Description Default Type <code>&lt;input&gt;</code> Input of any type is accepted. <code>Any</code> <code>&lt;output&gt;</code> Outputs true if the input is greater than or equal to the operand and false otherwise. <code>Bool</code> <code>Value</code> The value to check against. <code>0</code> <code>Any</code> <p>Checks if the input is greater than or equal to the operand.</p>"},{"location":"reference/shards/shards/General/IsMoreEqual/#details","title":"Details","text":"<p>This shard compares the input to its <code>:Value</code> parameter and outputs <code>true</code> if the input value is more than or equal to the value of its <code>:Value</code> parameter, else it outputs <code>false</code>.</p> <p>For a valid comparison, the input and <code>:Value</code> parameter must have identical data types. A comparison across different data types will throw a validation error.</p> <p>This shard can be used to compare simple data types like stings, integers, floats, etc. However, complex data types like sequences or tables cannot be meaningfully compared for the lesser-than/greater-than attribute. Using this shard on such complex data types will give unexpected and meaningless results.</p> <p>See also</p> <ul> <li><code>IsLess</code></li> <li><code>IsLessEqual</code></li> <li><code>IsMore</code></li> </ul>"},{"location":"reference/shards/shards/General/IsMoreEqual/#examples","title":"Examples","text":"CodeOutput <pre><code>;; string comparison\n\"z\" (IsMoreEqual \"a\")\n(Assert.Is true :Break true)\n\n;; integer comparison\n5 (IsMoreEqual 2)\n(Assert.Is true :Break true)\n\n;; float comparison\n9.0 (IsMoreEqual (+ 1.0 1.0))\n(Assert.Is true :Break true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/General/IsNone/","title":"IsNone","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value which type to check against. <code>Any</code> <code>&lt;output&gt;</code> <code>true</code> is the type of input is <code>None</code>; otherwise, <code>false</code>. <code>Bool</code> <p>Gets whether the type of the input is <code>None</code>.</p> <p> </p>"},{"location":"reference/shards/shards/General/IsNot/","title":"IsNot","text":"Name - Description Default Type <code>&lt;input&gt;</code> Input of any type is accepted. <code>Any</code> <code>&lt;output&gt;</code> Outputs true if the input is not equal to the operand and false otherwise. <code>Bool</code> <code>Value</code> The value to check against. <code>0</code> <code>Any</code> <p>Checks if the input is not equal to the operand.</p>"},{"location":"reference/shards/shards/General/IsNot/#details","title":"Details","text":"<p>This shard compares the input to its <code>:Value</code> parameter and outputs <code>true</code> if they are different, else outputs <code>false</code>.</p> <p>If the input and <code>:Value</code> parameter have different data types they will be assessed as inequal by default even if they are numerically equal (for example <code>int 5</code> is not equal to <code>float 5.0</code>).</p> <p>See also</p> <ul> <li><code>Is</code></li> </ul>"},{"location":"reference/shards/shards/General/IsNot/#examples","title":"Examples","text":"CodeOutput <pre><code>;; string comparison\n\"hello\" (IsNot \"HELLO\")\n(Assert.Is true :Break true)\n\n;; integer comparison\n2 (Math.Add 3) (IsNot 4)\n(Assert.Is true :Break true)\n\n;; integer/float comparison\n4 (IsNot (+ 1.0 3.0))\n(Assert.Is true :Break true)\n\n;; string/integer comparison\n\"Shards\" (IsNot 122)\n(Assert.Is true :Break true)\n\n;; sequence comparison\n[1 2 3] (IsNot [1 3])\n(Assert.Is true :Break true)\n\n;; table comparison\n{:key3 [10 20] :key2 [30]} (IsNot {:key1 [10 20] :key2 [30]})\n(Assert.Is true :Break true)\n\n;; sequence/table comparison\n[1 2 3] (IsNot {:key1 [1 2] :key2 [3]})\n(Assert.Is true :Break true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/General/IsNotNone/","title":"IsNotNone","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value which type to check against. <code>Any</code> <code>&lt;output&gt;</code> <code>true</code> is the type of input different from <code>None</code>; otherwise, <code>false</code>. <code>Bool</code> <p>Gets whether the type of the input is different from <code>None</code>.</p> <p> </p>"},{"location":"reference/shards/shards/General/IsRunning/","title":"IsRunning","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input of this shard is ignored. <code>&lt;output&gt;</code> This shard will either return true if the specified Wire is still running, or false if it has ended. <code>Bool</code> <code>Wire</code> The wire to check. <code>none</code> <code>Wire</code><code>String</code><code>Var(Wire)</code> <p>Checks if a Wire is running and outputs true if it is, false if otherwise. (Note that a looped Wire will always be running and thus will always return true)</p> <p> </p>"},{"location":"reference/shards/shards/General/IsSeq/","title":"IsSeq","text":"Name - Description Default Type <code>&lt;input&gt;</code> Input of any type is accepted. <code>Any</code> <code>&lt;output&gt;</code> Outputs true if the input value is of the specified type, and false otherwise. <code>Bool</code> <p>Checks the input value if it is of the type specified. The shard will return true if the input is of the appropriate type, and false otherwise.</p> <p> </p>"},{"location":"reference/shards/shards/General/IsString/","title":"IsString","text":"Name - Description Default Type <code>&lt;input&gt;</code> Input of any type is accepted. <code>Any</code> <code>&lt;output&gt;</code> Outputs true if the input value is of type String, and false otherwise. <code>Bool</code> <p>Checks the input value if it is a String. The shard will return true if the input is of the appropriate type, and false otherwise.</p> <p> </p>"},{"location":"reference/shards/shards/General/IsTable/","title":"IsTable","text":"Name - Description Default Type <code>&lt;input&gt;</code> Input of any type is accepted. <code>Any</code> <code>&lt;output&gt;</code> Outputs true if the input value is of type Table, and false otherwise. <code>Bool</code> <p>Checks the input value if it is a Table. The shard will return true if the input is of the appropriate type, and false otherwise.</p> <p> </p>"},{"location":"reference/shards/shards/General/IsTrue/","title":"IsTrue","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value to check against. <code>Bool</code> <code>&lt;output&gt;</code> <code>true</code> if the input is <code>true</code>; otherwise, <code>false</code>. <code>Bool</code> <p>Gets whether the input is <code>true</code>.</p> <p> </p>"},{"location":"reference/shards/shards/General/IsValidNumber/","title":"IsValidNumber","text":"Name - Description Default Type <code>&lt;input&gt;</code> The floating-point number to be checked. <code>Float</code> <code>&lt;output&gt;</code> Outputs true if the input is a valid normal floating-point number, otherwise outputs false. <code>Bool</code> <p>Checks if the input is a valid floating-point number (not zero, subnormal, infinity, or NaN). Outputs true if the input is a normal floating-point number, otherwise outputs false.</p> <p> </p>"},{"location":"reference/shards/shards/General/IsWire/","title":"IsWire","text":"Name - Description Default Type <code>&lt;input&gt;</code> Input of any type is accepted. <code>Any</code> <code>&lt;output&gt;</code> Outputs true if the input value is of type Wire, and false otherwise. <code>Bool</code> <p>Checks the input value if it is a Wire. The shard will return true if the input is of the appropriate type, and false otherwise.</p> <p> </p>"},{"location":"reference/shards/shards/General/Isolate/","title":"Isolate","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Any</code> <code>&lt;output&gt;</code> <code>Any</code> <code>Contents</code> <code>none</code> <code>Shard</code><code>[Shard]</code> <code>Include</code> Includes only the listed variables <code>none</code> <code>[String]</code> <code>Exclude</code> Ignores all the listed variables <code>none</code> <code>[String]</code> <p>Isolates the inner shards' environment by only allowing certain variables</p> <p> </p>"},{"location":"reference/shards/shards/General/LastError/","title":"LastError","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input of this shard is ignored. <code>&lt;output&gt;</code> The last error message that occurred as a string. <code>String</code> <p>This shard outputs the last error message that occurred as a string.</p> <p> </p>"},{"location":"reference/shards/shards/General/Lerp/","title":"Lerp","text":"Name - Description Default Type <code>&lt;input&gt;</code> The factor to interpolate between the start and end values. <code>Float</code> <code>&lt;output&gt;</code> The interpolated value between the start and end values based on the factor provided as input. <code>Int</code><code>Int2</code><code>Int3</code><code>Int4</code><code>Int8</code><code>Int16</code><code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <code>First</code> The start value <code>none</code> <code>Int</code><code>Var(Int)</code><code>Int2</code><code>Var(Int2)</code><code>Int3</code><code>Var(Int3)</code><code>Int4</code><code>Var(Int4)</code><code>Int8</code><code>Var(Int8)</code><code>Int16</code><code>Var(Int16)</code><code>Float</code><code>Var(Float)</code><code>Float2</code><code>Var(Float2)</code><code>Float3</code><code>Var(Float3)</code><code>Float4</code><code>Var(Float4)</code><code>Color</code><code>Var(Color)</code> <code>Second</code> The end value <code>none</code> <code>Int</code><code>Var(Int)</code><code>Int2</code><code>Var(Int2)</code><code>Int3</code><code>Var(Int3)</code><code>Int4</code><code>Var(Int4)</code><code>Int8</code><code>Var(Int8)</code><code>Int16</code><code>Var(Int16)</code><code>Float</code><code>Var(Float)</code><code>Float2</code><code>Var(Float2)</code><code>Float3</code><code>Var(Float3)</code><code>Float4</code><code>Var(Float4)</code><code>Color</code><code>Var(Color)</code> <p>Linearly interpolate between the start value specified in the <code>First</code> parameter and the end value specified in the <code>Second</code> parameter based on the factor provided as input.</p> <p> </p>"},{"location":"reference/shards/shards/General/Limit/","title":"Limit","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input sequence to truncate. <code>[Any]</code> <code>&lt;output&gt;</code> The truncated sequence (or a single element if Max is 1). <code>Any</code> <code>Max</code> How many maximum elements to take from the input sequence. <code>0</code> <code>Int</code> <p>This shard truncates the input sequence to the specified number of elements(specified by the Max parameter) and outputs the truncated sequence.</p> <p> </p>"},{"location":"reference/shards/shards/General/Listen/","title":"Listen","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Any</code> <code>&lt;output&gt;</code> <code>Any</code> <code>Name</code> The name of the channel. <code>\"\"</code> <code>String</code> <code>Type</code> The expected type to receive. <code>none</code> <code>Type</code> <code>Buffer</code> The amount of values to buffer before outputting them. <code>1</code> <code>Int</code>"},{"location":"reference/shards/shards/General/LoadImage/","title":"LoadImage","text":"Name - Description Default Type <code>&lt;input&gt;</code> An image represented as a byte array <code>Bytes</code><code>Any</code> <code>&lt;output&gt;</code> The image as an image type. <code>Image</code> <code>File</code> The file to load the image from <code>none</code> <code>String</code><code>Var(String)</code> <code>BPP</code> bits per pixel (HDR images loading and such!) <code>none</code> <code>BPP</code> <code>PremultiplyAlpha</code> Toggle premultiplication of alpha channel <code>none</code> <code>Bool</code> <p>This shard loads an image from a file (specified in the File parameter) or byte array (passed as input) and outputs it as an image type, that can subsequently be used by other shards such as UI.Image and UI.ImageButton.</p> <p> </p>"},{"location":"reference/shards/shards/General/Log/","title":"Log","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value to be logged to the console. <code>Any</code> <code>&lt;output&gt;</code> The same value that was inputted, unmodified. <code>Any</code> <code>Prefix</code> The message to prefix to the logged output. Note: the prefix will include a colon ':' before the value. <code>\"\"</code> <code>String</code> <code>Level</code> The level of logging. <code>LogLevel::Info</code> <code>LogLevel</code> <code>Name</code> The name of the logger to use, the default is 'shards'. <code>\"shards\"</code> <code>String</code> <p>Logs the output of a shard or the value of a variable to the console along with an optional prefix string. The logging level can be specified to control the verbosity of the log output.</p>"},{"location":"reference/shards/shards/General/Log/#details","title":"Details","text":"<p>This shard is used for printing information to the console for debugging purposes.</p> <p>It can log the output of a shard or the value of a variable. It can also prefix a message string to the logged output while displaying it in the console.</p>"},{"location":"reference/shards/shards/General/Log/#examples","title":"Examples","text":"CodeOutput <pre><code>\"I am a var\" = .var\n(* 2 4) (Log) ;; log previous shard output\n.var (Log)  ;; log a variable value\n(+ 3 9) (Log :Prefix \"String\") ;; prefix a string to the logged output\n</code></pre> <pre><code>\n</code></pre> CodeOutput <pre><code>\"I am a var\" = .var\n(* 2 4) (Log :Level LogLevel.Info) ;; log previous shard output\n.var (Log :Level LogLevel.Warning)  ;; log a variable value\n(+ 3 9) (Log :Prefix \"String\" :Level LogLevel.Error) ;; prefix a string to the logged output\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/General/LogType/","title":"LogType","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value whose type will be logged to the console. <code>Any</code> <code>&lt;output&gt;</code> The same value that was inputted, unmodified. <code>Any</code> <code>Prefix</code> The message to prefix to the logged output. Note: the prefix will include a colon ':' before the value. <code>\"\"</code> <code>String</code> <code>Level</code> The level of logging. <code>LogLevel::Info</code> <code>LogLevel</code> <code>Name</code> The name of the logger to use, the default is 'shards'. <code>\"shards\"</code> <code>String</code> <p>Logs the type of the value to the console along with an optional prefix string. The logging level can be specified to control the verbosity of the log output.</p> <p> </p>"},{"location":"reference/shards/shards/General/Lowest/","title":"Lowest","text":"Name - Description Default Type <code>&lt;input&gt;</code> A sequence of elements of any type. <code>[Any]</code> <code>&lt;output&gt;</code> Outputs the element with the lowest value. <code>Any</code> <p>Takes a sequence and outputs the element with the lowest value.</p> <p> </p>"},{"location":"reference/shards/shards/General/MakeColor/","title":"MakeColor","text":"Name - Description Default Type <code>&lt;input&gt;</code> No input is required. This shard uses the values provided in the parameters to construct the vector. <code>&lt;output&gt;</code> Outputs a vector of four color channels (RGBA). <code>Any</code> <code>0</code> Vector element <code>none</code> <code>Var(Int)</code><code>Int</code> <code>1</code> Vector element <code>none</code> <code>Var(Int)</code><code>Int</code> <code>2</code> Vector element <code>none</code> <code>Var(Int)</code><code>Int</code> <code>3</code> Vector element <code>none</code> <code>Var(Int)</code><code>Int</code> <p>Creates a vector of four color channels (RGBA). If fewer than four values are provided, the remaining elements will be set to 0. The alias for this shard is @color.</p> <p> </p>"},{"location":"reference/shards/shards/General/MakeFloat2/","title":"MakeFloat2","text":"Name - Description Default Type <code>&lt;input&gt;</code> No input is required. This shard uses the values provided in the parameters to construct the vector. <code>&lt;output&gt;</code> Outputs a vector of two Float elements. <code>Any</code> <code>0</code> Vector element <code>none</code> <code>Var(Float)</code><code>Float</code> <code>1</code> Vector element <code>none</code> <code>Var(Float)</code><code>Float</code> <p>Creates a vector of two Float elements from the values provided in the parameters. If fewer than two values are provided, the remaining elements will be set to 0. The alias for this shard is @f2.</p> <p> </p>"},{"location":"reference/shards/shards/General/MakeFloat3/","title":"MakeFloat3","text":"Name - Description Default Type <code>&lt;input&gt;</code> No input is required. This shard uses the values provided in the parameters to construct the vector. <code>&lt;output&gt;</code> Outputs a vector of three Float elements. <code>Any</code> <code>0</code> Vector element <code>none</code> <code>Var(Float)</code><code>Float</code> <code>1</code> Vector element <code>none</code> <code>Var(Float)</code><code>Float</code> <code>2</code> Vector element <code>none</code> <code>Var(Float)</code><code>Float</code> <p>Creates a vector of three Float elements from the values provided in the parameters. If fewer than three values are provided, the remaining elements will be set to 0. The alias for this shard is @f3.</p> <p> </p>"},{"location":"reference/shards/shards/General/MakeFloat4/","title":"MakeFloat4","text":"Name - Description Default Type <code>&lt;input&gt;</code> No input is required. This shard uses the values provided in the parameters to construct the vector. <code>&lt;output&gt;</code> Outputs a vector of Four Float elements. <code>Any</code> <code>0</code> Vector element <code>none</code> <code>Var(Float)</code><code>Float</code> <code>1</code> Vector element <code>none</code> <code>Var(Float)</code><code>Float</code> <code>2</code> Vector element <code>none</code> <code>Var(Float)</code><code>Float</code> <code>3</code> Vector element <code>none</code> <code>Var(Float)</code><code>Float</code> <p>Creates a vector of four Float elements from the values provided in the parameters. If fewer than four values are provided, the remaining elements will be set to 0. The alias for this shard is @f4.</p> <p> </p>"},{"location":"reference/shards/shards/General/MakeInt16/","title":"MakeInt16","text":"Name - Description Default Type <code>&lt;input&gt;</code> No input is required. This shard uses the values provided in the parameters to construct the vector. <code>&lt;output&gt;</code> Outputs a vector of sixteen Int elements. <code>Any</code> <code>0</code> Vector element <code>none</code> <code>Var(Int)</code><code>Int</code> <code>1</code> Vector element <code>none</code> <code>Var(Int)</code><code>Int</code> <code>2</code> Vector element <code>none</code> <code>Var(Int)</code><code>Int</code> <code>3</code> Vector element <code>none</code> <code>Var(Int)</code><code>Int</code> <code>4</code> Vector element <code>none</code> <code>Var(Int)</code><code>Int</code> <code>5</code> Vector element <code>none</code> <code>Var(Int)</code><code>Int</code> <code>6</code> Vector element <code>none</code> <code>Var(Int)</code><code>Int</code> <code>7</code> Vector element <code>none</code> <code>Var(Int)</code><code>Int</code> <code>8</code> Vector element <code>none</code> <code>Var(Int)</code><code>Int</code> <code>9</code> Vector element <code>none</code> <code>Var(Int)</code><code>Int</code> <code>10</code> Vector element <code>none</code> <code>Var(Int)</code><code>Int</code> <code>11</code> Vector element <code>none</code> <code>Var(Int)</code><code>Int</code> <code>12</code> Vector element <code>none</code> <code>Var(Int)</code><code>Int</code> <code>13</code> Vector element <code>none</code> <code>Var(Int)</code><code>Int</code> <code>14</code> Vector element <code>none</code> <code>Var(Int)</code><code>Int</code> <code>15</code> Vector element <code>none</code> <code>Var(Int)</code><code>Int</code> <p>Creates a vector of sixteen Int elements from the values provided in the parameters. If fewer than sixteen values are provided, the remaining elements will be set to 0. The alias for this shard is @i16.</p> <p> </p>"},{"location":"reference/shards/shards/General/MakeInt2/","title":"MakeInt2","text":"Name - Description Default Type <code>&lt;input&gt;</code> No input is required. This shard uses the values provided in the parameters to construct the vector. <code>&lt;output&gt;</code> Outputs a vector of two Int elements. <code>Any</code> <code>0</code> Vector element <code>none</code> <code>Var(Int)</code><code>Int</code> <code>1</code> Vector element <code>none</code> <code>Var(Int)</code><code>Int</code> <p>Creates a vector of two Int elements from the values provided in the parameters. If fewer than two values are provided, the remaining elements will be set to 0. The alias for this shard is @i2.</p> <p> </p>"},{"location":"reference/shards/shards/General/MakeInt3/","title":"MakeInt3","text":"Name - Description Default Type <code>&lt;input&gt;</code> No input is required. This shard uses the values provided in the parameters to construct the vector. <code>&lt;output&gt;</code> Outputs a vector of three Int elements. <code>Any</code> <code>0</code> Vector element <code>none</code> <code>Var(Int)</code><code>Int</code> <code>1</code> Vector element <code>none</code> <code>Var(Int)</code><code>Int</code> <code>2</code> Vector element <code>none</code> <code>Var(Int)</code><code>Int</code> <p>Creates a vector of three Int elements from the values provided in the parameters. If fewer than three values are provided, the remaining elements will be set to 0.The alias for this shard is @i3.</p> <p> </p>"},{"location":"reference/shards/shards/General/MakeInt4/","title":"MakeInt4","text":"Name - Description Default Type <code>&lt;input&gt;</code> No input is required. This shard uses the values provided in the parameters to construct the vector. <code>&lt;output&gt;</code> Outputs a vector of four Int elements. <code>Any</code> <code>0</code> Vector element <code>none</code> <code>Var(Int)</code><code>Int</code> <code>1</code> Vector element <code>none</code> <code>Var(Int)</code><code>Int</code> <code>2</code> Vector element <code>none</code> <code>Var(Int)</code><code>Int</code> <code>3</code> Vector element <code>none</code> <code>Var(Int)</code><code>Int</code> <p>Creates a vector of four Int elements from the values provided in the parameters. If fewer than four values are provided, the remaining elements will be set to 0. The alias for this shard is @i4.</p> <p> </p>"},{"location":"reference/shards/shards/General/MakeInt8/","title":"MakeInt8","text":"Name - Description Default Type <code>&lt;input&gt;</code> No input is required. This shard uses the values provided in the parameters to construct the vector. <code>&lt;output&gt;</code> Outputs a vector of eight Int elements. <code>Any</code> <code>0</code> Vector element <code>none</code> <code>Var(Int)</code><code>Int</code> <code>1</code> Vector element <code>none</code> <code>Var(Int)</code><code>Int</code> <code>2</code> Vector element <code>none</code> <code>Var(Int)</code><code>Int</code> <code>3</code> Vector element <code>none</code> <code>Var(Int)</code><code>Int</code> <code>4</code> Vector element <code>none</code> <code>Var(Int)</code><code>Int</code> <code>5</code> Vector element <code>none</code> <code>Var(Int)</code><code>Int</code> <code>6</code> Vector element <code>none</code> <code>Var(Int)</code><code>Int</code> <code>7</code> Vector element <code>none</code> <code>Var(Int)</code><code>Int</code> <p>Creates a vector of eight Int elements from the values provided in the parameters. If fewer than eight values are provided, the remaining elements will be set to 0. The alias for this shard is @i8</p> <p> </p>"},{"location":"reference/shards/shards/General/MakeTrait/","title":"MakeTrait","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input of this shard is ignored. <code>&lt;output&gt;</code> The trait object created. <code>Any</code> <code>Name</code> The trait name <code>none</code> <code>String</code> <code>Types</code> The trait types <code>none</code> <code>{Type}</code> <p>This shard creates a trait with the specified name and types and makes it available for use in the wire.</p> <p> </p>"},{"location":"reference/shards/shards/General/Map/","title":"Map","text":"Name - Description Default Type <code>&lt;input&gt;</code> The sequence or table to process. <code>[Any]</code><code>{Any}</code> <code>&lt;output&gt;</code> The resulting processed sequence or table. <code>[Any]</code> <code>Apply</code> The function to apply to each item of the sequence or key-value pair of the table. <code>none</code> <code>Shard</code><code>[Shard]</code> <p>Processes each element of a sequence or key-value pair of a table using the shards specified in the <code>Apply</code> parameter and outputs the modified sequence or table. Note that this shard is able to use the $0 and $1 internal variables, as well as $i for the current index.</p> <p> </p>"},{"location":"reference/shards/shards/General/Match/","title":"Match","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value that's compared with the declared cases. <code>Any</code> <code>&lt;output&gt;</code> Same value as input if <code>:Passthrough</code> is <code>true</code> else the output of the matched case's shard if <code>:Passthrough</code> is <code>false</code>. <code>Any</code> <code>Cases</code> Values to match against the input. A <code>none</code> case will match anything. <code>[]</code> <code>[Any]</code> <code>Passthrough</code> Parameter to control the shard's output. <code>true</code> allows the <code>Match</code> shard's input itself to appear as its output; <code>false</code> allows the matched shard's output to appear as <code>Match</code> shard's output. <code>true</code> <code>Bool</code> <p>Compares the input with the declared cases (in order of the declaration) and activates the shard of the first matched case.</p>"},{"location":"reference/shards/shards/General/Match/#details","title":"Details","text":"<p><code>Match</code> compares its input with every case declared via the <code>:Cases</code> parameter (in the order of their declaration) till a match is found.</p> <p>Once a match is found the shard of that matched case is activated/executed and <code>Match</code> execution stops. All subsequent cases (even matching ones) are ignored.</p> <p>A <code>nil</code> case matches anything, so it's a good practice to declare a <code>nil</code> case at the end of <code>:Cases</code> to execute some default logic if no valid matches exist for a given input. If you do not have a <code>nil</code> case, then a non-matching input to <code>Match</code> will fail the shard.</p>"},{"location":"reference/shards/shards/General/Match/#a-note-on-passthrough","title":"A note on <code>:Passthrough</code>","text":"<p>The <code>:Passthrough</code> parameter can control the final output of the shard it applies to.</p> <p>Setting this parameter to <code>true</code> allows the original input of a shard to pass through as its output as well. If this parameter is set to <code>false</code>, passthrough is suppressed and then the output of the shard is the actual computed value coming out from the shard execution.</p> <p><code>:Passthrough</code> parameter set to <code>true</code> will allow the original input (the one that was used to match against every case in the shard) to be returned as the final output of <code>Match</code>, irrespective of the case match results. Setting <code>:Passthrough</code> to <code>false</code> will enable the matched case's shard output to be returned as the final output of <code>Match</code>.</p> <p>However, for <code>:Passthrough</code> to work correctly, the data types of the shard input and the shard's case outputs must match.</p>"},{"location":"reference/shards/shards/General/Match/#examples","title":"Examples","text":"CodeOutput <pre><code>;; single match + nil match at end + no passthrough\n1\n(Match [2 (-&gt; \"Matched 2\")         ;; case processed, match not found\n        1 (-&gt; \"Matched 1\")         ;; case processed, match found\n        3 (-&gt; \"Matched 3\")         ;; case ignored\n        nil (-&gt; \"Matched nil\")]    ;; case ignored \n       :Passthrough false)         ;; no passthrough --\n(Assert.Is \"Matched 1\" true)       ;; -- so matched case's output becomes `Match` shard's output\n</code></pre> <pre><code>\n</code></pre> CodeOutput <pre><code>;; multiple matches + nil match at end + no passthrough\n1\n(Match [(+ 0 1) (-&gt; \"Matched 1a\")  ;; case processed, match found\n        1 (-&gt; \"Matched 1\")         ;; case ignored\n        2 (-&gt; \"Matched 2\")         ;; case ignored\n        nil (-&gt; \"Matched nil\")]    ;; case ignored \n       :Passthrough false)         ;; no passthrough --\n(Assert.Is \"Matched 1a\" true)      ;; -- so matched case's output becomes `Match` shard's output\n</code></pre> <pre><code>\n</code></pre> CodeOutput <pre><code>;; multiple matches + nil match at start + with passthrough\n1\n(Match [nil (-&gt; (Msg \"Matched nil\"))     ;; case processed, match found\n        1 (-&gt; (Msg \"Matched 1\"))         ;; case ignored\n        (+ 0 1) (-&gt; (Msg \"Matched 1a\"))  ;; case ignored\n        2 (-&gt; (Msg \"Matched 2\"))]        ;; case ignored\n       :Passthrough true)                ;; passthrough --\n(Assert.Is 1 true)                       ;; -- so input to `Match` is also its output\n</code></pre> <pre><code>\n</code></pre> CodeOutput <pre><code>;; no matches + nil match in the middle + with passthrough\n1\n(Match [2 (-&gt; (Msg \"Matched 2\"))         ;; case processed, match not found\n        nil (-&gt; (Msg \"Matched nil\"))     ;; case processed, match found\n        3 (-&gt; (Msg \"Matched 3\"))]        ;; case ignored\n       :Passthrough true)                ;; passthrough --\n(Assert.Is 1 true)                       ;; -- so input to `Match` is also its output\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/General/Max/","title":"Max","text":"Name - Description Default Type <code>&lt;input&gt;</code> The first value to compare with. <code>Int</code><code>Int2</code><code>Int3</code><code>Int4</code><code>Int8</code><code>Int16</code><code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <code>&lt;output&gt;</code> The larger value between the input and the operand. <code>Int</code><code>Int2</code><code>Int3</code><code>Int4</code><code>Int8</code><code>Int16</code><code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <code>Operand</code> The operand for this operation. <code>0</code> <code>Int</code><code>Var(Int)</code><code>Int2</code><code>Var(Int2)</code><code>Int3</code><code>Var(Int3)</code><code>Int4</code><code>Var(Int4)</code><code>Int8</code><code>Var(Int8)</code><code>Int16</code><code>Var(Int16)</code><code>Float</code><code>Var(Float)</code><code>Float2</code><code>Var(Float2)</code><code>Float3</code><code>Var(Float3)</code><code>Float4</code><code>Var(Float4)</code><code>Color</code><code>Var(Color)</code><code>[Any]</code><code>Var([Any])</code> <p>This shard compares the input with the value specified in the <code>Operand</code> parameter and outputs the larger value.</p>"},{"location":"reference/shards/shards/General/Max/#details","title":"Details","text":"<p>This shard compares the input to its <code>:Operand</code> parameter and outputs the greater of the two values.</p> <p>If the input is a sequence and the <code>:Operand</code> a single number, each input element is compared with the <code>:Operand</code> and the greater value from each comparison is collected and output as a sequence.</p> <p>If the input and <code>:Operand</code> both are sequences, each element of the input sequence is compared with the corresponding-index element in the <code>:Operand</code> sequence and the greater value from each comparison is collected and output as a sequence.</p> <p>If the input sequence is smaller in size than the <code>:Operand</code> sequence the comparison stops with the last element of the input sequence. If the <code>:Operand</code> sequence is smaller the remaining input sequence elements loop over the <code>:Operand</code> sequence till all input sequence elements have been compared.</p> <p>This shard works only on numbers (integers, floats) and on sequences of such numbers. The data types of the input and the <code>:Operand</code> parameters must match.</p> <p>See also</p> <ul> <li><code>Min</code></li> </ul>"},{"location":"reference/shards/shards/General/Max/#examples","title":"Examples","text":"CodeOutput <pre><code>;; sequence vs number\n(Const [-1 0 1 2 5])\n(Max\n ;:Operand\n 3)\n(Assert.Is [3 3 3 3 5] true)\n\n;; number vs number\n(Const 3)\n(Max\n ;:Operand\n 2)\n(Assert.Is 3 true)\n\n;; sequence (equal) vs sequence (equal)\n(Const [-1 0 1 2 5])\n(Max\n ;:Operand\n [3 -2 4 0 1])\n(Assert.Is [3 0 4 2 5] true)\n\n;; sequence (smaller) vs sequence (bigger)\n(Const [-1 0 5])\n(Max\n ;:Operand\n [3 -2 4 0 1])\n(Assert.Is [3 0 5] true)\n\n;; sequence (bigger) vs sequence (smaller)\n(Const [-1 0 1 2 5])\n(Max\n ;:Operand\n [3 -2 1])\n(Assert.Is [3 0 1 3 5] true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/General/Maybe/","title":"Maybe","text":"Name - Description Default Type <code>&lt;input&gt;</code> Must match the input types of the first shard in the sequence. <code>Any</code> <code>&lt;output&gt;</code> Will match the output types of the first shard of the sequence. <code>Any</code> <code>Shards</code> The shards to activate. <code>none</code> <code>Shard</code><code>[Shard]</code> <code>Else</code> The shards to activate on failure. <code>none</code> <code>Shard</code><code>[Shard]</code> <code>Silent</code> If logging should be disabled while running the shards (this will also disable (Log) and (Msg) shards) and no warning message should be printed on failure. <code>false</code> <code>Bool</code> <p>Attempts to activate a shard or a sequence of shards. Upon failure, activate another shard or sequence of shards.</p>"},{"location":"reference/shards/shards/General/Maybe/#examples","title":"Examples","text":"CodeOutput <pre><code>[1 2]\n(Maybe\n ;:Shards\n (Take 3)\n ;:Else\n (Take 0)\n ;:Silent\n true)\n(Log \"result\")\n</code></pre> <pre><code>\n</code></pre> CodeOutput <pre><code>[1 2]\n(Maybe\n ;:Shards\n (Take 3)\n ;:Else\n (-&gt;\n  (Msg \"Invalid, default to 42\" LogLevel.Warning)\n  42)\n ;:Silent\n true)\n(Log \"result\")\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/General/Memoize/","title":"Memoize","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Any</code> <code>&lt;output&gt;</code> <code>Any</code> <code>Evaluate</code> The shards to evaluate the cached value based on input <code>none</code> <code>Shard</code><code>[Shard]</code> <p>Computes a value</p> <p> </p>"},{"location":"reference/shards/shards/General/Merge/","title":"Merge","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>{Any}</code> <code>&lt;output&gt;</code> <code>{Any}</code> <code>Target</code> The table to merge into. <code>none</code> <code>Var({Any})</code> <p>Combine two tables into one, with the input table taking priority over the operand table, which will be written and returned as output. This shard is useful in scenarios where you need to merge data from different sources while keeping the priority of certain values.</p> <p> </p>"},{"location":"reference/shards/shards/General/Min/","title":"Min","text":"Name - Description Default Type <code>&lt;input&gt;</code> The first value to compare with. <code>Int</code><code>Int2</code><code>Int3</code><code>Int4</code><code>Int8</code><code>Int16</code><code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <code>&lt;output&gt;</code> The smaller value between the input and the operand. <code>Int</code><code>Int2</code><code>Int3</code><code>Int4</code><code>Int8</code><code>Int16</code><code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <code>Operand</code> The operand for this operation. <code>0</code> <code>Int</code><code>Var(Int)</code><code>Int2</code><code>Var(Int2)</code><code>Int3</code><code>Var(Int3)</code><code>Int4</code><code>Var(Int4)</code><code>Int8</code><code>Var(Int8)</code><code>Int16</code><code>Var(Int16)</code><code>Float</code><code>Var(Float)</code><code>Float2</code><code>Var(Float2)</code><code>Float3</code><code>Var(Float3)</code><code>Float4</code><code>Var(Float4)</code><code>Color</code><code>Var(Color)</code><code>[Any]</code><code>Var([Any])</code> <p>This shard compares the input with the value specified in the <code>Operand</code> parameter and outputs the smaller value.</p>"},{"location":"reference/shards/shards/General/Min/#details","title":"Details","text":"<p>This shard compares the input to its <code>:Operand</code> parameter and outputs the lesser of the two values.</p> <p>If the input is a sequence and the <code>:Operand</code> a single number, each input element is compared with the <code>:Operand</code> and the lesser value from each comparison is collected and output as a sequence.</p> <p>If the input and <code>:Operand</code> both are sequences, each element of the input sequence is compared with the corresponding-index element in the <code>:Operand</code> sequence and the lesser value from each comparison is collected and output as a sequence.</p> <p>If the input sequence is smaller in size than the <code>:Operand</code> sequence the comparison stops with the last element of the input sequence. If the <code>:Operand</code> sequence is smaller the remaining input sequence elements loop over the <code>:Operand</code> sequence till all input sequence elements have been compared.</p> <p>This shard works only on numbers (integers, floats) and on sequences of such numbers. The data types of the input and the <code>:Operand</code> parameters must match.</p> <p>See also</p> <ul> <li><code>Max</code></li> </ul>"},{"location":"reference/shards/shards/General/Min/#examples","title":"Examples","text":"CodeOutput <pre><code>;; sequence vs number\n(Const [-1 0 1 2 5])\n(Min\n ;:Operand\n 3)\n(Assert.Is [-1 0 1 2 3] true)\n\n;; number vs number\n(Const 3)\n(Min\n ;:Operand\n 2)\n(Assert.Is 2 true)\n\n;; sequence (equal) vs sequence (equal)\n(Const [-1 0 1 2 5])\n(Min\n ;:Operand\n [3 -2 4 0 1])\n(Assert.Is [-1 -2 1 0 1] true)\n\n;; sequence (smaller) vs sequence (bigger)\n(Const [-1 0 5])\n(Min\n ;:Operand\n [3 -2 4 0 1])\n(Assert.Is [-1 -2 4] true)\n\n;; sequence (bigger) vs sequence (smaller)\n(Const [-1 0 1 2 5])\n(Min\n ;:Operand\n [3 -2 1])\n(Assert.Is [-1 -2 1 2 -2] true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/General/Msg/","title":"Msg","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input is ignored. This shard displays a static message. <code>Any</code> <code>&lt;output&gt;</code> The same variable that was inputted, unmodified. <code>Any</code> <code>Message</code> The message to display on the user's screen or console. <code>\"\"</code> <code>String</code> <code>Level</code> The level of logging. <code>LogLevel::Info</code> <code>LogLevel</code> <p>Displays the passed message string to the user via standard output. The input variable is ignored, and only the static message is displayed.</p>"},{"location":"reference/shards/shards/General/Msg/#details","title":"Details","text":"<p>This shard is used for displaying messages to the user on the standard output (which is usually the console).</p> <p>The message to display can be passed to this shard either as a string or as a variable holding a value. In case a variable is passed the shard displays the variable's value.</p>"},{"location":"reference/shards/shards/General/Msg/#examples","title":"Examples","text":"CodeOutput <pre><code>(defshards msgshard [a b]\n  (Msg a)  ;; print value of 1st arg passed\n  (Msg b)) ;; print value of 2nd arg passed\n\n(Msg \"Hello World\") ;; prints string\n(msgshard \"Bye\" \"Universe\") ;; prints args passed\n</code></pre> <pre><code>\n</code></pre> CodeOutput <pre><code>(defshards msgshard [a b]\n  (Msg a LogLevel.Warning)  ;; print value of 1st arg passed\n  (Msg b LogLevel.Error)) ;; print value of 2nd arg passed\n\n(Msg \"Hello World\" LogLevel.Info) ;; prints string\n(msgshard \"Bye\" \"Universe\") ;; prints args passed\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/General/Mul/","title":"Mul","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value or the sequence of values to multiply the value specified in the Operand parameter with. <code>Int</code><code>Int2</code><code>Int3</code><code>Int4</code><code>Int8</code><code>Int16</code><code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <code>&lt;output&gt;</code> This shard outputs the result of the multiplication. <code>Int</code><code>Int2</code><code>Int3</code><code>Int4</code><code>Int8</code><code>Int16</code><code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <code>Operand</code> The value or sequence of values to multiply the input by. <code>0</code> <code>Int</code><code>Var(Int)</code><code>Int2</code><code>Var(Int2)</code><code>Int3</code><code>Var(Int3)</code><code>Int4</code><code>Var(Int4)</code><code>Int8</code><code>Var(Int8)</code><code>Int16</code><code>Var(Int16)</code><code>Float</code><code>Var(Float)</code><code>Float2</code><code>Var(Float2)</code><code>Float3</code><code>Var(Float3)</code><code>Float4</code><code>Var(Float4)</code><code>Color</code><code>Var(Color)</code><code>[Any]</code><code>Var([Any])</code> <p>This shard multiplies the input value by the value provided in the Operand parameter.</p> <p> </p>"},{"location":"reference/shards/shards/General/Mutant/","title":"Mutant","text":"Name - Description Default Type <code>&lt;input&gt;</code> Any input type is accepted. The input value will pass through unchanged. <code>Any</code> <code>&lt;output&gt;</code> Outputs the input value, passed through unchanged. <code>Any</code> <code>Shard</code> The shard to mutate. <code>none</code> <code>Shard</code> <code>Indices</code> The parameter indices to mutate of the inner shard. <code>none</code> <code>[Int]</code> <code>Mutations</code> Optional operations to apply to the parameters, if empty a default operator will be used. <code>none</code> <code>[Shard [Shard] None]</code> <code>Options</code> Mutation options table - a table with mutation options. <code>none</code> <code>{Any}</code> <p>This shard modifies the parameters of the shard specified in the Shard parameter. Which parameters are modified is specified Indices parameter and how they are modified is specified in the Mutations parameter. This shard should be used in conjunction with the Evolve shard to evolve the wire.</p> <p> </p>"},{"location":"reference/shards/shards/General/NaNTo0/","title":"NaNTo0","text":"Name - Description Default Type <code>&lt;input&gt;</code> A float value or a sequence of float values to be checked for NaN. <code>Float</code><code>[Float]</code> <code>&lt;output&gt;</code> The input with any NaN values replaced by 0. <code>Float</code><code>[Float]</code> <p>Replaces NaN (Not a Number) values in the input with 0. This shard can handle both single float values and sequences of float values.</p> <p> </p>"},{"location":"reference/shards/shards/General/NanoID/","title":"NanoID","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>&lt;output&gt;</code> <code>String</code> <code>Size</code> The output string length of the created NanoID. <code>21</code> <code>Int</code> <p>Creates a random NanoID.</p> <p> </p>"},{"location":"reference/shards/shards/General/Not/","title":"Not","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value to be negated. <code>Bool</code> <code>&lt;output&gt;</code> The negation of the input. <code>Bool</code> <p>Computes the logical negation of the input.</p>"},{"location":"reference/shards/shards/General/Not/#examples","title":"Examples","text":"CodeOutput <pre><code>false (Not)\n(Assert.Is true :Break true)\n\ntrue (Not)\n(Assert.Is false :Break true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/General/Once/","title":"Once","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Any</code> <code>&lt;output&gt;</code> <code>Any</code> <code>Action</code> The shard or sequence of shards to execute. <code>none</code> <code>Shard</code><code>[Shard]</code> <code>Every</code> The number of seconds to wait until repeating the action, if 0 the action will happen only once per wire flow execution. <code>none</code> <code>Float</code><code>Var(Float)</code> <p>Executes the shard or sequence of shards with the desired frequency in a wire flow execution.</p>"},{"location":"reference/shards/shards/General/Once/#details","title":"Details","text":"<p>If you run <code>(Once)</code> with <code>:Every</code> set to its default value (i.e., 0), the sequence of shards will be executed only once per wire flow execution. Since this a very common use case (initialize loop counters, etc.) there's an alias for this - <code>(Setup)</code>.</p> <p>Basically, <code>(Setup)</code> is just <code>(Once)</code> with its <code>:Every</code> parameter value permanently set to 0.</p>"},{"location":"reference/shards/shards/General/Once/#examples","title":"Examples","text":"CodeOutput <pre><code>;; Once\n(defmesh Main)\n(defloop test\n    \"Hello World, every 1.5s during a wire flow execution\" = .string1\n    \"Hello World, once during every wire flow execution\" = .string2\n\n    .string1\n    (Once\n        :Action (Log)\n        :Every 1.5 ;; string logs once every 1.5 secs i.e for a total of 3 times\n    )\n\n    .string2\n    (Once\n        :Action (Log)\n        ;; :Every defaults to 0 so this string logs only once\n    )\n)\n;; here one wire flow execution is 5 secs (5 mesh iterations, one per second)\n;; so string1 logs for a maximum of 5/(1.5) =&gt; ~3 times and string2 logs only once\n(schedule Main test)\n(run Main 1 5)\n</code></pre> <pre><code>\n</code></pre> CodeOutput <pre><code>;; Setup\n(defmesh Main)\n(defloop test\n    (Setup\n        0 &gt;= .counter\n        .counter (Log \"counter set to 0 only once\")\n        ;; =&gt; 0\n        )\n    (Math.Inc .counter)\n    .counter (Log \"counter incremented every time wire executes\")\n    ;; =&gt; 1, 2, 3, 4, 5\n)\n(schedule Main test)\n(run Main 1 5)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/General/Or/","title":"Or","text":"Name - Description Default Type <code>&lt;input&gt;</code> If true, the flow stops and succeeds; otherwise, the flow continues. <code>Bool</code> <code>&lt;output&gt;</code> The output of this shard will be the input of the current conditional flow or wire. <code>Bool</code> <p>Computes the logical OR between the input of this shard and the output of the next shard. If the input is true, the flow stops and succeeds; if false, the flow continues with the next shard. Typically used within conditional flows (e.g., If, When) to chain conditions. Note: Outside a conditional flow, it might restart the current wire, which can be used as a trick in certain scenarios.</p>"},{"location":"reference/shards/shards/General/Or/#examples","title":"Examples","text":"CodeOutput <pre><code>false (Or) false\n(Assert.Is false :Break true)\n\nfalse (Or) true\n(Assert.Is true :Break true)\n\ntrue (Or) false\n(Assert.Is true :Break true)\n\ntrue (Or) true\n(Assert.Is true :Break true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/General/Pack/","title":"Pack","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>[Any]</code> <code>&lt;output&gt;</code> <code>Bytes</code> <code>Definition</code> A string defining the struct e.g. \"i32 f32 b i8[256]\". <code>\"\"</code> <code>String</code> <code>AsPointer</code> Output an Int pointer rather than Bytes type. <code>false</code> <code>Bool</code>"},{"location":"reference/shards/shards/General/ParseFloat/","title":"ParseFloat","text":"Name - Description Default Type <code>&lt;input&gt;</code> A string representing a number. <code>String</code> <code>&lt;output&gt;</code> A floating-point number equivalent to the number contained in the string input. <code>Float</code> <p>Converts the string representation of a number to its floating-point number equivalent.</p>"},{"location":"reference/shards/shards/General/ParseFloat/#examples","title":"Examples","text":"CodeOutput <pre><code>\"3.14\" (ParseFloat) (Log)\n(Assert.Is 3.14 :Break true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/General/ParseInt/","title":"ParseInt","text":"Name - Description Default Type <code>&lt;input&gt;</code> A number represented as a string. <code>String</code> <code>&lt;output&gt;</code> A signed integer equivalent to the number contained in the string input. <code>Int</code> <code>Base</code> Numerical base (radix) that determines the valid characters and their interpretation. <code>10</code> <code>Int</code> <p>Converts the string representation of a number to its signed integer equivalent.</p>"},{"location":"reference/shards/shards/General/ParseInt/#examples","title":"Examples","text":"CodeOutput <pre><code>\"42\" (ParseInt) (Log)\n(Assert.Is 42 :Break true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/General/Pass/","title":"Pass","text":"Name - Description Default Type <code>&lt;input&gt;</code> Any input type is accepted. The input value will pass through unchanged. <code>Any</code> <code>&lt;output&gt;</code> Outputs the input value, passed through unchanged. <code>Any</code> <p>This shard is a \"no operation\" shard. It simply passes through the input without modifying it.</p> <p> </p>"},{"location":"reference/shards/shards/General/Pause/","title":"Pause","text":"Name - Description Default Type <code>&lt;input&gt;</code> Input is ignored. <code>Any</code> <code>&lt;output&gt;</code> Passes the input value through. <code>Any</code> <code>Time</code> The amount of time in seconds (can be fractional) to pause this wire. <code>none</code> <code>Float</code><code>Int</code><code>Var(Float)</code><code>Var(Int)</code> <p>Pauses the wire for a given amount of time.</p> <p> </p>"},{"location":"reference/shards/shards/General/PauseMs/","title":"PauseMs","text":"Name - Description Default Type <code>&lt;input&gt;</code> Input is ignored. <code>Any</code> <code>&lt;output&gt;</code> Passes the input value through. <code>Any</code> <code>Time</code> The amount of time in milliseconds to pause this wire. <code>none</code> <code>Int</code><code>Var(Int)</code> <p>Pauses the wire for a given amount of time.</p> <p> </p>"},{"location":"reference/shards/shards/General/Peek/","title":"Peek","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input of this shard is ignored. <code>&lt;output&gt;</code> This shard either outputs none if the peeked Wire is still in progress, or the peeked Wire's output if it has ended. <code>Any</code> <code>Wire</code> The wire to check. <code>none</code> <code>Wire</code><code>String</code><code>Var(Wire)</code> <p>Checks if another Wire has ended (Note that a looped Wire will never end). Outputs the Wire's output if it has ended, or none if it is still in progress.</p> <p> </p>"},{"location":"reference/shards/shards/General/Percentile/","title":"Percentile","text":"Name - Description Default Type <code>&lt;input&gt;</code> The sequence of floats to calculate the percentile of. <code>[Float]</code> <code>&lt;output&gt;</code> The percentile of the input value within the specified sequence. <code>Float</code> <code>Percentile</code> The percentile to calculate. <code>50</code> <code>Float</code><code>Var(Float)</code> <p>This shard calculates the percentile of the input value within the specified sequence.</p> <p> </p>"},{"location":"reference/shards/shards/General/Pop/","title":"Pop","text":"Name - Description Default Type <code>&lt;input&gt;</code> Any input is ignored. <code>&lt;output&gt;</code> The element popped from the sequence. <code>Any</code> <code>Name</code> The name of the variable. <code>\"\"</code> <code>String</code><code>Var(Any)</code> <code>Key</code> The key of the value to read from the table (parameter applicable only if the target variable is a table). <code>none</code> <code>Any</code> <code>Global</code> If the variable is available to all of the wires in the same mesh. <code>false</code> <code>Bool</code> <p>Pops (removes and outputs) the last element of the sequence variable. Works only on sequences. If the variable is not a sequence or the sequence is empty, an error is thrown.</p>"},{"location":"reference/shards/shards/General/Pop/#details","title":"Details","text":"<p><code>Pop</code> drops (removes) the last element of the sequence variable that has been passed to in the <code>:Name</code> parameter and makes it available to the next shard as its input.</p> <p>This shard works on both sequences and tables. Parameter <code>:Key</code> applies only to tables.</p> <p>Since variables may be locally scoped (created with <code>(:Global false)</code>; exists only for current wire) or globally scoped (created with <code>(:Global true)</code>; exists for all wires of that mesh), both parameters <code>:Global</code> and <code>:Name</code> are used in combination to identify the correct variable to pop elements from. </p> <p>Input field is ignored and the output of this shard is the element which was popped from the sequence passed to it via the <code>:Name</code> parameter. </p> <p>See also</p> <ul> <li><code>AppendTo</code></li> <li><code>Clear</code></li> <li><code>Drop</code></li> <li><code>DropFront</code></li> <li><code>Erase</code></li> <li><code>PopFront</code></li> <li><code>Remove</code></li> </ul>"},{"location":"reference/shards/shards/General/Pop/#examples","title":"Examples","text":"CodeOutput <pre><code>;; pop last element from a local sequence\n[10 20 30 40] &gt;= .seq               ;; create a local sequence\n(Get .seq) (Log)                    ;; local sequence =&gt; [10, 20, 30, 40]\n(Pop :Name .seq) (Log)              ;; pops the last element as output =&gt; 40\n(Get .seq) (Log)                    ;; updated sequence =&gt; [10, 20, 30]\n\n;; pop last element from a same-name global sequence\n[11 21 31 41] &gt;== .seq              ;; create a same-name global sequence\n(Get .seq :Global true) (Log)       ;; local sequence =&gt; [11, 21, 31, 41]\n(Pop :Name .seq :Global true) (Log) ;; pops the last element as output =&gt; 41\n(Get .seq :Global true) (Log)       ;; updated sequence =&gt; [11, 21, 31]\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/General/PopFront/","title":"PopFront","text":"Name - Description Default Type <code>&lt;input&gt;</code> Any input is ignored. <code>&lt;output&gt;</code> The element popped from the sequence. <code>Any</code> <code>Name</code> The name of the variable. <code>\"\"</code> <code>String</code><code>Var(Any)</code> <code>Key</code> The key of the value to read from the table (parameter applicable only if the target variable is a table). <code>none</code> <code>Any</code> <code>Global</code> If the variable is available to all of the wires in the same mesh. <code>false</code> <code>Bool</code> <p>Pops (removes and outputs) the first element of the sequence variable. Works only on sequences. If the variable is not a sequence or the sequence is empty, an error is thrown.</p>"},{"location":"reference/shards/shards/General/PopFront/#details","title":"Details","text":"<p><code>PopFront</code> drops (removes) the first element of the sequence variable that has been passed to in the <code>:Name</code> parameter and makes it available to the next shard as its input.</p> <p>This shard works on both sequences and tables. Parameter <code>:Key</code> applies only to tables.</p> <p>Since variables may be locally scoped (created with <code>(:Global false)</code>; exists only for current wire) or globally scoped (created with <code>(:Global true)</code>; exists for all wires of that mesh), both parameters <code>:Global</code> and <code>:Name</code> are used in combination to identify the correct variable to pop elements from. </p> <p>Input field is ignored and the output of this shard is the element which was popped from the sequence passed to it via the <code>:Name</code> parameter. </p> <p>See also</p> <ul> <li><code>Clear</code></li> <li><code>Drop</code></li> <li><code>DropFront</code></li> <li><code>Erase</code></li> <li><code>Pop</code></li> <li><code>PrependTo</code></li> <li><code>Remove</code></li> </ul>"},{"location":"reference/shards/shards/General/PopFront/#examples","title":"Examples","text":"CodeOutput <pre><code>;; pop first element from a local sequence\n[10 20 30 40] &gt;= .seq                       ;; create a local sequence\n(Get .seq) (Log)                            ;; local sequence =&gt; [10, 20, 30, 40]\n(PopFront :Name .seq) (Log)                 ;; pops the first element as output =&gt; 10\n(Get .seq) (Log)                            ;; updated sequence =&gt; [20, 30, 40]\n\n;; pop first element from a same-name global sequence\n[11 21 31 41] &gt;== .seq                      ;; create a same-name global sequence\n(Get .seq :Global true) (Log)               ;; local sequence =&gt; [11, 21, 31, 41]\n(PopFront :Name .seq :Global true) (Log)    ;; pops the first element as output =&gt; 11\n(Get .seq :Global true) (Log)               ;; updated sequence =&gt; [21, 31, 41]\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/General/Pow/","title":"Pow","text":"Name - Description Default Type <code>&lt;input&gt;</code> The base value to raise the power of. <code>Int</code><code>Int2</code><code>Int3</code><code>Int4</code><code>Int8</code><code>Int16</code><code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <code>&lt;output&gt;</code> The result of raising the input to the power of the operand. <code>Int</code><code>Int2</code><code>Int3</code><code>Int4</code><code>Int8</code><code>Int16</code><code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <code>Operand</code> The operand for this operation. <code>0</code> <code>Int</code><code>Var(Int)</code><code>Int2</code><code>Var(Int2)</code><code>Int3</code><code>Var(Int3)</code><code>Int4</code><code>Var(Int4)</code><code>Int8</code><code>Var(Int8)</code><code>Int16</code><code>Var(Int16)</code><code>Float</code><code>Var(Float)</code><code>Float2</code><code>Var(Float2)</code><code>Float3</code><code>Var(Float3)</code><code>Float4</code><code>Var(Float4)</code><code>Color</code><code>Var(Color)</code><code>[Any]</code><code>Var([Any])</code> <p>This shard raises the input to the power of the exponent specified in the Operand parameter.</p> <p> </p>"},{"location":"reference/shards/shards/General/PremultiplyAlpha/","title":"PremultiplyAlpha","text":"Name - Description Default Type <code>&lt;input&gt;</code> The image to apply the premultiplication of alpha channels to. <code>Image</code> <code>&lt;output&gt;</code> The image as a result of the application of the premultiplication of alpha channels. <code>Image</code> <p>Applies the premultiplication of alpha channels of an image to its RGB channels. Does nothing if the image has already been premultiplied in Shards. This mainly applies to PNG images.</p> <p> </p>"},{"location":"reference/shards/shards/General/PrependTo/","title":"PrependTo","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value to prepend to the collection. <code>Any</code> <code>&lt;output&gt;</code> The input to this shard is passed through as its output. <code>Any</code> <code>Collection</code> The collection to add the input to. <code>none</code> <code>Var([Any])</code><code>Var(String)</code><code>Var(Bytes)</code> <p>Prepends the input to the context variable passed to <code>Collection</code>.</p>"},{"location":"reference/shards/shards/General/PrependTo/#details","title":"Details","text":"<p><code>PrependTo</code> prepends (i.e., adds to the start) its input to the variable it receives in its <code>:Collection</code> parameter. </p> <p>This shard works on string and sequence variables.</p> <p>The input to this shard is also passed through as its output.</p> <p>See also</p> <ul> <li><code>DropFront</code></li> <li><code>PopFront</code></li> <li><code>Push</code></li> <li><code>Set</code></li> <li><code>Update</code></li> </ul>"},{"location":"reference/shards/shards/General/PrependTo/#examples","title":"Examples","text":"CodeOutput <pre><code>;; prepend element to sequence\n[1 2 3] &gt;= .seq\n0 (PrependTo .seq)   ;; prepends element to sequence\n.seq (Log)           ;; updated sequence =&gt; [0, 1, 2, 3]\n\n;; prepend character to string\n\"pen\" &gt;= .str\n\"O\" (PrependTo .str) ;; prepends character to string\n.str (Log)           ;; updated string =&gt; Open\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/General/Produce/","title":"Produce","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Any</code> <code>&lt;output&gt;</code> <code>Any</code> <code>Name</code> The name of the channel. <code>\"\"</code> <code>String</code> <code>Type</code> The optional explicit (and unsafe because of that) we produce. <code>none</code> <code>Type</code>"},{"location":"reference/shards/shards/General/Profile/","title":"Profile","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input of this shard will be provided as input to the shards in the Action parameter. <code>Any</code> <code>&lt;output&gt;</code> The output of this shard will be the output of the shards in the Action parameter. <code>Any</code> <code>Action</code> The action shards to profile. <code>none</code> <code>Shard</code><code>[Shard]</code> <code>Label</code> The label to print when outputting time data. <code>\"&lt;no label&gt;\"</code> <code>String</code> <p>This shard outputs the amount of time(nanoseconds) it took to execute the shards provided in the Action parameter.</p> <p> </p>"},{"location":"reference/shards/shards/General/PtrToString/","title":"PtrToString","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Int</code> <code>&lt;output&gt;</code> <code>String</code>"},{"location":"reference/shards/shards/General/Push/","title":"Push","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value to push into the sequence. <code>Any</code> <code>&lt;output&gt;</code> The input to this shard is passed through as its output. <code>Any</code> <code>Name</code> The name of the variable. <code>\"\"</code> <code>String</code><code>Var(Any)</code> <code>Key</code> The key of the value to write in the table (parameter applicable only if the target variable is a table). <code>none</code> <code>Any</code> <code>Global</code> If the variable is available to all of the wires in the same mesh. <code>false</code> <code>Bool</code> <code>Clear</code> Whether to clear this sequence at every wire iteration. This only works if it's the first push. The default is true. <code>true</code> <code>Bool</code> <p>Pushes a new value into a sequence variable. If the variable does not exist, it will be created.</p>"},{"location":"reference/shards/shards/General/Push/#details","title":"Details","text":"<p><code>Push</code> updates sequences and tables by pushing elements and/or sequences into them.</p> <p>The name of the variable to update should come from the <code>:Name</code> parameter and the new update value(s) should come from the shard's input.</p> <p>For existing sequences <code>Push</code> pushes in the new elements. If a sequence doesn't exist then <code>Push</code> will create it while pushing in the first element. These elements may be string constants, numerics, or even sequences themselves.</p> <p>For tables <code>Push</code> can update only those existing keys whose values are of the type sequence. In such cases <code>Push</code> can push in new elements in those key-value pair sequences. The key to be updated must be passed in via the <code>:Key</code> parameter.</p> <p>Note</p> <ol> <li>Do not use <code>Push</code> to update any variables created by <code>Set</code> (or its aliases <code>&gt;=</code>/<code>&gt;&gt;=</code>). <code>Push</code> is best used to update variables that were themselves created by <code>Push</code> (first push).</li> <li>Though, if really want to do (1.) you can offload the current sequence into another sequence variable, push new values into it, and update the table with this sequence variable (see the last code example).  </li> </ol> <p>The <code>:Global</code> parameter controls whether the created variables can be referenced across wires (<code>:Global</code> set to <code>true</code>) or only within the current wire (<code>:Global</code> set to <code>false</code>, default behaviour).</p> <p>Variables may be locally scoped (created with <code>(:Global false)</code>; exists only for current wire) or globally scoped (created with <code>(:Global true)</code>; exists for all wires of that mesh). Hence, in update mode (i.e. when you apply <code>Push</code> to an existing variable) the <code>:Global</code> parameter is used in conjunction with the <code>:Name</code> parameter to identify the correct variable to update. </p> <p>The parameter <code>:Clear</code> controls whether we should clear out this sequence after every wire iteration (<code>Clear</code> set to <code>true</code>, default behaviour) or should the sequence data persist across wire iterations (<code>Clear</code> set to <code>false</code>).</p> <p>The input to this shard is the new update value that is to be pushed into the sequence/table being modified. This value is also passed through as this shard's output.</p> <p>Note</p> <p><code>Push</code> has two aliases: <code>&gt;&gt;</code> which is an alias for <code>(Push ... :Clear true)</code>, and <code>&gt;&gt;!</code> which is an alias for <code>(Push ... :Clear false)</code>. See the code examples at the end to understand how these aliases are used.</p> <p>See also</p> <ul> <li><code>AppendTo</code></li> <li><code>PrependTo</code></li> <li><code>Sequence</code></li> <li><code>Set</code></li> <li><code>Table</code></li> <li><code>Update</code></li> </ul>"},{"location":"reference/shards/shards/General/Push/#examples","title":"Examples","text":"CodeOutput <pre><code>;; create and update sequence with `Push`; value available only to current wire\n1 (Push :Name .seq1)                    ;; create a sequence by pushing the first element\n.seq1 (Log \".seq1\")                     ;; sequence created =&gt; [1]\n2 (Push :Name .seq1)                    ;; push one more element into sequence\n.seq1 (Log \".seq1\")                     ;; sequence updated =&gt; [1, 2]\n\n;; create and update sequence with `Push`; value available to all wires on mesh\n[10 20] (Push :Name .seq2 :Global true) ;; create sequence with two elements\n.seq2 (Log \".seq2\")                     ;; sequence created =&gt; [10, 20]\n30 (Push :Name .seq2 :Global true)      ;; push one more element into sequence\n.seq2 (Log \".seq2\")                     ;; sequence updated =&gt; [10, 20, 30]\n\n;; create empty sequence with `Sequence`; add elements with `Push`\n(Sequence :Name .seq3)                  ;; create empty sequence\n.seq3 (Log \".seq3\")                     ;; empty sequence created =&gt; []\n1 (Push :Name .seq3 :Clear false)       ;; push an element into sequence\n.seq3 (Log \".seq3\")                     ;; sequence updated =&gt; [1]               \n2 (Push :Name .seq3 :Clear false)       ;; push another element into sequence\n.seq3 (Log \".seq3\")                     ;; sequence updated =&gt; [1, 2]    \n\n;; create empty table with `Table`; add/update key sequence values with `Push`\n;; (Table :Name .table1)                   ;; created an empty table (one key, no value)\n;; .table1 (Log)                           ;; table with one key (no value) created =&gt; {A: []}\n1 (Push .table1 \"A\")                    ;; push new key \"A\" with sequence value \"[1]\"\n.table1 (Log)                           ;; table key/value updated =&gt; {A: [1]}\n2 (Push .table1 \"A\")                    ;; push new element into key \"A\" existing sequence\n.table1 (Log)                           ;; table key/value updated =&gt; {A: [1, 2]}   \n\n;; create and update local/global sequence variables\n\"Local\" (Push .seq)                     ;; create local sequence variable with first push\n\"Global\" (Push .seq :Global true)       ;; create same-name global sequence variable with first push\n(Get .seq) (Log)                        ;; get local variable =&gt; [Local]\n(Get .seq :Global true) (Log)           ;; get same-name updated global variable =&gt; [Global]\n\"Local2\" (Push .seq)                    ;; push new value into local sequence variable\n\"Global2\" (Push .seq :Global true)      ;; push new value into  same-name global sequence variable\n(Get .seq) (Log)                        ;; get updated local sequence variable =&gt; [Local, Local2]\n(Get .seq :Global true) (Log)           ;; get updated global sequence variable =&gt; [Global, Global2]\n\n;; Using a `Push` alias: `&gt;&gt;` is alias for `(Push :Clear true)` \n\"Hello\" &gt;&gt; .seq4                        ;; create sequence by pushing the first element\n.seq4 (Log \".seq4\")                     ;; sequence created =&gt; [Hello]\n\"World\" &gt;&gt; .seq4                        ;; update the sequence by pushing one more element\n.seq4 (Log \".seq4\")                     ;; sequence updated with second element =&gt; [Hello, World]\n\n;; Using a `Push` alias: `&gt;&gt;!` is alias for `(Push :Clear false)`\n\"Bye\" &gt;&gt;! .seq5                         ;; create sequence by pushing the first element\n.seq5 (Log \".seq5\")                     ;; sequence created =&gt; [Bye]\n\"Universe\" &gt;&gt;! .seq5                    ;; update the sequence by pushing one more element\n.seq5 (Log \".seq5\")                     ;; sequence updated with second element =&gt; [Bye, Universe]\n\n;; Technique to update a non-push created Table's sequence values with `Push`\n{:k1 [1 2 3]} &gt;= .table2                ;; table is created using `Set`\n.table2 (Log)                           ;; table with key/value pair created =&gt; {:k1 [1 2 3]}\n(Get .table2 \"k1\") &gt;= .seqvar           ;; target value offloaded into a sequence variable\n4 (Push .seqvar)                        ;; update sequence variable using `Push`\n.seqvar (Log)                           ;; sequence variable updated =&gt; [1, 2, 3, 4] \n{:k1 .seqvar} &gt;= .table2                ;; update table key sequence value with modified sequence variable                      \n.table2 (Log)                           ;; targeted table key updated with required sequence values =&gt; {:k1 [1 2 3 4]}\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/General/RTake/","title":"RTake","text":"Name - Description Default Type <code>&lt;input&gt;</code> The sequence from which elements will be extracted. <code>Bytes</code><code>String</code><code>[Any]</code> <code>&lt;output&gt;</code> The extracted elements. <code>Any</code> <code>Indices</code> One or more indices (counted backwards from the last element) to extract from a sequence. <code>none</code> <code>Int</code><code>[Int]</code><code>Var(Int)</code><code>Var([Int])</code> <p>Works exactly like <code>Take</code> except that the selection indices are counted backwards from the last element in the target sequence. Also, <code>RTake</code> works only on sequences, not on tables.</p>"},{"location":"reference/shards/shards/General/RTake/#examples","title":"Examples","text":"CodeOutput <pre><code>;; RTake on sequences\n[10 20 30 40] (RTake 1) (Log)\n(Assert.Is 30 :Break true)\n[10 20 30 40] (RTake [0 1]) (Log)\n(Assert.Is [40, 30] :Break true)\n\n;; RTake not valid on tables\n\n;; RTake using a variable as index\n1 = .index\n[1 2 3 4] (RTake .index) (Log)\n(Assert.Is 3 :Break true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/General/RadiansToDegrees/","title":"RadiansToDegrees","text":"Name - Description Default Type <code>&lt;input&gt;</code> Takes a float value representing an angle in radians. <code>Float</code> <code>&lt;output&gt;</code> Outputs a float value representing the input angle in degrees. <code>Float</code> <p>This shard converts the input angle from radians to degrees. The conversion is done using the formula: degrees = radians * (180 / \u03c0).</p> <p> </p>"},{"location":"reference/shards/shards/General/RandomBytes/","title":"RandomBytes","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input of this shard is ignored. <code>&lt;output&gt;</code> Outputs a random sequence of bytes. <code>Bytes</code> <code>Size</code> The amount of bytes to output. <code>32</code> <code>Int</code> <p>This shard generates a random sequence of bytes. The size of the sequence is specified in the Size parameter.</p> <p> </p>"},{"location":"reference/shards/shards/General/RandomFloat/","title":"RandomFloat","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input of this shard is ignored. <code>&lt;output&gt;</code> Outputs a random float. <code>Float</code> <code>Max</code> The maximum (if integer, not including) value to output. <code>none</code> <code>Float</code><code>Var(Float)</code> <p>This shard generates a random float between 0 and the maximum value specified in the Max parameter (exclusive).</p> <p> </p>"},{"location":"reference/shards/shards/General/RandomInt/","title":"RandomInt","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input of this shard is ignored. <code>&lt;output&gt;</code> Outputs a random integer. <code>Int</code> <code>Max</code> The maximum (if integer, not including) value to output. <code>none</code> <code>Int</code><code>Var(Int)</code> <p>This shard generates a random integer between 0 (inclusive) and the maximum value specified in the Max parameter (exclusive).</p> <p> </p>"},{"location":"reference/shards/shards/General/ReadFile/","title":"ReadFile","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>&lt;output&gt;</code> <code>Any</code> <code>Filename</code> The file to read from. <code>none</code> <code>String</code><code>Var(String)</code>"},{"location":"reference/shards/shards/General/Recur/","title":"Recur","text":"Name - Description Default Type <code>&lt;input&gt;</code> After the first cycle of Recur, the output of the Wire that calls Recur will be fed back as input for the next cycle. <code>Any</code> <code>&lt;output&gt;</code> The output of Recur will be the output of the Wire that calls it. <code>Any</code> <p>The Recur shard executes the Wire that calls it recursively, using the output of the Wire as input again, until the base cases are reached. It then combines the results to produce the final result. For the shard not to Recur endlessly, a base case needs to be defined, usually through a When or If shard.</p>"},{"location":"reference/shards/shards/General/Recur/#examples","title":"Examples","text":"CodeOutput <pre><code>(defwire fibo\n   &gt;= .n\n   (If (IsLess 2)\n       :Then (-&gt; (Pass))\n       :Else (-&gt; .n (Math.Subtract 2) (Recur) &gt;= .a\n                 .n (Math.Subtract 1) (Recur) &gt;= .b\n                 .a (Math.Add .b))))\n\n16 (Do fibo)\n(Log)\n(Assert.Is 987 true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/General/Reduce/","title":"Reduce","text":"Name - Description Default Type <code>&lt;input&gt;</code> The sequence to reduce. <code>[Any]</code> <code>&lt;output&gt;</code> The resulting value after applying the operation to each item of the sequence. <code>Any</code> <code>Apply</code> The function to apply to each item of the sequence. <code>none</code> <code>Shard</code><code>[Shard]</code> <p>Reduces a sequence to a single value by applying an operation (specified in the Apply parameter) to each item of the sequence. Note that this shard is able to use the $0 internal variable for the current item and $i for the current index.</p> <p> </p>"},{"location":"reference/shards/shards/General/Ref/","title":"Ref","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value to be set to the variable. <code>Any</code> <code>&lt;output&gt;</code> The input value is passed through as the output. <code>Any</code> <code>Name</code> The name of the variable. <code>\"\"</code> <code>String</code><code>Var(Any)</code> <code>Key</code> The key of the value to read from the table (parameter applicable only if the target variable is a table). <code>none</code> <code>Any</code> <code>Global</code> If the variable is available to all of the wires in the same mesh. <code>false</code> <code>Bool</code> <code>Overwrite</code> If the variable should be overwritten if it already exists. <code>false</code> <code>Bool</code> <p>Creates an immutable reference variable. Once created this variable cannot be changed.</p>"},{"location":"reference/shards/shards/General/Ref/#details","title":"Details","text":"<p><code>Ref</code> creates an immutable variable and assigns a constant value to it. Once created this variable cannot be changed.</p> <p>The name of the variable comes from the <code>:Name</code> parameter and the constant value comes from the input. The type of input controls the kind of variable that will created: numeric input creates numeric variable, string input creates string variable, and sequence input would create a sequence variable.</p> <p>To create a table variable, along with the input, you also have to pass the key in the <code>:Key</code> parameter. In this case the input (whatever it may be - numeric, string, sequence) becomes the value of the key that was passed in parameter <code>:Key</code>.</p> <p>The <code>:Global</code> parameter controls whether the created variables can be referenced across wires (<code>:Global</code> set to <code>true</code>) or only within the current wire (<code>:Global</code> set to <code>false</code>, default behaviour).</p> <p>The input to this shard is used as the value for the new variable and is also passed through as this shard's output.</p> <p>Note</p> <p><code>Ref</code> has two aliases: <code>=</code> and <code>&amp;&gt;</code>. Both are aliases for <code>(Ref ... :Global false)</code>. See the code examples at the end to understand how these aliases are used.</p> <p>See also</p> <ul> <li><code>Const</code></li> <li><code>Get</code></li> <li><code>Set</code></li> </ul>"},{"location":"reference/shards/shards/General/Ref/#examples","title":"Examples","text":"CodeOutput <pre><code>;; create an immutable string variable (by default available only to current wire)\n\"Hello\" (Ref :Name .svar)\n.svar (Log \".svar\")                 ;; =&gt; .svar: Hello\n\n;; uncomment next line to see the immutable-variable-update error\n;; 20 (Update .svar)\n;; =&gt; Error composing shard: Set/Ref/Update, attempted to write an immutable variable.\n\n;; create an immutable numeric variable (available to all wires because `:Global true`)\n100 (Ref :Name .nvar :Global true)\n.nvar (Log \".nvar\")                 ;; =&gt; .nvar: 100\n\n;; create an immutable sequence\n[10 20] (Ref :Name .seq)\n.seq (Log \".seq\")                   ;; =&gt; .seq: [10, 20]\n\n;; create an immutable table\n(Const [\"a\" \"b\"]) (Ref :Name \"table\" :Key \"key1\")\n.table (Log \".table\")               ;; =&gt; .table: {key1: [a, b]}\n\n;; Using `Ref` aliases\n\n;; `=` is alias for `(Ref :Global false)`: create an immutable string variable: \n\"World\" = .svarA\n.svarA (Log \".svarA\")               ;; =&gt; .svarA: World\n\n;; `&amp;&gt;` is another alias for `(Ref :Global false)`: create an immubtable numeric variable\n100 &amp;&gt; .nvarA\n.nvarA (Log \".nvarA\")               ;; =&gt; .nvarA: 100\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/General/Remove/","title":"Remove","text":"Name - Description Default Type <code>&lt;input&gt;</code> Any input is ignored. <code>&lt;output&gt;</code> Output is the filtered sequence. <code>[Any]</code> <code>From</code> The name of the sequence variable to edit in place. <code>none</code> <code>Var([Any])</code> <code>Join</code> Other columns to join sort/filter using the input (they must be of the same length). <code>none</code> <code>Var([Any])</code><code>[Var([Any])]</code> <code>Predicate</code> The shards to use as predicate, if true the item will be popped from the sequence. <code>none</code> <code>Shard</code><code>[Shard]</code> <code>Unordered</code> Turn on to remove items very quickly but will not preserve the sequence items order. <code>false</code> <code>Bool</code> <p>Removes all elements from a sequence that match the given condition. Can also take these matched indices and remove corresponding elements from a joined sequence.</p>"},{"location":"reference/shards/shards/General/Remove/#details","title":"Details","text":"<p><code>Remove</code> removes all the elements of the <code>:Name</code> parameter sequence that matches the condition laid out in the <code>:Predicate</code> parameter.</p> <p>It can also take these condition-matched indices (from the <code>:From</code> sequence) and remove the corresponding elements from a joined sequence (passed via the <code>:Join</code> parameter). Remember, <code>Remove</code> doesn't apply the <code>:Predicate</code> conditions to the joined sequence, but removes corresponding elements from it based on <code>:Predicate</code> matched indices of the main sequence. For this to work both the sequences must have the same length.</p> <p>Note</p> <p>Think of this as the Shards equivalent of a relational database inner join. The main sequence and the joined sequence can be thought of as columns from two different tables inner joined over indices equality. So that the changes in elements of one sequence (rows in the first table) can be propagated to the corresponding elements of the joined sequence (corresponding rows in the joined table). </p> <p>In this case the operation is deletion of selected elements (selected rows) from one sequence (table) leading to deletion of corresponding elements (connected rows) of the joined sequence (joined table).</p> <p>The <code>:Predicate</code> parameter can take any conditional/logical expression or combination of shards that will result in assertion that can be tested on the sequence elements.</p> <p>The <code>:Unordered</code> parameter can be set to <code>true</code> if you need to make the removal process faster, but then the order of the remaining elements in the resulting sequence elements may not be preserved. By default, this order is preserved.</p> <p><code>Remove</code> works only on sequences.</p> <p>Any input to this shard is ignored and its output is the main filtered sequence.</p> <p>See also</p> <ul> <li><code>Clear</code></li> <li><code>Drop</code></li> <li><code>DropFront</code></li> <li><code>Erase</code></li> <li><code>Pop</code></li> <li><code>PopFront</code></li> <li><code>Sort</code></li> </ul>"},{"location":"reference/shards/shards/General/Remove/#examples","title":"Examples","text":"CodeOutput <pre><code>;; remove predicate-satisfying elements from :From sequence\n[10 20 30] &gt;= .seq1\n(Remove\n    :From .seq1\n    :Predicate (IsMore 20)\n    :Unordered false)\n(Log \"output\")      ;; =&gt; output: [10, 20]\n.seq1 (Log \".seq1\") ;; index-2 element matched, removed =&gt; .seq1: [10, 20]\n\n;; remove corresponding index elements from :Join sequence\n[10 20 30] &gt;= .seq2\n[100 200 300] &gt;= .seqJ\n(Remove .seq2 :Predicate (Is 20) :Join .seqJ)\n.seq2 (Log \".seq2\") ;; index-1 element matched, removed from seq2 =&gt; .seq2: [10, 30]\n.seqJ (Log \".seqJ\") ;; matched index-1 element removed from seqJ  =&gt; .seqJ: [100, 300]\n\n;; remove with :Unordered true (faster but sequence items order may not be preserved)\n[[20 30] [30 40] [40 50]] &gt;= .seq3\n(Remove .seq3 :Predicate (-&gt; (Take 0) (IsLess 30)) :Unordered true)\n.seq3 (Log \".seq3\") ;; index-0 element matched, removed =&gt; .seq3: [[40, 50], [30, 40]]\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/General/Repeat/","title":"Repeat","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input will be passed to both the action and the <code>Until</code> condition if used. <code>Any</code> <code>&lt;output&gt;</code> The output of this shard will be its input. <code>Any</code> <code>Action</code> The shards to repeat. <code>none</code> <code>Shard</code><code>[Shard]</code> <code>Times</code> How many times we should repeat the action. <code>none</code> <code>Int</code><code>Var(Int)</code> <code>Forever</code> If we should repeat the action forever. <code>false</code> <code>Bool</code> <code>Until</code> Optional shards to use as predicate to continue repeating until it's true <code>none</code> <code>Shard</code><code>[Shard]</code> <p>Repeat an action a given number of times or until the 'Until' parameter returns true.</p>"},{"location":"reference/shards/shards/General/Repeat/#examples","title":"Examples","text":"CodeOutput <pre><code>(Repeat\n (-&gt; (Msg \"Hello\"))\n :Times 5)\n</code></pre> <pre><code>\n</code></pre> CodeOutput <pre><code>0 &gt;= .n\n(Repeat\n (-&gt;\n  .n (Log \"Counting\")\n  (Math.Inc .n))\n :Forever true\n :Until (-&gt; .n (IsMore 9)))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/General/Replace/","title":"Replace","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input sequence or string to be modified. <code>[Any]</code><code>String</code> <code>&lt;output&gt;</code> Outputs the resulting sequence or string with the replacements applied. <code>[Any]</code><code>String</code> <code>Patterns</code> The patterns to find represented as a sequence. <code>none</code> <code>[String]</code><code>Var([String])</code><code>Var([Any])</code><code>[Any]</code> <code>Replacements</code> The corresponding replacements to apply to the input, if a single value is provided every match will be replaced with that single value. <code>none</code> <code>Any</code><code>Var(Any)</code><code>[Any]</code><code>Var([Any])</code> <p>This shard replaces all occurrences of the pattern(specified in the Patterns parameter) found in the input sequence or string, with replacements (specified in the Replacements parameter).</p> <p> </p>"},{"location":"reference/shards/shards/General/ResizeImage/","title":"ResizeImage","text":"Name - Description Default Type <code>&lt;input&gt;</code> The image to resize. <code>Image</code> <code>&lt;output&gt;</code> The resized image. <code>Image</code> <code>Width</code> The target width. <code>32</code> <code>Int</code><code>Var(Int)</code> <code>Height</code> The target height. <code>32</code> <code>Int</code><code>Var(Int)</code> <p>This shard resizes an image to the specified dimensions specified in the Width and Height parameters.</p> <p> </p>"},{"location":"reference/shards/shards/General/Restart/","title":"Restart","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input to restart the wire with. Must match the wire's root input type. <code>Any</code> <code>&lt;output&gt;</code> This shard does not produce an output as it restarts the flow. <p>Restarts the current flow with the provided input. This shard is used to restart the execution of the current wire from the beginning, using the same input. It ensures that the input type matches the wire's root input type. Note: This is a flow stopper and will not continue to subsequent shards in the current execution sequence.</p> <p> </p>"},{"location":"reference/shards/shards/General/Resume/","title":"Resume","text":"Name - Description Default Type <code>&lt;input&gt;</code> Any input type is accepted. The input value will pass through unchanged. <code>Any</code> <code>&lt;output&gt;</code> Outputs the input value, passed through unchanged. <code>Any</code> <code>Wire</code> The Wire to resume. <code>none</code> <code>Wire</code><code>String</code><code>Var(Wire)</code> <p>Resumes another Wire (previously paused using Suspend).</p>"},{"location":"reference/shards/shards/General/Resume/#examples","title":"Examples","text":"CodeOutput <pre><code>(defwire hello\n  (Msg \"Hello\")\n  (SwitchTo))\n\n(SwitchTo hello)\n(Msg \"World\")\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/General/Return/","title":"Return","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input to return (when supported) and stop the flow. <code>Any</code> <code>&lt;output&gt;</code> This shard does not produce an output as it stops the flow. <p>Stops the current flow and outputs the provided input. This shard is used to exit the execution of the current wire early within loops or conditional flows, returning the specified input.</p> <p> </p>"},{"location":"reference/shards/shards/General/Reverse/","title":"Reverse","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input sequence or string to be reversed. <code>[Any]</code><code>String</code><code>Bytes</code> <code>&lt;output&gt;</code> Outputs the reversed sequence or string. <code>[Any]</code><code>String</code><code>Bytes</code> <p>This shard reverses the order of the elements in the input sequence or string.</p> <p> </p>"},{"location":"reference/shards/shards/General/Sequence/","title":"Sequence","text":"Name - Description Default Type <code>&lt;input&gt;</code> Any input is ignored. <code>Any</code> <code>&lt;output&gt;</code> The input to this shard is passed through as its output. <code>Any</code> <code>Name</code> The name of the variable. <code>\"\"</code> <code>String</code><code>Var(Any)</code> <code>Key</code> The key of the value to write in the table (parameter applicable only if the target variable is a table). <code>none</code> <code>Any</code> <code>Global</code> If the variable is available to all of the wires in the same mesh. <code>false</code> <code>Bool</code> <code>Clear</code> If we should clear this sequence at every wire iteration; works only if this is the first push; default: true. <code>true</code> <code>Bool</code> <code>Type</code> The sequence type to forward declare. <code>none</code> <code>Type</code> <p>Creates an empty sequence (or sequence in a table if a key is passed). Useful to declare and specify types.</p>"},{"location":"reference/shards/shards/General/Sequence/#details","title":"Details","text":"<p><code>Sequence</code> creates an empty sequence when the <code>:Key</code> parameter is not set. If a key is passed via this parameter <code>Sequence</code> creates an empty table instead (behaving like the <code>Table</code> shard). The created sequence name is defined in the <code>:Name</code> parameter.</p> <p>This shard can control the scope of the created sequence variable. A <code>true</code> value for the <code>:Global</code> parameter makes the scope of the sequence global (available to all wires on the mesh), and a <code>false</code> value makes the scope local (available only to the wire its defined in).</p> <p>By default a sequence created with this shard would be cleared (emptied) every time the wire is executed (since <code>:Clear</code> is <code>true</code> by default). To retain the sequence values across wire iterations set the <code>:Clear</code> parameter to <code>false</code>.</p> <p>This shard can also define the sequence's inner data types via the <code>:Types</code> parameter. More than one data type may be set.</p> <p>Any input to this shard is ignored and instead passed through as its output.</p> <p>See also</p> <ul> <li><code>Get</code></li> <li><code>Push</code></li> <li><code>Set</code></li> <li><code>Table</code></li> <li><code>Update</code></li> </ul>"},{"location":"reference/shards/shards/General/Sequence/#examples","title":"Examples","text":"CodeOutput <pre><code>;; without key, without types, local scope, :Clear true, using `Push`\n(Sequence :Name .seqA)\n.seqA (Log)             ;; created an empty sequence =&gt; []\n1 (Push .seqA)\n.seqA (Log)             ;; updated sequence =&gt; [1]\n2 (Push .seqA)\n.seqA (Log)             ;; updated sequence =&gt; [1, 2]\n\n;; with key (becomes table), single type, global scope, :Clear true, using `Set`\n(Sequence .seqB :Key \"A\" :Global true :Type (type [Float]))\n.seqB  (Log)            ;; created an empty table =&gt; {A: []}\n10.2 (Set .seqB  \"A\")\n.seqB  (Log)            ;; updated table =&gt; {A: 10.2}\n20.1 (Set .seqB  \"A\")\n.seqB  (Log)            ;; updated table =&gt; {A: 20.1}\n\n;; without key, multiple types, local scope, :Clear false, using `Push`\n(Sequence .seqC :Type (type [Float Int]) :Clear false)\n.seqC (Log)             ;; created an empty sequence =&gt; []\n10.3 (Push .seqC)\n.seqC (Log)             ;; updated sequence =&gt; [10.3]\n20 (Push .seqC)\n.seqC(Log)              ;; updated sequence =&gt; [10.3, 20]\n\n;; with key (becomes table), single type, local scope, :Clear true, using `Push`\n;; (Sequence .seqD :Key \"A\" :Types Type.Int)\n;; .seqD (Log)             ;; created an empty table =&gt; {A: []}\n10 (Push .seqD \"A\")\n.seqD(Log)              ;; updated table =&gt; {A: [10]}\n20 (Push .seqD\"A\")\n.seqD (Log)             ;; updated table =&gt; {A: [10, 20]}\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/General/Set/","title":"Set","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value to be set to the variable. <code>Any</code> <code>&lt;output&gt;</code> The input value is passed through as the output. <code>Any</code> <code>Name</code> The name of the variable. <code>\"\"</code> <code>String</code><code>Var(Any)</code> <code>Key</code> The key of the value to write in the table (parameter applicable only if the target variable is a table). <code>none</code> <code>Any</code> <code>Global</code> If the variable is available to all of the wires in the same mesh. <code>false</code> <code>Bool</code> <code>Tracked</code> If the variable should be marked as tracked. <code>false</code> <code>Bool</code> <p>Creates a mutable variable and assigns a value to it.</p>"},{"location":"reference/shards/shards/General/Set/#details","title":"Details","text":"<p><code>Set</code> creates a mutable variable and assigns a value to it. Once created this variable can be modified.</p> <p>The name of the variable comes from the <code>:Name</code> parameter and the variable value comes from the input. The type of input controls the kind of variable that will created: numeric input creates numeric variable, string input creates string variable, and sequence input would create a sequence variable.</p> <p>To create a table variable, along with the input, you also have to pass the key in the <code>:Key</code> parameter. In this case the input (whatever it may be - numeric, string, sequence) becomes the value of the key that was passed in parameter <code>:Key</code>.</p> <p>The <code>:Global</code> parameter controls whether the created variables can be referenced across wires (<code>:Global</code> set to <code>true</code>) or only within the current wire (<code>:Global</code> set to <code>false</code>, default behaviour).</p> <p>Though it will generate a warning <code>Set</code> can also be used to update existing variables (like adding a new key-value pair to an existing table).</p> <p>Note</p> <p>Do not use <code>Push</code> to update any variables created by <code>Set</code> (or its aliases <code>&gt;=</code>/<code>&gt;&gt;=</code>). Such variables are best best updated by <code>Set</code> itself (all types of variables) or <code>AppendTo</code> (only sequences and string variables).  </p> <p>Variables may be locally scoped (created with <code>(:Global false)</code>; exists only for current wire) or globally scoped (created with <code>(:Global true)</code>; exists for all wires of that mesh). Hence, in update mode (i.e. when you apply <code>Set</code> to an existing variable) the <code>:Global</code> parameter is used in conjunction with the <code>:Name</code> parameter to identify the correct variable to update. </p> <p>The input to this shard is used as the value for the variable being created and is also passed through as this shard's output.</p> <p>Note</p> <p><code>Set</code> has two aliases: <code>&gt;=</code> is an alias for <code>(Set ... :Global false)</code> while <code>&gt;==</code> is an alias for <code>(Set ... :Global true)</code>. See the code examples at the end to understand how these aliases are used.</p> <p>See also</p> <ul> <li><code>AppendTo</code></li> <li><code>Const</code></li> <li><code>Get</code></li> <li><code>PrependTo</code></li> <li><code>Ref</code></li> <li><code>Sequence</code></li> <li><code>Table</code></li> </ul>"},{"location":"reference/shards/shards/General/Set/#examples","title":"Examples","text":"CodeOutput <pre><code>;; create a mutable string variable, modify it (by default available only to current wire)\n\"Hello\" (Set :Name .svar)\n.svar (Log \".svar\")                 ;; =&gt; .svar: Hello\n\"World\" (Update .svar)              ;; modify string variable\n.svar (Log \"modified .svar\")        ;; =&gt; .svar: World\n\n;; create a mutable numeric variable, modify it (available to all wires because `:Global true`)\n100 (Set :Name .nvar :Global true)\n.nvar (Log \".nvar\")                 ;; =&gt; .nvar: 100\n200 (Update .nvar)                  ;; modify numeric variable\n.nvar (Log \"modified .nvar\")        ;; =&gt; modified .nvar: 200\n\n;; create a mutable sequence\n[10 20 30] (Set :Name .sequence)\n.sequence (Log \".sequence\")         ;; =&gt; .sequence: [10, 20, 30]\n\n;; create a mutable table\n(Const [\"a\" \"b\"]) (Set :Name \"table\" :Key \"key1\")\n.table (Log \".table\")               ;; =&gt; .table: {key1: [a, b]}\n\n;; add a key-value pair to existing mutable table (will generate warnings)\n\"def\" (Set \"table\" :Key \"key2\")     ;; add new key\n.table (Log \"modified .table\")      ;; =&gt; modified .table: {key2: def, key1: [a, b]}\n\n;; Using `Set` aliases\n\n;; `&gt;=` is alias for `(Set :Global false)`: create a mutable string variable\n\"World\" &gt;= .svarA\n.svarA (Log \".svarA\")               ;; =&gt; .svarA: World\n\n;; `&gt;==` is alias for `(Set :Global true)`: create a mutable numeric variable\n100 &gt;== .nvarA\n.nvarA (Log \".nvarA\")               ;; =&gt; .nvarA: 100\n\n;; create and update local/global variables\n\"Local\" (Set .str)                  ;; create local variable\n\"Global\" (Set .str :Global true)    ;; create same-name global variable\n(Get .str) (Log)                    ;; get updated local variable =&gt; \"Local\"\n(Get .str :Global true) (Log)       ;; get same-name updated global variable =&gt; \"Global\"\n\"LocalNew\" (Set .str)               ;; create local variable\n\"GlobalNew\" (Set .str :Global true) ;; create same-name global variable\n(Get .str) (Log)                    ;; get updated local variable =&gt; \"LocalNew\"\n(Get .str :Global true) (Log)       ;; get same-name updated global variable =&gt; \"GlobalNew\"\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/General/SetLogLevel/","title":"SetLogLevel","text":"Name - Description Default Type <code>&lt;input&gt;</code> A string representing the new log level (e.g., 'debug', 'info', 'warn', 'error', 'critical'). <code>String</code> <code>&lt;output&gt;</code> Outputs the input value, passed through unchanged. <code>Any</code> <p>This shard changes the log level to the level specified by the string passed as input. </p> <p> </p>"},{"location":"reference/shards/shards/General/Shuffle/","title":"Shuffle","text":"Name - Description Default Type <code>&lt;input&gt;</code> Any input is ignored. <code>Any</code> <code>&lt;output&gt;</code> The input is passed through as the output. <code>Any</code> <code>Name</code> The name of the variable. <code>\"\"</code> <code>String</code><code>Var(Any)</code> <code>Key</code> The key of the value to read from the table (parameter applicable only if the target variable is a table). <code>none</code> <code>Any</code> <code>Global</code> If the variable is available to all of the wires in the same mesh. <code>false</code> <code>Bool</code> <p>Shuffles the elements of the sequence variable. Works only on sequences. If the variable is not a sequence, it simply passes through without failing.</p> <p> </p>"},{"location":"reference/shards/shards/General/Sin/","title":"Sin","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input float or sequence of floats to calculate the sine of. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <code>&lt;output&gt;</code> Outputs the sine of the input. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <p>This shard calculates the sine of the given input, where the input is the angle in radians.</p> <p> </p>"},{"location":"reference/shards/shards/General/SleepBlocking%21/","title":"SleepBlocking!","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Any</code> <code>&lt;output&gt;</code> <code>Any</code>"},{"location":"reference/shards/shards/General/Slice/","title":"Slice","text":"Name - Description Default Type <code>&lt;input&gt;</code> The string or sequence from which characters/elements have to be extracted. <code>[Any]</code><code>Bytes</code><code>String</code> <code>&lt;output&gt;</code> The extracted characters/elements. <code>Any</code> <code>From</code> The position/index of the first character or element that is to be extracted (including). Negative position/indices simply loop over the target string/sequence counting backwards. <code>0</code> <code>Int</code><code>[Int]</code><code>Var(Int)</code><code>Var([Int])</code> <code>To</code> The position/index of the last character or element that is to be extracted (excluding). Negative position/indices simply loop over the target string/sequence counting backwards. <code>none</code> <code>Int</code><code>[Int]</code><code>Var(Int)</code><code>Var([Int])</code> <code>Step</code> The increment between each position/index. Chooses every nth sample to extract, where n is the increment. Value has to be greater than zero. <code>1</code> <code>Int</code> <p>Extracts characters from a string or elements from a sequence based on the start and end positions/indices and an increment parameter. Operation is non-destructive; the target string/sequence is not modified.</p>"},{"location":"reference/shards/shards/General/Slice/#examples","title":"Examples","text":"CodeOutput <pre><code>;; Slice on strings\n\"Hello World\" (Slice :From 1 :To 3 :Step 1)\n(Log) ;; =&gt; \"el\"\n\"Hello World\" (Slice 0 11 2)\n(Log) ;; =&gt; \"HloWrd\"\n\n;; Slice on sequences\n[10 20 30 40 50 60 70 80 90] (Slice 1 3 1)\n(Log) ;; =&gt; [20, 30]\n[10 20 30 40 50 60 70 80 90] (Slice 0 7 3)\n(Log) ;; =&gt; [10, 40, 70]\n[10 20 30 40 50 60 70 80 90] (Slice -9 -2 3)\n(Log) ;; =&gt; [10, 40, 70] : index -9 is same as 0, index -2 is same as 7\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/General/Snowflake/","title":"Snowflake","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>&lt;output&gt;</code> <code>Int</code> <code>MachineId</code> The machine ID, must be less than 32 <code>0</code> <code>Int</code> <code>NodeId</code> The node ID, must be less than 32 <code>0</code> <code>Int</code> <p>Creates a Snowflake ID.</p> <p> </p>"},{"location":"reference/shards/shards/General/Sort/","title":"Sort","text":"Name - Description Default Type <code>&lt;input&gt;</code> Any input is ignored. <code>&lt;output&gt;</code> Output is the sorted sequence. <code>[Any]</code> <code>From</code> The name of the sequence variable to edit in place. <code>none</code> <code>Var([Any])</code> <code>Join</code> Other columns to join sort/filter using the input (they must be of the same length). <code>none</code> <code>Var([Any])</code><code>[Var([Any])]</code> <code>Desc</code> If sorting should be in descending order, defaults ascending. <code>false</code> <code>Bool</code> <code>Key</code> The shards to use to transform the collection's items before they are compared. Can be None. <code>none</code> <code>Shard</code><code>[Shard]</code> <p>Sorts the elements of a sequence. Can also move around the elements of a joined sequence in alignment with the sorted sequence.</p>"},{"location":"reference/shards/shards/General/Sort/#details","title":"Details","text":"<p><code>Sort</code> sorts all the elements of the sequence that has been passed to it in the <code>:Name</code> parameter based on the value of the <code>:Desc</code> parameter. If <code>:Desc</code> is set to true the sequence is sorted in descending order, else it's sorted in the ascending order (which is the default behaviour).</p> <p>This shard can also take final element order of the sorted sequence and apply that to a joined sequence (passed via the <code>:Join</code> parameter). For example, if the element at index-7 moved to index-3 in the main sequence due to sorting then in the joined sequence too the element at index-7 would move to index-3. The movement of all elements in the main sequence (post-sort) would be mirrored in the joined sequence. For this to work both the sequences must have the same length.</p> <p>Note</p> <p>Think of this as the Shards equivalent of a relational database inner join. The main sequence and the joined sequence can be thought of as columns from two different tables inner joined over indices equality. So that the changes in elements of one sequence (rows in the first table) can be propogated to the corresponding elements of the joined sequence (corresponding rows in the joined table). </p> <p>In this case the operation is changing of indices (position) of selected elements (selected rows) in one sequence (table) leading to an equivalent change of indices (position) of corresponding elements (connected rows) of the joined sequence (joined table).</p> <p>The <code>:Key</code> parameter can take a shard or group of shards to transform the sequence elements before they're compared for sorting. This transformation doesn't actually change the value of the elements in the final sorted sequence (it's used only for sort comparisons).</p> <p><code>Sort</code> works only on sequences.</p> <p>Any input to this shard is ignored and its output is the main sorted sequence.</p> <p>See also</p> <ul> <li><code>Remove</code></li> </ul>"},{"location":"reference/shards/shards/General/Sort/#examples","title":"Examples","text":"CodeOutput <pre><code>; sort ascending (since default :Desc is false)\n[9 5 1 3 8] &gt;= .seq1\n(Sort :From .seq1)\n.seq1 (Log \"seq1\")  ;; sorted ascending =&gt; seq1: [1, 3, 5, 8, 9]\n\n; sorting descending (:Desc set to true)\n[9 5 1 3 8] &gt;= .seq2\n(Sort .seq2 :Desc true)\n.seq2 (Log \"seq2\")  ;; sorted ascending =&gt; seq2: [9, 8, 5, 3, 1]\n\n;; sort ascending using a :Key\n[9 5 1 3 8] &gt;= .seq3\n(Sort .seq3 :Key (Math.Multiply -1))\n.seq3 (Log \"seq3\")  ;; :Key transform makes it look like descending sort =&gt; seq3: [9, 8, 5, 3, 1]\n\n;; sort ascending with a joined sequence\n[9 5 1 3 8] &gt;= .seq4\n[\"a\" \"b\" \"c\" \"d\" \"e\"] &gt;= .seqJ\n(Sort .seq4 :Join .seqJ)\n.seq4 (Log \"seq4\")  ;; main sequence sorted in ascending order =&gt; seq4: [1, 3, 5, 8, 9]\n.seqJ (Log \"seqJ\")  ;; sorted order applied to joined sequence =&gt; seqJ: [c, d, b, e, a]\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/General/Spawn/","title":"Spawn","text":"Name - Description Default Type <code>&lt;input&gt;</code> Any input type is accepted. The input of this shard will be given as input for the specified Wire <code>Any</code> <code>&lt;output&gt;</code> Outputs the specific copy of the Wire that was scheduled. <code>Wire</code> <code>Wire</code> The Wire to schedule and run asynchronously <code>none</code> <code>Wire</code><code>[Shard]</code> <p>Schedules the specified Wire and runs it asynchronously. The current Wire will continue its execution independently of the specified Wire. Unlike Detach, a copy of the specified Wire is scheduled every time the shard is called.</p>"},{"location":"reference/shards/shards/General/Spawn/#examples","title":"Examples","text":"CodeOutput <pre><code>(defwire logic\n  (IsMore 10) (Or) (IsLess 0))\n\n11\n(-&gt; (Spawn logic) &gt;= .ccc\n    (Wait .ccc))\n(Assert.Is true true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/General/Sqrt/","title":"Sqrt","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input float or sequence of floats to calculate the square root of. This value must be a positive number or sequence of positive numbers. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <code>&lt;output&gt;</code> Outputs the square root of the input. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <p>This shard calculates the square root of the given input.</p> <p> </p>"},{"location":"reference/shards/shards/General/Step/","title":"Step","text":"Name - Description Default Type <code>&lt;input&gt;</code> Any input type is accepted. The input of this shard will be given as input for the specified Wire <code>Any</code> <code>&lt;output&gt;</code> Outputs the input value, passed through unchanged. <code>Any</code> <code>Wire</code> The Wire to schedule and progress. <code>none</code> <code>Wire</code><code>String</code> <p>The first time Step is called, the specified wire is scheduled. On subsequent calls, the specified Wire's state is progressed before the current Wire continues its execution. This means that a pause in execution of the child Wire will not pause the parent Wire.</p>"},{"location":"reference/shards/shards/General/Step/#examples","title":"Examples","text":"CodeOutput <pre><code>(defwire hello\n  (Msg \"Hello\"))\n\n(Detach hello)\n(Step\n  ;:Wire\n  hello)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/General/Stop/","title":"Stop","text":"Name - Description Default Type <code>&lt;input&gt;</code> Any input type is accepted. The input value will either pass through unchanged or be ignored. <code>Any</code> <code>&lt;output&gt;</code> Depending on what is specified in the Passthrough parameter, this shard either outputs the input value, passed through unchanged or it outputs the output of the stopped Wire. Note that if it outputs the output of the stopped wire, it will be of Type::Any and thus should be checked or converted to the appropriate Type. <code>Any</code> <code>Wire</code> The Wire to stop. If none provided, the shard will stop the current Wire. <code>none</code> <code>Wire</code><code>String</code><code>Var(Wire)</code> <code>Passthrough</code> If set to true, outputs the input value, passed through unchanged. <code>false</code> <code>Bool</code> <p>Either stops the execution of a specified Wire or the current Wire.</p>"},{"location":"reference/shards/shards/General/Stop/#examples","title":"Examples","text":"CodeOutput <pre><code>(defloop Loop\n  (Math.Add 1)\n  (Log)\n  (Cond\n   [(-&gt; (Is 5))\n    (Stop)])\n  (Restart))\n\n0\n(Do Loop)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/General/StringToBytes/","title":"StringToBytes","text":"Name - Description Default Type <code>&lt;input&gt;</code> A string to be converted to bytes. <code>String</code> <code>&lt;output&gt;</code> The byte representation of the input string. <code>Bytes</code> <p>Converts a string to its byte representation.</p> <p> </p>"},{"location":"reference/shards/shards/General/StripAlpha/","title":"StripAlpha","text":"Name - Description Default Type <code>&lt;input&gt;</code> The image to remove the alpha channel from. <code>Image</code> <code>&lt;output&gt;</code> The image with the alpha channel removed. <code>Image</code> <p>This shard takes an image with 4 channels(RGBA) and converts it to a 3-channel(RGB) image with the alpha channel removed.</p> <p> </p>"},{"location":"reference/shards/shards/General/Sub/","title":"Sub","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value or the sequence of values to subtract the value specified in the Operand parameter from. <code>Int</code><code>Int2</code><code>Int3</code><code>Int4</code><code>Int8</code><code>Int16</code><code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <code>&lt;output&gt;</code> This shard outputs the result of the subtraction. <code>Int</code><code>Int2</code><code>Int3</code><code>Int4</code><code>Int8</code><code>Int16</code><code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <code>Operand</code> The value or sequence of values to subtract from the input. <code>0</code> <code>Int</code><code>Var(Int)</code><code>Int2</code><code>Var(Int2)</code><code>Int3</code><code>Var(Int3)</code><code>Int4</code><code>Var(Int4)</code><code>Int8</code><code>Var(Int8)</code><code>Int16</code><code>Var(Int16)</code><code>Float</code><code>Var(Float)</code><code>Float2</code><code>Var(Float2)</code><code>Float3</code><code>Var(Float3)</code><code>Float4</code><code>Var(Float4)</code><code>Color</code><code>Var(Color)</code><code>[Any]</code><code>Var([Any])</code> <p>This shard subtracts the value provided in the Operand parameter from the input value.</p>"},{"location":"reference/shards/shards/General/Sub/#examples","title":"Examples","text":"CodeOutput <pre><code>;; SubFlow container shard + nesting\n(int 5)\n(Log \"input to Sub1\") ;; =&gt; 5\n(SubFlow ;; Sub1: a set of shard sequences\n ;:Shards\n (-&gt;\n  (Math.Multiply 2)\n  (Assert.Is 10 true)\n  (Log \"Sub1 inner shard o/p | 5 * 2\") ;; =&gt; 10\n  ))\n(Log \"Sub1 output =&gt; input to Sub2\") ;; =&gt; 5\n(SubFlow  ;; Sub2: another set of shard sequences\n ;:Shards\n (-&gt;\n  (Math.Multiply 3)\n  (Assert.Is 15 true)\n  (Log \"Sub2 inner shard o/p | 5 * 3\") ;; =&gt; 15\n  (Log \"input to nested-SubFlow\") ;; =&gt; 15\n  (SubFlow ;; nesting of SubFlow shards\n   ;:Shards\n   (-&gt;\n    (Math.Multiply 2)\n    (Assert.Is 30 true)\n    (Log \"nested-SubFlow inner shard o/p | (5 * 3) * 2\") ;; =&gt; 30\n    ))\n  (Log \"output from nested SubFlow\") ;; =&gt; 15\n  ))\n(Log \"Sub2 output =&gt; output\") ;; =&gt; 5\n</code></pre> <pre><code>\n</code></pre> CodeOutput <pre><code>;; Using `SubFlow`, with `-&gt;`\n(int 5)                                ;; input to `SubFlow` shards\n(SubFlow (-&gt; (Math.Multiply 2)\n         (Log)))                       ;; 5 * 2 =&gt; 10\n(SubFlow (-&gt; (Math.Multiply 3)\n         (Log)                         ;; 5 * 3 =&gt; 15\n         (SubFlow (-&gt; (Math.Multiply 2)\n                  (Log)))))            ;; 15 * 2 =&gt; 30\n(Log \"output of the last `SubFlow` shard\") ;; input is output =&gt; 5\n\n;; Using `|`, no need for `-&gt;`\n(int 100)                              ;; input to `|` shards\n(| (Math.Multiply 2)\n   (Log))                              ;; 100 * 2 =&gt; 200\n(| (Math.Multiply 3)\n   (Log)                               ;; 100 * 3 =&gt; 300\n   (| (Math.Multiply 2)\n      (Log)))                          ;; 300 * 2 =&gt; 600\n(Log \"output of the last `|` shard\")   ;; input is output =&gt; 100\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/General/SubFlow/","title":"SubFlow","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input value passed to this Sub flow (and hence to the shard or sequence of shards in this Sub flow). <code>Any</code> <code>&lt;output&gt;</code> The output of this Sub flow (which is the same as its input). <code>Any</code> <code>Shards</code> The shard or sequence of shards to execute in the Sub flow. <code>none</code> <code>Shard</code><code>[Shard]</code> <p>Activates a shard or a sequence of shards independently, without consuming the input. I.e. the input of the Sub flow will also be its output regardless of the shards activated in this Sub flow.</p>"},{"location":"reference/shards/shards/General/SubFlow/#details","title":"Details","text":"<p>In Shards, a shard receives an input, processes it, and produces an output. Usually, this output is different from the input that the shard processed.</p> <p>However, in some cases, we want a shard (or a sequence of shards) to return the same value as its output that it received as an input. For example, when we want a shard to process the same input that its previous shard (or sequence of shards) processed, irrespective of the output created by the previous shard(s).</p> <p>There is a pass-through parameter available for some shards (like <code>Match</code>) that can allow these shards to pass through their input to their output. For other shards, we can use the <code>SubFlow</code> shard (also called the <code>SubFlow</code> flow) to achieve the same effect by wrapping the target shard(s) within the <code>SubFlow</code>.</p> <p><code>SubFlow</code> passes its input to the first shard contained within. The shard contained within <code>SubFlow</code> then processes the input, creating an output which is then passed to the next shard in the sequence inside the <code>SubFlow</code> flow. This continues till the last shard in the flow is reached. The output of the last shard is not used by the <code>SubFlow</code> flow. Instead, the <code>SubFlow</code> flow outputs the same value that it had received as input.</p> <p>While <code>SubFlow</code> may seem to not use any of its internal shards' inputs or outputs, every variable assigned inside the <code>SubFlow</code> will be available outside as well since <code>SubFlow</code> will always be executed. Hence, the inputs and outputs of the shards within the <code>SubFlow</code> flow can be made available outside the <code>SubFlow</code> by saving them into <code>SubFlow</code> variables.</p> <p>As a result, the aforementioned method gives a pseudo-pass-through capability to any shard (if you wrap a shard with a <code>SubFlow</code> shard) or to any sequence of shards (if you wrap a whole sequence of shards within a <code>SubFlow</code> shard).</p> <p>By nesting <code>SubFlow</code> shards you can simulate even more flexible and powerful shard execution paths.</p> <p>Note</p> <p><code>SubFlow</code> has an alias <code>|</code> which is more convenient to use. <code>|</code> also removes the need to use <code>-&gt;</code> as, unlike <code>SubFlow</code>, it doesn't require the parameter shards to be grouped.</p> <p> </p>"},{"location":"reference/shards/shards/General/Suspend/","title":"Suspend","text":"Name - Description Default Type <code>&lt;input&gt;</code> Any input type is accepted. The input value will pass through unchanged. <code>Any</code> <code>&lt;output&gt;</code> Outputs the input value, passed through unchanged. <code>Any</code> <code>Wire</code> The wire to pause. <code>none</code> <code>Wire</code><code>String</code><code>Var(Wire)</code> <p>Pauses a specified Wire's execution. If no Wire is specified, pauses the current wire.</p> <p> </p>"},{"location":"reference/shards/shards/General/Swap/","title":"Swap","text":"Name - Description Default Type <code>&lt;input&gt;</code> Input is ignored. <code>Any</code> <code>&lt;output&gt;</code> The input to this shard is passed through as its output. <code>Any</code> <code>First</code> The name of first variable. <code>none</code> <code>Var(Any)</code> <code>Second</code> The name of second variable. <code>none</code> <code>Var(Any)</code> <p>Swaps the values of the two variables passed to it via <code>First</code> and <code>Second</code> parameters.</p>"},{"location":"reference/shards/shards/General/Swap/#details","title":"Details","text":"<p><code>Swap</code> swaps the values of the two variables passed to it, one via the <code>First</code> parameter, the other via the <code>Second</code> parameter.</p> <p>This shard works on all kinds of variables and across types. So you can not only swap between two integers, two strings, two sequences, two tables etc., but also between a string and a number, a table and a sequence and so on.</p> <p>Any input to this shard is ignored and instead passed through as its output.</p>"},{"location":"reference/shards/shards/General/Swap/#examples","title":"Examples","text":"CodeOutput <pre><code>\"Shards\" &gt;= .string\n123 &gt;= .number1\n456 &gt;= .number2\n789 &gt;= .number3\n[10 20] &gt;= .sequence\n{\"k1\" 1 \"k2\" 2} &gt;= .table\n\n(Swap\n    :First .number1\n    :Second .number2)        ;; swap two numbers\n.number1 (Log \"number1\")    ;; swapped =&gt; number1: 456\n.number2 (Log \"number2\")    ;; swapped =&gt; number2: 123\n\n(Swap .string .table)       ;; swap a string and a table\n.string (Log \"string\")      ;; swapped =&gt; string: {\"k1\" 1 \"k2\" 2}\n.table (Log \"table\")        ;; swapped =&gt; table: \"Shards\"\n\n(Swap .number3 .sequence)   ;; swap a number and a sequence\n.number3 (Log \"number3\")    ;; swapped =&gt; number3:[10 20]\n.sequence (Log \"sequence\")  ;; swapped =&gt; sequence: 789\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/General/SwitchTo/","title":"SwitchTo","text":"Name - Description Default Type <code>&lt;input&gt;</code> Any input type is accepted. The input of this shard will be given as input for the specified Wire <code>Any</code> <code>&lt;output&gt;</code> The output of this shard is the output of the Wire that execution was switched to, upon switching back to the parent Wire. <code>Any</code> <code>Wire</code> The Wire to switch to. If none is provided, the Wire is switched back to the parent Wire it was switched from (should a parent Wire exist). <code>none</code> <code>Wire</code><code>String</code> <code>Restart</code> If the Wire should always restart from the beginning instead of resuming from its previous state. <code>false</code> <code>Bool</code> <code>StopOnCleanup</code> If the child Wire should be stopped when the parent Wire is Destroyed or Stopped. <code>false</code> <code>Bool</code> <p>Suspends the current Wire and switches execution to the specified Wire.</p> <p> </p>"},{"location":"reference/shards/shards/General/Table/","title":"Table","text":"Name - Description Default Type <code>&lt;input&gt;</code> Any input is ignored. <code>Any</code> <code>&lt;output&gt;</code> The input to this shard is passed through as its output. <code>Any</code> <code>Name</code> The name of the variable. <code>\"\"</code> <code>String</code><code>Var(Any)</code> <code>Key</code> The key of the value to write in the table (parameter applicable only if the target variable is a table). <code>none</code> <code>Any</code> <code>Global</code> If the variable is available to all of the wires in the same mesh. <code>false</code> <code>Bool</code> <code>Type</code> The table type to forward declare. <code>none</code> <code>Type</code> <p>Creates an empty table. Useful to declare and specify types.</p>"},{"location":"reference/shards/shards/General/Table/#details","title":"Details","text":"<p><code>Table</code> creates an empty table with or without a specified key (via the <code>:Key</code> parameter). The created table name is defined in the <code>:Name</code> parameter.</p> <p>Whether the created table variable has a global scope (available to all wires on the mesh) or a local scope (available only to the wire its defined in) can be controlled via the <code>:Global</code> parameter (<code>true</code> for global scope, <code>false</code> for local scope; default is <code>false</code>).</p> <p>In addition to the key and the scope, this shard can also define the table's inner data types via the <code>:Types</code> parameter. More than one data type may be set.</p> <p>Any input to this shard is ignored and instead passed through as its output.</p> <p>See also</p> <ul> <li><code>Get</code></li> <li><code>Push</code></li> <li><code>Sequence</code></li> <li><code>Set</code></li> <li><code>Update</code></li> </ul>"},{"location":"reference/shards/shards/General/Table/#examples","title":"Examples","text":"CodeOutput <pre><code>;; without key, without types, local scope, using `Push` (puts sequence values)\n;; (Table :Name .tableA)\n;; .tableA (Log)         ;; created a table =&gt; {A: []}\n1 (Push .tableA \"A\")\n.tableA (Log)         ;; updated table =&gt; {A: [1]}\n2 (Push .tableA \"A\")\n.tableA (Log)         ;; updated table =&gt; {A: [1, 2]}\n\n;; with key, single type, global scope, using `Set`\n(Table .tableB :Key \"A\" :Global true :Type (type {:A Float}))\n.tableB (Log)         ;; created a table =&gt; {A: {}}\n10.2 (Set .tableB \"A\")\n.tableB (Log)         ;; updated table =&gt; {A: 10.2}\n20.1 (Set .tableB \"A\")\n.tableB (Log)         ;; updated table =&gt; {A: 20.1}\n\n;; with key, multiple types, local scope, using `Set`\n(Table .tableC :Key \"A\" :Type (type {:A Float :B Int}))\n.tableC (Log)         ;; created a table =&gt; {A: {}}\n10.3 (Set .tableC \"A\")\n.tableC (Log)         ;; updated table =&gt; {A: 10.3}\n20 (Set .tableC \"B\")\n.tableC (Log)         ;; updated table =&gt; {B: 20, A: 10.3}\n\n;; with key, single type, local scope, using `Push` (puts sequence values)\n;; (Table .tableD :Key \"A\" :Types Type.Int)\n;; .tableD (Log)         ;; created a table =&gt; {A: []}\n10 (Push .tableD \"A\")\n.tableD (Log)         ;; updated table =&gt; {A: [10]}\n20 (Push .tableD \"A\")\n.tableD (Log)         ;; updated table =&gt; {A: [10, 20]}\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/General/Take/","title":"Take","text":"Name - Description Default Type <code>&lt;input&gt;</code> The sequence or table from which elements or values will be extracted. <code>Int2</code><code>Int3</code><code>Int4</code><code>Int8</code><code>Int16</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Bytes</code><code>Color</code><code>String</code><code>[Any]</code><code>{Any}</code> <code>&lt;output&gt;</code> The extracted elements from a sequence or values from a table. If the key cannot be established to exist at compose time, the output will be of type Any. <code>Any</code> <code>Indices/Keys</code> One or more indices or keys to extract from a sequence or table. <code>none</code> <code>Any</code><code>Var(Any)</code> <p>Extracts one or more elements from a sequence or values from a table using the provided indices or keys. This operation is non-destructive and does not modify the target sequence or table. If the key cannot be established to exist at compose time, the output will be of type Any.</p>"},{"location":"reference/shards/shards/General/Take/#examples","title":"Examples","text":"CodeOutput <pre><code>;; Take on sequences\n[10 20 30 40] (Take 1) (Log)\n(Assert.Is 20 :Break true)\n[10 20 30 40] (Take [1 2]) (Log)\n(Assert.Is [20, 30] :Break true)\n\n;; Take on tables\n{\"Hello\" 10 \"World\" 20} (Take \"Hello\") (Log)\n(Assert.Is 10 :Break true)\n{\"Hello\" 10 \"World\" 20} (Take [\"World\" \"Hello\"]) (Log)\n(Assert.Is [20, 10] :Break true)\n{\"Hello\" 10 \"World\" 20} (Take \"Universe\") (Log)\n(Assert.Is nil :Break true)\n{:abc 10 :def 20} (Take \"def\") (Log)\n(Assert.Is 20 :Break true)\n\n;; Take using a variable as index\n1 = .index\n[1 2 3 4] (Take .index) (Log)\n(Assert.Is 2 :Break true)\n\"Hello\" = .key\n{\"Hello\" 10 \"World\" 20} (Take .key) (Log)\n(Assert.Is 10 :Break true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/General/Tan/","title":"Tan","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input float or sequence of floats to calculate the tangent of. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <code>&lt;output&gt;</code> Outputs the tangent of the input. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <p>This shard calculates the tangent of the given input, where the input is the angle in radians.</p> <p> </p>"},{"location":"reference/shards/shards/General/TargetCamera/","title":"TargetCamera","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>{pivot: Float3 distance: Float rotation: Float2}</code> <code>&lt;output&gt;</code> <code>{pivot: Float3 distance: Float rotation: Float2}</code> <code>FlySpeed</code> Controls fly speed with the keyboard <code>none</code> <code>Float</code><code>Var(Float)</code> <code>ScrollSpeed</code> Controls middle mouse movement speed <code>none</code> <code>Float</code><code>Var(Float)</code> <code>PanSpeed</code> Controls middle mouse pan speed <code>none</code> <code>Float</code><code>Var(Float)</code> <code>LookSpeed</code> Controls right mouse look speed <code>none</code> <code>Float</code><code>Var(Float)</code> <code>PivotDistance</code> Controls distance to the point being looked at <code>none</code> <code>Float</code><code>Var(Float)</code> <p>Provides editor free camera controls</p> <p> </p>"},{"location":"reference/shards/shards/General/Tensor/","title":"Tensor","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>[Int]</code><code>[Float]</code> <code>&lt;output&gt;</code> <code>Tensor</code> <code>Shape</code> The shape of the tensor to create. If not provided, the shape will be inferred from the input. <code>none</code> <code>[Int]</code><code>Var([Int])</code> <code>Type</code> The data type of the tensor to create. If not provided, the data type will be inferred from the input. <code>TensorType::F32</code> <code>TensorType</code> <code>GPU</code> If true, the tensor will be created on the GPU (if available). <code>false</code> <code>Bool</code> <p>Creates a tensor from a sequence (or nested sequences) of variables.</p> <p> </p>"},{"location":"reference/shards/shards/General/ToBase58/","title":"ToBase58","text":"Name - Description Default Type <code>&lt;input&gt;</code> The byte array or string to encode. <code>Bytes</code><code>String</code> <code>&lt;output&gt;</code> Outputs the base58 encoded string. <code>String</code> <p>This shard encodes the input(either a byte array or a string) into a base58 encoded string.</p> <p> </p>"},{"location":"reference/shards/shards/General/ToBase64/","title":"ToBase64","text":"Name - Description Default Type <code>&lt;input&gt;</code> Accepts a byte array or a string value as input. <code>Bytes</code><code>String</code> <code>&lt;output&gt;</code> Outputs the Base64 encoded string representation of the input value. <code>String</code> <p>Encodes the input bytes or string value to its Base64 string representation.</p> <p> </p>"},{"location":"reference/shards/shards/General/ToBytes/","title":"ToBytes","text":"Name - Description Default Type <code>&lt;input&gt;</code> This shard will take any value. <code>Any</code> <code>&lt;output&gt;</code> This shard will return a seriliazed byte array representing the input value. <code>Bytes</code> <p>This shard takes a value and converts it to a serialized binary representation (a serialized byte array).</p> <p> </p>"},{"location":"reference/shards/shards/General/ToColor/","title":"ToColor","text":"Name - Description Default Type <code>&lt;input&gt;</code> Takes input values of type <code>Int</code>, <code>Float</code>, <code>String</code>, or a collection  of <code>Int</code>s and <code>Float</code>s. Note that the shard can only convert strings that represent numerical values, such as \"5\", and not words like \"Five\". <code>Any</code> <code>&lt;output&gt;</code> Outputs a vector of four color channels (RGBA). <code>Any</code> <p>Converts various input types to a vector of four color channels (RGBA). If a single value or a collection with less than 4 elements is provided, the remaining unaccounted elements in the resulting vector will be set to 0.</p> <p> </p>"},{"location":"reference/shards/shards/General/ToFloat/","title":"ToFloat","text":"Name - Description Default Type <code>&lt;input&gt;</code> Takes input values of type <code>Int</code>, <code>Float</code>, <code>String</code>, or a collection  of <code>Int</code>s and <code>Float</code>s. Note that the shard can only convert strings that represent numerical values, such as \"5\", and not words like \"Five\". <code>Any</code> <code>&lt;output&gt;</code> Outputs a numerical value that can include a fractional or decimal component. <code>Any</code> <p>Converts various input types to type Float.</p>"},{"location":"reference/shards/shards/General/ToFloat/#details","title":"Details","text":"<p>This shard typecasts integer and string numeric values into the single float data type (<code>float</code>).</p>"},{"location":"reference/shards/shards/General/ToFloat/#examples","title":"Examples","text":"CodeOutput <pre><code>1 (ToFloat) (Log)\n(Assert.Is 1.0 :Break true)\n\n2.2 (ToFloat) (Log)\n(Assert.Is 2.2 :Break true)\n\n\"3\" (ToFloat) (Log)\n(Assert.Is 3.0 :Break true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/General/ToFloat2/","title":"ToFloat2","text":"Name - Description Default Type <code>&lt;input&gt;</code> Takes input values of type <code>Int</code>, <code>Float</code>, <code>String</code>, or a collection  of <code>Int</code>s and <code>Float</code>s. Note that the shard can only convert strings that represent numerical values, such as \"5\", and not words like \"Five\". <code>Any</code> <code>&lt;output&gt;</code> Outputs a vector of two Float elements. <code>Any</code> <p>Converts various input types to a vector of two Float elements. If a single value or a collection with only one element is provided, the second element in the resulting vector will be set to 0.</p> <p> </p>"},{"location":"reference/shards/shards/General/ToFloat3/","title":"ToFloat3","text":"Name - Description Default Type <code>&lt;input&gt;</code> Takes input values of type <code>Int</code>, <code>Float</code>, <code>String</code>, or a collection  of <code>Int</code>s and <code>Float</code>s. Note that the shard can only convert strings that represent numerical values, such as \"5\", and not words like \"Five\". <code>Any</code> <code>&lt;output&gt;</code> Outputs a vector of three Float elements. <code>Any</code> <p>Converts various input types to a vector of three Float elements. If a single value or a collection with less than 3 elements is provided, the remaining unaccounted elements in the resulting vector will be set to 0.</p> <p> </p>"},{"location":"reference/shards/shards/General/ToFloat4/","title":"ToFloat4","text":"Name - Description Default Type <code>&lt;input&gt;</code> Takes input values of type <code>Int</code>, <code>Float</code>, <code>String</code>, or a collection  of <code>Int</code>s and <code>Float</code>s. Note that the shard can only convert strings that represent numerical values, such as \"5\", and not words like \"Five\". <code>Any</code> <code>&lt;output&gt;</code> Outputs a vector of Four Float elements. <code>Any</code> <p>Converts various input types to a vector of Four Float elements. If a single value or a collection with less than 4 elements is provided, the remaining unaccounted elements in the resulting vector will be set to 0.</p> <p> </p>"},{"location":"reference/shards/shards/General/ToHex/","title":"ToHex","text":"Name - Description Default Type <code>&lt;input&gt;</code> Takes an integer, byte array, or string value. <code>Int</code><code>Int16</code><code>Bytes</code><code>String</code> <code>&lt;output&gt;</code> The hexadecimal string representation of the input value. <code>String</code> <p>Converts an integer, bytes, or string value into its hexadecimal string representation.</p> <p> </p>"},{"location":"reference/shards/shards/General/ToInt/","title":"ToInt","text":"Name - Description Default Type <code>&lt;input&gt;</code> Takes input values of type <code>Int</code>, <code>Float</code>, <code>String</code>, or a collection  of <code>Int</code>s and <code>Float</code>s. Note that the shard can only convert strings that represent numerical values, such as \"5\", and not words like \"Five\". <code>Any</code> <code>&lt;output&gt;</code> Outputs a numerical whole number without any fractional or decimal component. <code>Any</code> <p>Converts various input types to type Int.</p>"},{"location":"reference/shards/shards/General/ToInt/#details","title":"Details","text":"<p>This shard typecasts float and string numeric values into the single integer data type (<code>int</code>).</p>"},{"location":"reference/shards/shards/General/ToInt/#examples","title":"Examples","text":"CodeOutput <pre><code>1 (ToInt) (Log)\n(Assert.Is 1 :Break true)\n\n2.2 (ToInt) (Log)\n(Assert.Is 2 :Break true)\n\n\"3\" (ToInt) (Log)\n(Assert.Is 3 :Break true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/General/ToInt16/","title":"ToInt16","text":"Name - Description Default Type <code>&lt;input&gt;</code> Takes input values of type <code>Int</code>, <code>Float</code>, <code>String</code>, or a collection  of <code>Int</code>s and <code>Float</code>s. Note that the shard can only convert strings that represent numerical values, such as \"5\", and not words like \"Five\". <code>Any</code> <code>&lt;output&gt;</code> Outputs a vector of sixteen Int elements. <code>Any</code> <p>Converts various input types to a vector of sixteen Int elements. If a single value or a collection with less than 16 elements is provided, the remaining unaccounted elements in the resulting vector will be set to 0.</p> <p> </p>"},{"location":"reference/shards/shards/General/ToInt2/","title":"ToInt2","text":"Name - Description Default Type <code>&lt;input&gt;</code> Takes input values of type <code>Int</code>, <code>Float</code>, <code>String</code>, or a collection  of <code>Int</code>s and <code>Float</code>s. Note that the shard can only convert strings that represent numerical values, such as \"5\", and not words like \"Five\". <code>Any</code> <code>&lt;output&gt;</code> Outputs a vector of two Int elements. <code>Any</code> <p>Converts various input types to a vector of two Int elements. If a single value or a collection with only one element is provided, the second element in the resulting vector will be set to 0.</p> <p> </p>"},{"location":"reference/shards/shards/General/ToInt3/","title":"ToInt3","text":"Name - Description Default Type <code>&lt;input&gt;</code> Takes input values of type <code>Int</code>, <code>Float</code>, <code>String</code>, or a collection  of <code>Int</code>s and <code>Float</code>s. Note that the shard can only convert strings that represent numerical values, such as \"5\", and not words like \"Five\". <code>Any</code> <code>&lt;output&gt;</code> Outputs a vector of three Int elements. <code>Any</code> <p>Converts various input types to a vector of three Int elements. If a single value or a collection with less than 3 elements is provided, the remaining unaccounted elements in the resulting vector will be set to 0.</p> <p> </p>"},{"location":"reference/shards/shards/General/ToInt4/","title":"ToInt4","text":"Name - Description Default Type <code>&lt;input&gt;</code> Takes input values of type <code>Int</code>, <code>Float</code>, <code>String</code>, or a collection  of <code>Int</code>s and <code>Float</code>s. Note that the shard can only convert strings that represent numerical values, such as \"5\", and not words like \"Five\". <code>Any</code> <code>&lt;output&gt;</code> Outputs a vector of four Int elements. <code>Any</code> <p>Converts various input types to a vector of four Int elements. If a single value or a collection with less than 4 elements is provided, the remaining unaccounted elements in the resulting vector will be set to 0.</p> <p> </p>"},{"location":"reference/shards/shards/General/ToInt8/","title":"ToInt8","text":"Name - Description Default Type <code>&lt;input&gt;</code> Takes input values of type <code>Int</code>, <code>Float</code>, <code>String</code>, or a collection  of <code>Int</code>s and <code>Float</code>s. Note that the shard can only convert strings that represent numerical values, such as \"5\", and not words like \"Five\". <code>Any</code> <code>&lt;output&gt;</code> Outputs a vector of eight Int elements. <code>Any</code> <p>Converts various input types to a vector of eight Int elements. If a single value or a collection with less than 8 elements is provided, the remaining unaccounted elements in the resulting vector will be set to 0.</p> <p> </p>"},{"location":"reference/shards/shards/General/ToJson/","title":"ToJson","text":"Name - Description Default Type <code>&lt;input&gt;</code> If Pure is set to false, this shard accepts an input of any type. If Pure is set to true, this shard only accepts standard JSON types (tables, sequences, strings, numbers, booleans and none). <code>Any</code> <code>&lt;output&gt;</code> Outputs the input converted to a JSON string. <code>String</code> <code>Pure</code> If the input string is generic pure json rather then shards flavored json. <code>true</code> <code>Bool</code> <code>Indent</code> How many spaces to use as json prettify indent. <code>0</code> <code>Int</code> <p>This shard takes its input and converts it into a JSON string.</p> <p> </p>"},{"location":"reference/shards/shards/General/ToLEB128/","title":"ToLEB128","text":"Name - Description Default Type <code>&lt;input&gt;</code> The integer to encode. <code>Int</code> <code>&lt;output&gt;</code> Outputs the LEB128 encoded byte array. <code>Bytes</code> <code>Signed</code> If the integer to encode/decode is signed and can be negative. <code>false</code> <code>Bool</code> <p>This shard encodes the input(a signed or unsigned integer) into a LEB128 encoded byte array.</p> <p> </p>"},{"location":"reference/shards/shards/General/ToString/","title":"ToString","text":"Name - Description Default Type <code>&lt;input&gt;</code> Input of any type is accepted. <code>Any</code> <code>&lt;output&gt;</code> The string representation of the input value. <code>String</code> <p>Converts any input value to its string representation.</p> <p> </p>"},{"location":"reference/shards/shards/General/TraitId/","title":"TraitId","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>&lt;output&gt;</code> <code>Int2</code> <code>Trait</code> The trait <code>none</code> <code>Trait</code> <p>Retrieves the hash id of the given trait</p> <p> </p>"},{"location":"reference/shards/shards/General/TryMany/","title":"TryMany","text":"Name - Description Default Type <code>&lt;input&gt;</code> This shard takes a sequence of values as input. Each value from the sequence is provided as input to its corresponding copy of the scheduled Wire. The total number of copies of the specified Wire scheduled, will be the same as the number of elements in the sequence provided. <code>[Any]</code> <code>&lt;output&gt;</code> Depending on the Policy specified the shard will return a different output. WaitUntil::FirstSuccess will return the output of the first successful Wire. WaitUntil::SomeSuccess return a sequence with all the output from all the copies of the specified Wire. WaitUntil::AllSuccess will either stop execution of the current Wire if any of the copies fail or return a sequence with all the output from all the copies of the specified Wire. <code>[Any]</code> <code>Wire</code> The Wire to copy and schedule. <code>none</code> <code>Wire</code><code>[Shard]</code> <code>Policy</code> The execution policy for the shard to abide by. A copied Wire is only deemed successful if it did not have an internal failure (eg.through Assert) <code>WaitUntil::AllSuccess</code> <code>WaitUntil</code> <code>Threads</code> The number of cpu threads to use. Number specified can not be lower than 1. <code>0</code> <code>Int</code> <p>This shard takes a sequence of values as input, schedules multiple copies of a specified Wire and executes them asynchronously. Each value from the sequence is provided as input to its corresponding copy of the scheduled Wire. The shard will then wait for all the scheduled Wires to end, and then, depending on the Policy specified, the shard will either return the output of the first successful Wire, return a sequence with all the output from all the copies of the specified Wire or stop execution of the current Wire if all the copies failed.</p>"},{"location":"reference/shards/shards/General/TryMany/#examples","title":"Examples","text":"CodeOutput <pre><code>(Const [\"A\" \"B\" \"C\"])\n(TryMany\n ;:Wire\n (Wire\n  \"print\"\n  (Log)\n  \"Ok\")\n ;:Policy\n WaitUntil.AllSuccess\n ;:Threads\n 12)\n(Assert.Is [\"Ok\" \"Ok\" \"Ok\"] true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/General/TypeOf/","title":"TypeOf","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input of this shard is ignored. <code>&lt;output&gt;</code> Outputs the type of the specified expression's output. <code>Type</code> <code>OutputOf</code> Evaluates the output type of the given expression. <code>none</code> <code>Shard</code><code>[Shard]</code> <p>Evaluates the output type of the given expression specified by the 'OutputOf' parameter and outputs that type. No input is required for this shard.</p> <p> </p>"},{"location":"reference/shards/shards/General/UI/","title":"UI","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value that will be passed to the Contents shards of the UI. <code>Any</code> <code>&lt;output&gt;</code> The output of this shard will be its input. <code>Object</code> <code>Contents</code> The UI contents. <code>none</code> <code>Shard</code><code>[Shard]</code> <code>Scale</code> The UI scale <code>none</code> <code>Float</code><code>Var(Float)</code> <code>Queue</code> The draw queue. <code>none</code> <code>Var(GFX.DrawQueue)</code> <p>Initializes a UI context</p>"},{"location":"reference/shards/shards/General/UI/#examples","title":"Examples","text":"CodeOutput <pre><code>(defloop main-wire\n  (GFX.MainWindow\n   :Contents\n   (-&gt;\n    (Setup\n     (GFX.DrawQueue) &gt;= .ui-draw-queue\n     (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n\n    (UI)\n\n    (GFX.Render :Steps .render-steps))))\n(defmesh root)\n(schedule root main-wire)\n(run root 0.1 10)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/General/UUID/","title":"UUID","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>&lt;output&gt;</code> <code>Int16</code> <p>Outputs a UUID (Universally Unique Identifier).</p> <p> </p>"},{"location":"reference/shards/shards/General/Unpack/","title":"Unpack","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Int</code><code>Bytes</code> <code>&lt;output&gt;</code> <code>[Any]</code> <code>Definition</code> A string defining the struct e.g. \"i32 f32 b i8[256]\". <code>\"\"</code> <code>String</code>"},{"location":"reference/shards/shards/General/UnsafeActivate%21/","title":"UnsafeActivate!","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Any</code> <code>&lt;output&gt;</code> <code>Any</code> <code>Activate</code> The function address, must be of type std::function. <code>0</code> <code>Int</code> <code>Cleanup</code> The function address, must be of type std::function. <code>0</code> <code>Int</code>"},{"location":"reference/shards/shards/General/Update/","title":"Update","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value to be set to the variable. <code>Any</code> <code>&lt;output&gt;</code> The input value is passed through as the output. <code>Any</code> <code>Name</code> The name of the variable. <code>\"\"</code> <code>String</code><code>Var(Any)</code> <code>Key</code> The key of the value to read from the table (parameter applicable only if the target variable is a table). <code>none</code> <code>Any</code> <code>Global</code> If the variable is available to all of the wires in the same mesh. <code>false</code> <code>Bool</code> <p>Modifies the value of an existing mutable variable.</p>"},{"location":"reference/shards/shards/General/Update/#details","title":"Details","text":"<p><code>Update</code> modifies the value of an existing mutable variable.</p> <p>The name of the variable comes from the <code>:Name</code> parameter and the update value comes from the input. </p> <p><code>Update</code> overwrites string, numeric, and sequence variables with the new value (coming from input). However, for sequences, it cannot update a sequence at the level of elements (i.e., add elements, remove elements, change element order, etc.), so it overwrites the whole sequence with whatever you've passed in the input field.</p> <p>Also, for an existing table, <code>Update</code> can only change the existing keys' values. It cannot add new key-value pairs to the table (do that with <code>Set</code>). To update existing key-values in a table you need to pass the key in the <code>:Key</code> parameter.</p> <p>Since variables may be locally scoped (created with <code>(:Global false)</code>; exists only for current wire) or globally scoped (created with <code>(:Global true)</code>; exists for all wires of that mesh), both parameters <code>:Global</code> and <code>:Name</code> are used in combination to identify the correct variable to update.</p> <p>The input to this shard is the update value to be applied to the mutable variables and is also passed through as this shard's output.</p> <p>Note</p> <p><code>Update</code> has an alias <code>&gt;</code>. Its an alias for <code>Update</code> with the defaults: <code>(Update ...)</code>. See the code examples at the end to understand how this alias is used.</p> <p>See also</p> <ul> <li><code>AppendTo</code></li> <li><code>PrependTo</code></li> <li><code>Push</code></li> <li><code>Sequence</code></li> <li><code>Set</code></li> <li><code>Table</code></li> </ul>"},{"location":"reference/shards/shards/General/Update/#examples","title":"Examples","text":"CodeOutput <pre><code>;; update a mutable string variable (by default available only to current wire)\n\"Hello\" (Set :Name .svar)\n.svar (Log \".svar\")                 ;; =&gt; .svar: Hello\n\"World\" (Update .svar)              ;; modify string variable\n.svar (Log \"modified .svar\")        ;; =&gt; .svar: World\n\n;; update a mutable numeric variable (available to all wires because `:Global true`)\n100 (Set :Name .nvar :Global true)\n.nvar (Log \".nvar\")                 ;; =&gt; .nvar: 100\n200 (Update \n    :Name .nvar\n    :Global true)                   ;; modify numeric variable\n.nvar (Log \"modified .nvar\")        ;; =&gt; modified .nvar: 200\n\n;; update a mutable sequence (will overwrite it completely)\n[10 20 30] (Set :Name .sequence)\n[100] (Update :Name .sequence)\n.sequence (Log \".sequence\")         ;; =&gt; .sequence: [100]\n\n;; update a mutable table: update existing key-value pair\n[\"a\" \"b\"] (Set\n            :Name \"table1\"\n            :Key \"key1\")\n.table1 (Log \".table1\")             ;; =&gt; .table1: {key1: [a, b]}\n[\"def\"] (Update .table1 :Key \"key1\")\n.table1 (Log \".table1\")             ;; =&gt; .table1: {key1: [def]}\n\n;; Using an `Update` alias\n\n;; `&gt;` is alias for `(Update ...)`: update an existing string variable\n\"Hello\" (Set :Name .svarA)\n.svarA (Log \".svarA\")               ;; =&gt; .svar: Hello\n\"World\" &gt; .svarA                    ;; modify string variable\n.svarA (Log \"modified .svar\")       ;; =&gt; .svar: World\n\n;; create and update local/global table variables\n[\"a\" \"b\"] (Set\n            :Name \"table\"\n            :Key \"key1\")            ;; create local table\n[\"c\" \"d\"] (Set\n            :Name \"table\"\n            :Key \"key1\"\n            :Global true)           ;; create same-name global table\n(Get .table) (Log)                  ;; local table =&gt; {key1: [a, b]}\n(Get .table :Global true) (Log)     ;; same-name global table =&gt; {key1: [c, d]}\n[\"X\"] (Update .table :Key \"key1\")   ;; update local table\n[\"Y\"] (Update .table\n            :Key \"key1\"\n            :Global true)           ;; update same-name global table\n(Get .table) (Log)                  ;; updated local table =&gt; {key1: [X]}\n(Get .table :Global true) (Log)     ;; updated same-name global table =&gt; {key1: [Y]}\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/General/VarAddr/","title":"VarAddr","text":"Name - Description Default Type <code>&lt;input&gt;</code> The name of the variable whose address is to be retrieved. <code>String</code> <code>&lt;output&gt;</code> The memory address of the specified variable, represented as an integer. <code>Int</code> <p>Retrieves the memory address of the specified variable and outputs it as an integer.</p> <p> </p>"},{"location":"reference/shards/shards/General/VarPtr/","title":"VarPtr","text":"Name - Description Default Type <code>&lt;input&gt;</code> The variable whose pointer is to be retrieved. It must be of type sequence, bytes, or string. <code>Any</code> <code>&lt;output&gt;</code> The memory address of the specified variable's data, represented as an integer. <code>Int</code> <p>Retrieves the memory address of the data contained in the specified variable and outputs it as an integer. The variable must be of type sequence, bytes, or string.</p> <p> </p>"},{"location":"reference/shards/shards/General/Wait/","title":"Wait","text":"Name - Description Default Type <code>&lt;input&gt;</code> Any input type is accepted. The input value will either pass through unchanged or be ignored. <code>&lt;output&gt;</code> If Passthrough is true, this shard outputs the input value, passed through unchanged. Otherwise, it outputs the output of the Wire it waited for. <code>Any</code> <code>Wire</code> The Wire to wait for. <code>none</code> <code>Wire</code><code>String</code><code>Var(Wire)</code> <code>Passthrough</code> If set to true, outputs the input value, passed through unchanged. <code>false</code> <code>Bool</code> <code>Timeout</code> The optional amount of time in seconds to wait for the specified Wire to complete. If the specified time elapses before the specified Wire is complete, the current Wire will fail with a Timeout error. <code>none</code> <code>Float</code><code>Var(Float)</code> <p>Waits for the specified Wire to complete before resuming execution of the current Wire.</p>"},{"location":"reference/shards/shards/General/Wait/#examples","title":"Examples","text":"CodeOutput <pre><code>(defwire myWire\n  (If (IsLess 0) (-&gt; \"Negative\") (-&gt; \"Positive\")))\n\n5\n(Detach myWire)\n(Wait\n  ;:Wire\n  \"myWire\"\n  ;:Passthrough\n  false)\n(Assert.Is \"Positive\" true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/General/When/","title":"When","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value that will be passed to the predicate. <code>Any</code> <code>&lt;output&gt;</code> The input of the shard if <code>Passthrough</code> is <code>true</code>, or the <code>Predicate</code> is <code>false</code>; otherwise, the output of the <code>Action</code>. <code>Any</code> <code>Predicate</code> The predicate to evaluate in order to trigger Action. <code>none</code> <code>Shard</code><code>[Shard]</code> <code>Action</code> The shards to activate on when Predicate is true for When and false for WhenNot. <code>none</code> <code>Shard</code><code>[Shard]</code> <code>Passthrough</code> The output of this shard will be its input. <code>true</code> <code>Bool</code> <p>Conditional shard that only executes the action if the predicate is true.</p>"},{"location":"reference/shards/shards/General/When/#examples","title":"Examples","text":"CodeOutput <pre><code>64\n(When\n ;:Predicate\n (IsMore 50)\n ;:Action\n (Msg \"More than 50\"))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/General/WhenDone/","title":"WhenDone","text":"Name - Description Default Type <code>&lt;input&gt;</code> Any input type is accepted. The input of this shard will be given as input for the specified Wire <code>Any</code> <code>&lt;output&gt;</code> Outputs the specific copy of the Wire that was scheduled. <code>Any</code> <code>Wire</code> The Wire to schedule and run asynchronously <code>none</code> <code>Wire</code><code>[Shard]</code> <p>Schedules the specified Wire and runs it asynchronously. The current Wire will continue its execution independently of the specified Wire. Unlike Detach, a copy of the specified Wire is scheduled every time the shard is called.</p> <p> </p>"},{"location":"reference/shards/shards/General/WhenNot/","title":"WhenNot","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value that will be passed to the predicate. <code>Any</code> <code>&lt;output&gt;</code> The input of the shard if <code>Passthrough</code> is <code>true</code>, or the <code>Predicate</code> is <code>true</code>; otherwise, the output of the <code>Action</code>. <code>Any</code> <code>Predicate</code> The predicate to evaluate in order to trigger Action. <code>none</code> <code>Shard</code><code>[Shard]</code> <code>Action</code> The shards to activate on when Predicate is true for When and false for WhenNot. <code>none</code> <code>Shard</code><code>[Shard]</code> <code>Passthrough</code> The output of this shard will be its input. <code>true</code> <code>Bool</code> <p>Conditional shard that only executes the action if the predicate is false.</p>"},{"location":"reference/shards/shards/General/WhenNot/#examples","title":"Examples","text":"CodeOutput <pre><code>42\n(WhenNot\n ;:Predicate\n (IsMore 50)\n ;:Action\n (Msg \"Less than 50\"))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/General/WireRunner/","title":"WireRunner","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Any</code> <code>&lt;output&gt;</code> <code>Any</code> <code>Wire</code> The wire variable to compose and run. <code>none</code> <code>Wire</code><code>Var(Wire)</code> <code>Mode</code> The way to run the wire. Inline: will run the sub wire inline within the root wire, a pause in the child wire will pause the root too; Detached: will run the wire separately in the same mesh, a pause in this wire will not pause the root; Stepped: the wire will run as a child, the root will tick the wire every activation of this shard and so a child pause won't pause the root. <code>Enum: 0 vendor: 0x66726167 type: 0x72756e43</code> <code>RunWireMode</code>"},{"location":"reference/shards/shards/General/WriteFile/","title":"WriteFile","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Any</code> <code>&lt;output&gt;</code> <code>Any</code> <code>Filename</code> The file to write to. <code>none</code> <code>String</code><code>Var(String)</code> <code>Append</code> If we should append to the file if existed already or truncate. (default: false). <code>none</code> <code>Bool</code> <code>Flush</code> If the file should be flushed to disk after every write. <code>none</code> <code>Bool</code>"},{"location":"reference/shards/shards/General/WritePNG/","title":"WritePNG","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Image</code> <code>&lt;output&gt;</code> <code>Bytes</code><code>Image</code> <code>File</code> The file to write the image to <code>none</code> <code>String</code><code>Var(String)</code>"},{"location":"reference/shards/shards/General/Zip/","title":"Zip","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>&lt;output&gt;</code> <code>[{Any}]</code><code>[[Any]]</code> <code>Sequences</code> The sequences to zip together. <code>none</code> <code>[[Any] Var([Any])]</code> <code>Keys</code> The element keys to user. <code>none</code> <code>[String]</code> <p>Zip will take any number of sequences and return a sequence of sequences, where each sequence is a tuple of the values from the input sequences at the same index.</p> <p> </p>"},{"location":"reference/shards/shards/General/_ExportStrings/","title":"_ExportStrings","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>&lt;output&gt;</code> <code>[Any]</code>"},{"location":"reference/shards/shards/Gizmos/Arrow/","title":"Gizmos.Arrow","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>[Float4](4)</code> <code>&lt;output&gt;</code> <code>BodyColor</code> The color of the arrow <code>@f4(1 1 1 1)</code> <code>Float4</code><code>Var(Float4)</code> <code>CapColor</code> The color of the arrow <code>@f4(1 1 1 1)</code> <code>Float4</code><code>Var(Float4)</code> <p>Shows an arrow</p> <p> </p>"},{"location":"reference/shards/shards/Gizmos/Box/","title":"Gizmos.Box","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Any</code> <code>&lt;output&gt;</code> <code>Center</code> Center of the box <code>none</code> <code>Float3</code><code>Var(Float3)</code> <code>Size</code> Size of the box <code>none</code> <code>Float3</code><code>Var(Float3)</code> <code>Transform</code> Transform applied to the box <code>none</code> <code>[Float4](4)</code><code>Var([Float4](4))</code> <code>Color</code> Boxar color of the box <code>none</code> <code>Float4</code><code>Var(Float4)</code> <code>Thickness</code> Width of the box in screen space <code>none</code> <code>Int</code><code>Float</code> <p>Draws a box in 3d space</p> <p> </p>"},{"location":"reference/shards/shards/Gizmos/Circle/","title":"Gizmos.Circle","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Any</code> <code>&lt;output&gt;</code> <code>Center</code> Center of the circle <code>none</code> <code>Float3</code><code>Var(Float3)</code> <code>XBase</code> X direction of the plane the circle is on <code>none</code> <code>Float3</code><code>Var(Float3)</code> <code>YBase</code> Y direction of the plane the circle is on <code>none</code> <code>Float3</code><code>Var(Float3)</code> <code>Radius</code> Radius <code>none</code> <code>Float</code><code>Var(Float)</code> <code>Color</code> Linear color of the circle <code>none</code> <code>Float4</code><code>Var(Float4)</code> <code>Thickness</code> Width of the circle in screen space <code>none</code> <code>Int</code><code>Float</code> <p>Draws a line in 3d space</p> <p> </p>"},{"location":"reference/shards/shards/Gizmos/Context/","title":"Gizmos.Context","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Any</code> <code>&lt;output&gt;</code> <code>Any</code> <code>View</code> The view used to render the gizmos.When drawing over a scene, the view should be the same. <code>none</code> <code>Var(GFX.View)</code> <code>ViewSize</code> The size of the view <code>none</code> <code>Int2</code><code>Var(Int2)</code> <code>Queue</code> The queue to draw into. <code>none</code> <code>Var(GFX.DrawQueue)</code> <code>Contents</code> Actual logic to draw the actual gizmos, the input of this flow will be a boolean that will be true if the gizmo is being pressed and so edited. <code>none</code> <code>Shard</code><code>[Shard]</code> <code>Scaling</code> The scaling factor for gizmo elements. <code>none</code> <code>Float</code><code>Var(Float)</code> <code>Interactive</code> Used to togle gizmo interactions on/off. <code>none</code> <code>Var(Bool)</code> <p>Provides a context for rendering gizmos</p> <p> </p>"},{"location":"reference/shards/shards/Gizmos/Debug/","title":"Gizmos.Debug","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Any</code> <code>&lt;output&gt;</code> <code>Any</code> <p>Shows the renderer debug visuals</p> <p> </p>"},{"location":"reference/shards/shards/Gizmos/Disc/","title":"Gizmos.Disc","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Any</code> <code>&lt;output&gt;</code> <code>Center</code> Center of the disc <code>none</code> <code>Float3</code><code>Var(Float3)</code> <code>XBase</code> X direction of the plane the disc is on <code>none</code> <code>Float3</code><code>Var(Float3)</code> <code>YBase</code> Y direction of the plane the disc is on <code>none</code> <code>Float3</code><code>Var(Float3)</code> <code>OuterRadius</code> Radius of the outer circle of the disc <code>none</code> <code>Float</code><code>Var(Float)</code> <code>InnerRadius</code> Radius of the inner circle of the disc <code>none</code> <code>Float</code><code>Var(Float)</code> <code>Color</code> Linear color of the disc <code>none</code> <code>Float4</code><code>Var(Float4)</code> <code>Culling</code> Back-face culling of the disc <code>none</code> <code>Bool</code><code>Var(Bool)</code> <p>Draws a filled disc in 3d space</p> <p> </p>"},{"location":"reference/shards/shards/Gizmos/Grid/","title":"Gizmos.Grid","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Any</code> <code>&lt;output&gt;</code> <code>Center</code> Center of the disc <code>none</code> <code>Float3</code><code>Var(Float3)</code> <code>XBase</code> X direction of the grid <code>none</code> <code>Float3</code><code>Var(Float3)</code> <code>YBase</code> Y direction of the grid <code>none</code> <code>Float3</code><code>Var(Float3)</code> <code>Thickness</code> Width of the line in screen space <code>none</code> <code>Int</code><code>Float</code> <code>StepSize</code> Step size of the grid lines <code>none</code> <code>Float</code><code>Var(Float)</code> <code>Size</code> Number of grid lines <code>none</code> <code>Int</code><code>Var(Int)</code> <code>Color</code> Linear color of the grid lines <code>none</code> <code>Float4</code><code>Var(Float4)</code> <p>Draws a grid</p> <p> </p>"},{"location":"reference/shards/shards/Gizmos/Highlight/","title":"Gizmos.Highlight","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>GFX.Drawable</code><code>[GFX.Drawable]</code> <code>&lt;output&gt;</code> <code>Color</code> Color to render wireframe at <code>@f4(1 0 0 1)</code> <code>Float4</code> <p>Queues a draw operation to highlight a drawable</p> <p> </p>"},{"location":"reference/shards/shards/Gizmos/Line/","title":"Gizmos.Line","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Any</code> <code>&lt;output&gt;</code> <code>A</code> Starting position of the line <code>none</code> <code>Float3</code><code>Var(Float3)</code> <code>B</code> Ending position of the line <code>none</code> <code>Float3</code><code>Var(Float3)</code> <code>Color</code> Linear color of the line <code>none</code> <code>Float4</code><code>Var(Float4)</code> <code>Thickness</code> Width of the line in screen space <code>none</code> <code>Int</code><code>Float</code> <p>Draws a line in 3d space</p> <p> </p>"},{"location":"reference/shards/shards/Gizmos/Point/","title":"Gizmos.Point","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Any</code> <code>&lt;output&gt;</code> <code>Center</code> Center of the point <code>none</code> <code>Float3</code><code>Var(Float3)</code> <code>Color</code> Pointar color of the point <code>none</code> <code>Float4</code><code>Var(Float4)</code> <code>Thickness</code> Size of the point in screen space <code>none</code> <code>Int</code><code>Float</code> <p>Draws a point in 3d space</p> <p> </p>"},{"location":"reference/shards/shards/Gizmos/Rect/","title":"Gizmos.Rect","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Any</code> <code>&lt;output&gt;</code> <code>Center</code> Starting position of the rectangle <code>none</code> <code>Float3</code><code>Var(Float3)</code> <code>XBase</code> X direction of the plane the rectangle is on <code>none</code> <code>Float3</code><code>Var(Float3)</code> <code>YBase</code> Y direction of the plane the rectangle is on <code>none</code> <code>Float3</code><code>Var(Float3)</code> <code>Size</code> Size of the rectangle <code>none</code> <code>Float2</code><code>Var(Float2)</code> <code>Color</code> Linear color of the rectangle <code>none</code> <code>Float4</code><code>Var(Float4)</code> <code>Thickness</code> Width of the rectangle in screen space <code>none</code> <code>Int</code><code>Float</code> <p>Draws a rectangle in 3d space</p> <p> </p>"},{"location":"reference/shards/shards/Gizmos/RefspaceGridOverlay/","title":"Gizmos.RefspaceGridOverlay","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Any</code> <code>&lt;output&gt;</code> <code>Center</code> Center of the disc <code>none</code> <code>Float3</code><code>Var(Float3)</code> <code>XBase</code> X direction of the plane the disc is on <code>none</code> <code>Float3</code><code>Var(Float3)</code> <code>YBase</code> Y direction of the plane the disc is on <code>none</code> <code>Float3</code><code>Var(Float3)</code> <code>Thickness</code> Width of the line in screen space <code>none</code> <code>Int</code><code>Float</code> <code>StepSize</code> Step size of the grid lines <code>none</code> <code>Float</code><code>Var(Float)</code> <code>Color</code> Linear color of the grid lines <code>none</code> <code>Float4</code><code>Var(Float4)</code> <p>Draws a grid</p> <p> </p>"},{"location":"reference/shards/shards/Gizmos/Rotation/","title":"Gizmos.Rotation","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>{translation: Float3 rotation: Float4 scale: Float3}</code><code>[{translation: Float3 rotation: Float4 scale: Float3}]</code> <code>&lt;output&gt;</code> <code>{translation: Float3 rotation: Float4 scale: Float3}</code><code>[{translation: Float3 rotation: Float4 scale: Float3}]</code> <code>ScreenSize</code> Size of the gizmo on screen (UI size) <code>none</code> <code>Float</code><code>Var(Float)</code> <p>Shows a rotation gizmo</p> <p> </p>"},{"location":"reference/shards/shards/Gizmos/Scaling/","title":"Gizmos.Scaling","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>{translation: Float3 rotation: Float4 scale: Float3}</code><code>[{translation: Float3 rotation: Float4 scale: Float3}]</code> <code>&lt;output&gt;</code> <code>{translation: Float3 rotation: Float4 scale: Float3}</code><code>[{translation: Float3 rotation: Float4 scale: Float3}]</code> <code>ScreenSize</code> Size of the gizmo on screen (UI size) <code>none</code> <code>Float</code><code>Var(Float)</code> <p>Shows a scaling gizmo</p> <p> </p>"},{"location":"reference/shards/shards/Gizmos/ScreenScale/","title":"Gizmos.ScreenScale","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Float</code> <code>&lt;output&gt;</code> <code>Float</code> <code>Position</code> The point in space at which the object is rendered <code>none</code> <code>Float3</code><code>Var(Float3)</code> <p>Outputs a scaling factor to give an object a uniform size on the screen</p> <p> </p>"},{"location":"reference/shards/shards/Gizmos/ScreenXY/","title":"Gizmos.ScreenXY","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>&lt;output&gt;</code> <code>[Float3]</code> <p>Outputs an X and Y direction that are aligned with the current view</p> <p> </p>"},{"location":"reference/shards/shards/Gizmos/SolidRect/","title":"Gizmos.SolidRect","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Any</code> <code>&lt;output&gt;</code> <code>Center</code> Starting position of the rectangle <code>none</code> <code>Float3</code><code>Var(Float3)</code> <code>XBase</code> X direction of the plane the rectangle is on <code>none</code> <code>Float3</code><code>Var(Float3)</code> <code>YBase</code> Y direction of the plane the rectangle is on <code>none</code> <code>Float3</code><code>Var(Float3)</code> <code>Size</code> Size of the rectange <code>none</code> <code>Float2</code><code>Var(Float2)</code> <code>Color</code> Rectanglear color of the rectangle <code>none</code> <code>Float4</code><code>Var(Float4)</code> <code>Culling</code> Back-face culling of the rectangle <code>none</code> <code>Bool</code><code>Var(Bool)</code> <p>Draws a filled rectangle in 3d space</p> <p> </p>"},{"location":"reference/shards/shards/Gizmos/Translation/","title":"Gizmos.Translation","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>{translation: Float3 rotation: Float4 scale: Float3}</code><code>[{translation: Float3 rotation: Float4 scale: Float3}]</code> <code>&lt;output&gt;</code> <code>{translation: Float3 rotation: Float4 scale: Float3}</code><code>[{translation: Float3 rotation: Float4 scale: Float3}]</code> <code>ScreenSize</code> Size of the gizmo on screen (UI size) <code>none</code> <code>Float</code><code>Var(Float)</code> <p>Shows a translation gizmo</p> <p> </p>"},{"location":"reference/shards/shards/Hash/Blake2-128/","title":"Hash.Blake2-128","text":"Name - Description Default Type <code>&lt;input&gt;</code> The string, bytes or a sequence of strings/bytes to hash. <code>Bytes</code><code>[Bytes]</code><code>String</code><code>[String]</code> <code>&lt;output&gt;</code> Outputs the 128-bit hash as a byte array. <code>Bytes</code> <p>This shard outputs the compact 128-bit hash(of 16 bytes) of the input (string, bytes or a sequence of strings/bytes) using the BLAKE2b-128 hashing algorithm.</p> <p> </p>"},{"location":"reference/shards/shards/Hash/Blake2-256/","title":"Hash.Blake2-256","text":"Name - Description Default Type <code>&lt;input&gt;</code> The string, bytes or a sequence of strings/bytes to hash. <code>Bytes</code><code>[Bytes]</code><code>String</code><code>[String]</code> <code>&lt;output&gt;</code> Outputs the 256-bit hash as a byte array. <code>Bytes</code> <p>This shard outputs the 256-bit hash(of 32 bytes) of the input (string, bytes or a sequence of strings/bytes) using the BLAKE2b-256 hashing algorithm.</p> <p> </p>"},{"location":"reference/shards/shards/Hash/Keccak-256/","title":"Hash.Keccak-256","text":"Name - Description Default Type <code>&lt;input&gt;</code> The string, bytes or a sequence of strings/bytes to hash. <code>Bytes</code><code>[Bytes]</code><code>String</code><code>[String]</code> <code>&lt;output&gt;</code> Outputs the 256-bit hash as a byte array. <code>Bytes</code> <p>This shard outputs the 256-bit hash (32-bytes) of the input (string, bytes or a sequence of strings/bytes) using the Keccak-256 hashing algorithm.</p> <p> </p>"},{"location":"reference/shards/shards/Hash/Keccak-512/","title":"Hash.Keccak-512","text":"Name - Description Default Type <code>&lt;input&gt;</code> The string, bytes or a sequence of strings/bytes to hash. <code>Bytes</code><code>[Bytes]</code><code>String</code><code>[String]</code> <code>&lt;output&gt;</code> Outputs the 512-bit hash as a byte array. <code>Bytes</code> <p>This shard outputs the 512-bit hash (64-bytes) of the input (string, bytes or a sequence of strings/bytes) using the Keccak-512 hashing algorithm.</p> <p> </p>"},{"location":"reference/shards/shards/Hash/Sha2-256/","title":"Hash.Sha2-256","text":"Name - Description Default Type <code>&lt;input&gt;</code> The string, bytes or a sequence of strings/bytes to hash. <code>Bytes</code><code>[Bytes]</code><code>String</code><code>[String]</code> <code>&lt;output&gt;</code> Outputs the 256-bit hash as a byte array. <code>Bytes</code> <p>This shard outputs the 256-bit hash (32-bytes) of the input (string, bytes or a sequence of strings/bytes) using the Keccak-256 hashing algorithm.</p> <p> </p>"},{"location":"reference/shards/shards/Hash/Sha2-512/","title":"Hash.Sha2-512","text":"Name - Description Default Type <code>&lt;input&gt;</code> The string, bytes or a sequence of strings/bytes to hash. <code>Bytes</code><code>[Bytes]</code><code>String</code><code>[String]</code> <code>&lt;output&gt;</code> Outputs the 512-bit hash as a byte array. <code>Bytes</code> <p>This shard outputs the 512-bit hash (64-bytes) of the input (string, bytes or a sequence of strings/bytes) using the SHA2-512 hashing algorithm.</p> <p> </p>"},{"location":"reference/shards/shards/Hash/Sha3-256/","title":"Hash.Sha3-256","text":"Name - Description Default Type <code>&lt;input&gt;</code> The string, bytes or a sequence of strings/bytes to hash. <code>Bytes</code><code>[Bytes]</code><code>String</code><code>[String]</code> <code>&lt;output&gt;</code> Outputs the 256-bit hash as a byte array. <code>Bytes</code> <p>This shard outputs the 256-bit hash (32-bytes) of the input (string, bytes or a sequence of strings/bytes) using the SHA3-256 hashing algorithm.</p> <p> </p>"},{"location":"reference/shards/shards/Hash/Sha3-512/","title":"Hash.Sha3-512","text":"Name - Description Default Type <code>&lt;input&gt;</code> The string, bytes or a sequence of strings/bytes to hash. <code>Bytes</code><code>[Bytes]</code><code>String</code><code>[String]</code> <code>&lt;output&gt;</code> Outputs the 512-bit hash as a byte array. <code>Bytes</code> <p>This shard outputs the 512-bit hash (64-bytes) of the input (string, bytes or a sequence of strings/bytes) using the SHA3-512 hashing algorithm.</p> <p> </p>"},{"location":"reference/shards/shards/Hash/XXH-128/","title":"Hash.XXH-128","text":"Name - Description Default Type <code>&lt;input&gt;</code> The string, bytes or a sequence of strings/bytes to hash. <code>Bytes</code><code>[Bytes]</code><code>String</code><code>[String]</code> <code>&lt;output&gt;</code> Outputs the 128-bit hash as a byte array. <code>Bytes</code> <p>This shard outputs the 128-bit hash(of 16 bytes) of the input (string, bytes or a sequence of strings/bytes) using the XXH128 hashing algorithm.</p> <p> </p>"},{"location":"reference/shards/shards/Hash/XXH-64/","title":"Hash.XXH-64","text":"Name - Description Default Type <code>&lt;input&gt;</code> The string, bytes or a sequence of strings/bytes to hash. <code>Bytes</code><code>[Bytes]</code><code>String</code><code>[String]</code> <code>&lt;output&gt;</code> Outputs the 64-bit hash as a byte array. <code>Bytes</code> <p>This shard outputs the 64-bit hash(of 8 bytes) of the input (string, bytes or a sequence of strings/bytes) using the XXH64 hashing algorithm.</p> <p> </p>"},{"location":"reference/shards/shards/Hash/XXH3-128/","title":"Hash.XXH3-128","text":"Name - Description Default Type <code>&lt;input&gt;</code> The string, bytes or a sequence of strings/bytes to hash. <code>Bytes</code><code>[Bytes]</code><code>String</code><code>[String]</code> <code>&lt;output&gt;</code> Outputs the 128-bit hash as a byte array. <code>Bytes</code> <p>This shard outputs the 128-bit hash(of 16 bytes) of the input (string, bytes or a sequence of strings/bytes) using the XXH3(128-bit) hashing algorithm.</p> <p> </p>"},{"location":"reference/shards/shards/Hash/XXH3-64/","title":"Hash.XXH3-64","text":"Name - Description Default Type <code>&lt;input&gt;</code> The string, bytes or a sequence of strings/bytes to hash. <code>Bytes</code><code>[Bytes]</code><code>String</code><code>[String]</code> <code>&lt;output&gt;</code> Outputs the 64-bit hash as a byte array. <code>Bytes</code> <p>This shard outputs the 64-bit hash(of 8 bytes) of the input (string, bytes or a sequence of strings/bytes) using the XXH3(64-bit) hashing algorithm.</p> <p> </p>"},{"location":"reference/shards/shards/Http/Chunk/","title":"Http.Chunk","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input to the chunk shard is the data (String or Bytes) to be sent in the current chunk. This data is part of a larger response that will be sent in multiple chunks if necessary. <code>String</code><code>Bytes</code> <code>&lt;output&gt;</code> The output is the same as the input. The chunked transfer encoding is handled internally when writing to the socket. <code>String</code><code>Bytes</code> <code>Status</code> The HTTP status code to return. <code>200</code> <code>Int</code> <code>Headers</code> The headers to attach to this response. <code>none</code> <code>{String}</code><code>Var({String})</code> <p>This shard processes and packages outgoing Http response date into smaller manageable pieces and subsequently writes them to the socket while managing the chunked transfer encoding process.</p> <p> </p>"},{"location":"reference/shards/shards/Http/Delete/","title":"Http.Delete","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input for this shard should either be none, string, bytes, or string table to send in the body of the DELETE request. <code>{String}</code><code>Bytes</code><code>String</code> <code>&lt;output&gt;</code> The output is the response from the server through the DELETE request as a string, byte array, or table (if the FullResponse parameter is set to true). <code>{status: Int headers: {String} body: Bytes}</code><code>Bytes</code><code>{status: Int headers: {String} body: String}</code><code>String</code><code>Object</code> <code>URL</code> The url to request to. <code>\"\"</code> <code>String</code><code>Var(String)</code> <code>Headers</code> If a table of headers is provided, it will be used as is; if no headers are provided, a Content-Type header will be derived based on the input type. <code>none</code> <code>{String}</code><code>Var({String})</code> <code>Timeout</code> How many seconds to wait for the request to complete. <code>10</code> <code>Int</code> <code>Bytes</code> If instead of a string the shard should output bytes. <code>false</code> <code>Bool</code> <code>FullResponse</code> If the output should be a table with the full response, including headers and status. <code>false</code> <code>Bool</code> <code>AcceptInvalidCerts</code> If we should ignore invalid certificates. This is useful for testing but should not be used in production. <code>false</code> <code>Bool</code> <code>Retry</code> How many times to retry the request if it fails. <code>0</code> <code>Int</code> <code>KeepAlive</code> If the client instance should be kept alive, allowing connection reuse for multiple requests. The client won't be closed until this shard cleans up. <code>false</code> <code>Bool</code> <code>Streaming</code> If the response should be streamed, in which case the output will be an object to use with the Http.Stream shard. <code>false</code> <code>Bool</code> <p>This shard sends a HTTP DELETE request to the specified URL and outputs the response.</p> <p> </p>"},{"location":"reference/shards/shards/Http/Get/","title":"Http.Get","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input for this shard should either be none or an optional string table of query parameters to append to the URL. <code>{String}</code> <code>&lt;output&gt;</code> The output is the response from the server through the GET request. <code>{status: Int headers: {String} body: Bytes}</code><code>Bytes</code><code>{status: Int headers: {String} body: String}</code><code>String</code><code>Object</code> <code>URL</code> The url to request to. <code>\"\"</code> <code>String</code><code>Var(String)</code> <code>Headers</code> If a table of headers is provided, it will be used as is; if no headers are provided, a Content-Type header will be derived based on the input type. <code>none</code> <code>{String}</code><code>Var({String})</code> <code>Timeout</code> How many seconds to wait for the request to complete. <code>10</code> <code>Int</code> <code>Bytes</code> If instead of a string the shard should output bytes. <code>false</code> <code>Bool</code> <code>FullResponse</code> If the output should be a table with the full response, including headers and status. <code>false</code> <code>Bool</code> <code>AcceptInvalidCerts</code> If we should ignore invalid certificates. This is useful for testing but should not be used in production. <code>false</code> <code>Bool</code> <code>Retry</code> How many times to retry the request if it fails. <code>0</code> <code>Int</code> <code>KeepAlive</code> If the client instance should be kept alive, allowing connection reuse for multiple requests. The client won't be closed until this shard cleans up. <code>false</code> <code>Bool</code> <code>Streaming</code> If the response should be streamed, in which case the output will be an object to use with the Http.Stream shard. <code>false</code> <code>Bool</code> <p>This shard sends a GET request to the specified URL and outputs the response.</p> <p> </p>"},{"location":"reference/shards/shards/Http/Head/","title":"Http.Head","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input for this shard should either be none or an optional string table of query parameters to append to the URL. <code>{String}</code> <code>&lt;output&gt;</code> The output is the headers of the response from the server through the HEAD request. <code>{status: Int headers: {String} body: Bytes}</code><code>Bytes</code><code>{status: Int headers: {String} body: String}</code><code>String</code><code>Object</code> <code>URL</code> The url to request to. <code>\"\"</code> <code>String</code><code>Var(String)</code> <code>Headers</code> If a table of headers is provided, it will be used as is; if no headers are provided, a Content-Type header will be derived based on the input type. <code>none</code> <code>{String}</code><code>Var({String})</code> <code>Timeout</code> How many seconds to wait for the request to complete. <code>10</code> <code>Int</code> <code>Bytes</code> If instead of a string the shard should output bytes. <code>false</code> <code>Bool</code> <code>FullResponse</code> If the output should be a table with the full response, including headers and status. <code>false</code> <code>Bool</code> <code>AcceptInvalidCerts</code> If we should ignore invalid certificates. This is useful for testing but should not be used in production. <code>false</code> <code>Bool</code> <code>Retry</code> How many times to retry the request if it fails. <code>0</code> <code>Int</code> <code>KeepAlive</code> If the client instance should be kept alive, allowing connection reuse for multiple requests. The client won't be closed until this shard cleans up. <code>false</code> <code>Bool</code> <code>Streaming</code> If the response should be streamed, in which case the output will be an object to use with the Http.Stream shard. <code>false</code> <code>Bool</code> <p>This shard sends a HEAD request to the specified URL and outputs the response.</p> <p> </p>"},{"location":"reference/shards/shards/Http/Patch/","title":"Http.Patch","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input for this shard should either be none, string, bytes, or string table to send in the body of the PATCH request. <code>{String}</code><code>Bytes</code><code>String</code> <code>&lt;output&gt;</code> The output is the response from the server through the PATCH request as a string, byte array, or table (if the FullResponse parameter is set to true). <code>{status: Int headers: {String} body: Bytes}</code><code>Bytes</code><code>{status: Int headers: {String} body: String}</code><code>String</code><code>Object</code> <code>URL</code> The url to request to. <code>\"\"</code> <code>String</code><code>Var(String)</code> <code>Headers</code> If a table of headers is provided, it will be used as is; if no headers are provided, a Content-Type header will be derived based on the input type. <code>none</code> <code>{String}</code><code>Var({String})</code> <code>Timeout</code> How many seconds to wait for the request to complete. <code>10</code> <code>Int</code> <code>Bytes</code> If instead of a string the shard should output bytes. <code>false</code> <code>Bool</code> <code>FullResponse</code> If the output should be a table with the full response, including headers and status. <code>false</code> <code>Bool</code> <code>AcceptInvalidCerts</code> If we should ignore invalid certificates. This is useful for testing but should not be used in production. <code>false</code> <code>Bool</code> <code>Retry</code> How many times to retry the request if it fails. <code>0</code> <code>Int</code> <code>KeepAlive</code> If the client instance should be kept alive, allowing connection reuse for multiple requests. The client won't be closed until this shard cleans up. <code>false</code> <code>Bool</code> <code>Streaming</code> If the response should be streamed, in which case the output will be an object to use with the Http.Stream shard. <code>false</code> <code>Bool</code> <p>This shard sends a HTTP PATCH request to the specified URL and outputs the response.</p> <p> </p>"},{"location":"reference/shards/shards/Http/Post/","title":"Http.Post","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input for this shard should either be none, string, bytes, or string table to send in the body of the POST request. <code>{String}</code><code>Bytes</code><code>String</code> <code>&lt;output&gt;</code> The output is the response from the server through the POST request as a string, byte array, or table (if the FullResponse parameter is set to true). <code>{status: Int headers: {String} body: Bytes}</code><code>Bytes</code><code>{status: Int headers: {String} body: String}</code><code>String</code><code>Object</code> <code>URL</code> The url to request to. <code>\"\"</code> <code>String</code><code>Var(String)</code> <code>Headers</code> If a table of headers is provided, it will be used as is; if no headers are provided, a Content-Type header will be derived based on the input type. <code>none</code> <code>{String}</code><code>Var({String})</code> <code>Timeout</code> How many seconds to wait for the request to complete. <code>10</code> <code>Int</code> <code>Bytes</code> If instead of a string the shard should output bytes. <code>false</code> <code>Bool</code> <code>FullResponse</code> If the output should be a table with the full response, including headers and status. <code>false</code> <code>Bool</code> <code>AcceptInvalidCerts</code> If we should ignore invalid certificates. This is useful for testing but should not be used in production. <code>false</code> <code>Bool</code> <code>Retry</code> How many times to retry the request if it fails. <code>0</code> <code>Int</code> <code>KeepAlive</code> If the client instance should be kept alive, allowing connection reuse for multiple requests. The client won't be closed until this shard cleans up. <code>false</code> <code>Bool</code> <code>Streaming</code> If the response should be streamed, in which case the output will be an object to use with the Http.Stream shard. <code>false</code> <code>Bool</code> <p>This shard sends a HTTP POST request to the specified URL and outputs the response.</p> <p> </p>"},{"location":"reference/shards/shards/Http/Put/","title":"Http.Put","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input for this shard should either be none, string, bytes, or string table to send in the body of the PUT request. <code>{String}</code><code>Bytes</code><code>String</code> <code>&lt;output&gt;</code> The output is the response from the server through the PUT request as a string, byte array, or table (if the FullResponse parameter is set to true). <code>{status: Int headers: {String} body: Bytes}</code><code>Bytes</code><code>{status: Int headers: {String} body: String}</code><code>String</code><code>Object</code> <code>URL</code> The url to request to. <code>\"\"</code> <code>String</code><code>Var(String)</code> <code>Headers</code> If a table of headers is provided, it will be used as is; if no headers are provided, a Content-Type header will be derived based on the input type. <code>none</code> <code>{String}</code><code>Var({String})</code> <code>Timeout</code> How many seconds to wait for the request to complete. <code>10</code> <code>Int</code> <code>Bytes</code> If instead of a string the shard should output bytes. <code>false</code> <code>Bool</code> <code>FullResponse</code> If the output should be a table with the full response, including headers and status. <code>false</code> <code>Bool</code> <code>AcceptInvalidCerts</code> If we should ignore invalid certificates. This is useful for testing but should not be used in production. <code>false</code> <code>Bool</code> <code>Retry</code> How many times to retry the request if it fails. <code>0</code> <code>Int</code> <code>KeepAlive</code> If the client instance should be kept alive, allowing connection reuse for multiple requests. The client won't be closed until this shard cleans up. <code>false</code> <code>Bool</code> <code>Streaming</code> If the response should be streamed, in which case the output will be an object to use with the Http.Stream shard. <code>false</code> <code>Bool</code> <p>This shard sends a HTTP PUT request to the specified URL and outputs the response.</p> <p> </p>"},{"location":"reference/shards/shards/Http/Read/","title":"Http.Read","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input of this shard is ignored. <code>&lt;output&gt;</code> The output is a table containing the HTTP request method, headers, target, and body. <code>{method: String headers: {String} target: String body: String}</code> <p>This shard reads incoming HTTP requests from a client connection, parses its components, and outputs them as a table. This shard should be used in conjunction with the Http.Server shard to handle incoming requests.</p> <p> </p>"},{"location":"reference/shards/shards/Http/Response/","title":"Http.Response","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input string or byte array will be used directly as the body of the response. <code>String</code><code>Bytes</code> <code>&lt;output&gt;</code> Outputs the input value, passed through unchanged. <code>String</code><code>Bytes</code> <code>Status</code> The HTTP status code to return. <code>200</code> <code>Int</code><code>Var(Int)</code> <code>Headers</code> The headers to attach to this response. <code>none</code> <code>{String}</code><code>Var({String})</code> <code>ContentType</code> The content type of the response. <code>\"application/json\"</code> <code>String</code><code>Var(String)</code> <p>This shard sends an HTTP response to the client after receiving an HTTP request.</p> <p> </p>"},{"location":"reference/shards/shards/Http/SendFile/","title":"Http.SendFile","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input for this shard should be a string representing the path to the file to be sent. <code>String</code> <code>&lt;output&gt;</code> Outputs the input value, passed through unchanged. <code>String</code> <code>Headers</code> The headers to attach to this response. <code>none</code> <code>{String}</code><code>Var({String})</code> <p>This shard sends a static file to the client over HTTP.</p> <p> </p>"},{"location":"reference/shards/shards/Http/Server/","title":"Http.Server","text":"Name - Description Default Type <code>&lt;input&gt;</code> Any input type is accepted. The input value will pass through unchanged. <code>Any</code> <code>&lt;output&gt;</code> Outputs the input value, passed through unchanged. <code>Any</code> <code>Handler</code> The wire that will be spawned and handle a remote request. <code>none</code> <code>Wire</code> <code>Endpoint</code> The URL from where your service can be accessed by a client. <code>\"0.0.0.0\"</code> <code>String</code> <code>Port</code> The port this service will use. <code>7070</code> <code>Int</code> <p>This shard sets up an HTTP server that listens for incoming connections, creates new peers for each connection, and delegates request handling to the specified handler wire. It manages the lifecycle of connections and ensures proper cleanup when the server is stopped.</p> <p> </p>"},{"location":"reference/shards/shards/Http/Stream/","title":"Http.Stream","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>&lt;output&gt;</code> Bytes read from the stream. When the stream is exhausted, this will return an empty byte array. <code>Bytes</code> <code>Stream</code> The stream to read from. <code>none</code> <code>Var(Object)</code> <p>Reads data from a previously opened stream.</p> <p> </p>"},{"location":"reference/shards/shards/Inputs/DebugUI/","title":"Inputs.DebugUI","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Any</code> <code>&lt;output&gt;</code> <code>Any</code> <p>Shows the input system debug UI</p> <p> </p>"},{"location":"reference/shards/shards/Inputs/Detached/","title":"Inputs.Detached","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Any</code> <code>&lt;output&gt;</code> <code>Any</code> <code>Context</code> The window context to attach to <code>none</code> <code>Var(Object)</code> <code>Input</code> Runs detached on the input loop <code>none</code> <code>Wire</code><code>[Shard]</code> <code>Then</code> Runs inline after data has been output from the Input callback <code>none</code> <code>Shard</code><code>[Shard]</code> <code>Priority</code> The order in which this input handler is run <code>0</code> <code>Int</code> <code>WindowRegion</code> Sets the window region for input handling. <code>none</code> <code>Int4</code><code>Var(Int4)</code> <code>Name</code> Name used for logging/debugging purposes <code>none</code> <code>String</code> <p>Runs the contents on the input thread, and it's continuation on the current thread with the last data from the input thread</p> <p> </p>"},{"location":"reference/shards/shards/Inputs/GetContext/","title":"Inputs.GetContext","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input of this shard is ignored. <code>&lt;output&gt;</code> Outputs the current window context. <code>Object</code> <p>This shard obtains the current window context and makes the information (window size, current time since application started, delta time since last frame, input events etc.) available to the rest of the Shards program.</p> <p> </p>"},{"location":"reference/shards/shards/Inputs/HandleURL/","title":"Inputs.HandleURL","text":"Name - Description Default Type <code>&lt;input&gt;</code> Any input type is accepted. The input value will pass through unchanged. <code>&lt;output&gt;</code> Outputs the input value, passed through unchanged. <code>Any</code> <code>Action</code> Code to execute when a file drop event or URL event is received. <code>none</code> <code>Shard</code><code>[Shard]</code> <p>This shard listens to file drop events and URL events. When files are dropped onto the application or URLs events are received, this shard executes the specified Action for each file dropped or URL event received. The file path or URL is then passed as a string to the Action.</p> <p> </p>"},{"location":"reference/shards/shards/Inputs/IsKeyDown/","title":"Inputs.IsKeyDown","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input of this shard is ignored. <code>&lt;output&gt;</code> Outputs a boolean value indicating whether the specified key is currently pressed down. <code>Bool</code> <code>Key</code> The key to check. <code>\"\"</code> <code>String</code> <p>This shard outputs true if the key specified is currently pressed down, and false otherwise.</p> <p> </p>"},{"location":"reference/shards/shards/Inputs/KeyDown/","title":"Inputs.KeyDown","text":"Name - Description Default Type <code>&lt;input&gt;</code> Input of any type is accepted. The input is passed as input to the code specified in the Action parameter. <code>Any</code> <code>&lt;output&gt;</code> Outputs the input value, passed through unchanged. <code>Any</code> <code>Key</code> The key to check. <code>none</code> <code>String</code> <code>Action</code> The code to run if the key event happened. <code>none</code> <code>Shard</code><code>[Shard]</code> <code>Repeat</code> If set to true, the event specified in the Action parameter will be repeated if the key is held down. Otherwise, the event will be executed only on the frame the key is pressed down. <code>false</code> <code>Bool</code> <code>Modifiers</code> Modifier keys to check for such as \"leftctrl\", \"leftshift\", \"leftalt\", \"rightctrl\", \"rightshift\", \"rightalt\", etc. <code>none</code> <code>[ModifierKey]</code> <code>Consume</code> If set to true, this event will be consumed. Meaning, if there was a previous shard with \"Consume\" set to true, all subsequent calls of the same shard with the same key specified will not activate. <code>true</code> <code>Bool</code> <code>SkipConsumed</code> If true, skips events already consumed by previous shards. If false, processes all events regardless of their consumed state. <code>true</code> <code>Bool</code> <p>This shard checks if the key specified is pressed down. If the key is pressed down, the shard executes the code specified in the Action parameter on the frame the key is pressed down. If the Repeat parameter is set to true, the code specified in the Action parameter will be repeated every frame the key is held down instead.</p> <p> </p>"},{"location":"reference/shards/shards/Inputs/KeyUp/","title":"Inputs.KeyUp","text":"Name - Description Default Type <code>&lt;input&gt;</code> Input of any type is accepted. The input is passed as input to the code specified in the Action parameter. <code>Any</code> <code>&lt;output&gt;</code> Outputs the input value, passed through unchanged. <code>Any</code> <code>Key</code> The key to check. <code>none</code> <code>String</code> <code>Action</code> The code to run if the key event happened. <code>none</code> <code>Shard</code><code>[Shard]</code> <code>Repeat</code> This parameter is ignored for Inputs.KeyUp. <code>false</code> <code>Bool</code> <code>Modifiers</code> Modifier keys to check for such as \"leftctrl\", \"leftshift\", \"leftalt\", \"rightctrl\", \"rightshift\", \"rightalt\", etc. <code>none</code> <code>[ModifierKey]</code> <code>Consume</code> If set to true, this event will be consumed. Meaning, if there was a previous shard with \"Consume\" set to true, all subsequent calls of the same shard with the same key specified will not activate. <code>true</code> <code>Bool</code> <code>SkipConsumed</code> If true, skips events already consumed by previous shards. If false, processes all events regardless of their consumed state. <code>true</code> <code>Bool</code> <p>This shard checks if the key specified is released. If the key is released, the shard executes the code specified in the Action parameter on the frame the key is released.</p> <p> </p>"},{"location":"reference/shards/shards/Inputs/MatchModifier/","title":"Inputs.MatchModifier","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input of this shard is ignored. <code>&lt;output&gt;</code> Outputs a boolean value: true if any of the specified modifier keys are currently pressed down and false otherwise. <code>Bool</code> <code>Modifiers</code> Sequence of Modifier keys to check for such as Modifier::Shift, Modifier::Alt, Modifier::Primary and Modifier::Secondary. <code>none</code> <code>[ModifierKey]</code> <p>This shard outputs true if any of the modifier keys in the sequence provided in the Modifier parameter are currently pressed down, and false otherwise.</p> <p> </p>"},{"location":"reference/shards/shards/Inputs/Mouse/","title":"Inputs.Mouse","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Any</code> <code>&lt;output&gt;</code> <code>Any</code> <code>Hidden</code> If the cursor should be hidden. <code>false</code> <code>Bool</code> <code>Capture</code> If the mouse should be confined to the application window. <code>false</code> <code>Bool</code> <code>Relative</code> If the mouse should only report relative movements. <code>false</code> <code>Bool</code>"},{"location":"reference/shards/shards/Inputs/MouseDelta/","title":"Inputs.MouseDelta","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input of this shard is ignored. <code>&lt;output&gt;</code> Outputs how much the mouse has moved since the last frame, represented as a vector with 2 float elements. <code>Float2</code> <p>This shard outputs how much the mouse has moved since the last frame as a float2 vector. The first element represents the horizontal movement (a positive value indicates movement to the right), and the second element represents the vertical movement (a positive value indicates movement downwards).</p> <p> </p>"},{"location":"reference/shards/shards/Inputs/MouseDown/","title":"Inputs.MouseDown","text":"Name - Description Default Type <code>&lt;input&gt;</code> Input of any type is accepted. The input is passed as input to the code specified in the Action parameter. <code>Any</code> <code>&lt;output&gt;</code> Outputs the input value, passed through unchanged. <code>Any</code> <code>Left</code> The action to perform when the left mouse button is pressed down. <code>none</code> <code>Shard</code><code>[Shard]</code> <code>Right</code> The action to perform when the right mouse button is pressed down. <code>none</code> <code>Shard</code><code>[Shard]</code> <code>Middle</code> The action to perform when the middle mouse button is pressed down. <code>none</code> <code>Shard</code><code>[Shard]</code> <code>Consume</code> If set to true, this event will be consumed. Meaning, if there was a previous shard with \"Consume\" set to true, all subsequent calls of the same shard with the same key specified will not activate. <code>true</code> <code>Bool</code> <code>SkipConsumed</code> If true, skips events already consumed by previous shards. If false, processes all events regardless of their consumed state. <code>true</code> <code>Bool</code> <p>Checks if the appropriate mouse button is pressed down. If it is pressed down, the shard executes the code specified in the respective parameter on the frame the button is pressed down. (If the Right Mouse button was pressed down, the code specified in the Right parameter will be executed.)</p> <p> </p>"},{"location":"reference/shards/shards/Inputs/MousePixelPos/","title":"Inputs.MousePixelPos","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input of this shard is ignored. <code>&lt;output&gt;</code> Outputs the pixel position of the cursor represented as a vector with 2 int elements. <code>Int2</code> <p>This shard outputs the current pixel position of the cursor within the input region, represented as an int2 vector. The first element represents the x position of the cursor, and the second element represents the y position of the cursor. The coordinates are in pixel space, with (0,0) being the top-left corner of the input region and (input-region-pixel-width, input-region-pixel-height) being the bottom-right corner.</p> <p> </p>"},{"location":"reference/shards/shards/Inputs/MousePos/","title":"Inputs.MousePos","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input of this shard is ignored. <code>&lt;output&gt;</code> Outputs the position of the cursor represented as a vector with 2 float elements. <code>Float2</code> <p>This shard outputs the current logical position of the cursor within the input region, represented as a float2 vector. The first element represents the x position of the cursor, and the second element represents the y position of the cursor. The coordinates are in the same space as the input region's size, with (0,0) being the top-left corner and (input-region-width,input-region-height) being the bottom-right corner.</p> <p> </p>"},{"location":"reference/shards/shards/Inputs/MouseUp/","title":"Inputs.MouseUp","text":"Name - Description Default Type <code>&lt;input&gt;</code> Input of any type is accepted. The input is passed as input to the code specified in the Action parameter. <code>Any</code> <code>&lt;output&gt;</code> Outputs the input value, passed through unchanged. <code>Any</code> <code>Left</code> The action to perform when the left mouse button is pressed down. <code>none</code> <code>Shard</code><code>[Shard]</code> <code>Right</code> The action to perform when the right mouse button is pressed down. <code>none</code> <code>Shard</code><code>[Shard]</code> <code>Middle</code> The action to perform when the middle mouse button is pressed down. <code>none</code> <code>Shard</code><code>[Shard]</code> <code>Consume</code> If set to true, this event will be consumed. Meaning, if there was a previous shard with \"Consume\" set to true, all subsequent calls of the same shard with the same key specified will not activate. <code>true</code> <code>Bool</code> <code>SkipConsumed</code> If true, skips events already consumed by previous shards. If false, processes all events regardless of their consumed state. <code>true</code> <code>Bool</code> <p>Checks if the appropriate mouse button is released. If it is released, the shard executes the code specified in the respective parameter on the frame the button is released.(If the Right Mouse button was released, the code specified in the Right parameter will be executed.)</p> <p> </p>"},{"location":"reference/shards/shards/Inputs/PixelSize/","title":"Inputs.PixelSize","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input of this shard is ignored. <code>&lt;output&gt;</code> Outputs the pixel size of the input region represented as a vector with two int elements. <code>Int2</code> <p>This shard outputs the pixel size of the input region represented as an int2 vector. The first element represents the width of the region, and the second element represents the height of the region.</p> <p> </p>"},{"location":"reference/shards/shards/Inputs/Size/","title":"Inputs.Size","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input of this shard is ignored. <code>&lt;output&gt;</code> Outputs the size of the input region represented as a vector with two float elements. <code>Float2</code> <p>This shard outputs the size of the input region represented as a float2 vector. The first element represents the width of the region, and the second element represents the height of the region.</p> <p> </p>"},{"location":"reference/shards/shards/ML/Detokenize/","title":"ML.Detokenize","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>[Int]</code><code>Tensor</code> <code>&lt;output&gt;</code> <code>String</code> <code>Tokenizer</code> The tokenizer to use for detokenization. <code>none</code> <code>Var(Tokenizer)</code> <code>SkipSpecialTokens</code> If true, skip special tokens during detokenization. <code>true</code> <code>Bool</code> <p>Converts token IDs or tensors back into text using a tokenizer.</p> <p> </p>"},{"location":"reference/shards/shards/ML/Forward/","title":"ML.Forward","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>[Tensor]</code> <code>&lt;output&gt;</code> <code>[Tensor]</code> <code>Model</code> The model to use. <code>none</code> <code>Var(Model)</code> <p>Forward a tensor through a model.</p> <p> </p>"},{"location":"reference/shards/shards/ML/Model/","title":"ML.Model","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Bytes</code> <code>&lt;output&gt;</code> <code>Model</code> <code>Model</code> The model to use. <code>none</code> <code>MLModels</code> <code>Format</code> The format of the model. <code>none</code> <code>MLFormats</code> <code>Configuration</code> The configuration of the model. <code>none</code> <code>{Any}</code><code>Var({Any})</code> <code>GPU</code> Whether to use the GPU (if available). <code>false</code> <code>Bool</code> <p>This shard allows you to load a machine learning model and specify its format and configuration.</p> <p> </p>"},{"location":"reference/shards/shards/ML/Tokenizer/","title":"ML.Tokenizer","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>String</code> <code>&lt;output&gt;</code> <code>Tokenizer</code> <p>Loads a tokenizer from an input json string, ready to be used for tokenizing text.</p> <p> </p>"},{"location":"reference/shards/shards/ML/Tokens/","title":"ML.Tokens","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>String</code> <code>&lt;output&gt;</code> <code>[Int]</code> <code>Tokenizer</code> The tokenizer to use. <code>none</code> <code>Var(Tokenizer)</code> <code>AddSpecialTokens</code> If true, add special tokens. <code>true</code> <code>Bool</code> <code>AsTensor</code> Outputs a tensor object instead of an int sequence. <code>false</code> <code>Bool</code> <code>Format</code> The format of the output tensor. If As Tensor is true. <code>TensorType::U32</code> <code>TensorType</code> <code>GPU</code> If true, the output tensor will be on the GPU (if ). <code>false</code> <code>Bool</code> <p>Tokenizes text using a tokenizer.</p> <p> </p>"},{"location":"reference/shards/shards/Markdown/Parse/","title":"Markdown.Parse","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>String</code> <code>&lt;output&gt;</code> <code>[String]</code> <code>Reset</code> Reset the parser <code>false</code> <code>Bool</code><code>Var(Bool)</code> <p>A markdown commonmark pull parser.</p> <p> </p>"},{"location":"reference/shards/shards/Math/Abs/","title":"Math.Abs","text":"Name - Description Default Type <code>&lt;input&gt;</code> The numeric value or a sequence of numeric values to get the absolute value of. <code>Int</code><code>Int2</code><code>Int3</code><code>Int4</code><code>Int8</code><code>Int16</code><code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <code>&lt;output&gt;</code> Outputs the absolute value of the input. <code>Int</code><code>Int2</code><code>Int3</code><code>Int4</code><code>Int8</code><code>Int16</code><code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <p>This shard outputs the absolute value of the input.</p>"},{"location":"reference/shards/shards/Math/Abs/#examples","title":"Examples","text":"CodeOutput <pre><code>(Const [-0.1 -0.2 0.4])\n(Math.Abs) (Log)\n\n(Assert.Is [0.1 0.2 0.4] true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/Math/Acos/","title":"Math.Acos","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input float or sequence of floats to calculate the inverse cosine of. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <code>&lt;output&gt;</code> Outputs the angle in radians whose cosine is the input value. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <p>This shard calculates the inverse cosine of the given input, where the input is the cosine value. The output is the angle in radians whose cosine is the input value.</p>"},{"location":"reference/shards/shards/Math/Acos/#examples","title":"Examples","text":"CodeOutput <pre><code>(float4 -1.0 0.0 0.5 1.0)\n(Math.Acos) (Log)\n\n(Math.Subtract (float4 3.1415927 1.5707963 1.0471976 0.0)) (Math.Abs)\n(IsLess (float4 1e-05 1e-05 1e-05 1e-05)) (Assert.Is true true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/Math/Acosh/","title":"Math.Acosh","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input float or sequence of floats to calculate the inverse hyperbolic cosine of. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <code>&lt;output&gt;</code> Outputs the real number whose hyperbolic cosine is the input value. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <p>This shard calculates the inverse hyperbolic cosine of the given input, where the input is the hyperbolic cosine value. The output is the real number whose hyperbolic cosine is the input value.</p>"},{"location":"reference/shards/shards/Math/Acosh/#examples","title":"Examples","text":"CodeOutput <pre><code>(float3 1.0 2.0 2.5)\n(Math.Acosh) (Log)\n\n(Math.Subtract (float3 0 1.3169578 1.5667992)) (Math.Abs)\n(IsLess (float3 1e-05 1e-05 1e-05)) (Assert.Is true true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/Math/Add/","title":"Math.Add","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value or the sequence of values to add the value specified in the Operand parameter to. <code>Int</code><code>Int2</code><code>Int3</code><code>Int4</code><code>Int8</code><code>Int16</code><code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <code>&lt;output&gt;</code> This shard outputs the result of the addition. <code>Int</code><code>Int2</code><code>Int3</code><code>Int4</code><code>Int8</code><code>Int16</code><code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <code>Operand</code> The value or sequence of values to add to the input. <code>0</code> <code>Int</code><code>Var(Int)</code><code>Int2</code><code>Var(Int2)</code><code>Int3</code><code>Var(Int3)</code><code>Int4</code><code>Var(Int4)</code><code>Int8</code><code>Var(Int8)</code><code>Int16</code><code>Var(Int16)</code><code>Float</code><code>Var(Float)</code><code>Float2</code><code>Var(Float2)</code><code>Float3</code><code>Var(Float3)</code><code>Float4</code><code>Var(Float4)</code><code>Color</code><code>Var(Color)</code><code>[Any]</code><code>Var([Any])</code> <p>This shard adds the input value to the value provided in the Operand parameter.</p>"},{"location":"reference/shards/shards/Math/Add/#details","title":"Details","text":"<p>Addition is a binary operation, i.e. it needs two arguments to give a result.</p> <p>The <code>Math.Add</code> shard takes in the Input and the parameter <code>:Operand</code> to produce the Output.</p> <p>Both Input and <code>:Operand</code> can be an integer, a float, or a sequence of such entities (but both value types should match for a given operation). The Output is generally of the same type as the Input provided to the shard.</p>"},{"location":"reference/shards/shards/Math/Add/#binary-operations-on-sequences","title":"Binary operations on sequences","text":"<p>Taking <code>Math.Add</code> operator as an example.</p> <p>If sequences are passed as arguments, the operator takes pairs of correspondingly placed elements from these sequences and computes the result for each pair. This gives rise to different scenarios.</p> <ol> <li> <p>Input and <code>:Operand</code> sequence sizes are equal</p> <p>Since each element in Input sequence has a corresponding element in <code>:Operand</code> sequence, the Output sequence also has the same number of resultant elements and hence the same size as the argument sequences.</p> Entity Sequence Seq. Size Input [a b c] 3 <code>:Operand</code> [1 2 3] 3 Output [(a+1) (b+2) (c+3)] 3 </li> <li> <p>Input sequence size &lt; <code>:Operand</code> sequence size</p> <p>Here a few <code>:Operand</code> elements (<code>:Operand</code> sequence size - Input sequence size) will have no Input elements to pair off with. These <code>:Operand</code> elements are ignored in the final Output. Hence the Output sequence size here will the same as the Input sequence size.</p> Entity Sequence Seq. Size Input [a b] 2 <code>:Operand</code> [1 2 3] 3 Output [(a+1) (b+2) (_+3)] =&gt; [(a+1) (b+2)] 2 </li> <li> <p>Input sequence size &gt; <code>:Operand</code> sequence size</p> <p>Once all the <code>:Operand</code> elements have been paired off and computed with the corresponding Input elements, the remaining Input elements (Input sequence size - <code>:Operand</code> sequence size) will continue looping over the <code>:Operand</code> sequence till all of the Input sequence elements have been used. As a result the Output sequence will again be the same size as the Input sequence.</p> Entity Sequence Seq. Size Input [a b c d e] 5 <code>:Operand</code> [1 2] 2 Output [(a+1) (b+2) (c+1) (d+2) (e+1)] 5 </li> </ol> <p>Note</p> <p>Such sequence operations are useful in transforming and translating 2D/3D grid values (a frequent requirement in graphics rendering). This is done by passing the transform inputs as an Input sequence (to be applied to every row/line for a 2D grid or to every 2D-matrix/plane for a 3D grid) of the 2D matrix and the <code>:Operand</code> sequence as the set of 2D/3D coordinates (represented linearly) that is to be transformed.</p>"},{"location":"reference/shards/shards/Math/Add/#examples","title":"Examples","text":"CodeOutput <pre><code>;; Add integers\n(int 5) ;; :Input\n(Log) ;; prints input =&gt; 5\n(Math.Add\n 2) ;; :Operand\n(Log) ;; prints input + operand =&gt; 7\n(Assert.Is 7 true) ;; expect: (5 + 2) =&gt; 7\n</code></pre> <pre><code>\n</code></pre> CodeOutput <pre><code>;; Add floats\n(float 5.3) ;; :Input\n(Log) ;; prints input =&gt; 5.3\n(Math.Add\n 2.1) ;; :Operand\n (Log) ;; prints input + operand =&gt; 7.4\n(Assert.Is 7.4 true) ;; expect: (5.3 + 2.1) =&gt; 7.4\n</code></pre> <pre><code>\n</code></pre> CodeOutput <pre><code>;; Add equal-sized sequences\n[4 5.1 6.4] ;; :Input\n(Log) ;; prints input =&gt; [4 5.1 6.4]\n(Math.Add\n [3 4.0 2.2]) ;; :Operand\n;; input seq elements compute with corresponding operand seq elements\n(Log) ;; prints input + operand =&gt; [7 9.1 8.6]\n(Assert.IsAlmost [7 9.1 8.6] true) ;; expect: [(4 + 3) (5.1 + 4.0) (6.4 + 2.2)] =&gt; [7 9.1 8.6]\n</code></pre> <pre><code>\n</code></pre> CodeOutput <pre><code>;; Add unequal-sized sequences (input size &lt; operand size)\n[4.0] ;; :Input\n(Log) ;; prints input =&gt; [4.0]\n(Math.Add\n [3.0 4.0 2.2]) ;; :Operand\n;; input seq elements compute with corresponding operand seq elements\n;; since input size &lt; operand size, remaining operand seq elements ignored\n(Log) ;; prints input + operand =&gt; [7.0]\n(Assert.Is [7.0] true) ;; expect: [(4.0 + 3.0) ... ... ] =&gt; [7.0]\n</code></pre> <pre><code>\n</code></pre> CodeOutput <pre><code>;; Add unequal-sized sequences (input size &gt; operand size)\n[4 2 1 5 8] ;; :Input\n(Log) ;; prints input =&gt; [4 2 1 5 8]\n(Math.Add\n [6 4]) ;; :Operand\n;; input seq elements compute with corresponding operand seq elements\n;; for (input size &gt; operand size): remaining input seq elements continually loop over operand seq elements\n(Log) ;; prints input + operand =&gt; [10 6 7 9 14]\n(Assert.Is [10 6 7 9 14] true) ;; expect: [(4 + 6) (2 + 4) (1 + 6) (5 + 4) (8 + 6)] =&gt; [10 6 7 9 14]\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/Math/And/","title":"Math.And","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value or the sequence of values to compare the value specified in the Operand parameter with. <code>Int</code><code>Int2</code><code>Int3</code><code>Int4</code><code>Int8</code><code>Int16</code><code>Color</code><code>[Any]</code><code>Bool</code> <code>&lt;output&gt;</code> This shard outputs the value resulting from the AND operation. <code>Int</code><code>Int2</code><code>Int3</code><code>Int4</code><code>Int8</code><code>Int16</code><code>Color</code><code>[Any]</code><code>Bool</code> <code>Operand</code> The value or sequence of values to compare the input with. <code>0</code> <code>Int</code><code>Int2</code><code>Int3</code><code>Int4</code><code>Int8</code><code>Int16</code><code>Color</code><code>[Any]</code><code>Bool</code><code>Var(Bool)</code> <p>This shard performs a bitwise AND operation on the input value with the value specified in the Operand parameter and outputs the result. A bitwise AND operation is a binary operation that compares each bit of the binary representations of two numbers and outputs 1 if the bits are 1 and 0 otherwise. The shard then outputs a value, whose binary representation is the concatenation of the resulting 1s and 0s from the AND comparison.</p>"},{"location":"reference/shards/shards/Math/And/#examples","title":"Examples","text":"CodeOutput <pre><code>(int4 0 2 4 8)\n(Math.And\n ;:Operand\n (int4 3 3 3 3)) (Log)\n\n(Assert.Is (int4 0 2 0 0) true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/Math/Asin/","title":"Math.Asin","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input float or sequence of floats to calculate the inverse sine of. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <code>&lt;output&gt;</code> Outputs the angle in radians whose sine is the input value. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <p>This shard calculates the inverse sine of the given input, where the input is the sine value. The output is the angle in radians whose sine is the input value.</p>"},{"location":"reference/shards/shards/Math/Asin/#examples","title":"Examples","text":"CodeOutput <pre><code>(float4 -1.0 0.0 0.5 1.0)\n(Math.Asin) (Log)\n\n(Math.Subtract (float4 -1.5707963 0.0 0.52359878 1.5707963)) (Math.Abs)\n(IsLess (float4 1e-05 1e-05 1e-05 1e-05)) (Assert.Is true true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/Math/Asinh/","title":"Math.Asinh","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input float or sequence of floats to calculate the inverse hyperbolic sine of. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <code>&lt;output&gt;</code> Outputs the real number whose hyperbolic sine is the input value. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <p>This shard calculates the inverse hyperbolic sine of the given input, where the input is the hyperbolic sine value. The output is the real number whose hyperbolic sine is the input value.</p>"},{"location":"reference/shards/shards/Math/Asinh/#examples","title":"Examples","text":"CodeOutput <pre><code>(float3 -1.0 0.0 1.0)\n(Math.Asinh) (Log)\n\n(Math.Subtract (float3 -0.88137359 0.0 0.88137359)) (Math.Abs)\n(IsLess (float3 1e-05 1e-05 1e-05)) (Assert.Is true true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/Math/Atan/","title":"Math.Atan","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input float or sequence of floats to calculate the inverse tangent of. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <code>&lt;output&gt;</code> Outputs the angle in radians whose tangent is the input value. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <p>This shard calculates the inverse tangent of the given input, where the input is the tangent value. The output is the angle in radians whose tangent is the input value.</p>"},{"location":"reference/shards/shards/Math/Atan/#examples","title":"Examples","text":"CodeOutput <pre><code>(float3 -1.0 0.0 1.0)\n(Math.Atan) (Log)\n\n(Math.Subtract (float3 -0.78539816 0.0 0.78539816)) (Math.Abs)\n(IsLess (float3 1e-05 1e-05 1e-05)) (Assert.Is true true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/Math/Atanh/","title":"Math.Atanh","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input float or sequence of floats to calculate the inverse hyperbolic tangent of. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <code>&lt;output&gt;</code> Outputs the real number whose hyperbolic tangent is the input value. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <p>This shard calculates the inverse hyperbolic tangent of the given input (atanh(x)), where x, outputs y such that tanh(y) = x.</p>"},{"location":"reference/shards/shards/Math/Atanh/#examples","title":"Examples","text":"CodeOutput <pre><code>(float3 -0.5 0.0 0.5)\n(Math.Atanh) (Log)\n\n(Math.Subtract (float3 -0.54930614 0.0 0.54930614)) (Math.Abs)\n(IsLess (float3 1e-05 1e-05 1e-05)) (Assert.Is true true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/Math/AxisAngleX/","title":"Math.AxisAngleX","text":"Name - Description Default Type <code>&lt;input&gt;</code> Takes a float value representing the X rotation in radians. <code>Float</code> <code>&lt;output&gt;</code> Outputs a float4 vector (a vector with 4 float elements) representing a rotation quaternion around the X-axis. <code>Float4</code> <p>This shard creates a rotation quaternion for rotation around the X-axis. It takes a float input representing the angle in radians and outputs the rotation quaternion as a float4 vector. A float4 vector is a vector with 4 float elements.</p> <p> </p>"},{"location":"reference/shards/shards/Math/AxisAngleY/","title":"Math.AxisAngleY","text":"Name - Description Default Type <code>&lt;input&gt;</code> Takes a float value representing the Y rotation in radians. <code>Float</code> <code>&lt;output&gt;</code> Outputs a float4 vector (a vector with 4 float elements) representing a rotation quaternion around the Y-axis. <code>Float4</code> <p>This shard creates a rotation quaternion for rotation around the Y-axis. It takes a float input representing the angle in radians and outputs the rotation quaternion as a float4 vector. A float4 vector is a vector with 4 float elements.</p> <p> </p>"},{"location":"reference/shards/shards/Math/AxisAngleZ/","title":"Math.AxisAngleZ","text":"Name - Description Default Type <code>&lt;input&gt;</code> Takes a float value representing the Z rotation in radians. <code>Float</code> <code>&lt;output&gt;</code> Outputs a float4 vector (a vector with 4 float elements) representing a rotation quaternion around the Z-axis. <code>Float4</code> <p>This shard creates a rotation quaternion for rotation around the Z-axis. It takes a float input representing the angle in radians and outputs the rotation quaternion as a float4 vector. A float4 vector is a vector with 4 float elements.</p> <p> </p>"},{"location":"reference/shards/shards/Math/Cbrt/","title":"Math.Cbrt","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input float or sequence of floats to calculate the cube root of. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <code>&lt;output&gt;</code> Outputs the cube root of the input. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <p>This shard calculates the cube root of the given input.</p>"},{"location":"reference/shards/shards/Math/Cbrt/#examples","title":"Examples","text":"CodeOutput <pre><code>(float3 -27.0 1.0 8.0)\n(Math.Cbrt) (Log)\n\n(Math.Subtract (float3 -3.0 1.0 2.0)) (Math.Abs)\n(IsLess (float3 1e-05 1e-05 1e-05)) (Assert.Is true true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/Math/Ceil/","title":"Math.Ceil","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input float or sequence of floats to round up. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <code>&lt;output&gt;</code> Outputs the input rounded up to the nearest integer (as a float). <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <p>This shard rounds up the input to the nearest integer.</p>"},{"location":"reference/shards/shards/Math/Ceil/#examples","title":"Examples","text":"CodeOutput <pre><code>(float3 -0.95 4.0 7.54)\n(Math.Ceil) (Log)\n\n(Assert.Is (float3 0.0 4.0 8.0) true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/Math/Compose/","title":"Math.Compose","text":"Name - Description Default Type <code>&lt;input&gt;</code> Takes a table as input. The table should have a Translation key with a float3 vector value, a Rotation key with a float4 vector value and a Scale key with a float3 vector value. Eg. <code>{translation: Float3 rotation: Float4 scale: Float3}</code> <code>&lt;output&gt;</code> Outputs a 4x4 transformation matrix (sequence of four float4 vectors) that combines the input translation, rotation, and scale. <code>[Float4](4)</code> <p>Creates a 4x4 transformation matrix (sequence of four float4 vectors) from a table containing the appropriate Translation, Rotation and Scale values. values. The translation value should be a float3 vector representing positions on the x y z axis. The rotation value should be a float4 vector representing the quaternion rotation. Lastly, the scale should be a float3 vector representing the size on the x y and z axis. Eg. {translation: @f3(1 2 3), rotation: @f4(0 0 0 1), scale: @f3(1 1 1)} A float3 vector is a vector with 3 float elements while a float4 vector is a vector with 4 float elements.</p> <p> </p>"},{"location":"reference/shards/shards/Math/Cos/","title":"Math.Cos","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input float or sequence of floats to calculate the cosine of. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <code>&lt;output&gt;</code> Outputs the cosine of the input. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <p>This shard calculates the cosine of the given input, where the input is the angle in radians.</p>"},{"location":"reference/shards/shards/Math/Cos/#examples","title":"Examples","text":"CodeOutput <pre><code>(float3 0 3.1415927 6.2831853)\n(Math.Cos) (Log)\n\n(Math.Subtract (float3 1.0 -1.0 1.0)) (Math.Abs)\n(IsLess (float3 1e-05 1e-05 1e-05)) (Assert.Is true true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/Math/Cosh/","title":"Math.Cosh","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input float or sequence of floats to calculate the hyperbolic cosine of. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <code>&lt;output&gt;</code> Outputs the hyperbolic cosine of the input. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <p>This shard calculates the hyperbolic cosine of the given input, where the input is the real number. The hyperbolic cosine is a hyperbolic function that is analogous to the circular cosine function, but it uses exponential functions instead of angles.</p>"},{"location":"reference/shards/shards/Math/Cosh/#examples","title":"Examples","text":"CodeOutput <pre><code>(float3 -1.0 0.0 1.0)\n(Math.Cosh) (Log)\n\n(Math.Subtract (float3 1.5430806 1.0 1.5430806)) (Math.Abs)\n(IsLess (float3 1e-05 1e-05 1e-05)) (Assert.Is true true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/Math/Cross/","title":"Math.Cross","text":"Name - Description Default Type <code>&lt;input&gt;</code> Accepts float3 vector (a vector with 3 float elements) as input. <code>Float3</code><code>[Float3]</code> <code>&lt;output&gt;</code> Outputs the result of the cross product as a float3 vector or a sequence of float3 vectors if the input was a sequence of float3 vectors. <code>Float3</code><code>[Float3]</code> <code>Operand</code> The float3 vector to compute the cross product with. <code>0</code> <code>Float2</code><code>[Float2]</code><code>Float3</code><code>[Float3]</code><code>Float4</code><code>[Float4]</code><code>Var(Float2)</code><code>Var([Float2])</code><code>Var(Float3)</code><code>Var([Float3])</code><code>Var(Float4)</code><code>Var([Float4])</code> <p>This shard computes the cross product of the float3 vector (or sequence of float3 vectors) provided as input and the float3 vector provided in the Operand parameter and outputs the result as a float3 vector (or sequence of float3 vectors). A float3 vector is a vector with 3 float elements.</p> <p> </p>"},{"location":"reference/shards/shards/Math/Dec/","title":"Math.Dec","text":"Name - Description Default Type <code>&lt;input&gt;</code> The float or integer (or sequence of floats or integers) to decrease by 1. <code>Any</code> <code>&lt;output&gt;</code> The input decreased by 1. <code>Any</code> <code>Value</code> The value to apply the operation to. <code>none</code> <code>Var(Int)</code><code>Var(Int2)</code><code>Var(Int3)</code><code>Var(Int4)</code><code>Var(Int8)</code><code>Var(Int16)</code><code>Var(Float)</code><code>Var(Float2)</code><code>Var(Float3)</code><code>Var(Float4)</code><code>Var(Color)</code><code>Var([Any])</code> <p>Decreases the input by 1.</p>"},{"location":"reference/shards/shards/Math/Dec/#details","title":"Details","text":"<p>This shard decrements the <code>:Value</code> parameter by 1.</p> <p>The <code>:Value</code> parameter should be a variable that holds a valid numeric value.</p> <p>See also</p> <ul> <li><code>Math.Inc</code></li> </ul>"},{"location":"reference/shards/shards/Math/Dec/#examples","title":"Examples","text":"CodeOutput <pre><code> 10.0 &gt;= .mutable\n(Math.Dec\n ;:Value\n .mutable)\n.mutable (Log)\n\n(Assert.Is 9.0 true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/Math/Decompose/","title":"Math.Decompose","text":"Name - Description Default Type <code>&lt;input&gt;</code> Takes a 4x4 transformation matrix as input. This matrix should be a sequence of four float4 vectors representing the combined translation, rotation, and scale transformations. <code>[Float4](4)</code> <code>&lt;output&gt;</code> Outputs a table containing the Translation, Rotation, and Scale components. Eg. <code>{translation: Float3 rotation: Float4 scale: Float3}</code> <p>This shard converts a 4x4 transformation matrix (a sequence of four float 4 vectors) into a table containing its constituent Translation, Rotation, and Scale components. The table has a Translation key with a float3 vector value representing positions on the x, y, z axes, a Rotation key with a float4 vector value representing the quaternion rotation, and a Scale key with a float3 vector value, representing the size on the x, y, z axes. Eg. {translation: @f3(1 2 3), rotation: @f4(0 0 0 1), scale: @f3(1 1 1)} A float3 vector is a vector with 3 float elements while a float4 vector is a vector with 4 float elements. </p> <p> </p>"},{"location":"reference/shards/shards/Math/DegreesToRadians/","title":"Math.DegreesToRadians","text":"Name - Description Default Type <code>&lt;input&gt;</code> Takes a float value representing an angle in degrees. <code>Float</code> <code>&lt;output&gt;</code> Outputs a float value representing the input angle in radians. <code>Float</code> <p>This shard converts the input angle from degrees to radians. The conversion is done using the formula: radians = degrees * (\u03c0 / 180).</p> <p> </p>"},{"location":"reference/shards/shards/Math/Divide/","title":"Math.Divide","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value or the sequence of values to divide the value specified in the Operand parameter with. <code>Int</code><code>Int2</code><code>Int3</code><code>Int4</code><code>Int8</code><code>Int16</code><code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <code>&lt;output&gt;</code> This shard outputs the result of the division. <code>Int</code><code>Int2</code><code>Int3</code><code>Int4</code><code>Int8</code><code>Int16</code><code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <code>Operand</code> The value or sequence of values to divide the input by. <code>0</code> <code>Int</code><code>Var(Int)</code><code>Int2</code><code>Var(Int2)</code><code>Int3</code><code>Var(Int3)</code><code>Int4</code><code>Var(Int4)</code><code>Int8</code><code>Var(Int8)</code><code>Int16</code><code>Var(Int16)</code><code>Float</code><code>Var(Float)</code><code>Float2</code><code>Var(Float2)</code><code>Float3</code><code>Var(Float3)</code><code>Float4</code><code>Var(Float4)</code><code>Color</code><code>Var(Color)</code><code>[Any]</code><code>Var([Any])</code> <p>This shard divides the input value by the value provided in the Operand parameter.</p>"},{"location":"reference/shards/shards/Math/Divide/#examples","title":"Examples","text":"CodeOutput <pre><code>(float 9)\n(Math.Divide\n ;:Operand\n 2.0) (Log)\n\n(Assert.Is 4.5 true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/Math/Dot/","title":"Math.Dot","text":"Name - Description Default Type <code>&lt;input&gt;</code> Takes in a float vector of any dimension (e.g., float2, float3, float4). <code>Float2</code><code>[Float2]</code><code>Float3</code><code>[Float3]</code><code>Float4</code><code>[Float4]</code> <code>&lt;output&gt;</code> Outputs the resulting dot product as a float value. <code>Float2</code><code>[Float2]</code><code>Float3</code><code>[Float3]</code><code>Float4</code><code>[Float4]</code> <code>Operand</code> The operand. <code>0</code> <code>Float2</code><code>[Float2]</code><code>Float3</code><code>[Float3]</code><code>Float4</code><code>[Float4]</code><code>Var(Float2)</code><code>Var([Float2])</code><code>Var(Float3)</code><code>Var([Float3])</code><code>Var(Float4)</code><code>Var([Float4])</code> <p>Computes the dot product of two float vectors with an equal number of elements, and outputs the resulting float value. The first float vector is passed as input and the second float vector is specified in the Operand parameter.</p> <p> </p>"},{"location":"reference/shards/shards/Math/Erf/","title":"Math.Erf","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input float or sequence of floats to calculate the error function of. This can be any real number. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <code>&lt;output&gt;</code> Outputs probability result of the error function of the input. The output is always between -1 and 1. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <p>This shard calculates the error function of the given input. The error function is related to the probability that a random variable with normal distribution of mean 0 and variance 1/2 falls in the range specified by the input value.</p>"},{"location":"reference/shards/shards/Math/Erf/#examples","title":"Examples","text":"CodeOutput <pre><code>(float3 0.0 1.0 2.0)\n(Math.Erf) (Log)\n\n(Math.Subtract (float3 0.0 0.84270079 0.99532226)) (Math.Abs)\n(IsLess (float3 1e-05 1e-05 1e-05)) (Assert.Is true true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/Math/Erfc/","title":"Math.Erfc","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input float or sequence of floats to calculate the complementary error function of. This can be any real number. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <code>&lt;output&gt;</code> Outputs the probability result of the complementary error function of the input. The output is always between 0 and 2. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <p>This shard calculates the complementary error function of the given input. The complementary error function is related to the probability that the absolute value of a random variable with normal distribution of mean 0 and variance 1/2 is greater than the input value.</p>"},{"location":"reference/shards/shards/Math/Erfc/#examples","title":"Examples","text":"CodeOutput <pre><code>(float3 0.0 1.0 2.0)\n(Math.Erfc) (Log)\n\n(Math.Subtract (float3 1.0 0.15729920 4.677735e-3)) (Math.Abs)\n(IsLess (float3 1e-05 1e-05 1e-05)) (Assert.Is true true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/Math/Exp/","title":"Math.Exp","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input float or sequence of floats to use as the exponent for the base e exponential function. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <code>&lt;output&gt;</code> Outputs the result of the exponential operation. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <p>This shard calculates the exponential function with base e (Euler's number) for the given input. The exponential function is equivalent to raising Euler's number to the power of the input.</p>"},{"location":"reference/shards/shards/Math/Exp/#examples","title":"Examples","text":"CodeOutput <pre><code>(float 0)\n(Math.Exp) (Log)\n\n(Assert.Is (float 1) true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/Math/Exp2/","title":"Math.Exp2","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input float or sequence of floats used as the exponent for the base 2 exponential function. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <code>&lt;output&gt;</code> Outputs the result of the exponential operation. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <p>This shard calculates the exponential function with base 2 for the given input. The exponential function with base 2 is equivalent to raising 2 to the power of the input.</p>"},{"location":"reference/shards/shards/Math/Exp2/#examples","title":"Examples","text":"CodeOutput <pre><code>(float 5)\n(Math.Exp2) (Log)\n\n(Assert.Is (float 32) true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/Math/Expm1/","title":"Math.Expm1","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input float or sequence of floats used as the exponent for the base e exponential function. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <code>&lt;output&gt;</code> Outputs the result of the exponential operation. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <p>This shard calculates the exponential function with base e (Euler's number) for the given input and subtracts 1 from the result.</p>"},{"location":"reference/shards/shards/Math/Expm1/#examples","title":"Examples","text":"CodeOutput <pre><code>(float 0)\n(Math.Expm1) (Log)\n\n(Assert.Is (float 0) true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/Math/FastInvSqrt/","title":"Math.FastInvSqrt","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input float or sequence of floats to calculate the inverse square root of. This value must be a positive number or sequence of positive numbers. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <code>&lt;output&gt;</code> Outputs the inverse square root of the input. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <p>This shard calculates the inverse square root of the given input.</p>"},{"location":"reference/shards/shards/Math/FastInvSqrt/#examples","title":"Examples","text":"CodeOutput <pre><code>4.0\n(Math.FastInvSqrt) (Log)\n\n(Math.Subtract 0.4999978) (Math.Abs)\n(IsLess 1e-05) (Assert.Is true true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/Math/FastSqrt/","title":"Math.FastSqrt","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input float or sequence of floats to calculate the square root of. This value must be a positive number or sequence of positive numbers. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <code>&lt;output&gt;</code> Outputs the square root of the input. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <p>This shard calculates the square root of the given input.</p>"},{"location":"reference/shards/shards/Math/FastSqrt/#examples","title":"Examples","text":"CodeOutput <pre><code>4.0\n(Math.FastSqrt) (Log)\n\n(Math.Subtract 2.0) (Math.Abs)\n(IsLess 1e-05) (Assert.Is true true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/Math/Floor/","title":"Math.Floor","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input float or sequence of floats to round down. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <code>&lt;output&gt;</code> Outputs the input rounded down to the nearest integer (as a float). <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <p>This shard rounds down the input to the nearest integer.</p>"},{"location":"reference/shards/shards/Math/Floor/#examples","title":"Examples","text":"CodeOutput <pre><code>(float3 -0.95 4.0 7.54)\n(Math.Floor) (Log)\n\n(Assert.Is (float3 -1.0 4.0 7.0) true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/Math/Inc/","title":"Math.Inc","text":"Name - Description Default Type <code>&lt;input&gt;</code> The float or integer (or sequence of floats or integers) to increase by 1. <code>Any</code> <code>&lt;output&gt;</code> The input increased by 1. <code>Any</code> <code>Value</code> The value to apply the operation to. <code>none</code> <code>Var(Int)</code><code>Var(Int2)</code><code>Var(Int3)</code><code>Var(Int4)</code><code>Var(Int8)</code><code>Var(Int16)</code><code>Var(Float)</code><code>Var(Float2)</code><code>Var(Float3)</code><code>Var(Float4)</code><code>Var(Color)</code><code>Var([Any])</code> <p>Increases the input by 1.</p>"},{"location":"reference/shards/shards/Math/Inc/#details","title":"Details","text":"<p>This shard increments the <code>:Value</code> parameter by 1.</p> <p>The <code>:Value</code> parameter should be a variable that holds a valid numeric value.</p> <p>See also</p> <ul> <li><code>Math.Dec</code></li> </ul>"},{"location":"reference/shards/shards/Math/Inc/#examples","title":"Examples","text":"CodeOutput <pre><code> 10.0 &gt;= .mutable\n(Math.Inc\n ;:Value\n .mutable)\n.mutable (Log)\n(Assert.Is 11.0 true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/Math/Inverse/","title":"Math.Inverse","text":"Name - Description Default Type <code>&lt;input&gt;</code> Takes a 4x4 matrix (a sequence of four float4 vectors) as input. <code>[Float4](4)</code> <code>&lt;output&gt;</code> Outputs the inverse of the input 4x4 matrix. <code>[Float4](4)</code> <p>This shard takes a 4x4 matrices as input and computes its inverse. A 4x4 matrix is a sequence with exactly 4 float4 vectors while a float4 vector is a vector with 4 float elements.</p> <p> </p>"},{"location":"reference/shards/shards/Math/LGamma/","title":"Math.LGamma","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input float or sequence of floats to calculate the log gamma function of. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <code>&lt;output&gt;</code> Outputs the log gamma function of the input. The output is always positive for positive inputs. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <p>This shard calculates the log gamma function of the given input. The log gamma function is the natural logarithm of the absolute value of the gamma function.</p>"},{"location":"reference/shards/shards/Math/LGamma/#examples","title":"Examples","text":"CodeOutput <pre><code>(float3 1.0 0.5 10.0)\n(Math.LGamma) (Log)\n\n(Math.Subtract (float3 0.0 0.572365 12.801827)) (Math.Abs)\n(IsLess (float3 1e-05 1e-05 1e-05)) (Assert.Is true true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/Math/LShift/","title":"Math.LShift","text":"Name - Description Default Type <code>&lt;input&gt;</code> The integer or the sequence of integers to shift the bits of. <code>Int</code><code>Int2</code><code>Int3</code><code>Int4</code><code>Int8</code><code>Int16</code><code>Color</code><code>[Any]</code> <code>&lt;output&gt;</code> Outputs the value resulting from the left shift operation. <code>Int</code><code>Int2</code><code>Int3</code><code>Int4</code><code>Int8</code><code>Int16</code><code>Color</code><code>[Any]</code> <code>Operand</code> The number of positions to shift the bits of the input value to the left by. <code>0</code> <code>Int</code><code>Int2</code><code>Int3</code><code>Int4</code><code>Int8</code><code>Int16</code><code>Color</code><code>[Any]</code> <p>This shard shifts the bits of the input value to the left by the number of positions specified in the Operand parameter. The shard then outputs a value, whose binary representation is the resulting shifted binary.</p>"},{"location":"reference/shards/shards/Math/LShift/#examples","title":"Examples","text":"CodeOutput <pre><code>(int 4)\n(Math.LShift 2) (Log)\n\n(Assert.Is 16 true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/Math/Length/","title":"Math.Length","text":"Name - Description Default Type <code>&lt;input&gt;</code> Accepts a float vector of any dimension (e.g., float2, float3, float4). <code>Float2</code><code>[Float2]</code><code>Float3</code><code>[Float3]</code><code>Float4</code><code>[Float4]</code> <code>&lt;output&gt;</code> Outputs the magnitude of the input vector as a float. <code>Float</code> <p>Computes the magnitude of a float vector of any dimension and outputs the result as a float.</p> <p> </p>"},{"location":"reference/shards/shards/Math/LengthSquared/","title":"Math.LengthSquared","text":"Name - Description Default Type <code>&lt;input&gt;</code> Accepts a float vector of any dimension (e.g., float2, float3, float4). <code>Float2</code><code>[Float2]</code><code>Float3</code><code>[Float3]</code><code>Float4</code><code>[Float4]</code> <code>&lt;output&gt;</code> Outputs the squared magnitude of the input vector as a float. <code>Float</code> <p>Computes the squared magnitude of a float vector of any dimension and outputs the result as a float.</p> <p> </p>"},{"location":"reference/shards/shards/Math/Lerp/","title":"Math.Lerp","text":"Name - Description Default Type <code>&lt;input&gt;</code> The factor to interpolate between the start and end values. <code>Float</code> <code>&lt;output&gt;</code> The interpolated value between the start and end values based on the factor provided as input. <code>Int</code><code>Int2</code><code>Int3</code><code>Int4</code><code>Int8</code><code>Int16</code><code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <code>First</code> The start value <code>none</code> <code>Int</code><code>Var(Int)</code><code>Int2</code><code>Var(Int2)</code><code>Int3</code><code>Var(Int3)</code><code>Int4</code><code>Var(Int4)</code><code>Int8</code><code>Var(Int8)</code><code>Int16</code><code>Var(Int16)</code><code>Float</code><code>Var(Float)</code><code>Float2</code><code>Var(Float2)</code><code>Float3</code><code>Var(Float3)</code><code>Float4</code><code>Var(Float4)</code><code>Color</code><code>Var(Color)</code> <code>Second</code> The end value <code>none</code> <code>Int</code><code>Var(Int)</code><code>Int2</code><code>Var(Int2)</code><code>Int3</code><code>Var(Int3)</code><code>Int4</code><code>Var(Int4)</code><code>Int8</code><code>Var(Int8)</code><code>Int16</code><code>Var(Int16)</code><code>Float</code><code>Var(Float)</code><code>Float2</code><code>Var(Float2)</code><code>Float3</code><code>Var(Float3)</code><code>Float4</code><code>Var(Float4)</code><code>Color</code><code>Var(Color)</code> <p>Linearly interpolate between the start value specified in the <code>First</code> parameter and the end value specified in the <code>Second</code> parameter based on the factor provided as input.</p> <p> </p>"},{"location":"reference/shards/shards/Math/Log/","title":"Math.Log","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input float or sequence of floats to calculate the natural logarithm of. This value must be a positive number or sequence of positive numbers. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <code>&lt;output&gt;</code> Outputs the natural logarithm of the input. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <p>This shard calculates the natural logarithm for the given input. The output is the exponent to which e must be raised to obtain the input value.</p>"},{"location":"reference/shards/shards/Math/Log/#examples","title":"Examples","text":"CodeOutput <pre><code>(float3 1.0 0.5 10.0)\n(Math.Log) (Log)\n\n(Math.Subtract (float3 0.0 -0.69314718 2.3025851)) (Math.Abs)\n(IsLess (float3 1e-05 1e-05 1e-05)) (Assert.Is true true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/Math/Log10/","title":"Math.Log10","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input float or sequence of floats to calculate the base 10 logarithm of. This value must be a positive number or sequence of positive numbers. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <code>&lt;output&gt;</code> Outputs the base 10 logarithm of the input. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <p>This shard calculates the base 10 logarithm for the given input. The output is the exponent to which 10 must be raised to obtain the input value.</p>"},{"location":"reference/shards/shards/Math/Log10/#examples","title":"Examples","text":"CodeOutput <pre><code>(float3 1.0 0.5 10.0)\n(Math.Log10) (Log)\n\n(Math.Subtract (float3 0.0 -0.30102999 1.0)) (Math.Abs)\n(IsLess (float3 1e-05 1e-05 1e-05)) (Assert.Is true true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/Math/Log1p/","title":"Math.Log1p","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input float or sequence of floats to add 1 to and then calculate the natural logarithm of. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <code>&lt;output&gt;</code> Outputs the natural logarithm of the input plus 1. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <p>This shard adds 1 to the input and then calculates the natural logarithm of the result.</p> <p> </p>"},{"location":"reference/shards/shards/Math/Log2/","title":"Math.Log2","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input float or sequence of floats to calculate the base 2 logarithm of. This value must be a positive number or sequence of positive numbers. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <code>&lt;output&gt;</code> Outputs the base 2 logarithm. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <p>This shard calculates the base 2 logarithm for the given input. The output is the exponent to which 2 must be raised to obtain the input value.</p>"},{"location":"reference/shards/shards/Math/Log2/#examples","title":"Examples","text":"CodeOutput <pre><code>(float3 1.0 0.5 10.0)\n(Math.Log2) (Log)\n\n(Math.Subtract (float3 0.0 -1.0 3.3219281)) (Math.Abs)\n(IsLess (float3 1e-05 1e-05 1e-05)) (Assert.Is true true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/Math/LookAt/","title":"Math.LookAt","text":"Name - Description Default Type <code>&lt;input&gt;</code> Takes a table with two float3 values: 'Position' (the camera's position) and 'Target' (the point the camera is looking at). Eg. <code>{Position: Float3 Target: Float3}</code> <code>&lt;output&gt;</code> Outputs a 4x4 view matrix (a sequence of four float4 vectors). <code>[Float4](4)</code> <p>This shard creates a 4x4 view matrix (a sequence of four float4 vectors) for a camera based on the camera's position and a target point which is represented as a table with two float3 vectors: 'Position' and 'Target', that is passed as input. A float4 vector is a vector with 4 float elements while a float3 vector is a vector with 3 float elements.</p> <p> </p>"},{"location":"reference/shards/shards/Math/MatIdentity/","title":"Math.MatIdentity","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input of this shard is ignored. <code>&lt;output&gt;</code> Outputs a 4x4 identity matrix (a sequence of four float4 vectors). The matrix will have 1s on the main diagonal and 0s for the other elements. <code>[Float4](4)</code> <code>Type</code> The matrix row type of the corresponding matrix <code>Type::Float4</code> <code>Type</code> <p>This shard creates a standard 4x4 identity matrix. The standard identity matrix is a square matrix with 1s on the main diagonal and 0s for the other elements. A 4x4 matrix is a sequence with exactly 4 float4 vector and a float4 vector is a vector with 4 float elements.</p> <p> </p>"},{"location":"reference/shards/shards/Math/MatMul/","title":"Math.MatMul","text":"Name - Description Default Type <code>&lt;input&gt;</code> Takes a matrix as input. (2x2, 3x3 or 4x4) <code>[Float4](4)</code><code>[Float3](3)</code><code>[Float2](2)</code> <code>&lt;output&gt;</code> Outputs the result of the matrix multiplication. If a matrix is multiplied by a vector, the result is a vector (depending on the dimensions of the matrix provided). If two matrices are multiplied, the result is a matrix with the same dimensions as the input matrix. <code>[Float4](4)</code><code>Float4</code><code>[Float3](3)</code><code>Float3</code><code>[Float2](2)</code><code>Float2</code> <code>Operand</code> The operand for this operation. <code>0</code> <code>Int</code><code>Var(Int)</code><code>Int2</code><code>Var(Int2)</code><code>Int3</code><code>Var(Int3)</code><code>Int4</code><code>Var(Int4)</code><code>Int8</code><code>Var(Int8)</code><code>Int16</code><code>Var(Int16)</code><code>Float</code><code>Var(Float)</code><code>Float2</code><code>Var(Float2)</code><code>Float3</code><code>Var(Float3)</code><code>Float4</code><code>Var(Float4)</code><code>Color</code><code>Var(Color)</code><code>[Any]</code><code>Var([Any])</code> <p>Performs matrix multiplication on either two matrices or a matrix and a vector and outputs either a matrix or a vector accordingly. The two matrixes must be of similar dimensions (2x2, 3x3, or 4x4). And if multiplied with a vector, the vector too must have similar dimensions (2x2 with float2, 3x3 with float3, 4x4 with float4).</p> <p> </p>"},{"location":"reference/shards/shards/Math/Mean/","title":"Math.Mean","text":"Name - Description Default Type <code>&lt;input&gt;</code> The sequence of floating point numbers to calculate the average of. <code>[Float]</code> <code>&lt;output&gt;</code> The calculated average as a float. <code>Float</code> <code>Kind</code> The type of average to calculate. <code>Mean::Arithmetic</code> <code>Mean</code> <p>Calculates the average value of a sequence of floating point numbers.</p>"},{"location":"reference/shards/shards/Math/Mean/#examples","title":"Examples","text":"CodeOutput <pre><code>(Const [-1.0 0.0 1.0 2.0 5.0])\n(Math.Mean\n ;:Kind\n Mean.Arithmetic) (Log)\n\n(Assert.Is 1.4 true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/Math/Mod/","title":"Math.Mod","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value or the sequence of values to divide the value specified in the Operand parameter with. <code>Int</code><code>Int2</code><code>Int3</code><code>Int4</code><code>Int8</code><code>Int16</code><code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <code>&lt;output&gt;</code> This shard outputs the result of the modulus operation. <code>Int</code><code>Int2</code><code>Int3</code><code>Int4</code><code>Int8</code><code>Int16</code><code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <code>Operand</code> The value or sequence of values to divide the input by and get the remainder of. <code>0</code> <code>Int</code><code>Var(Int)</code><code>Int2</code><code>Var(Int2)</code><code>Int3</code><code>Var(Int3)</code><code>Int4</code><code>Var(Int4)</code><code>Int8</code><code>Var(Int8)</code><code>Int16</code><code>Var(Int16)</code><code>Float</code><code>Var(Float)</code><code>Float2</code><code>Var(Float2)</code><code>Float3</code><code>Var(Float3)</code><code>Float4</code><code>Var(Float4)</code><code>Color</code><code>Var(Color)</code><code>[Any]</code><code>Var([Any])</code> <p>This shard calculates the remainder of the division of the input value by the value provided in the Operand parameter.</p>"},{"location":"reference/shards/shards/Math/Mod/#examples","title":"Examples","text":"CodeOutput <pre><code>(int4 1 2 3 4)\n(Math.Mod\n ;:Operand\n (int4 2 2 2 2)) (Log)\n\n(Assert.Is (int4 1 0 1 0) true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/Math/Multiply/","title":"Math.Multiply","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value or the sequence of values to multiply the value specified in the Operand parameter with. <code>Int</code><code>Int2</code><code>Int3</code><code>Int4</code><code>Int8</code><code>Int16</code><code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <code>&lt;output&gt;</code> This shard outputs the result of the multiplication. <code>Int</code><code>Int2</code><code>Int3</code><code>Int4</code><code>Int8</code><code>Int16</code><code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <code>Operand</code> The value or sequence of values to multiply the input by. <code>0</code> <code>Int</code><code>Var(Int)</code><code>Int2</code><code>Var(Int2)</code><code>Int3</code><code>Var(Int3)</code><code>Int4</code><code>Var(Int4)</code><code>Int8</code><code>Var(Int8)</code><code>Int16</code><code>Var(Int16)</code><code>Float</code><code>Var(Float)</code><code>Float2</code><code>Var(Float2)</code><code>Float3</code><code>Var(Float3)</code><code>Float4</code><code>Var(Float4)</code><code>Color</code><code>Var(Color)</code><code>[Any]</code><code>Var([Any])</code> <p>This shard multiplies the input value by the value provided in the Operand parameter.</p>"},{"location":"reference/shards/shards/Math/Multiply/#details","title":"Details","text":"<p>Multiplication is a binary operation, i.e., it needs two arguments to give a result.</p> <p>The <code>Math.Multiply</code> shard takes in the Input and the parameter <code>:Operand</code> to produce the Output.</p> <p>Both Input and <code>:Operand</code> can be an integer, a float, or a sequence of such entities (but both value types should match for a given operation). The Output is generally of the same type as the Input provided to the shard.</p> See also <p>Binary operations on sequences</p>"},{"location":"reference/shards/shards/Math/Multiply/#examples","title":"Examples","text":"CodeOutput <pre><code>;; Multiply integers\n(int 5) ;; :Input\n(Log) ;; prints input =&gt; 5\n(Math.Multiply\n 2) ;; :Operand\n(Log) ;; prints input * operand =&gt; 10\n(Assert.Is 10 true) ;; expect: (5 * 2) =&gt; 10\n</code></pre> <pre><code>\n</code></pre> CodeOutput <pre><code>;; Multiply floats\n(float 5.3) ;; :Input\n(Log) ;; prints input =&gt; 5.3\n(Math.Multiply\n 2.1) ;; :Operand\n (Log) ;; prints input * operand =&gt; 11.13\n(Assert.Is 11.13 true) ;; expect: (5.3 * 2.1) =&gt; 11.13\n</code></pre> <pre><code>\n</code></pre> CodeOutput <pre><code>;; Multiply equal-sized sequences\n[4 5.1 6.4] ;; :Input\n(Log) ;; prints input =&gt; [4 5.1 6.4]\n(Math.Multiply\n [3 4.0 2.2]) ;; :Operand\n;; input seq elements compute with corresponding operand seq elements\n(Log) ;; prints input * operand =&gt; [12 20.4 14.08]\n(Assert.IsAlmost [12 20.4 14.08]) ;; expect: [(4 * 3) (5.1 * 4.0) (6.4 * 2.2)] =&gt; [12 20.4 14.08]\n</code></pre> <pre><code>\n</code></pre> CodeOutput <pre><code>;; Multiply unequal-sized sequences (input size &lt; operand size)\n[4.0] ;; :Input\n(Log) ;; prints input =&gt; [4.0]\n(Math.Multiply\n [3.0 4.0 2.2]) ;; :Operand\n;; input seq elements compute with corresponding operand seq elements\n;; since input size &lt; operand size, remaining operand seq elements ignored\n(Log) ;; prints input * operand =&gt; [12.0]\n(Assert.Is [12.0] true) ;; expect: [(4.0 * 3.0) ... ...] =&gt; [12.0]\n</code></pre> <pre><code>\n</code></pre> CodeOutput <pre><code>;; Multiply unequal-sized sequences (input size &gt; operand size)\n[4 2 1 5 8] ;; :Input\n(Log) ;; prints input =&gt; [4 2 1 5 8]\n(Math.Multiply\n [6 4]) ;; :Operand\n;; input seq elements compute with corresponding operand seq elements\n;; for (input size &gt; operand size): remaining input seq elements continually loop over operand seq elements\n(Log) ;; prints input + operand =&gt; [24 8 6 20 48]\n(Assert.Is [24 8 6 20 48] true) ;; expect: [(4 * 6) (2 * 4) (1 * 6) (5 * 4) (8 * 6)] =&gt; [24 8 6 20 48]\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/Math/Negate/","title":"Math.Negate","text":"Name - Description Default Type <code>&lt;input&gt;</code> The float or integer (or sequence of floats or integers) to reverse the sign of. <code>Int</code><code>Int2</code><code>Int3</code><code>Int4</code><code>Int8</code><code>Int16</code><code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <code>&lt;output&gt;</code> The input with its sign reversed. <code>Int</code><code>Int2</code><code>Int3</code><code>Int4</code><code>Int8</code><code>Int16</code><code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <p>This shard reverses the sign of the input. (A positive number becomes negative, and vice versa).</p> <p> </p>"},{"location":"reference/shards/shards/Math/Normalize/","title":"Math.Normalize","text":"Name - Description Default Type <code>&lt;input&gt;</code> Accepts a float vector of any dimension (e.g., float2, float3, float4) or a float sequence of any length. <code>[Float]</code><code>Float2</code><code>[Float2]</code><code>Float3</code><code>[Float3]</code><code>Float4</code><code>[Float4]</code> <code>&lt;output&gt;</code> Outputs a float vector of the same dimension or a float sequence of the same length as what was passed as input but with its values normalized to a magnitude of 1. <code>[Float]</code><code>Float2</code><code>[Float2]</code><code>Float3</code><code>[Float3]</code><code>Float4</code><code>[Float4]</code> <code>Positive</code> If set to true, the output will be in the range 0.0~1.0 instead of -1.0~1.0. <code>false</code> <code>Bool</code> <p>This shard normalizes a float vector of any dimension or a sequence of floats, scaling it to have a magnitude of 1 while preserving its direction. By default, output values can range from -1.0 to 1.0. If the 'Positive' parameter is set to true, the output will be scaled to the range 0.0 to 1.0. For example, normalizing [4.0 -5.0 6.0 -7.0] will result in [0.3563, -0.4454, 0.5345, -0.6236], which has a length of 1. </p> <p> </p>"},{"location":"reference/shards/shards/Math/Or/","title":"Math.Or","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value or the sequence of values to compare the value specified in the Operand parameter with. <code>Int</code><code>Int2</code><code>Int3</code><code>Int4</code><code>Int8</code><code>Int16</code><code>Color</code><code>[Any]</code><code>Bool</code> <code>&lt;output&gt;</code> This shard outputs the value resulting from the OR operation. <code>Int</code><code>Int2</code><code>Int3</code><code>Int4</code><code>Int8</code><code>Int16</code><code>Color</code><code>[Any]</code><code>Bool</code> <code>Operand</code> The value or sequence of values to compare the input with. <code>0</code> <code>Int</code><code>Int2</code><code>Int3</code><code>Int4</code><code>Int8</code><code>Int16</code><code>Color</code><code>[Any]</code><code>Bool</code><code>Var(Bool)</code> <p>This shard performs a bitwise OR operation on the input value with the value specified in the Operand parameter and outputs the result. A bitwise OR operation is a binary operation that compares each bit of the binary representations of two numbers and outputs 1 if either bit is 1 and 0 if both bits are 0. The shard then outputs a value, whose binary representation is the concatenation of the resulting 1s and 0s from the Or comparison.</p>"},{"location":"reference/shards/shards/Math/Or/#examples","title":"Examples","text":"CodeOutput <pre><code>(int4 0 2 4 8)\n(Math.Or\n ;:Operand\n (int4 3 3 3 3)) (Log)\n\n(Assert.Is (int4 3 3 7 11) true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/Math/Orthographic/","title":"Math.Orthographic","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input of this shard is ignored. <code>&lt;output&gt;</code> Outputs a 4x4 orthographic projection matrix (a sequence of four float4 vectors). <code>[Float4](4)</code> <code>Width</code> Width size. <code>1280</code> <code>Int</code><code>Float</code> <code>Height</code> Height size. <code>720</code> <code>Int</code><code>Float</code> <code>Near</code> Near plane. <code>0</code> <code>Int</code><code>Float</code> <code>Far</code> Far plane. <code>1000</code> <code>Int</code><code>Float</code> <p>This shard creates a 4x4 orthographic projection matrix based on the width size, height size, near, and far planes specified in the appropriate parameters. A 4x4 matrix is a sequence with exactly 4 float4 vectors while a float4 vector is a vector with 4 float elements.</p> <p> </p>"},{"location":"reference/shards/shards/Math/Percentile/","title":"Math.Percentile","text":"Name - Description Default Type <code>&lt;input&gt;</code> The sequence of floats to calculate the percentile of. <code>[Float]</code> <code>&lt;output&gt;</code> The percentile of the input value within the specified sequence. <code>Float</code> <code>Percentile</code> The percentile to calculate. <code>50</code> <code>Float</code><code>Var(Float)</code> <p>This shard calculates the percentile of the input value within the specified sequence.</p> <p> </p>"},{"location":"reference/shards/shards/Math/Pow/","title":"Math.Pow","text":"Name - Description Default Type <code>&lt;input&gt;</code> The base value to raise the power of. <code>Int</code><code>Int2</code><code>Int3</code><code>Int4</code><code>Int8</code><code>Int16</code><code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <code>&lt;output&gt;</code> The result of raising the input to the power of the operand. <code>Int</code><code>Int2</code><code>Int3</code><code>Int4</code><code>Int8</code><code>Int16</code><code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <code>Operand</code> The operand for this operation. <code>0</code> <code>Int</code><code>Var(Int)</code><code>Int2</code><code>Var(Int2)</code><code>Int3</code><code>Var(Int3)</code><code>Int4</code><code>Var(Int4)</code><code>Int8</code><code>Var(Int8)</code><code>Int16</code><code>Var(Int16)</code><code>Float</code><code>Var(Float)</code><code>Float2</code><code>Var(Float2)</code><code>Float3</code><code>Var(Float3)</code><code>Float4</code><code>Var(Float4)</code><code>Color</code><code>Var(Color)</code><code>[Any]</code><code>Var([Any])</code> <p>This shard raises the input to the power of the exponent specified in the Operand parameter.</p>"},{"location":"reference/shards/shards/Math/Pow/#examples","title":"Examples","text":"CodeOutput <pre><code>2.0\n(Math.Pow\n ;:Operand\n 3.0) (Log)\n\n(Assert.Is 8.0 true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/Math/Project/","title":"Math.Project","text":"Name - Description Default Type <code>&lt;input&gt;</code> Takes a float3 vector representing the 3D point in world space where x, y, and z are the coordinates in world space. <code>Float3</code> <code>&lt;output&gt;</code> Outputs a float3 vector representing the projected 2D point (x, y) in screen space, with the z component representing the depth. <code>Float3</code> <code>Matrix</code> The combined 4x4 view-projection matrix (sequence of four float4 vectors) to use. <code>none</code> <code>[Float4](4)</code><code>Var([Float4](4))</code> <code>ScreenSize</code> The size of the screen or viewport in pixels. <code>none</code> <code>Float2</code><code>Var(Float2)</code> <code>FlipY</code> Flip Y coordinate (on by default). <code>true</code> <code>Bool</code><code>Var(Var(Bool))</code> <p>This shard converts the input 3D world coordinates to 2D screen coordinates using a view-projection matrix. Both 3D and 2D coordinates are represented as float3 vectors (vectors with 3 float elements).It performs the full projection pipeline including matrix multiplication, perspective division, and viewport transformation using the 4x4 view-projection matrix specified in the Matrix parameter and the screen size in the ScreenSize parameter.</p> <p> </p>"},{"location":"reference/shards/shards/Math/QuatMultiply/","title":"Math.QuatMultiply","text":"Name - Description Default Type <code>&lt;input&gt;</code> Takes a float4 vector representing the quaternion to be multiplied. <code>Float4</code> <code>&lt;output&gt;</code> Outputs a float4 vector representing the resulting quaternion after multiplication. <code>Float4</code> <code>Operand</code> The float4 vector representing the second quaternion to multiply the input quaternion with. <code>none</code> <code>Float4</code><code>Var(Float4)</code> <p>This shard multiplies two quaternions (represented as float4 vectors) together. It combines the two rotations by multiplying the input quaternion with the operand quaternion. A float4 vector is a vector with 4 float elements.</p> <p> </p>"},{"location":"reference/shards/shards/Math/QuatRotate/","title":"Math.QuatRotate","text":"Name - Description Default Type <code>&lt;input&gt;</code> Takes a float3 vector representing the 3D vector to be rotated. <code>Float3</code> <code>&lt;output&gt;</code> Outputs a float3 vector representing the rotated 3D vector. <code>Float3</code> <code>Operand</code> The float4 vector representing the quaternion to rotate the input 3D vector by. <code>none</code> <code>Float4</code><code>Var(Float4)</code> <p>This shard rotates the input 3D vector (represented as a float3) by the quaternion (represented as a float4) specified in the Operand parameter and outputs the resulting rotated 3D vector. A float4 vector is a vector with 4 float elements while a float3 vector is a vector with 3 float elements.</p> <p> </p>"},{"location":"reference/shards/shards/Math/RShift/","title":"Math.RShift","text":"Name - Description Default Type <code>&lt;input&gt;</code> The integer or the sequence of integers to shift the bits of. <code>Int</code><code>Int2</code><code>Int3</code><code>Int4</code><code>Int8</code><code>Int16</code><code>Color</code><code>[Any]</code> <code>&lt;output&gt;</code> Outputs the value resulting from the right shift operation. <code>Int</code><code>Int2</code><code>Int3</code><code>Int4</code><code>Int8</code><code>Int16</code><code>Color</code><code>[Any]</code> <code>Operand</code> The number of positions to shift the bits of the input value to the right by. <code>0</code> <code>Int</code><code>Int2</code><code>Int3</code><code>Int4</code><code>Int8</code><code>Int16</code><code>Color</code><code>[Any]</code> <p>This shard shifts the bits of the input value to the right by the number of positions specified in the Operand parameter. The shard then outputs a value, whose binary representation is the resulting shifted binary.</p>"},{"location":"reference/shards/shards/Math/RShift/#examples","title":"Examples","text":"CodeOutput <pre><code>(int 4)\n(Math.RShift 2) (Log)\n\n(Assert.Is 1 true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/Math/RadiansToDegrees/","title":"Math.RadiansToDegrees","text":"Name - Description Default Type <code>&lt;input&gt;</code> Takes a float value representing an angle in radians. <code>Float</code> <code>&lt;output&gt;</code> Outputs a float value representing the input angle in degrees. <code>Float</code> <p>This shard converts the input angle from radians to degrees. The conversion is done using the formula: degrees = radians * (180 / \u03c0).</p> <p> </p>"},{"location":"reference/shards/shards/Math/Rotation/","title":"Math.Rotation","text":"Name - Description Default Type <code>&lt;input&gt;</code> Takes a float4 vector (a vector with 4 float elements) representing a rotation quaternion. <code>Float4</code> <code>&lt;output&gt;</code> Outputs a 4x4 rotation matrix (a sequence of four float4 vectors). <code>[Float4](4)</code> <p>This shard creates a 4x4 rotation matrix (a sequence of four float4 vectors) from a float4 vector input representing a rotation quaternion. A float4 vector is a vector with 4 float elements.</p> <p> </p>"},{"location":"reference/shards/shards/Math/Round/","title":"Math.Round","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input float or sequence of floats to round. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <code>&lt;output&gt;</code> Outputs the input rounded to the nearest integer (as a float). <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <p>This shard rounds the input floating-point number to the nearest integer.</p>"},{"location":"reference/shards/shards/Math/Round/#examples","title":"Examples","text":"CodeOutput <pre><code>(float3 -0.95 4.0 7.54)\n(Math.Round) (Log)\n\n(Assert.Is (float3 -1.0 4.0 8.0) true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/Math/Scaling/","title":"Math.Scaling","text":"Name - Description Default Type <code>&lt;input&gt;</code> Takes a float3 vector (a vector with 3 float elements) that represents the scaling factors in x, y, and z directions. The first element in the vector being x, the second y and the third z. <code>Float3</code> <code>&lt;output&gt;</code> Outputs a 4x4 scaling matrix (a sequence of four float4 vectors). <code>[Float4](4)</code> <p>This shard creates a 4x4 scaling matrix (a sequence of four float4 vectors) from a float3 vector input that represents the scaling factors in x, y, and z directions. A float4 vector is a vector with 4 float elements while a float3 vector is a vector with 3 float elements.</p> <p> </p>"},{"location":"reference/shards/shards/Math/Sin/","title":"Math.Sin","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input float or sequence of floats to calculate the sine of. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <code>&lt;output&gt;</code> Outputs the sine of the input. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <p>This shard calculates the sine of the given input, where the input is the angle in radians.</p>"},{"location":"reference/shards/shards/Math/Sin/#examples","title":"Examples","text":"CodeOutput <pre><code>(float3 0.0 1.0 1.5707963)\n(Math.Sin) (Log)\n\n(Math.Subtract (float3 0.0 0.84147098 1.0)) (Math.Abs)\n(IsLess (float3 1e-05 1e-05 1e-05)) (Assert.Is true true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/Math/Sinh/","title":"Math.Sinh","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input float or sequence of floats to calculate the hyperbolic sine of. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <code>&lt;output&gt;</code> Outputs the hyperbolic sine of the input. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <p>This shard calculates the hyperbolic sine of the given input, where the input is the real number. The hyperbolic sine is a hyperbolic function that is analogous to the circular sine function, but it uses exponential functions instead of angles.</p>"},{"location":"reference/shards/shards/Math/Sinh/#examples","title":"Examples","text":"CodeOutput <pre><code>(float3 -1.0 0.0 1.0)\n(Math.Sinh) (Log)\n\n(Math.Subtract (float3 -1.1752012 0.0 1.1752012)) (Math.Abs)\n(IsLess (float3 1e-05 1e-05 1e-05)) (Assert.Is true true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/Math/Slerp/","title":"Math.Slerp","text":"Name - Description Default Type <code>&lt;input&gt;</code> Takes a float value between 0 and 1 representing the interpolation factor. <code>Float</code> <code>&lt;output&gt;</code> Outputs a float4 vector representing the interpolated quaternion. <code>Float4</code> <code>First</code> The float4 vector representing the first quaternion to interpolate from. <code>none</code> <code>Float4</code><code>Var(Float4)</code> <code>Second</code> The float4 vector representing the second quaternion to interpolate to. <code>none</code> <code>Float4</code><code>Var(Float4)</code> <p>This shard performs Spherical Linear Interpolation (SLERP) between two quaternions (represented as float4 vectors). It smoothly interpolates between the quaternions specified in the 'First' parameter and 'Second' parameter based on the input interpolation factor. A float4 vector is a vector with 4 float elements.</p> <p> </p>"},{"location":"reference/shards/shards/Math/Sqrt/","title":"Math.Sqrt","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input float or sequence of floats to calculate the square root of. This value must be a positive number or sequence of positive numbers. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <code>&lt;output&gt;</code> Outputs the square root of the input. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <p>This shard calculates the square root of the given input.</p>"},{"location":"reference/shards/shards/Math/Sqrt/#examples","title":"Examples","text":"CodeOutput <pre><code>(float3 1.0 2.0 4.0)\n(Math.Sqrt) (Log)\n\n(Math.Subtract (float3 1.0 1.4142136 2.0)) (Math.Abs)\n(IsLess (float3 1e-05 1e-05 1e-05)) (Assert.Is true true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/Math/Subtract/","title":"Math.Subtract","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value or the sequence of values to subtract the value specified in the Operand parameter from. <code>Int</code><code>Int2</code><code>Int3</code><code>Int4</code><code>Int8</code><code>Int16</code><code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <code>&lt;output&gt;</code> This shard outputs the result of the subtraction. <code>Int</code><code>Int2</code><code>Int3</code><code>Int4</code><code>Int8</code><code>Int16</code><code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <code>Operand</code> The value or sequence of values to subtract from the input. <code>0</code> <code>Int</code><code>Var(Int)</code><code>Int2</code><code>Var(Int2)</code><code>Int3</code><code>Var(Int3)</code><code>Int4</code><code>Var(Int4)</code><code>Int8</code><code>Var(Int8)</code><code>Int16</code><code>Var(Int16)</code><code>Float</code><code>Var(Float)</code><code>Float2</code><code>Var(Float2)</code><code>Float3</code><code>Var(Float3)</code><code>Float4</code><code>Var(Float4)</code><code>Color</code><code>Var(Color)</code><code>[Any]</code><code>Var([Any])</code> <p>This shard subtracts the value provided in the Operand parameter from the input value.</p>"},{"location":"reference/shards/shards/Math/Subtract/#examples","title":"Examples","text":"CodeOutput <pre><code>(int 7)\n(Math.Subtract\n ;:Operand\n 2) (Log)\n\n(Assert.Is 5 true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/Math/TGamma/","title":"Math.TGamma","text":"Name - Description Default Type <code>&lt;input&gt;</code> This shard calculates the gamma function of the given input. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <code>&lt;output&gt;</code> Outputs the gamma function of the input. The output is always positive for positive inputs. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <p>This shard calculates the gamma function of the given input. The gamma function is a mathematical function that extends the concept of factorial to non-integer and complex numbers.</p>"},{"location":"reference/shards/shards/Math/TGamma/#examples","title":"Examples","text":"CodeOutput <pre><code>10.0\n(Math.TGamma) (Log)\n\n(Assert.IsAlmost 362880.0 true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/Math/Tan/","title":"Math.Tan","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input float or sequence of floats to calculate the tangent of. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <code>&lt;output&gt;</code> Outputs the tangent of the input. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <p>This shard calculates the tangent of the given input, where the input is the angle in radians.</p>"},{"location":"reference/shards/shards/Math/Tan/#examples","title":"Examples","text":"CodeOutput <pre><code>(float3 -1.0 0.0 1.0)\n(Math.Tan) (Log)\n\n(Math.Subtract (float3 -1.5574077 0.0 1.5574077)) (Math.Abs)\n(IsLess (float3 1e-05 1e-05 1e-05)) (Assert.Is true true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/Math/Tanh/","title":"Math.Tanh","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input float or sequence of floats to calculate the hyperbolic tangent of. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <code>&lt;output&gt;</code> Outputs the hyperbolic tangent of the input. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <p>This shard calculates the hyperbolic tangent of the given input, where the input is the real number. The hyperbolic tangent is a hyperbolic function that is analogous to the circular tangent function, but it uses exponential functions instead of angles.</p>"},{"location":"reference/shards/shards/Math/Tanh/#examples","title":"Examples","text":"CodeOutput <pre><code>(float3 -1.0 0.0 1.0)\n(Math.Tanh) (Log)\n\n(Math.Subtract (float3 -0.76159416 0.0 0.76159416)) (Math.Abs)\n(IsLess (float3 1e-05 1e-05 1e-05)) (Assert.Is true true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/Math/Translation/","title":"Math.Translation","text":"Name - Description Default Type <code>&lt;input&gt;</code> Takes a float3 vector (a vector with 3 float elements) that represents the translation in x, y, and z directions. The first element in the vector being x, the second y and the third z. <code>Float3</code> <code>&lt;output&gt;</code> Outputs a 4x4 translation matrix (a sequence of four float4 vectors). <code>[Float4](4)</code> <p>This shard creates a 4x4 translation matrix (a sequence of four float4 vectors) from a float3 vector input representing the translation in x, y, and z directions. A float4 vector is a vector with 4 float elements while a float3 vector is a vector with 3 float elements.</p> <p> </p>"},{"location":"reference/shards/shards/Math/Transpose/","title":"Math.Transpose","text":"Name - Description Default Type <code>&lt;input&gt;</code> Takes a matrix (sequence of float2, float3, or float4 vectors) as input. <code>[Float4](4)</code><code>[Float3](3)</code><code>[Float2](2)</code> <code>&lt;output&gt;</code> Outputs the transposed the matrix. <code>[Float4](4)</code><code>[Float3](3)</code><code>[Float2](2)</code> <p>Performs matrix transposition on the input matrix. Transposition flips the matrix over its main diagonal, switching its rows and columns. This shard supports 2x2, 3x3, and 4x4 as input matrices. A 4x4 matrix is a sequence with exactly 4 float4 vectors, a 3x3 matrix is a sequence with exactly 3 float3 vectors, and a 2x2 matrix is a sequence with exactly 2 float2 vectors.</p> <p> </p>"},{"location":"reference/shards/shards/Math/Trunc/","title":"Math.Trunc","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input float or sequence of floats to truncate. <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <code>&lt;output&gt;</code> Outputs the input truncated to the nearest integer (as a float). <code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Color</code><code>[Any]</code> <p>This shard truncates the input floating-point number towards zero, removing any fractional part without rounding.</p>"},{"location":"reference/shards/shards/Math/Trunc/#examples","title":"Examples","text":"CodeOutput <pre><code>(float3 -0.95 4.0 7.54)\n(Math.Trunc) (Log)\n\n(Assert.Is (float3 0 4 7) true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/Math/Unproject/","title":"Math.Unproject","text":"Name - Description Default Type <code>&lt;input&gt;</code> Takes a float3 vector representing the 3D vector where x and y are screen coordinates, and z is the depth value in screen space. <code>Float3</code> <code>&lt;output&gt;</code> Outputs a float3 vector representing the unprojected 3D point in world space. <code>Float3</code> <code>Matrix</code> The combined 4x4 view-projection matrix (sequence of four float4 vectors) to use. <code>none</code> <code>[Float4](4)</code><code>Var([Float4](4))</code> <code>ScreenSize</code> The float2 vector representing the size of the screen or viewport in pixels. <code>none</code> <code>Float2</code><code>Var(Float2)</code> <code>DepthRange</code> The float2 vector representing the range of depth values (near and far planes). Default is [0, 1]. <code>none</code> <code>Float2</code><code>Var(Float2)</code> <code>FlipY</code> Flip Y coordinate (on by default) <code>true</code> <code>Bool</code><code>Var(Var(Bool))</code> <p>This shard converts 2D screen coordinates back to 3D world coordinates using the inverse of a view-projection matrix. Both 3D and 2D coordinates are represented as float3 vectors (vectors with 3 float elements).It performs the reverse operation of the projection pipeline, including inverse matrix multiplication, and coordinate space transformations using the 4x4 view-projection matrix specified in the Matrix parameter and the screen size in the ScreenSize parameter.</p> <p> </p>"},{"location":"reference/shards/shards/Math/Xor/","title":"Math.Xor","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value or the sequence of values to compare the value specified in the Operand parameter with. <code>Int</code><code>Int2</code><code>Int3</code><code>Int4</code><code>Int8</code><code>Int16</code><code>Color</code><code>[Any]</code><code>Bool</code> <code>&lt;output&gt;</code> This shard outputs the value resulting from the XOR operation. <code>Int</code><code>Int2</code><code>Int3</code><code>Int4</code><code>Int8</code><code>Int16</code><code>Color</code><code>[Any]</code><code>Bool</code> <code>Operand</code> The value or sequence of values to compare the input with. <code>0</code> <code>Int</code><code>Int2</code><code>Int3</code><code>Int4</code><code>Int8</code><code>Int16</code><code>Color</code><code>[Any]</code><code>Bool</code><code>Var(Bool)</code> <p>This shard performs a bitwise XOR operation on the input with the value specified in the Operand parameter and outputs the result. A bitwise XOR operation is a binary operation that compares each bit of the binary representations of two numbers and outputs 1 if the bits are different and 0 if they are the same. The shard then outputs a value, whose binary representation is the concatenation of the resulting 1s and 0s from the XOR comparison.</p>"},{"location":"reference/shards/shards/Math/Xor/#examples","title":"Examples","text":"CodeOutput <pre><code>(int4 0 2 4 8)\n(Math.Xor\n ;:Operand\n (int4 3 3 3 3)) (Log)\n\n(Assert.Is (int4 3 1 7 11) true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/Mnemonic/Generate/","title":"Mnemonic.Generate","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Int</code> <code>&lt;output&gt;</code> <code>String</code> <p>Generates a BIP39 mnemonic</p> <p> </p>"},{"location":"reference/shards/shards/Mnemonic/ToSeed/","title":"Mnemonic.ToSeed","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>String</code> <code>&lt;output&gt;</code> <code>Bytes</code> <p>Converts a BIP39 mnemonic to a seed</p> <p> </p>"},{"location":"reference/shards/shards/Network/Broadcast/","title":"Network.Broadcast","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input to broadcast to all connected peers. <code>Any</code> <code>&lt;output&gt;</code> Outputs the input value, passed through unchanged. <code>Any</code> <code>Server</code> The server to send the input to. <code>Var: Network.Server</code> <code>Var(Object)</code> <code>Exclude</code> The list of Peer IDs to exclude from the broadcast. <code>none</code> <code>Var([Int])</code><code>[Int]</code> <p>This shard sends the input to all peers connected to the server (created by Network.Server) specified in the Server parameter.</p> <p> </p>"},{"location":"reference/shards/shards/Network/Client/","title":"Network.Client","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input of this shard is ignored. <code>Any</code> <code>&lt;output&gt;</code> The peer object created. <code>Object</code> <code>Address</code> The local bind address or the remote address. <code>\"localhost\"</code> <code>String</code><code>Var(String)</code> <code>Port</code> The port to bind if server or to connect to if client. <code>9191</code> <code>Int</code><code>Var(Int)</code> <code>Handler</code> The shards to execute when a packet is received. <code>none</code> <code>Shard</code><code>[Shard]</code> <p>This shard creates a UDP client connection using the KCP protocol, on the address and port specified in the Address and Port parameters.</p> <p> </p>"},{"location":"reference/shards/shards/Network/Peer/","title":"Network.Peer","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input of this shard is ignored. <code>Any</code> <code>&lt;output&gt;</code> Outputs the Peer object specified. <code>Object</code> <code>Peer</code> The Peer ID of the Peer object to get. <code>Var: Network.Peer</code> <code>Var(Object)</code> <p>This shard outputs the peer object of the peer with the Peer ID specified in the Peer parameter.</p> <p> </p>"},{"location":"reference/shards/shards/Network/PeerID/","title":"Network.PeerID","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input of this shard is ignored. <code>Any</code> <code>&lt;output&gt;</code> The Peer ID of the peer specified in the Peer parameter. <code>Int</code> <code>Peer</code> The Peer object to get the ID of. <code>Var: Network.Peer</code> <code>Var(Object)</code> <p>This shard outputs the Peer ID of the peer specified in the Peer parameter as an integer.</p> <p> </p>"},{"location":"reference/shards/shards/Network/Send/","title":"Network.Send","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input to send to the peer. <code>Any</code> <code>&lt;output&gt;</code> Outputs the input value, passed through unchanged. <code>Any</code> <code>Peer</code> The optional explicit peer to send packets to. <code>Var: Network.Peer</code> <code>Var(Object)</code> <p>This shard sends the input to the peer specified in the Peer parameter.</p> <p> </p>"},{"location":"reference/shards/shards/Network/SendRaw/","title":"Network.SendRaw","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input to send to the peer. <code>String</code><code>Bytes</code> <code>&lt;output&gt;</code> Outputs the input value, passed through unchanged. <code>Any</code> <code>Peer</code> The optional explicit peer to send packets to. <code>Var: Network.Peer</code> <code>Var(Object)</code> <p>This shard sends the input byte array or string to the peer specified in the Peer parameter.</p> <p> </p>"},{"location":"reference/shards/shards/Network/Server/","title":"Network.Server","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input of this shard is ignored. <code>Any</code> <code>&lt;output&gt;</code> The server object created. <code>Object</code> <code>Address</code> The local bind address or the remote address. <code>\"localhost\"</code> <code>String</code><code>Var(String)</code> <code>Port</code> The port to bind if server or to connect to if client. <code>9191</code> <code>Int</code><code>Var(Int)</code> <code>Handler</code> The wire to spawn for each new peer that connects, stopping that wire will break the connection. <code>none</code> <code>Wire</code> <code>Timeout</code> The timeout in seconds after which a peer will be disconnected if there is no network activity. <code>30</code> <code>Float</code> <code>OnDisconnect</code> The shards to execute when a peer disconnects, The Peer ID will be the input. <code>none</code> <code>Shard</code><code>[Shard]</code> <p>This shard sets up a UDP network server using the KCP protocol, on the address and port specified in the Address and Port parameters. This server then handles client connections and disconnections, messages received from clients and broadcasting messages to these clients.</p> <p> </p>"},{"location":"reference/shards/shards/Network/WS.Client/","title":"Network.WS.Client","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input of this shard is ignored. <code>Any</code> <code>&lt;output&gt;</code> The peer object created. <code>Object</code> <code>Address</code> The local bind address or the remote address. <code>none</code> <code>String</code><code>Var(String)</code> <code>Handler</code> The shards to execute when a packet is received. <code>none</code> <code>Shard</code><code>[Shard]</code> <code>Raw</code> If set to true, the client will receive raw byte packets instead of serialized objects. <code>none</code> <code>Bool</code> <p>This shard creates a WebSocket client connection using the TCP, on the address specified in the Address.</p> <p> </p>"},{"location":"reference/shards/shards/Network/WS.Server/","title":"Network.WS.Server","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input of this shard is ignored. <code>Any</code> <code>&lt;output&gt;</code> The server object created. <code>Object</code> <code>Address</code> The local bind address or the remote address. <code>none</code> <code>String</code><code>Var(String)</code> <code>Port</code> The port to bind if server or to connect to if client. <code>none</code> <code>Int</code><code>Var(Int)</code> <code>Handler</code> The wire to spawn for each new peer that connects, stopping that wire will break the connection. <code>none</code> <code>Wire</code><code>[Shard]</code> <code>Timeout</code> The timeout in seconds after which a peer will be disconnected if there is no network activity. <code>none</code> <code>Float</code> <code>OnDisconnect</code> The shards to execute when a peer disconnects, The Peer ID will be the input. <code>none</code> <code>Shard</code><code>[Shard]</code> <p>This shard sets up a Websocket network server using TCP, on the address and port specified in the Address and Port parameters. This server then handles client connections and disconnections, messages received from clients and broadcasting messages to these clients.</p> <p> </p>"},{"location":"reference/shards/shards/Physics/AngularVelocity/","title":"Physics.AngularVelocity","text":"Name - Description Default Type <code>&lt;input&gt;</code> The physics body to retrieve the angular velocity from. <code>Physics.Body</code> <code>&lt;output&gt;</code> Outputs the angular velocity of the input physics body as a float3. <code>Float3</code> <p>Retrieves the angular velocity of the input physics body</p> <p> </p>"},{"location":"reference/shards/shards/Physics/ApplyForce/","title":"Physics.ApplyForce","text":"Name - Description Default Type <code>&lt;input&gt;</code> The physics body to apply the linear and/or angular force to. <code>Physics.Body</code> <code>&lt;output&gt;</code> Outputs the input physics body with the applied linear and/or angular force. <code>Physics.Body</code> <code>Linear</code> The linear force to apply <code>@f3(0 0 0)</code> <code>Float3</code><code>Var(Float3)</code> <code>Angular</code> The angular force to apply <code>@f3(0 0 0)</code> <code>Float3</code><code>Var(Float3)</code> <p>This shard applies a short instantaneous linear and/or angular force to the input physics body.</p> <p> </p>"},{"location":"reference/shards/shards/Physics/ApplyForceAt/","title":"Physics.ApplyForceAt","text":"Name - Description Default Type <code>&lt;input&gt;</code> The physics body to apply the force to. <code>Physics.Body</code> <code>&lt;output&gt;</code> Outputs the input physics body with the force applied. <code>Physics.Body</code> <code>Force</code> The force to apply represented as a float3 containing the magnitude and direction of the force. <code>@f3(0 0 0)</code> <code>Float3</code><code>Var(Float3)</code> <code>Position</code> The position to apply the force at represented as a float3 <code>@f3(0 0 0)</code> <code>Float3</code><code>Var(Float3)</code> <p>Applies a force to the physics body at a specific location</p> <p> </p>"},{"location":"reference/shards/shards/Physics/ApplyImpulse/","title":"Physics.ApplyImpulse","text":"Name - Description Default Type <code>&lt;input&gt;</code> The physics body to apply the linear and/or angular force to. <code>Physics.Body</code> <code>&lt;output&gt;</code> Outputs the input physics body with the applied linear and/or angular force. <code>Physics.Body</code> <code>Linear</code> The linear force to apply <code>@f3(0 0 0)</code> <code>Float3</code><code>Var(Float3)</code> <code>Angular</code> The angular force to apply <code>@f3(0 0 0)</code> <code>Float3</code><code>Var(Float3)</code> <p>This shard applies a continuous linear and/or angular force to the input physics body.</p> <p> </p>"},{"location":"reference/shards/shards/Physics/Body/","title":"Physics.Body","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input of this shard is ignored. <code>Any</code> <code>&lt;output&gt;</code> Outputs the physics body created by this shard as a physics object that acts as an interface for other physics shard to interact with the body. <code>Physics.Body</code> <code>Location</code> The initial location of the physics object. The variable provided in this parameter is also updated through the physics simulations conducted on this body. Vice versa, the body's location is also updated if the variable's value is changed. <code>none</code> <code>Var(Float3)</code> <code>Rotation</code> The initial rotation of the physics object. The variable provided in this parameter is also updated through the physics simulations conducted on this body. Vice versa, the body's rotation is also updated if the variable's value is changed. <code>none</code> <code>Var(Float4)</code> <code>Static</code> If false, the physics body will be destroyed when the shard is not activated. If true, the body will persist and be included in the physics simulation even if the shard is not activated. <code>false</code> <code>Bool</code> <code>Enabled</code> Can be used to toggle the body on or off if it is a persistent body. If false, the body is temporarily removed from the simulation without destroying it. <code>true</code> <code>Bool</code><code>Var(Bool)</code> <code>Shape</code> The shape of the body. <code>none</code> <code>Var(Physics.Shape)</code> <code>Friction</code> The friction applied when this physics body is in contact with another physics body. <code>0.2</code> <code>Float</code><code>Var(Float)</code> <code>Restitution</code> The bounciness of the body when it collides with another physics body. <code>0</code> <code>Float</code><code>Var(Float)</code> <code>LinearDamping</code> How much linear velocity decays over time. <code>0.05</code> <code>Float</code><code>Var(Float)</code> <code>AngularDamping</code> How much angular velocity decays over time. <code>0.05</code> <code>Float</code><code>Var(Float)</code> <code>MaxLinearVelocity</code> Max linear velocity <code>500</code> <code>Float</code><code>Var(Float)</code> <code>MaxAngularVelocity</code> Max angular velocity <code>47.1239</code> <code>Float</code><code>Var(Float)</code> <code>GravityFactor</code> The gravity factor applied to this body <code>1</code> <code>Float</code><code>Var(Float)</code> <code>AllowedDOFs</code> The translation and rotation axes that the body is allowed to move and rotate around. <code>PhysicsDOF::&lt;invalid&gt;</code> <code>PhysicsDOF</code><code>[PhysicsDOF]</code><code>Var([PhysicsDOF])</code> <code>MotionType</code> Motion type of the body, Dynamic, Kinematic, or Static. <code>PhysicsMotion::Dynamic</code> <code>PhysicsMotion</code><code>Var(PhysicsMotion)</code> <code>CollisionGroup</code> The collision group this body belongs to and which collision groups it is allowed to collide with. The first component in the int2 dictates collision group membership mask, the second part contains a filter mask. <code>@i2(-1 -1)</code> <code>Int2</code><code>Var(Int2)</code> <code>Sensor</code> If true, this physics body will be considered a Sensor. Sensors only detect collisions but do not interact with collided objects (AKA triggers) <code>false</code> <code>Bool</code> <code>Mass</code> Mass of the body. For mass less or equal to 0, default mass calculation is used instead. <code>0</code> <code>Float</code><code>Var(Float)</code> <code>Tag</code> Tag attached to this body for use in collision events. <code>none</code> <code>Any</code> <code>Context</code> The physics context object that is managing the physics simulation. <code>Var: Physics.Context</code> <code>Var(Physics.Context)</code> <p>This shard creates a physics body, conducts physics simulations on this body while updating the relavent variables tied to this body, and creates an interface to allow other physics shards to interact with this body.</p> <p> </p>"},{"location":"reference/shards/shards/Physics/BoxShape/","title":"Physics.BoxShape","text":"Name - Description Default Type <code>&lt;input&gt;</code> The x,y and z half extents of the box collision shape to create. <code>Float3</code> <code>&lt;output&gt;</code> Outputs the created box collision shape. <code>Physics.Shape</code> <p>This shard creates a box collision shape from the input half extents provided.</p> <p> </p>"},{"location":"reference/shards/shards/Physics/CapsuleShape/","title":"Physics.CapsuleShape","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input of this shard is ignored. <code>Any</code> <code>&lt;output&gt;</code> Outputs the created capsule collision shape. <code>Physics.Shape</code> <code>HalfHeight</code> Half the height of the capsule. <code>none</code> <code>Float</code><code>Var(Float)</code> <code>Radius</code> Radius of the capsule. <code>none</code> <code>Float</code><code>Var(Float)</code> <p>This shard creates a capsule physics collision shape, using the height and radius provided in the HalfHeight and Radius parameters respectively. The capsule will be centered around the origin with one sphere cap at (0, -HalfHeight, 0) and the other at (0, HalfHeight, 0).</p> <p> </p>"},{"location":"reference/shards/shards/Physics/CenterOfMass/","title":"Physics.CenterOfMass","text":"Name - Description Default Type <code>&lt;input&gt;</code> The physics body to retrieve the position of the center of mass from. <code>Physics.Body</code> <code>&lt;output&gt;</code> Outputs the position of the center of mass of the input physics body as a float3. <code>Float3</code> <p>Retrieves the position of the center of mass of the input physics body</p> <p> </p>"},{"location":"reference/shards/shards/Physics/Collisions/","title":"Physics.Collisions","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Physics.Body</code> <code>&lt;output&gt;</code> <code>[{other: Physics.Body otherTag: Any penetrationDepth: Float normal: Float3}]</code> <code>Enter</code> The code to execute when a new contact is detected. <code>none</code> <code>[Shard]</code> <code>Leave</code> The code to execute when a contact is removed. <code>none</code> <code>[Shard]</code> <p>Gets the list of current contacts for the input physics body and runs the shards specified when a new contact is detected or when a contact is removed.</p> <p> </p>"},{"location":"reference/shards/shards/Physics/Context/","title":"Physics.Context","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input of this shard is ignored. <code>Any</code> <code>&lt;output&gt;</code> Outputs the physics context object. <code>Physics.Context</code> <p>Creates and initializes the core physics context object that will manage the physics simulation environment.</p> <p> </p>"},{"location":"reference/shards/shards/Physics/DebugDraw/","title":"Physics.DebugDraw","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Any</code> <code>&lt;output&gt;</code> <code>Any</code> <code>Context</code> The context <code>none</code> <code>Var(Physics.Context)</code> <code>DrawConstraints</code> Draw constraints <code>true</code> <code>Bool</code><code>Var(Bool)</code> <code>DrawConstraintLimits</code> Draw constraint limits <code>false</code> <code>Bool</code><code>Var(Bool)</code> <code>DrawConstraintReferenceFrames</code> Draw constraint reference frames <code>false</code> <code>Bool</code><code>Var(Bool)</code> <code>DrawBodies</code> Draw bodies <code>true</code> <code>Bool</code><code>Var(Bool)</code> <code>DrawBodyGetSupportFunction</code> Draw the GetSupport() function, used for convex collision detection <code>false</code> <code>Bool</code><code>Var(Bool)</code> <code>DrawBodySupportDirection</code> When drawing the support function, also draw which direction mapped to a specific support point <code>false</code> <code>Bool</code><code>Var(Bool)</code> <code>DrawBodyGetSupportingFace</code> Draw the faces that were found colliding during collision detection <code>false</code> <code>Bool</code><code>Var(Bool)</code> <code>DrawBodyShape</code> Draw the shapes of all bodies <code>true</code> <code>Bool</code><code>Var(Bool)</code> <code>DrawBodyShapeWireframe</code> When mDrawShape is true and this is true, the shapes will be drawn in wireframe instead of solid. <code>false</code> <code>Bool</code><code>Var(Bool)</code> <code>DrawBodyShapeColor</code> Coloring scheme to use for shapes <code>PhysicsDebugShapeColor::MotionTypeColor</code> <code>PhysicsDebugShapeColor</code><code>Var(PhysicsDebugShapeColor)</code> <code>DrawBodyBoundingBox</code> Draw a bounding box per body <code>false</code> <code>Bool</code><code>Var(Bool)</code> <code>DrawBodyCenterOfMassTransform</code> Draw the center of mass for each body <code>false</code> <code>Bool</code><code>Var(Bool)</code> <code>DrawBodyWorldTransform</code> Draw the world transform (which can be different than the center of mass) for each body <code>false</code> <code>Bool</code><code>Var(Bool)</code> <code>DrawBodyVelocity</code> Draw the velocity vector for each body <code>false</code> <code>Bool</code><code>Var(Bool)</code> <code>DrawBodyMassAndInertia</code> Draw the mass and inertia (as the box equivalent) for each body <code>false</code> <code>Bool</code><code>Var(Bool)</code> <code>DrawBodySleepStats</code> Draw stats regarding the sleeping algorithm of each body <code>false</code> <code>Bool</code><code>Var(Bool)</code> <code>DrawSoftBodyVertices</code> Draw the vertices of soft bodies <code>false</code> <code>Bool</code><code>Var(Bool)</code> <code>DrawSoftBodyVertexVelocities</code> Draw the velocities of the vertices of soft bodies <code>false</code> <code>Bool</code><code>Var(Bool)</code> <code>DrawSoftBodyEdgeConstraints</code> Draw the edge constraints of soft bodies <code>false</code> <code>Bool</code><code>Var(Bool)</code> <code>DrawSoftBodyBendConstraints</code> Draw the bend constraints of soft bodies <code>false</code> <code>Bool</code><code>Var(Bool)</code> <code>DrawSoftBodyVolumeConstraints</code> Draw the volume constraints of soft bodies <code>false</code> <code>Bool</code><code>Var(Bool)</code> <code>DrawSoftBodySkinConstraints</code> Draw the skin constraints of soft bodies <code>false</code> <code>Bool</code><code>Var(Bool)</code> <code>DrawSoftBodyLRAConstraints</code> Draw the LRA constraints of soft bodies <code>false</code> <code>Bool</code><code>Var(Bool)</code> <code>DrawSoftBodyPredictedBounds</code> Draw the predicted bounds of soft bodies <code>false</code> <code>Bool</code><code>Var(Bool)</code> <code>DrawSoftBodyConstraintColor</code> Coloring scheme to use for soft body constraints <code>PhysicsDebugSoftBodyConstraintColor::ConstraintType</code> <code>PhysicsDebugSoftBodyConstraintColor</code><code>Var(PhysicsDebugSoftBodyConstraintColor)</code>"},{"location":"reference/shards/shards/Physics/DistanceConstraint/","title":"Physics.DistanceConstraint","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Any</code> <code>&lt;output&gt;</code> <code>Any</code> <code>FirstBody</code> The first body, keep unset to attach to the fixed world <code>none</code> <code>Var(Physics.Body)</code> <code>SecondBody</code> The second body, keep unset to attach to the fixed world <code>none</code> <code>Var(Physics.Body)</code> <code>Static</code> Static node, persist when not activated <code>false</code> <code>Bool</code> <code>Enabled</code> Can be used to toggle this node when it has static persistence <code>true</code> <code>Bool</code><code>Var(Bool)</code> <code>Space</code> This determines in which space the constraint is setup, all other properties should be in the specified space <code>ConstraintSpace::LocalToBodyCOM</code> <code>ConstraintSpace</code> <code>FirstPoint</code> The position of the connection point for the first body. <code>@f3(0 0 0)</code> <code>Float3</code><code>Var(Float3)</code> <code>SecondPoint</code> The position of the connection point for the second body. <code>@f3(0 0 0)</code> <code>Float3</code><code>Var(Float3)</code> <code>MinDistance</code> Minimum distance between the two points. If the value is negative, it will be replaced by the distance between FirstPoint and SecondPoint (works only if Space is world space) <code>-1</code> <code>Float</code><code>Var(Float)</code> <code>MaxDistance</code> Maximum distance between the two points. If the value is negative, it will be replaced by the distance between FirstPoint and SecondPoint (works only if Space is world space) <code>-1</code> <code>Float</code><code>Var(Float)</code> <code>LimitSpring</code> When set, makes the limits soft <code>{damping: 1 frequency: 0}</code> <code>{frequency: Float damping: Float}</code><code>{stiffness: Float damping: Float}</code><code>Var({frequency: Float damping: Float})</code><code>Var({stiffness: Float damping: Float})</code> <p>This shard creates a tether between two bodies, keeping the distance between them within the range specified in the MinDistance and MaxDistance parameters.</p> <p> </p>"},{"location":"reference/shards/shards/Physics/Dump/","title":"Physics.Dump","text":"Name - Description Default Type <code>&lt;input&gt;</code> Any input type is accepted. The input value will pass through unchanged. <code>Any</code> <code>&lt;output&gt;</code> Outputs the input value, passed through unchanged. <code>Any</code> <code>Context</code> The context <code>none</code> <code>Var(Physics.Context)</code> <p>Logs information about the current state of the physics simulation in the console.</p> <p> </p>"},{"location":"reference/shards/shards/Physics/End/","title":"Physics.End","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Any</code> <code>&lt;output&gt;</code> <code>Any</code> <code>Context</code> The physics context object that will manage the simulation <code>none</code> <code>Var(Physics.Context)</code> <code>TimeStep</code> The amount of simulated time that will elapse during each call to this shard. <code>0.0166667</code> <code>Float</code><code>Var(Float)</code> <code>MaxIterations</code> Maximum number of iterations to run the simulation. A higher number will result in a more accurate simulation, but will take more time to compute. <code>1</code> <code>Int</code><code>Var([Int])</code> <p>This shard runs the physics simulation. It should be called after defining physics bodies to be included in the simulation.</p> <p> </p>"},{"location":"reference/shards/shards/Physics/FixedConstraint/","title":"Physics.FixedConstraint","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Any</code> <code>&lt;output&gt;</code> <code>Any</code> <code>FirstBody</code> The first body, keep unset to attach to the fixed world <code>none</code> <code>Var(Physics.Body)</code> <code>SecondBody</code> The second body, keep unset to attach to the fixed world <code>none</code> <code>Var(Physics.Body)</code> <code>Static</code> Static node, persist when not activated <code>false</code> <code>Bool</code> <code>Enabled</code> Can be used to toggle this node when it has static persistence <code>true</code> <code>Bool</code><code>Var(Bool)</code> <code>Space</code> This determines in which space the constraint is setup, all other properties should be in the specified space <code>ConstraintSpace::WorldSpace</code> <code>ConstraintSpace</code> <code>FirstReferenceFrame</code> The rotation and position of the connection point for the first body. <code>[@f4(1 0 0 0) @f4(0 1 0 0) @f4(0 0 1 0) @f4(0 0 0 1)]</code> <code>[Float4](4)</code><code>Var([Float4](4))</code> <code>SecondReferenceFrame</code> The rotation and position of the connection point for the second body. <code>[@f4(1 0 0 0) @f4(0 1 0 0) @f4(0 0 1 0) @f4(0 0 0 1)]</code> <code>[Float4](4)</code><code>Var([Float4](4))</code> <code>AutoDetectPoint</code> When the Space parameter is set to World space, the connection points will be automatically set to the current rotation and position of the two bodies. <code>true</code> <code>Bool</code><code>Var(Bool)</code> <p>This shard rigidly connects two physics bodies together. When forces are applied to either body, they react as if they were a single rigid object.</p> <p> </p>"},{"location":"reference/shards/shards/Physics/HullShape/","title":"Physics.HullShape","text":"Name - Description Default Type <code>&lt;input&gt;</code> A GFX mesh or drawable object. <code>GFX.Mesh</code><code>GFX.Drawable</code> <code>&lt;output&gt;</code> Outputs the created physics collisionshape. <code>Physics.Shape</code> <code>MaxConvexRadius</code> The convex radius given to the collision shape. A larger convex radius results in better performance but a less accurate simulation. A convex radius of 0 is allowed <code>0.05</code> <code>Float</code><code>Var(Float)</code> <p>Creates a physics shape from a GFX mesh or drawable input</p> <p> </p>"},{"location":"reference/shards/shards/Physics/InverseMass/","title":"Physics.InverseMass","text":"Name - Description Default Type <code>&lt;input&gt;</code> The physics body to retrieve the inverse mass from. <code>Physics.Body</code> <code>&lt;output&gt;</code> Outputs the inverse mass of the input physics body as a float. <code>Float</code> <p>Retrieves the inverse mass of the input physics body. The inverse mass is 1.0 divided by the mass of the input physics body.</p> <p> </p>"},{"location":"reference/shards/shards/Physics/LinearVelocity/","title":"Physics.LinearVelocity","text":"Name - Description Default Type <code>&lt;input&gt;</code> The physics body to retrieve the linear velocity from. <code>Physics.Body</code> <code>&lt;output&gt;</code> Outputs the linear velocity of the input physics body as a float3. <code>Float3</code> <p>Retrieves the linear velocity of the input physics body</p> <p> </p>"},{"location":"reference/shards/shards/Physics/Location/","title":"Physics.Location","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Physics.Body</code> <code>&lt;output&gt;</code> <code>Float3</code> <p>Retrieves the position of the physics body</p> <p> </p>"},{"location":"reference/shards/shards/Physics/MotionType/","title":"Physics.MotionType","text":"Name - Description Default Type <code>&lt;input&gt;</code> The physics body to retrieve the motion type from. <code>Physics.Body</code> <code>&lt;output&gt;</code> Outputs the motion type of the input physics body. <code>PhysicsMotion</code> <p>Retrieves the motion type of the input physics body</p> <p> </p>"},{"location":"reference/shards/shards/Physics/Rotation/","title":"Physics.Rotation","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Physics.Body</code> <code>&lt;output&gt;</code> <code>Float4</code> <p>Retrieves the rotation of the physics body</p> <p> </p>"},{"location":"reference/shards/shards/Physics/SetPose/","title":"Physics.SetPose","text":"Name - Description Default Type <code>&lt;input&gt;</code> The physics body to overwrite the position and/or rotation of. <code>Physics.Body</code> <code>&lt;output&gt;</code> Outputs the input physics body with the overwritten position and/or rotation. <code>Physics.Body</code> <code>Linear</code> The position to set <code>none</code> <code>Float3</code><code>Var(Float3)</code> <code>Angular</code> The rotation to set <code>none</code> <code>Float4</code><code>Var(Float4)</code> <p>Overwrites the position and/or rotation of the input physics body.</p> <p> </p>"},{"location":"reference/shards/shards/Physics/SetVelocity/","title":"Physics.SetVelocity","text":"Name - Description Default Type <code>&lt;input&gt;</code> The physics body to overwrite the linear and/or angular velocity of. <code>Physics.Body</code> <code>&lt;output&gt;</code> Outputs the input physics body with the overwritten linear and/or angular velocity. <code>Physics.Body</code> <code>Linear</code> The linear velocity to set <code>none</code> <code>Float3</code><code>Var(Float3)</code> <code>Angular</code> The angular velocity to set <code>none</code> <code>Float3</code><code>Var(Float3)</code> <p>Overwrites the linear and/or angular velocity of the input physics body</p> <p> </p>"},{"location":"reference/shards/shards/Physics/SliderConstraint/","title":"Physics.SliderConstraint","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Any</code> <code>&lt;output&gt;</code> <code>Any</code> <code>FirstBody</code> The first body, keep unset to attach to the fixed world <code>none</code> <code>Var(Physics.Body)</code> <code>SecondBody</code> The second body, keep unset to attach to the fixed world <code>none</code> <code>Var(Physics.Body)</code> <code>Static</code> Static node, persist when not activated <code>false</code> <code>Bool</code> <code>Enabled</code> Can be used to toggle this node when it has static persistence <code>true</code> <code>Bool</code><code>Var(Bool)</code> <code>Space</code> This determines in which space the constraint is setup, all other properties should be in the specified space <code>ConstraintSpace::LocalToBodyCOM</code> <code>ConstraintSpace</code> <code>FirstPoint</code> The position of the connection point for the first body. <code>@f3(0 0 0)</code> <code>Float3</code><code>Var(Float3)</code> <code>SecondPoint</code> The position of the connection point for the second body. <code>@f3(0 0 0)</code> <code>Float3</code><code>Var(Float3)</code> <code>SliderAxis</code> Axis along which movement is possible. <code>@f3(1 0 0)</code> <code>Float3</code><code>Var(Float3)</code> <code>NormalAxis</code> Vector perpendicular to the slider axis, to define the frame <code>@f3(0 1 0)</code> <code>Float3</code><code>Var(Float3)</code> <code>LimitsMin</code> The maximum distance the slider can move in the negative direction. <code>1.17549e-38</code> <code>Float</code><code>Var(Float)</code> <code>LimitsMax</code> The maximum distance the slider can move in the positive direction. <code>3.40282e+38</code> <code>Float</code><code>Var(Float)</code> <code>LimitSpring</code> When set, makes the limits soft. <code>{damping: 1 frequency: 0}</code> <code>{frequency: Float damping: Float}</code><code>{stiffness: Float damping: Float}</code><code>Var({frequency: Float damping: Float})</code><code>Var({stiffness: Float damping: Float})</code> <code>MaxFrictionForce</code> Maximum amount of friction force to apply (in Newtons) on the slider. <code>0</code> <code>Float</code><code>Var(Float)</code> <code>MotorSettings</code> Defines the maximum and minimum amount of force of the motor applied to the slider. <code>{maxForceLimit: 3.40282e+38 maxTorqueLimit: 3.40282e+38 minForceLimit: 1.17549e-38 minTorqueLimit: 1.17549e-38}</code> <code>{minForceLimit: Float maxForceLimit: Float minTorqueLimit: Float maxTorqueLimit: Float}</code><code>Var({minForceLimit: Float maxForceLimit: Float minTorqueLimit: Float maxTorqueLimit: Float})</code> <code>MotorSpringSettings</code> Defines the Motor spring settings applied on the slider <code>{damping: 1 frequency: 0}</code> <code>{frequency: Float damping: Float}</code><code>{stiffness: Float damping: Float}</code><code>Var({frequency: Float damping: Float})</code><code>Var({stiffness: Float damping: Float})</code> <p>This shard creates a slider constraint between two bodies, turning the two bodies into sliders that can slide along the axis specified in the SliderAxis parameter.</p> <p> </p>"},{"location":"reference/shards/shards/Physics/SoftBody/","title":"Physics.SoftBody","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Any</code> <code>&lt;output&gt;</code> <code>Physics.Body</code> <code>Location</code> The initial location, updated by physics simulation <code>none</code> <code>Var(Float3)</code> <code>Rotation</code> The initial location, updated by physics simulation <code>none</code> <code>Var(Float4)</code> <code>Static</code> Static node, persist when not activated <code>false</code> <code>Bool</code> <code>Enabled</code> Can be used to toggle this node when it has static persistence <code>true</code> <code>Bool</code><code>Var(Bool)</code> <code>Shape</code> The shape of the body <code>none</code> <code>Var(Physics.SoftBodyShape)</code> <code>Friction</code> <code>0.2</code> <code>Float</code><code>Var(Float)</code> <code>Restitution</code> Restitution coefficient <code>0</code> <code>Float</code><code>Var(Float)</code> <code>LinearDamping</code> Linear damping coefficient <code>0.05</code> <code>Float</code><code>Var(Float)</code> <code>MaxLinearVelocity</code> Max linear velocity <code>500</code> <code>Float</code><code>Var(Float)</code> <code>GravityFactor</code> Gravity factor <code>1</code> <code>Float</code><code>Var(Float)</code> <code>Pressure</code> Pressure <code>0</code> <code>Float</code><code>Var(Float)</code> <code>CollisionGroup</code> Collision filtering type (the first component contains group membership mask, the second part contains a filter mask)If any bits match the filter of the other, the two objects will collide <code>@i2(-1 -1)</code> <code>Int2</code><code>Var(Int2)</code> <code>Tag</code> Tag for the body used in collision events <code>none</code> <code>Any</code> <code>Context</code> The physics context <code>Var: Physics.Context</code> <code>Var(Physics.Context)</code> <p>Defines a new node</p> <p> </p>"},{"location":"reference/shards/shards/Physics/SoftBodyShape/","title":"Physics.SoftBodyShape","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>GFX.Mesh</code><code>GFX.Drawable</code> <code>&lt;output&gt;</code> <code>Physics.SoftBodyShape</code> <code>Compliance</code> Compliance <code>0.0001</code> <code>Float</code><code>Var(Float)</code> <code>ShearCompliance</code> Shear compliance <code>0.0001</code> <code>Float</code><code>Var(Float)</code> <code>BendCompliance</code> Bend compliance <code>0.001</code> <code>Float</code><code>Var(Float)</code>"},{"location":"reference/shards/shards/Physics/SphereShape/","title":"Physics.SphereShape","text":"Name - Description Default Type <code>&lt;input&gt;</code> The radius of the sphere collision shape to create. <code>Float</code> <code>&lt;output&gt;</code> Outputs the created sphere collision shape. <code>Physics.Shape</code> <p>Create a sphere collision shape, from the input radius provided.</p> <p> </p>"},{"location":"reference/shards/shards/Physics/WithContext/","title":"Physics.WithContext","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Any</code> <code>&lt;output&gt;</code> <code>Any</code> <code>Contents</code> The contents to run with the context in scope <code>none</code> <code>[Shard]</code> <code>Context</code> The context <code>none</code> <code>Var(Physics.Context)</code>"},{"location":"reference/shards/shards/Process/Exe/","title":"Process.Exe","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>&lt;output&gt;</code> <code>String</code> <p>Gives the current executable path.</p> <p> </p>"},{"location":"reference/shards/shards/Process/Run/","title":"Process.Run","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>String</code> <code>&lt;output&gt;</code> <code>String</code> <code>Executable</code> The executable to run. <code>none</code> <code>Path</code><code>Var(Path)</code><code>String</code><code>Var(String)</code> <code>Arguments</code> The arguments to pass to the executable. <code>none</code> <code>[String]</code><code>Var([String])</code> <code>Timeout</code> The maximum time to wait for the executable to finish in seconds. <code>none</code> <code>Int</code>"},{"location":"reference/shards/shards/Process/StackTrace/","title":"Process.StackTrace","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>&lt;output&gt;</code> <code>String</code>"},{"location":"reference/shards/shards/Random/Name/","title":"Random.Name","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>&lt;output&gt;</code> <code>String</code> <code>Words</code> How many words to generate and concatenate <code>2</code> <code>Int</code> <code>Separator</code> A separator character to use between generated words <code>\"-\"</code> <code>String</code> <p>Generate a random name (Petname)</p> <p> </p>"},{"location":"reference/shards/shards/Reflect/Get/","title":"Reflect.Get","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>&lt;output&gt;</code> <code>Any</code> <code>Variable Name</code> The name of the variable to get <code>none</code> <code>Var(String)</code> <p>Gets a variable dynamically by name. Returns None if the variable doesn't exist.</p> <p> </p>"},{"location":"reference/shards/shards/Reflect/Name/","title":"Reflect.Name","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Shard</code> <code>&lt;output&gt;</code> <code>String</code>"},{"location":"reference/shards/shards/Reflect/Shards/","title":"Reflect.Shards","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Wire</code> <code>&lt;output&gt;</code> <code>[Shard]</code> <p>Given a wire as input it will recurse deep inside it and gather all shards in the wire, its sub-wires and sub-flows.</p> <p> </p>"},{"location":"reference/shards/shards/Regex/Match/","title":"Regex.Match","text":"Name - Description Default Type <code>&lt;input&gt;</code> The string to match. <code>String</code> <code>&lt;output&gt;</code> Outputs either a sequence of strings, containing the fully matched string and any capture groups or an empty sequence if there are no matches. <code>[String]</code> <code>Regex</code> The regular expression as a string. <code>\"\"</code> <code>String</code> <p>This shard matches the entire input string against the regex pattern specified in the Regex parameter and outputs a sequence of strings, containing the fully matched string and any capture groups. It will return an empty sequence if there are no matches.</p> <p> </p>"},{"location":"reference/shards/shards/Regex/Replace/","title":"Regex.Replace","text":"Name - Description Default Type <code>&lt;input&gt;</code> The string to modify. <code>String</code> <code>&lt;output&gt;</code> The input string with all occurrences of the regex pattern replaced with the replacement string. <code>String</code> <code>Regex</code> The regular expression as a string. <code>\"\"</code> <code>String</code> <code>Replacement</code> The regex replacement expression. <code>none</code> <code>String</code><code>Var(String)</code> <p>This shard modifies the input string by replacing all occurrences of the regex pattern, specified in the Regex parameter, with the replacement string specified in the Replacement parameter.</p> <p> </p>"},{"location":"reference/shards/shards/Regex/Search/","title":"Regex.Search","text":"Name - Description Default Type <code>&lt;input&gt;</code> The string to search. <code>String</code> <code>&lt;output&gt;</code> A sequence of strings, each containing one occurrence of the regex pattern. <code>[String]</code> <code>Regex</code> The regular expression as a string. <code>\"\"</code> <code>String</code> <p>This shard searches the input string for the regex pattern specified in the Regex parameter and outputs a sequence of strings, containing every occurrence of the pattern. An empty sequence is returned if there are no matches</p> <p> </p>"},{"location":"reference/shards/shards/SVG/ToImage/","title":"SVG.ToImage","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>String</code><code>Bytes</code> <code>&lt;output&gt;</code> <code>Image</code> <code>Size</code> The desired output size, if (0, 0) will default to the size defined in the svg data. <code>none</code> <code>Int2</code><code>Var(Int2)</code> <code>Offset</code> A positive x and y value offsets towards the right and the bottom of the screen respectively. (0.0, 0.0) by default. <code>none</code> <code>Float2</code><code>Var(Float2)</code> <code>Padding</code> Pixels of padding to add <code>none</code> <code>Int2</code> <p>Converts an SVG string or bytes to an image.</p> <p> </p>"},{"location":"reference/shards/shards/Shader/","title":"Shaders","text":"<p>Shaders are written using a subset of the regular shards language, in addition to some of the shader specific shards listed here.</p>"},{"location":"reference/shards/shards/Shader/#supported-operations","title":"Supported operations","text":""},{"location":"reference/shards/shards/Shader/#variables","title":"Variables","text":"<pre><code>0.0 &gt;= .float-var ; Set\n3.14 &gt; .float-var ; Update\n1.0 = .const-var ; Constant\n</code></pre>"},{"location":"reference/shards/shards/Shader/#vector-types","title":"Vector types","text":"<pre><code>(Float3 0.0) &gt;= .v3-zero\n(Float3 1.0 0.0 0.0) &gt;= .v3-forward\n</code></pre>"},{"location":"reference/shards/shards/Shader/#vector-swizzles","title":"Vector swizzles","text":"<pre><code>.v3-forward (Take 0) &gt;= .x\n.v3-forward (Take [2 1 0]) &gt;= .v3-reversed\n.v3-forward (Take [2 1]) &gt;= .v2-zy\n</code></pre>"},{"location":"reference/shards/shards/Shader/#sub-flow","title":"Sub flow","text":"<pre><code>.v3-forward\n(| (Take 0) &gt;= .x)\n(| (Take 1) &gt;= .y)\n(| (Take 2) &gt;= .z)\n</code></pre>"},{"location":"reference/shards/shards/Shader/#push-for-matrix-types-only","title":"Push (for matrix types only)","text":"<p>Push works for building matrix types out of vectors, but with the constraint that you can't push from within branching control flows.</p> <pre><code>(Float4 1.0 0.0 0.0 0.0) &gt;&gt; .mat\n(Float4 0.0 1.0 0.0 0.0) &gt;&gt; .mat\n(Float4 0.0 0.0 1.0 0.0) &gt;&gt; .mat\n(Float4 0.0 0.0 0.0 1.0) &gt;&gt; .mat\n.mat ; this evaluates to a float4x4 when used in expressions\n</code></pre>"},{"location":"reference/shards/shards/Shader/#scalar-an-vector-maths","title":"Scalar an vector maths","text":"<pre><code>(Float3 ...) &gt;= .v3\n\n4.0 (Math.Cos) &gt;= .cos-4\n.cos-4 (Math.Sin) &gt;= .cos-sin-4\n(Math.Floor) &gt;= .floored-result\n\n.v3 (Math.Multiply 2.0) &gt;=. v3-multiplied\n.v3 (Math.Add 1.0) &gt;=. v3-plus-one\n.v3 (Math.Add (Float3 1.0 -1.0 0.0)) &gt;=. v3-adjusted\n\n.v3 (Math.Normalize) &gt;= .v3-normalized\n.v3 (Math.Length) &gt;= .length\n.v3 (Math.Dot .v3) &gt;= .dot-product\n.v3 (Math.Cross .v3) &gt;= .v3-cross\n</code></pre>"},{"location":"reference/shards/shards/Shader/#number-conversions","title":"Number conversions","text":"<pre><code>3.3 (ToInt) &gt;= .int-var ; (3)\n3.3 (ToFloat4) &gt;= .v4-var ; (Float4 3.3 0.0 0.0 0.0)\n\n(Float3 1.0 2.0 3.0) (ToFloat) &gt;= .float-var ; (1.0)\n\n(Float3 0.0 .float-var .float-var) &gt;= .v3 ; (0.0 1.0 1.0)\n</code></pre>"},{"location":"reference/shards/shards/Shader/#vector-contructors","title":"Vector contructors","text":"<pre><code>1.0 = .float-var\n(Float3 0.0 .float-var .float-var) &gt;= .v3 ; (0.0 1.0 1.0)\n(Float4 .float-var 0.0 4.0 .float-var) &gt;= .v4 ; (1.0 0.0 4.0 1.0)\n</code></pre>"},{"location":"reference/shards/shards/Shader/#matrix-multiplication","title":"Matrix multiplication","text":"<pre><code>(Float3 ...) &gt;&gt; .mat-0\n(Float3 ...) &gt;&gt; .mat-0\n...\n(Float3 ...) &gt;&gt; .mat-1\n(Float3 ...) &gt;&gt; .mat-1\n...\n(Float3 ...) &gt;= .v3\n\n; Matrix * Matrix = Matrix\n.mat-0 (Math.MatMul .mat-1) &gt;= .mat-2\n\n; Matrix * Vector = Vector\n.mat-2 (Math.MatMul .v3) &gt;= .v3-transformed\n</code></pre>"},{"location":"reference/shards/shards/Shader/#comparisons","title":"Comparisons","text":"<pre><code>3.4 (IsMoreEqual 3.0) &gt;= .bool ; (true)\n3.4 (IsLess 3.0) &gt; .bool ; (false)\n</code></pre>"},{"location":"reference/shards/shards/Shader/#branches","title":"Branches","text":"<pre><code>3.4 = .v\n.v (If (IsLess 3.0)\n      :Then (-&gt; ...)\n      :Else (-&gt; ...))\n\n.v (When (IsLess 3.0)\n      (-&gt; ...))\n\n.v (When (-&gt; (IsLess 3.0) (And) (IsGreater 1.0))\n      (-&gt; ...))\n</code></pre>"},{"location":"reference/shards/shards/Shader/#combinational-logic","title":"Combinational logic","text":"<pre><code>3.4 = .v\n.v (When (-&gt; (IsLess 3.0) (And) (IsGreater 1.0))\n      (-&gt; ...))\n.v (When (-&gt; (IsLess 3.0) (Or) (IsGreater 1.0))\n      (-&gt; ...))\n</code></pre>"},{"location":"reference/shards/shards/Shader/#for-range-loop","title":"For range loop","text":"<pre><code>(ForRange 0 32 (-&gt;\n  = .i\n  ...\n  ))\n</code></pre>"},{"location":"reference/shards/shards/Shader/#function-like-wire-evaluation","title":"Function-like wire evaluation","text":"<p>Pure Wires are supported. They can be run using <code>Do</code> and passing an input as a scalar/vector/matrix type. Their output is returned.</p> <pre><code>(defpure rotation-matrix\n  &gt;= .input\n  .input (Math.Cos) &gt;= .c\n  .input (Math.Sin)\n  (| &gt;= .s)\n  (| (Math.Negate) &gt;= .neg-s)\n  (Float2 .c .s) &gt;&gt; .result\n  (Float2 .neg-s .c) &gt;&gt; .result\n  .result ; Output a 2x2 matrix\n)\n\n0.45 (Do rotation-matrix) &gt;= .mat2-2 ; This will contain the result from the wire\n</code></pre> <p>Non-pure Wires are also supported. They will accept an input value and return their output. In addition they will also capture any variables referenced that are defined in parent Wires.</p> <pre><code>(defwire sub-logic\n  .global (Math.Cos) &gt;= .v\n  2.0 (Math.Add .v)\n)\n\n3.0 &gt;== .global\n(Do sub-logic) &gt;= .v1\n2.0 &gt; .global\n(Do sub-logic) &gt;= .v2\n</code></pre> <p>Partial support</p> <p>Currently, only values that are read from parent Wires are supported. Trying to update a variable defined in a parent Wire will have no effect on that variable.</p> <p> </p>"},{"location":"reference/shards/shards/Shader/LinearizeDepth/","title":"Shader.LinearizeDepth","text":"Name - Description Default Type <code>&lt;input&gt;</code> The non-linear depth value to convert. <code>Float</code> <code>&lt;output&gt;</code> The linear depth value. <code>Float</code> <p>This shard converts non-linear depth buffer values to linear depth value.</p> <p> </p>"},{"location":"reference/shards/shards/Shader/Literal/","title":"Shader.Literal","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input of this shard is ignored. <code>&lt;output&gt;</code> This shard outputs the type set in the OutputType parameter. <code>Any</code> <code>Source</code> The WGSL source code to insert <code>none</code> <code>String</code><code>Var(String)</code><code>[String Var(Any)]</code> <code>Type</code> Where to insert the code. <code>none</code> <code>ShaderLiteralType</code> <code>OutputType</code> The type that this code is expected to output. (default: none) <code>none</code> <code>ShaderFieldBaseType</code> <code>OutputDimension</code> The dimension that this code is expected to output. (default: 4) <code>none</code> <code>Int</code> <code>OutputMatrixDimension</code> The matrix dimension that this code is expected to output. (default: 1) <code>none</code> <code>Int</code> <p>This shard allows the user to write WGSL code directly and insert it into the shader code. The WGSL code is written as a sequence of strings in the Source parameter.</p>"},{"location":"reference/shards/shards/Shader/Literal/#details","title":"Details","text":"<p>This shards inserts WGSL source code directly into the generated shader. This can be usefull to reuse large existing shader code bases.</p>"},{"location":"reference/shards/shards/Shader/Literal/#usages","title":"Usages","text":"<p>There are multiple ways to use this shard.</p>"},{"location":"reference/shards/shards/Shader/Literal/#static-code","title":"Static code","text":"<pre><code>  (Shader.Literal :Source \"\n    let color = vec4&lt;f32&gt;(1.0, 0.5, 0.25, 1.0);\n    return color; \")\n</code></pre> <p>This insertes the given WGSL source code directly into the current entry point.</p>"},{"location":"reference/shards/shards/Shader/Literal/#static-header-code","title":"Static header code","text":"<p>When defining WGSL functions, specify the <code>:Type ShaderLiteralType.Header</code> parameter:</p> <pre><code>  (Shader.Literal :Type ShaderLiteralType.Header :Source \"\n    fn scale(val: f32) -&gt; f32 {\n      return val * 0.5;\n    }\")\n</code></pre> <p>The generated code will then be placed outside the current entry point where it can be referenced by all other entry points as well.</p>"},{"location":"reference/shards/shards/Shader/Literal/#output-value","title":"Output value","text":"<p>When a Literal shard is expected to output a value, you need to specify the output type and dimensions.</p> <p>For example, returning the value from calling the function defined in the previous section:</p> <pre><code>  (Shader.Literal :Source \"scale(1.0)\" :OutputType ShaderFieldBaseType.Float32 :OutputDimension 1)\n  &gt;= .result ; This will now contain the Float scalar result\n</code></pre> <p><code>OutputMatrixDimension</code> can also be specified when returning matrix types, a value of 1 (default) indicates that the type is not a matrix. <code>mat4x3</code> would be represented by an <code>OutputDimension</code> of 4 and <code>MatrixDimension</code> of 3.</p> <p>The default value for <code>OutputDimension</code> is 4, so it can be left unspecified when returning 4 component vectors.</p>"},{"location":"reference/shards/shards/Shader/Literal/#capturing-variables","title":"Capturing variables","text":"<p>To pass existing variables into WGSL code, use the folowing structure:</p> <pre><code>  1.0 &gt;= .my-value\n  (Shader.Literal :Source [\"scale(\" .my-value \")\"])\n</code></pre> <p>When the source is a sequence, any variable references inside this sequence will be inserted into the genereted WGSL code.</p>"},{"location":"reference/shards/shards/Shader/Literal/#more-info","title":"More Info","text":"<p>For more information about the WebGPU Shading Language (WGSL), check the working draft here.</p> <p>For converting existing GLSL or SPIR-V shaders to WGSL, naga can be used.</p> <p> </p>"},{"location":"reference/shards/shards/Shader/ReadBuffer/","title":"Shader.ReadBuffer","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input of this shard is ignored. <code>&lt;output&gt;</code> The value of the parameter in the buffer specified. <code>Name</code> The name of the parameter to read <code>\"\"</code> <code>String</code> <code>BufferName</code> The name of the buffer to read from. (either view buffer or object buffer.) <code>\"\"</code> <code>String</code> <p>This shard reads the shader parameter (specified in the Name parameter) from the buffer (specified in the Buffer Name parameter).</p> <p> </p>"},{"location":"reference/shards/shards/Shader/ReadGlobal/","title":"Shader.ReadGlobal","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input of this shard is ignored. <code>&lt;output&gt;</code> The value of the global variable specified. <code>Name</code> The name of global shader variable to read. <code>\"\"</code> <code>String</code> <p>This shard reads the value of the global shader variable specified in the Name parameter.</p> <p> </p>"},{"location":"reference/shards/shards/Shader/ReadInput/","title":"Shader.ReadInput","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input of this shard is ignored. <code>&lt;output&gt;</code> The value of the  specified shader input. <code>Name</code> The name of the shader input to read. <code>\"\"</code> <code>String</code> <p>This shard reads the value of the shader input specified in the Name parameter.</p> <p> </p>"},{"location":"reference/shards/shards/Shader/RefBuffer/","title":"Shader.RefBuffer","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Any</code> <code>&lt;output&gt;</code> <code>GFX.Buffer</code> <code>Name</code> The name of the buffer <code>none</code> <code>String</code> <code>Pointer</code> Reference as pointer <code>none</code> <code>Bool</code> <p>Outputs a reference to the default sampler object for a named texture.</p> <p> </p>"},{"location":"reference/shards/shards/Shader/RefSampler/","title":"Shader.RefSampler","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Any</code> <code>&lt;output&gt;</code> <code>GFX.Sampler</code> <code>Name</code> Name of the texture <code>none</code> <code>String</code><code>Var(String)</code> <p>Outputs a reference to the default sampler object for a named texture.</p> <p> </p>"},{"location":"reference/shards/shards/Shader/RefTexture/","title":"Shader.RefTexture","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Any</code> <code>&lt;output&gt;</code> <code>GFX.Texture2D</code><code>GFX.TextureCube</code> <code>Name</code> Name of the texture <code>none</code> <code>String</code><code>Var(String)</code> <p>Outputs a reference to the texture object for a named texture.</p> <p> </p>"},{"location":"reference/shards/shards/Shader/SampleTexture/","title":"Shader.SampleTexture","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>&lt;output&gt;</code> <code>Float4</code> <code>Name</code> Name of the texture <code>none</code> <code>String</code><code>Var(String)</code> <p>Samples a named texture with default texture coordinates</p> <p> </p>"},{"location":"reference/shards/shards/Shader/SampleTextureCoord/","title":"Shader.SampleTextureCoord","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Float4</code><code>Float3</code><code>Float2</code><code>Float</code> <code>&lt;output&gt;</code> <code>Float4</code> <code>Name</code> Name of the texture <code>none</code> <code>String</code><code>Var(String)</code> <p>Samples a named texture with the passed in texture coordinates</p> <p> </p>"},{"location":"reference/shards/shards/Shader/WithInput/","title":"Shader.WithInput","text":"Name - Description Default Type <code>&lt;input&gt;</code> This shard does not read the attribute value directly. Use Shader.ReadInput within the Then branch if you need to access the shader input value. <code>&lt;output&gt;</code> This shard outputs none <code>Name</code> The name of the attribute to check for <code>\"\"</code> <code>String</code> <code>Then</code> The shards to execute if the attribute is being received. <code>none</code> <code>Shard</code><code>[Shard]</code> <code>Else</code> The shards to execute if the attribute is not being received <code>none</code> <code>Shard</code><code>[Shard]</code> <p>This shard creates a conditional statement within a shader code. If the shader input specified in the Name parameter is available to the shader stage that calls this shard, the code in the Then parameter will be executed. Otherwise, the code in the Else parameter will execute.</p> <p> </p>"},{"location":"reference/shards/shards/Shader/WithTexture/","title":"Shader.WithTexture","text":"Name - Description Default Type <code>&lt;input&gt;</code> This shard does not read the texture directly. Use Shader.SampleTexture within the Then branch if you need to access the texture. <code>&lt;output&gt;</code> This shard outputs none <code>Name</code> The name of the texture to check for. <code>\"\"</code> <code>String</code> <code>Then</code> The shards to execute if the texture is available <code>none</code> <code>Shard</code><code>[Shard]</code> <code>Else</code> The shards to execute if the texture is not available <code>none</code> <code>Shard</code><code>[Shard]</code> <p>This shard creates a conditional statement within a shader code. If the texture specified in the Name parameter is available for the vertex or pixel, the code in the Then parameter will be executed. Otherwise, the code in the Else parameter will execute.</p> <p> </p>"},{"location":"reference/shards/shards/Shader/WriteGlobal/","title":"Shader.WriteGlobal","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value to set to the global shader variable specified. <code>Any</code> <code>&lt;output&gt;</code> The shard outputs none, but the value is set to the global shader variable specified. <code>Name</code> The name of global variable to set the input value to. <code>\"\"</code> <code>String</code> <p>This shard sets the value passed as input to the global shader variable specified in the Name parameter.</p> <p> </p>"},{"location":"reference/shards/shards/Shader/WriteOutput/","title":"Shader.WriteOutput","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value to write to the shader output specified. <code>Any</code> <code>&lt;output&gt;</code> The shard outputs none, but the value is passed to the next stage or render target. <code>Name</code> The name of the output to write to. <code>\"\"</code> <code>String</code> <p>This shard writes the input value to the shader output or one of the outputs of the render pass (specified in the Name parameter).</p> <p> </p>"},{"location":"reference/shards/shards/Shards/Distill/","title":"Shards.Distill","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>String</code><code>Bytes</code><code>Object</code> <code>&lt;output&gt;</code> <code>Wire</code> <code>Name</code> The optional output wire name. <code>none</code> <code>String</code><code>Var(String)</code> <code>Defines</code> The optional initial injected defines. <code>none</code> <code>{Any}</code><code>Var({Any})</code> <code>Namespace</code> The optional namespace name. <code>none</code> <code>String</code><code>Var(String)</code>"},{"location":"reference/shards/shards/Shards/EnumTypeHelp/","title":"Shards.EnumTypeHelp","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Int</code> <code>&lt;output&gt;</code> <code>{Any}</code>"},{"location":"reference/shards/shards/Shards/EnumTypes/","title":"Shards.EnumTypes","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>&lt;output&gt;</code> <code>[Int]</code>"},{"location":"reference/shards/shards/Shards/Enumerate/","title":"Shards.Enumerate","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>&lt;output&gt;</code> <code>[String]</code>"},{"location":"reference/shards/shards/Shards/Errors/","title":"Shards.Errors","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Object</code> <code>&lt;output&gt;</code> <code>[String]</code> <p>Fetches all errors from a live AST Object input</p> <p> </p>"},{"location":"reference/shards/shards/Shards/Help/","title":"Shards.Help","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>String</code> <code>&lt;output&gt;</code> <code>{Any}</code>"},{"location":"reference/shards/shards/Shards/ObjectTypeHelp/","title":"Shards.ObjectTypeHelp","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Int</code> <code>&lt;output&gt;</code> <code>{Any}</code>"},{"location":"reference/shards/shards/Shards/ObjectTypes/","title":"Shards.ObjectTypes","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>&lt;output&gt;</code> <code>[Int]</code>"},{"location":"reference/shards/shards/Shards/Print/","title":"Shards.Print","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>String</code><code>Bytes</code><code>Object</code> <code>&lt;output&gt;</code> <code>String</code> <p>Pretty prints shards AST into a string.</p> <p> </p>"},{"location":"reference/shards/shards/Shards/Read/","title":"Shards.Read","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>String</code> <code>&lt;output&gt;</code> <code>String</code><code>Bytes</code><code>Object</code> <code>OutputType</code> Determines the type of AST to be outputted. <code>AstType::Bytes</code> <code>AstType</code> <code>BasePath</code> The base path used when interpreting file references. <code>\".\"</code> <code>String</code><code>Var(String)</code> <code>Include</code> The list of include paths. <code>[]</code> <code>[String]</code><code>Var(String)</code> <p>Reads the textual representation of a Shards program and outputs the binary or json AST representation.</p> <p> </p>"},{"location":"reference/shards/shards/Snappy/Compress/","title":"Snappy.Compress","text":"Name - Description Default Type <code>&lt;input&gt;</code> The byte array to compress. <code>Bytes</code> <code>&lt;output&gt;</code> The compressed byte array. <code>Bytes</code> <p>This shard compresses the input byte array using the Snappy algorithm and outputs the compressed byte array.</p> <p> </p>"},{"location":"reference/shards/shards/Snappy/Decompress/","title":"Snappy.Decompress","text":"Name - Description Default Type <code>&lt;input&gt;</code> The compressed byte array to decompress. <code>Bytes</code> <code>&lt;output&gt;</code> The decompressed byte array. <code>Bytes</code> <p>This shard decompressed the input byte array that has been previously compressed using the Snappy.Compress shard.</p> <p> </p>"},{"location":"reference/shards/shards/Sr25519/PublicKey/","title":"Sr25519.PublicKey","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Bytes</code> <code>&lt;output&gt;</code> <code>Bytes</code> <p>Extracts the public key from a Sr25519 keypair</p> <p> </p>"},{"location":"reference/shards/shards/Sr25519/Sign/","title":"Sr25519.Sign","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Bytes</code> <code>&lt;output&gt;</code> <code>Bytes</code> <code>Key</code> The private key to be used to sign the hashed message input. <code>none</code> <code>Bytes</code><code>Var(Bytes)</code> <p>Signs a message using the Schnorr signature on Ristretto compressed Ed25519 points.</p> <p> </p>"},{"location":"reference/shards/shards/Sr25519/Verify/","title":"Sr25519.Verify","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Bytes</code> <code>&lt;output&gt;</code> <code>Bool</code> <code>Key</code> The public key of the keypair that signed the message. This will be used to verify the signature. <code>none</code> <code>Bytes</code><code>Var(Bytes)</code> <code>Message</code> The message that was signed to produce the signature. This is the original plain bytes message that the signature was created for. <code>none</code> <code>Bytes</code><code>Var(Bytes)</code> <p>Verifies a Sr25519 signature</p> <p> </p>"},{"location":"reference/shards/shards/String/Contains/","title":"String.Contains","text":"Name - Description Default Type <code>&lt;input&gt;</code> The string to check. <code>String</code> <code>&lt;output&gt;</code> True if the input string contains the string specified, false otherwise. <code>Bool</code> <code>String</code> The string that the input needs to contain to output true. <code>\"\"</code> <code>String</code><code>Var(String)</code> <p>This shard checks if the input string contains the string specified in the String parameter. If the input string does contain the string specified, the shard will output true. Otherwise, it will output false.</p> <p> </p>"},{"location":"reference/shards/shards/String/DecodeURI/","title":"String.DecodeURI","text":"Name - Description Default Type <code>&lt;input&gt;</code> The URI-encoded string to be decoded. <code>String</code> <code>&lt;output&gt;</code> The resulting decoded string. <code>String</code> <p>This shard decodes a URI-encoded string back into its original format.</p> <p> </p>"},{"location":"reference/shards/shards/String/EncodeURI/","title":"String.EncodeURI","text":"Name - Description Default Type <code>&lt;input&gt;</code> The string to be encoded. <code>String</code> <code>&lt;output&gt;</code> The resulting URI-encoded string. <code>String</code> <p>This shard encodes a string into a URI-encoded format making it safe to use in URLs.</p> <p> </p>"},{"location":"reference/shards/shards/String/Ends/","title":"String.Ends","text":"Name - Description Default Type <code>&lt;input&gt;</code> The string to check. <code>String</code> <code>&lt;output&gt;</code> True if the input string ends with the string specified, false otherwise. <code>Bool</code> <code>With</code> The string that the input needs to end with to output true. <code>\"\"</code> <code>String</code><code>Var(String)</code> <p>This shard checks if the input string ends with the string specified in the With parameter. If the input string does contain the string specified, the shard will output true. Otherwise, it will output false.</p> <p> </p>"},{"location":"reference/shards/shards/String/Format/","title":"String.Format","text":"Name - Description Default Type <code>&lt;input&gt;</code> A sequence of values that will be converted to string and concatenated together. <code>[Any]</code> <code>&lt;output&gt;</code> A string consisting of all the elements of the sequence. <code>String</code> <p>This shard concatenates all the elements of a sequence into a string</p> <p> </p>"},{"location":"reference/shards/shards/String/Join/","title":"String.Join","text":"Name - Description Default Type <code>&lt;input&gt;</code> A sequence of string values that will be joined together. <code>[String Bytes]</code> <code>&lt;output&gt;</code> A string consisting of all the elements of the sequence separated by the specified separator. <code>String</code> <code>Separator</code> The string to use as a separator. <code>\"\"</code> <code>String</code> <p>This shard concatenates all the elements of a string sequence, using the specified separator between each element.</p>"},{"location":"reference/shards/shards/String/Join/#examples","title":"Examples","text":"CodeOutput <pre><code>[\"The quick brown fox \"\n \"jumps over the lazy dog\"\n \".\"]\n(String.Join) (Log)\n(Assert.Is \"The quick brown fox jumps over the lazy dog.\" :Break true)\n\n[\"2001\" \"01\" \"01\"]\n(String.Join \"/\") (Log)\n(Assert.Is \"2001/01/01\" :Break true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/String/Split/","title":"String.Split","text":"Name - Description Default Type <code>&lt;input&gt;</code> The string to split. <code>String</code> <code>&lt;output&gt;</code> A sequence of strings, containing the separated parts of the input string. <code>[String]</code> <code>Separator</code> The separator string to segment the input with. The input is split at each point where this string occurs. <code>\"\"</code> <code>String</code><code>Var(String)</code> <code>KeepSeparator</code> Whether to keep the separator in the output. <code>false</code> <code>Bool</code> <p>This shard splits the input string into a sequence of its constituent strings, using the string specified in the Separator parameter to segment the input. If the KeepSeparator parameter is true, the separator will be included in the output.</p> <p> </p>"},{"location":"reference/shards/shards/String/Starts/","title":"String.Starts","text":"Name - Description Default Type <code>&lt;input&gt;</code> The string to check. <code>String</code> <code>&lt;output&gt;</code> True if the input string starts with the string specified, false otherwise. <code>Bool</code> <code>With</code> The string that the input needs to start with to output true. <code>\"\"</code> <code>String</code><code>Var(String)</code> <p>This shard checks if the input string starts with the string specified in the With parameter. If the input string does contain the string specified, the shard will output true. Otherwise, it will output false.</p> <p> </p>"},{"location":"reference/shards/shards/String/ToLower/","title":"String.ToLower","text":"Name - Description Default Type <code>&lt;input&gt;</code> The string to convert to lowercase. <code>String</code> <code>&lt;output&gt;</code> The input string converted to lowercase. <code>String</code> <p>This shard converts all characters in the input string to lowercase.</p>"},{"location":"reference/shards/shards/String/ToLower/#examples","title":"Examples","text":"CodeOutput <pre><code>\"Hello\" (String.ToLower) (Log)\n(Assert.Is \"hello\" :Break true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/String/ToUpper/","title":"String.ToUpper","text":"Name - Description Default Type <code>&lt;input&gt;</code> The string to convert to uppercase. <code>String</code> <code>&lt;output&gt;</code> The input string converted to uppercase. <code>String</code> <p>This shard converts all characters in the input string to uppercase.</p>"},{"location":"reference/shards/shards/String/ToUpper/#examples","title":"Examples","text":"CodeOutput <pre><code>\"Hello\" (String.ToUpper) (Log)\n(Assert.Is \"HELLO\" :Break true)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/String/Trim/","title":"String.Trim","text":"Name - Description Default Type <code>&lt;input&gt;</code> The string to trim. <code>String</code> <code>&lt;output&gt;</code> The input string with all leading and trailing whitespace characters removed. <code>String</code> <p>This shard removes all leading and trailing whitespace characters from the input string and outputs the trimmed string.</p> <p> </p>"},{"location":"reference/shards/shards/TargetCamera/FromLookAt/","title":"TargetCamera.FromLookAt","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>&lt;output&gt;</code> <code>{pivot: Float3 distance: Float rotation: Float2}</code> <code>Target</code> <code>@f3(0 0 0)</code> <code>Float3</code><code>Var(Float3)</code> <code>Position</code> <code>@f3(2.5 2.5 5)</code> <code>Float3</code><code>Var(Float3)</code> <p>Provides editor free camera controls</p> <p> </p>"},{"location":"reference/shards/shards/TargetCamera/Matrix/","title":"TargetCamera.Matrix","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>{pivot: Float3 distance: Float rotation: Float2}</code> <code>&lt;output&gt;</code> <code>[Float4](4)</code> <p>Turns the target camera state into a view matrix</p> <p> </p>"},{"location":"reference/shards/shards/Tensor/Add/","title":"Tensor.Add","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Tensor</code> <code>&lt;output&gt;</code> <code>Tensor</code> <code>Other</code> The tensor to add. <code>none</code> <code>Var(Tensor)</code> <p>Adds two tensors element-wise.</p> <p> </p>"},{"location":"reference/shards/shards/Tensor/Div/","title":"Tensor.Div","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Tensor</code> <code>&lt;output&gt;</code> <code>Tensor</code> <code>Other</code> The tensor to divide by. <code>none</code> <code>Var(Tensor)</code><code>Float</code> <p>Divides two tensors element-wise.</p> <p> </p>"},{"location":"reference/shards/shards/Tensor/MatMul/","title":"Tensor.MatMul","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Tensor</code> <code>&lt;output&gt;</code> <code>Tensor</code> <code>Other</code> The tensor to multiply with. <code>none</code> <code>Var(Tensor)</code> <p>Performs matrix multiplication of two tensors.</p> <p> </p>"},{"location":"reference/shards/shards/Tensor/Mul/","title":"Tensor.Mul","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Tensor</code> <code>&lt;output&gt;</code> <code>Tensor</code> <code>Other</code> The tensor to multiply with. <code>none</code> <code>Var(Tensor)</code> <p>Multiplies two tensors element-wise.</p> <p> </p>"},{"location":"reference/shards/shards/Tensor/Pow/","title":"Tensor.Pow","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Tensor</code> <code>&lt;output&gt;</code> <code>Tensor</code> <code>Other</code> The tensor of exponents. <code>none</code> <code>Var(Tensor)</code> <p>Raises each element of the tensor to the power of the corresponding element in another tensor.</p> <p> </p>"},{"location":"reference/shards/shards/Tensor/Reshape/","title":"Tensor.Reshape","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Tensor</code> <code>&lt;output&gt;</code> <code>Tensor</code> <code>Shape</code> The new shape for the tensor. <code>none</code> <code>[Int]</code><code>Var([Int])</code> <p>Reshapes the tensor to the specified shape.</p> <p> </p>"},{"location":"reference/shards/shards/Tensor/Shape/","title":"Tensor.Shape","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Tensor</code> <code>&lt;output&gt;</code> <code>[Int]</code> <p>Outputs the shape of the tensor.</p> <p> </p>"},{"location":"reference/shards/shards/Tensor/Slice/","title":"Tensor.Slice","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Tensor</code> <code>&lt;output&gt;</code> <code>Tensor</code> <code>Dim</code> The dimension along which to slice the tensor. <code>none</code> <code>Int</code><code>Var(Int)</code> <code>Start</code> The starting index of the slice. <code>none</code> <code>Int</code><code>Var(Int)</code> <code>End</code> The ending index of the slice (exclusive). <code>none</code> <code>Int</code><code>Var(Int)</code> <p>Slices a tensor along a specified dimension.</p> <p> </p>"},{"location":"reference/shards/shards/Tensor/Split/","title":"Tensor.Split","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Tensor</code> <code>&lt;output&gt;</code> <code>[Tensor]</code> <code>Dim</code> The dimension along which to split the tensor. Default is 0. <code>0</code> <code>Int</code><code>Var(Int)</code> <code>Size</code> The size of the sections to split the tensor into. <code>none</code> <code>Int</code><code>Var(Int)</code> <p>Splits a tensor into multiple tensors along a specified dimension.</p> <p> </p>"},{"location":"reference/shards/shards/Tensor/Stack/","title":"Tensor.Stack","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>[Tensor]</code> <code>&lt;output&gt;</code> <code>Tensor</code> <code>Dim</code> The dimension along which to stack the tensors. Default is 0. <code>0</code> <code>Int</code><code>Var(Int)</code> <p>Stacks a sequence of tensors along a new axis.</p> <p> </p>"},{"location":"reference/shards/shards/Tensor/Sub/","title":"Tensor.Sub","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Tensor</code> <code>&lt;output&gt;</code> <code>Tensor</code> <code>Other</code> The tensor to subtract. <code>none</code> <code>Var(Tensor)</code> <p>Subtracts two tensors element-wise.</p> <p> </p>"},{"location":"reference/shards/shards/Tensor/Sum/","title":"Tensor.Sum","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Tensor</code> <code>&lt;output&gt;</code> <code>Tensor</code> <code>Dims</code> The dimensions to sum over. If not provided, sum over all dimensions. <code>none</code> <code>[Int]</code><code>Var([Int])</code> <p>Computes the sum of tensor elements along the specified dimensions.</p> <p> </p>"},{"location":"reference/shards/shards/Tensor/ToFloat/","title":"Tensor.ToFloat","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Tensor</code> <code>&lt;output&gt;</code> <code>Float</code> <p>Converts a single-element tensor to a float (f64) scalar.</p> <p> </p>"},{"location":"reference/shards/shards/Tensor/ToFloats/","title":"Tensor.ToFloats","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Tensor</code> <code>&lt;output&gt;</code> <code>[Float]</code> <p>Flattens a tensor into a Shards sequence of floats.</p> <p> </p>"},{"location":"reference/shards/shards/Tensor/ToInts/","title":"Tensor.ToInts","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Tensor</code> <code>&lt;output&gt;</code> <code>[Int]</code> <p>Flattens a tensor into a Shards sequence of integers.</p> <p> </p>"},{"location":"reference/shards/shards/Tensor/ToString/","title":"Tensor.ToString","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Tensor</code> <code>&lt;output&gt;</code> <code>String</code> <p>Outputs a string representation of a tensor.</p> <p> </p>"},{"location":"reference/shards/shards/Tensor/Transpose/","title":"Tensor.Transpose","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Tensor</code> <code>&lt;output&gt;</code> <code>Tensor</code> <p>Transposes the dimensions of the tensor.</p> <p> </p>"},{"location":"reference/shards/shards/Tensor/ZerosLike/","title":"Tensor.ZerosLike","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Tensor</code> <code>&lt;output&gt;</code> <code>Tensor</code> <p>Creates a tensor of zeros with the same shape as the input tensor.</p> <p> </p>"},{"location":"reference/shards/shards/Time/Delta/","title":"Time.Delta","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input of this shard is ignored. <code>&lt;output&gt;</code> Outputs the amount of time that has elapsed in seconds. <code>Float</code> <p>Outputs the time between the last call of this shard and the current call in seconds, capped to a limit</p> <p> </p>"},{"location":"reference/shards/shards/Time/DeltaMs/","title":"Time.DeltaMs","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input of this shard is ignored. <code>&lt;output&gt;</code> Outputs the amount of time that has elapsed in milliseconds. <code>Float</code> <p>Outputs the time between the last call of this shard and the current call in milliseconds, capped to a limit</p> <p> </p>"},{"location":"reference/shards/shards/Time/Epoch/","title":"Time.Epoch","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input of this shard is ignored. <code>&lt;output&gt;</code> Amount of time since the Unix epoch in seconds. <code>Int</code> <p>This shard outputs the the amount of time that has elapsed from the Unix epoch to the current system time in seconds.</p> <p> </p>"},{"location":"reference/shards/shards/Time/EpochMs/","title":"Time.EpochMs","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input of this shard is ignored. <code>&lt;output&gt;</code> Amount of time since the Unix epoch in milliseconds. <code>Int</code> <p>This shard outputs the the amount of time that has elapsed from the Unix epoch to the current system time in milliseconds.</p> <p> </p>"},{"location":"reference/shards/shards/Time/MovingAverage/","title":"Time.MovingAverage","text":"Name - Description Default Type <code>&lt;input&gt;</code> The floating point number to compute the average of. <code>Float</code> <code>&lt;output&gt;</code> The average of the floating point number over the specified number of frames. <code>Float</code> <code>Window</code> The sample size in frames <code>16</code> <code>Int</code> <code>Clear</code> Set to true to clear the moving average <code>none</code> <code>Var(Bool)</code> <p>This shard computes the average of a floating point number over a specified number of frames.</p> <p> </p>"},{"location":"reference/shards/shards/Time/Now/","title":"Time.Now","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input of this shard is ignored. <code>&lt;output&gt;</code> Outputs the amount of time that has elapsed in seconds. <code>Float</code> <p>This shard outputs the amount of time that has elapsed since the shards application or script was launched in seconds.</p> <p> </p>"},{"location":"reference/shards/shards/Time/NowMs/","title":"Time.NowMs","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input of this shard is ignored. <code>&lt;output&gt;</code> Outputs the amount of time that has elapsed in milliseconds. <code>Float</code> <p>This shard outputs the amount of time that has elapsed since the shards application or script was launched in milliseconds.</p> <p> </p>"},{"location":"reference/shards/shards/Time/ToString/","title":"Time.ToString","text":"Name - Description Default Type <code>&lt;input&gt;</code> The time to convert. <code>Int</code><code>Float</code> <code>&lt;output&gt;</code> A string representation of the time. <code>String</code> <code>Millis</code> True if the input is given in milliseconds, False if given in seconds. <code>false</code> <code>Bool</code> <p>This shard converts time into a human readable string.</p>"},{"location":"reference/shards/shards/Time/ToString/#examples","title":"Examples","text":"CodeOutput <pre><code>0 (Time.ToString) (Log)\n0 (Time.ToString :Millis true) (Log)\n500 (Time.ToString) (Log)\n500 (Time.ToString :Millis true) (Log)\n(Time.EpochMs) (Time.ToString :Millis true) (Log)\n\n(Pause 2.0)\n\n(Time.Now) (Time.ToString) (Log)\n(Time.NowMs) (Time.ToString :Millis true) (Log)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/Tracy/Message/","title":"Tracy.Message","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>String</code> <code>&lt;output&gt;</code> <code>String</code> <code>Color</code> <code>none</code> <code>Color</code>"},{"location":"reference/shards/shards/UI/","title":"UI","text":"<p>Shards for rendering user interfaces.</p> <p>Info</p> <p>All the shards listed here should be placed within a <code>UI</code> shard.</p> <p> </p>"},{"location":"reference/shards/shards/UI/AddFonts/","title":"UI.AddFonts","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>[[Any]]</code> <code>&lt;output&gt;</code> <code>[[Any]]</code> <p>Adds custom fonts to the UI system, the input should a seq of a pair (name, bytes).</p> <p> </p>"},{"location":"reference/shards/shards/UI/Area/","title":"UI.Area","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Any</code> <code>&lt;output&gt;</code> <code>Any</code> <code>Contents</code> The UI contents. <code>none</code> <code>Shard</code><code>[Shard]</code> <code>Position</code> Defines the position of the UI element. If 'Anchor' is set, this acts as a relative offset (X/Y). Accepts fixed and variable float2 types. <code>none</code> <code>Float2</code><code>Var(Float2)</code> <code>Pivot</code> Specifies the pivot point of the UI element. Can be any predefined anchor type or variable. <code>none</code> <code>Anchor</code><code>Var(Anchor)</code> <code>Anchor</code> Determines the side of the screen where the UI element is anchored. Accepts predefined anchor types or variables. <code>none</code> <code>Anchor</code><code>Var(Anchor)</code> <code>Order</code> Sets the rendering layer for the UI element. The default layer is 'background'. <code>none</code> <code>Order</code> <code>Constrain</code> Constrains the UI element to remain within the screen boundaries. Accepts a boolean value. <code>false</code> <code>Bool</code> <code>ForcedSize</code> Force area to be the given size, will update the area state <code>none</code> <code>Float2</code><code>Var(Float2)</code> <p>Places UI element at a specific position.</p>"},{"location":"reference/shards/shards/UI/Area/#examples","title":"Examples","text":"CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (-&gt;\n    (UI.Area\n     :Anchor Anchor.TopLeft\n     :Contents\n     (-&gt;\n      \"TopLeft\" (UI.Label)))\n    (UI.Area\n     :Anchor Anchor.Top\n     :Contents\n     (-&gt;\n      \"Top\" (UI.Label)))\n    (UI.Area\n     :Anchor Anchor.TopRight\n     :Contents\n     (-&gt;\n      \"TopRight\" (UI.Label :Wrap false)))\n    (UI.Area\n     :Anchor Anchor.Left\n     :Contents\n     (-&gt;\n      \"Left\" (UI.Label)))\n    (UI.Area\n     :Anchor Anchor.Center\n     :Contents\n     (-&gt;\n      \"Center\" (UI.Label)))\n    (UI.Area\n     :Anchor Anchor.Right\n     :Contents\n     (-&gt;\n      \"Right\" (UI.Label)))\n    (UI.Area\n     :Anchor Anchor.BottomLeft\n     :Contents\n     (-&gt;\n      \"BottomLeft\" (UI.Label)))\n    (UI.Area\n     :Anchor Anchor.Bottom\n     :Contents\n     (-&gt;\n      \"Bottom\" (UI.Label)))\n    (UI.Area\n     :Anchor Anchor.BottomRight\n     :Contents\n     (-&gt;\n      \"BottomRight\" (UI.Label :Wrap false)))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/UI/AutoGrid/","title":"UI.AutoGrid","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>[Any]</code> <code>&lt;output&gt;</code> <code>[Any]</code> <code>Contents</code> The UI contents to be generated and inserted in each column for each element in the given sequence. <code>none</code> <code>Shard</code><code>[Shard]</code> <code>Striped</code> Whether to alternate a subtle background color to every other row. <code>false</code> <code>Bool</code><code>Var(Bool)</code> <code>MaxGridWidth</code> Maximum grid width. <code>none</code> <code>Float</code><code>Var(Float)</code> <code>ItemWidth</code> The width of each item. <code>none</code> <code>Float</code><code>Var(Float)</code> <code>ColumnSpacing</code> Spacing between columns. <code>none</code> <code>Float</code><code>Var(Float)</code> <code>RowSpacing</code> Spacing between rows. <code>none</code> <code>Float</code><code>Var(Float)</code> <p>Works like UI.Grid, but given a Sequence, it will, it each object in the Sequence, execute the Shard provided in its Contents and automatically wrap the generated contents when it exceeds the grid's width.</p>"},{"location":"reference/shards/shards/UI/AutoGrid/#examples","title":"Examples","text":""},{"location":"reference/shards/shards/UI/BottomPanel/","title":"UI.BottomPanel","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value that will be passed to the Contents shards of the panel. <code>Any</code> <code>&lt;output&gt;</code> The output of this shard will be its input. <code>Any</code> <code>Resizable</code> Whether the panel can be resized. <code>false</code> <code>Bool</code> <code>DefaultSize</code> The initial size of the panel. <code>none</code> <code>Float</code> <code>MinSize</code> The minimum allowable size of the panel. <code>none</code> <code>Float</code> <code>MaxSize</code> The maximum allowable size of the panel. <code>none</code> <code>Float</code> <code>Contents</code> The UI contents. <code>none</code> <code>Shard</code><code>[Shard]</code> <p>Layout UI elements into the panel.</p>"},{"location":"reference/shards/shards/UI/BottomPanel/#examples","title":"Examples","text":"CodeOutput <pre><code>(GFX.MainWindow\n   :Contents\n   (-&gt;\n    (Setup\n     (GFX.DrawQueue) &gt;= .ui-draw-queue\n     (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n\n    (UI\n     (UI.BottomPanel\n      :Contents\n      (-&gt;\n       \"Bottom Panel\" (UI.Label))))\n\n    (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/UI/Button/","title":"UI.Button","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value that will be passed to the Action shards of the button. <code>Any</code> <code>&lt;output&gt;</code> Indicates whether the button was clicked during this frame. <code>Bool</code> <code>Label</code> The text label of this button. <code>\"\"</code> <code>String</code><code>Var(String)</code> <code>Action</code> The shards to execute when the button is pressed. <code>none</code> <code>Shard</code><code>[Shard]</code> <code>Style</code> The text style. <code>none</code> <code>{Any}</code><code>Var({Any})</code> <code>Wrap</code> The text wrapping mode. <code>TextWrap::Extend</code> <code>TextWrap</code><code>Bool</code> <code>Selected</code> Indicates whether the button is selected. <code>none</code> <code>Bool</code><code>Var(Bool)</code> <p>Clickable button with text.</p>"},{"location":"reference/shards/shards/UI/Button/#examples","title":"Examples","text":"CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.CentralPanel\n    (UI.Button\n     :Label \"Click me!\"\n     :Action (Msg \"Clicked\"))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre> CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.CentralPanel\n    (UI.Button\n     :Label \"Click me!\"\n     :Style {:color (color 255 255 0)}\n     :Action (Msg \"Clicked\"))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/UI/Canvas/","title":"UI.Canvas","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Any</code> <code>&lt;output&gt;</code> <code>Any</code> <code>Contents</code> <code>none</code> <code>Shard</code><code>[Shard]</code> <code>Rect</code> The target UI position (X/Y/W/H) <code>none</code> <code>Float4</code><code>Var(Float4)</code> <code>Order</code> The order this UI is drawn in <code>none</code> <code>Order</code> <p>A canvas to draw UI elements on</p> <p> </p>"},{"location":"reference/shards/shards/UI/CentralPanel/","title":"UI.CentralPanel","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value that will be passed to the Contents shards of the panel. <code>Any</code> <code>&lt;output&gt;</code> The output of this shard will be its input. <code>Any</code> <code>Contents</code> The UI contents. <code>none</code> <code>Shard</code><code>[Shard]</code> <p>Layout UI elements into the central panel.</p>"},{"location":"reference/shards/shards/UI/CentralPanel/#examples","title":"Examples","text":"CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.CentralPanel\n    :Contents\n    (-&gt;\n     \"Central Panel\" (UI.Label))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/UI/Checkbox/","title":"UI.Checkbox","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value is ignored. <code>&lt;output&gt;</code> Indicates whether the checkbox state changed during this frame. <code>Bool</code> <code>Label</code> The text label of this checkbox. <code>none</code> <code>String</code> <code>Variable</code> The variable that holds the input value. <code>none</code> <code>Bool</code><code>Var(Bool)</code> <code>Style</code> The text style. <code>none</code> <code>{Any}</code><code>Var({Any})</code> <p>Boolean on/off widget with text label.</p>"},{"location":"reference/shards/shards/UI/Checkbox/#examples","title":"Examples","text":"CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.CentralPanel\n    (UI.Checkbox\n     :Label \"Checked\"\n     :Variable .checked)))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre> CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.CentralPanel\n    (UI.Checkbox\n     :Label \"Checked\"\n     :Style {:color (color 255 0 255) :italics true}\n     :Variable .checked)))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/UI/CloseMenu/","title":"UI.CloseMenu","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value is ignored. <code>Any</code> <code>&lt;output&gt;</code> The output of this shard will be its input. <code>Any</code> <p>Closes the currently opened menu.</p>"},{"location":"reference/shards/shards/UI/CloseMenu/#examples","title":"Examples","text":"CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (-&gt;\n    (UI.TopPanel\n     :Contents\n     (UI.MenuBar\n      (-&gt;\n       (UI.Menu\n        :Title \"Menu\"\n        :Contents\n        (UI.Button \"Close\" (UI.CloseMenu))))))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/UI/CodeEditor/","title":"UI.CodeEditor","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value is ignored. <code>&lt;output&gt;</code> The value produced when changed. <code>Bool</code> <code>Code</code> The variable that holds the code to edit. <code>none</code> <code>String</code><code>Var(String)</code> <code>Language</code> The name of the programming language for syntax highlighting. <code>none</code> <code>String</code><code>Var(String)</code> <p>A TextField with support for highlighting.</p>"},{"location":"reference/shards/shards/UI/CodeEditor/#examples","title":"Examples","text":"CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (-&gt;\n    (Setup \"\" &gt;= .code)\n    (UI.TopPanel\n     :Contents\n     (UI.MenuBar\n      :Contents\n      (UI.Menu\n       \"Edit\"\n       (UI.Button\n        \"Clear\"\n        (-&gt; \"\" &gt; .code (UI.CloseMenu))))))\n    (UI.CentralPanel\n     :Contents\n     (UI.CodeEditor .code \"Rust\"))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/UI/Collapsing/","title":"UI.Collapsing","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value that will be passed to the Contents shards of the collapsing header. <code>Any</code> <code>&lt;output&gt;</code> The output of this shard will be its input. <code>Any</code> <code>Heading</code> The heading text or widgets for this collapsing header. <code>none</code> <code>String</code><code>Var(String)</code><code>Shard</code><code>[Shard]</code> <code>Contents</code> The UI contents. <code>none</code> <code>Shard</code><code>[Shard]</code> <code>DefaultOpen</code> Whether the collapsing header is opened by default. <code>false</code> <code>Bool</code><code>Var(Bool)</code> <p>A header which can be collapsed/expanded, revealing a contained UI region.</p>"},{"location":"reference/shards/shards/UI/Collapsing/#examples","title":"Examples","text":"CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.CentralPanel\n    :Contents\n    (UI.Collapsing\n     :Heading \"Heading\"\n     :DefaultOpen true\n     :Contents (-&gt; \"Content\" (UI.Label)))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre> CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.CentralPanel\n    :Contents\n    (UI.Collapsing\n     :Heading (UI.Button \"Heading\" (Msg \"Clicked\"))\n     :DefaultOpen true\n     :Contents (-&gt; \"Content\" (UI.Label)))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/UI/ColorInput/","title":"UI.ColorInput","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value is ignored. <code>&lt;output&gt;</code> The selected color. <code>Color</code> <code>Variable</code> The variable that holds the input value. <code>none</code> <code>Color</code><code>Var(Color)</code> <p>A widget where a color can be selected.</p>"},{"location":"reference/shards/shards/UI/ColorInput/#examples","title":"Examples","text":"CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.CentralPanel\n    (UI.ColorInput :Variable .color)))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/UI/Columns/","title":"UI.Columns","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value that will be passed to the Contents shards (each column). <code>Any</code> <code>&lt;output&gt;</code> The output of this shard will be its input. <code>Any</code> <code>Contents</code> A sequence of UI contents. <code>[]</code> <code>[None Shard [Shard]]</code> <p>Splits the contents into several columns.</p>"},{"location":"reference/shards/shards/UI/Columns/#examples","title":"Examples","text":"CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.CentralPanel\n    (UI.Columns\n     :Contents\n     [(-&gt;\n       \"Column 1\" (UI.Label))\n      (-&gt;\n       \"Column 2\" (UI.Label))])))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/UI/Combo/","title":"UI.Combo","text":"Name - Description Default Type <code>&lt;input&gt;</code> A sequence of values. <code>Any</code> <code>&lt;output&gt;</code> The selected value. <code>Any</code> <code>Label</code> The text label of this combobox. <code>none</code> <code>String</code> <code>Index</code> The index of the selected item. <code>none</code> <code>Int</code><code>Var(Int)</code> <code>Width</code> The width of the button and menu. <code>none</code> <code>Float</code><code>Var(Float)</code> <code>Style</code> The text style. <code>none</code> <code>{Any}</code><code>Var({Any})</code> <p>A drop-down selection menu with a label.</p>"},{"location":"reference/shards/shards/UI/Combo/#examples","title":"Examples","text":"CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.CentralPanel\n    (-&gt;\n     [\"\u03b1 \u0391\" \"\u03c9 \u03a9\"]\n     (UI.Combo\n      :Label \"Greek letter\"\n      :Index .index)\n     (ExpectString) &gt;= .letter)))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre> CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.CentralPanel\n    (-&gt;\n     [\"\u03b1 \u0391\" \"\u03c9 \u03a9\"]\n     (UI.Combo\n      :Label \"Greek letter\"\n      :Style {:color (color 200 10 200)}\n      :Index .index)\n     (ExpectString) &gt;= .letter)))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/UI/Console/","title":"UI.Console","text":"Name - Description Default Type <code>&lt;input&gt;</code> The raw logs. <code>String</code> <code>&lt;output&gt;</code> The output of this shard will be its input. <code>String</code> <code>ShowFilters</code> Whether to display filter controls. <code>false</code> <code>Bool</code> <code>Style</code> The console style. <code>none</code> <code>{Any}</code><code>Var({Any})</code> <p>A console with formatted logs.</p>"},{"location":"reference/shards/shards/UI/Console/#examples","title":"Examples","text":"CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (-&gt;\n    (UI.CentralPanel\n     (-&gt;\n      (UI.Button \"Say Hello\" (Msg \"Hello!\"))\n      (CaptureLog\n       :Size 24\n       :MinLevel \"info\"\n       :Pattern \"%^[%l]%$ [%Y-%m-%d %T.%e] %v\")\n      (String.Join)\n      (UI.Console)))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre> CodeOutput <pre><code>(defloop capture\n  (CaptureLog\n   :Size 24\n   :MinLevel \"info\"\n   :Pattern \"%^[%l]%$ [%Y-%m-%d %T.%e] %v\"\n   :Suspend true)\n  (String.Join) &gt; .logs\n  (Math.Inc .generation))\n\n(Setup\n \"\" (Set .logs :Global true)\n 0 (Set .generation :Global true)\n (Detach capture))\n\n(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (-&gt;\n    (UI.BottomPanel\n     :Contents\n     (-&gt;\n      (Get .generation :Global true)\n      (ToString) (UI.Label)))\n    (UI.CentralPanel\n     :Contents\n     (-&gt;\n      (UI.Button \"Say Hello\" (Msg \"Hello!\"))\n      (Get .logs :Global true)\n      (UI.Console :ShowFilters true)))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/UI/Disable/","title":"UI.Disable","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value that will be passed to the Contents shards of the scope. <code>Any</code> <code>&lt;output&gt;</code> The output of this shard will be its input. <code>Any</code> <code>Contents</code> The UI contents. <code>none</code> <code>Shard</code><code>[Shard]</code> <code>Disable</code> Whether the contents should be disabled. <code>true</code> <code>Bool</code><code>Var(Bool)</code> <p>Creates a scoped child UI.</p>"},{"location":"reference/shards/shards/UI/Disable/#examples","title":"Examples","text":"CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.CentralPanel\n    (UI.Disable\n     :Disable true\n     :Contents\n     (UI.Button \"Can't be clicked\"))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/UI/DockArea/","title":"UI.DockArea","text":"Name - Description Default Type <code>&lt;input&gt;</code> TODO. <code>Any</code> <code>&lt;output&gt;</code> TODO. <code>Any</code> <code>Contents</code> The UI contents containing tabs. <code>none</code> <code>Shard</code><code>[Shard]</code> <p>TODO.</p>"},{"location":"reference/shards/shards/UI/DockArea/#examples","title":"Examples","text":"CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.DockArea\n    :Contents\n    (-&gt;\n     (UI.Tab\n      :Title \"Tab 1\"\n      :Contents\n      (-&gt; \"Tab 1 contents\" (UI.Label)))\n     (UI.Tab\n      :Title \"Tab 2\"\n      :Contents\n      (-&gt; \"Tab 2 contents\" (UI.Label))))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/UI/DragAndDrop/","title":"UI.DragAndDrop","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Any</code> <code>&lt;output&gt;</code> <code>Any</code> <code>Contents</code> The property to retrieve from the UI context. <code>none</code> <code>Shard</code><code>[Shard]</code> <code>Hover</code> Callback function for checking if this is a valid drop target. <code>none</code> <code>Shard</code><code>[Shard]</code> <code>Drop</code> Callback function for when something is dropped. When set, this element will act as a drop target. When unset, it will act as a drag source. <code>none</code> <code>Shard</code><code>[Shard]</code> <code>ID</code> An optional ID value in case of ID conflicts. <code>none</code> <code>String</code><code>Var(String)</code> <code>Visualize</code> Visualize valid drop targets <code>none</code> <code>Bool</code> <p>Drag and drop source &amp; target.</p> <p> </p>"},{"location":"reference/shards/shards/UI/Float2Input/","title":"UI.Float2Input","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value is ignored. <code>&lt;output&gt;</code> The value produced. <code>Float2</code> <code>Variable</code> The variable that holds the input value. <code>none</code> <code>Float2</code><code>Var(Float2)</code> <p>A numeric input.</p>"},{"location":"reference/shards/shards/UI/Float2Input/#examples","title":"Examples","text":"CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.CentralPanel\n    (-&gt;\n     (UI.Float2Input :Variable .float2)\n     (ExpectFloat2))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/UI/Float2Slider/","title":"UI.Float2Slider","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value is ignored. <code>&lt;output&gt;</code> The value produced. <code>Float2</code> <code>Label</code> The label for this widget. <code>none</code> <code>String</code> <code>Style</code> The text style. <code>none</code> <code>{Any}</code><code>Var({Any})</code> <code>Variable</code> The variable that holds the input value. <code>none</code> <code>Float2</code><code>Var(Float2)</code> <code>Min</code> The minimum value. <code>none</code> <code>Float2</code><code>Var(Float2)</code> <code>Max</code> The maximum value. <code>none</code> <code>Float2</code><code>Var(Float2)</code> <p>A numeric slider.</p>"},{"location":"reference/shards/shards/UI/Float2Slider/#examples","title":"Examples","text":"CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.CentralPanel\n    (-&gt;\n     (UI.Float2Slider\n      :Variable .float2\n      :Min (float2 0) :Max (float2 1))\n     (ExpectFloat2))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/UI/Float3Input/","title":"UI.Float3Input","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value is ignored. <code>&lt;output&gt;</code> The value produced. <code>Float3</code> <code>Variable</code> The variable that holds the input value. <code>none</code> <code>Float3</code><code>Var(Float3)</code> <p>A numeric input.</p>"},{"location":"reference/shards/shards/UI/Float3Input/#examples","title":"Examples","text":"CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.CentralPanel\n    (-&gt;\n     (UI.Float3Input :Variable .float3)\n     (ExpectFloat3))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/UI/Float3Slider/","title":"UI.Float3Slider","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value is ignored. <code>&lt;output&gt;</code> The value produced. <code>Float3</code> <code>Label</code> The label for this widget. <code>none</code> <code>String</code> <code>Style</code> The text style. <code>none</code> <code>{Any}</code><code>Var({Any})</code> <code>Variable</code> The variable that holds the input value. <code>none</code> <code>Float3</code><code>Var(Float3)</code> <code>Min</code> The minimum value. <code>none</code> <code>Float3</code><code>Var(Float3)</code> <code>Max</code> The maximum value. <code>none</code> <code>Float3</code><code>Var(Float3)</code> <p>A numeric slider.</p>"},{"location":"reference/shards/shards/UI/Float3Slider/#examples","title":"Examples","text":"CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.CentralPanel\n    (-&gt;\n     (UI.Float3Slider\n      :Variable .float3\n      :Min (float3 0) :Max (float3 1))\n     (ExpectFloat3))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/UI/Float4Input/","title":"UI.Float4Input","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value is ignored. <code>&lt;output&gt;</code> The value produced. <code>Float4</code> <code>Variable</code> The variable that holds the input value. <code>none</code> <code>Float4</code><code>Var(Float4)</code> <p>A numeric input.</p>"},{"location":"reference/shards/shards/UI/Float4Input/#examples","title":"Examples","text":"CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.CentralPanel\n    (-&gt;\n     (UI.Float4Input :Variable .float4)\n     (ExpectFloat4))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/UI/Float4Slider/","title":"UI.Float4Slider","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value is ignored. <code>&lt;output&gt;</code> The value produced. <code>Float4</code> <code>Label</code> The label for this widget. <code>none</code> <code>String</code> <code>Style</code> The text style. <code>none</code> <code>{Any}</code><code>Var({Any})</code> <code>Variable</code> The variable that holds the input value. <code>none</code> <code>Float4</code><code>Var(Float4)</code> <code>Min</code> The minimum value. <code>none</code> <code>Float4</code><code>Var(Float4)</code> <code>Max</code> The maximum value. <code>none</code> <code>Float4</code><code>Var(Float4)</code> <p>A numeric slider.</p>"},{"location":"reference/shards/shards/UI/Float4Slider/#examples","title":"Examples","text":"CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.CentralPanel\n    (-&gt;\n     (UI.Float4Slider\n      :Variable .float4\n      :Min (float4 0) :Max (float4 1))\n     (ExpectFloat4))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/UI/FloatInput/","title":"UI.FloatInput","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value is ignored. <code>&lt;output&gt;</code> The value produced. <code>Float</code> <code>Variable</code> The variable that holds the input value. <code>none</code> <code>Float</code><code>Var(Float)</code> <code>Prefix</code> Display a prefix before the number. <code>none</code> <code>String</code> <p>A numeric input.</p>"},{"location":"reference/shards/shards/UI/FloatInput/#examples","title":"Examples","text":"CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.CentralPanel\n    (-&gt;\n     (UI.FloatInput :Variable .float)\n     (ExpectFloat))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/UI/FloatSlider/","title":"UI.FloatSlider","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value is ignored. <code>&lt;output&gt;</code> The value produced. <code>Float</code> <code>Label</code> The text label for this widget. <code>none</code> <code>String</code> <code>Style</code> The text style. <code>none</code> <code>{Any}</code><code>Var({Any})</code> <code>Variable</code> The variable that holds the input value. <code>none</code> <code>Float</code><code>Var(Float)</code> <code>Min</code> The minimum value. <code>none</code> <code>Float</code><code>Var(Float)</code> <code>Max</code> The maximum value. <code>none</code> <code>Float</code><code>Var(Float)</code> <p>A numeric slider.</p>"},{"location":"reference/shards/shards/UI/FloatSlider/#examples","title":"Examples","text":"CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.CentralPanel\n    (-&gt;\n     (UI.FloatSlider\n      :Variable .float\n      :Min 0.0 :Max 1.0)\n     (ExpectFloat))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/UI/Frame/","title":"UI.Frame","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value that will be passed to the Contents shards of the frame. <code>Any</code> <code>&lt;output&gt;</code> The output of this shard will be its input. <code>Any</code> <code>Contents</code> The UI contents. <code>none</code> <code>Shard</code><code>[Shard]</code> <code>InnerMargin</code> The margin inside the frame, between the outline and the contents. <code>none</code> <code>Float4</code> <code>OuterMargin</code> The margin outside the frame. <code>none</code> <code>Float4</code> <code>Rounding</code> Rounding radiuses for the corners. <code>none</code> <code>Float4</code> <code>FillColor</code> The color filling the background of the frame. <code>none</code> <code>Color</code><code>Var(Color)</code> <code>StrokeColor</code> The color for the frame outline. <code>none</code> <code>Color</code><code>Var(Color)</code> <code>StrokeWidth</code> The width of the frame outline. <code>none</code> <code>Float</code> <p>Visually groups the contents together.</p>"},{"location":"reference/shards/shards/UI/Frame/#examples","title":"Examples","text":"CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.CentralPanel\n    (UI.Frame\n     :InnerMargin (float4 10) :OuterMargin (float4 0) :Rounding (float4 5)\n     :FillColor (color 50 50 21)\n     :StrokeColor (color 250 250 32) :StrokeWidth (float 2)\n     :Contents\n     (-&gt;\n      \"Frame content\" (UI.Label)))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/UI/GetClipboard/","title":"UI.GetClipboard","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input of this shard is ignored. <code>&lt;output&gt;</code> Outputs the current clipboard contents as a string. <code>String</code> <p>This shard retrieves the current system clipboard contents.</p> <p> </p>"},{"location":"reference/shards/shards/UI/Grid/","title":"UI.Grid","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value that will be passed to the Contents shards of the grid. <code>Any</code> <code>&lt;output&gt;</code> The output of this shard will be its input. <code>Any</code> <code>Contents</code> The UI contents. <code>none</code> <code>Shard</code><code>[Shard]</code> <code>Striped</code> Whether to alternate a subtle background color to every other row. <code>false</code> <code>Bool</code><code>Var(Bool)</code> <code>NumColumns</code> The number of columns in the grid. Setting this will allow the last column to expand to take up the rest of the space of the parent UI. <code>none</code> <code>Int</code><code>Var(Int)</code> <code>MinWidth</code> Minimum column width. <code>none</code> <code>Float</code><code>Var(Float)</code> <code>MaxWidth</code> Maximum column width. <code>none</code> <code>Float</code><code>Var(Float)</code> <code>Spacing</code> Spacing between columns/rows. <code>none</code> <code>Float2</code><code>Var(Float2)</code> <p>Simple grid layout.</p>"},{"location":"reference/shards/shards/UI/Grid/#examples","title":"Examples","text":"CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.CentralPanel\n    (UI.Grid\n     :Striped true\n     :Contents\n     (-&gt;\n      \"Col 1\" (UI.Label)\n      \"Col 2\" (UI.Label)\n      \"Col 3\" (UI.Label)\n      (UI.NextRow)\n      \"Hello\" (UI.Label)\n      \"shards\" (UI.Label)\n      \"!\" (UI.Label)\n      (UI.NextRow)\n      \"Lorem ipsum dolor sit amet\" (UI.Label)\n      \"consectetur adipiscing elit\" (UI.Label)\n      \"sed do eiusmod tempor\" (UI.Label)))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/UI/Group/","title":"UI.Group","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value that will be passed to the Contents shards of the group. <code>Any</code> <code>&lt;output&gt;</code> The output of this shard will be its input. <code>Any</code> <code>Contents</code> The UI contents. <code>none</code> <code>Shard</code><code>[Shard]</code> <p>Visually groups the contents together.</p>"},{"location":"reference/shards/shards/UI/Group/#examples","title":"Examples","text":"CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.CentralPanel\n    (UI.Group\n     :Contents\n     (-&gt;\n      \"Group content\" (UI.Label)))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/UI/HexViewer/","title":"UI.HexViewer","text":"Name - Description Default Type <code>&lt;input&gt;</code> The data to visualize. Supports primitive types only (floats, ints, string and bytes). <code>Bytes</code><code>Enum</code><code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Int</code><code>Int2</code><code>Int3</code><code>Int4</code><code>Int8</code><code>Int16</code><code>String</code> <code>&lt;output&gt;</code> The output of this shard will be its input. <code>Bytes</code><code>Enum</code><code>Float</code><code>Float2</code><code>Float3</code><code>Float4</code><code>Int</code><code>Int2</code><code>Int3</code><code>Int4</code><code>Int8</code><code>Int16</code><code>String</code> <p>Displays an hexadecimal viewer of data.</p>"},{"location":"reference/shards/shards/UI/HexViewer/#examples","title":"Examples","text":"CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.CentralPanel\n    (-&gt;\n     (Setup\n      \"Hello shards!\" &gt;= .text)\n\n     (UI.Horizontal\n      (-&gt;\n       \"Text: \" (UI.Label)\n       (UI.TextField .text)))\n\n     .text (UI.HexViewer))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/UI/Horizontal/","title":"UI.Horizontal","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value that will be passed to the Contents shards of the layout. <code>Any</code> <code>&lt;output&gt;</code> The output of this shard will be its input. <code>Any</code> <code>Contents</code> The UI contents. <code>none</code> <code>Shard</code><code>[Shard]</code> <code>Wrap</code> Wrap the content once it reaches the right edge. <code>false</code> <code>Bool</code> <code>Centered</code> Center the contents horizontally. <code>false</code> <code>Bool</code> <p>Layout the contents horizontally.</p>"},{"location":"reference/shards/shards/UI/Horizontal/#examples","title":"Examples","text":"CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.CentralPanel\n    (UI.Horizontal\n     (-&gt;\n      \"Hello\" (UI.Label)\n      (UI.Separator)\n      \"World\" (UI.Label)))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/UI/Hyperlink/","title":"UI.Hyperlink","text":"Name - Description Default Type <code>&lt;input&gt;</code> The URL. <code>String</code> <code>&lt;output&gt;</code> The output of this shard will be its input. <code>String</code> <code>Label</code> Optional label for the hyperlink. <code>none</code> <code>String</code> <code>Style</code> The text style. <code>none</code> <code>{Any}</code><code>Var({Any})</code> <p>A clickable hyperlink.</p>"},{"location":"reference/shards/shards/UI/Hyperlink/#examples","title":"Examples","text":"CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.CentralPanel\n    (-&gt;\n     \"https://docs.fragcolor.com\"\n     (UI.Hyperlink :Label \"Fragcolor documentation\"))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre> CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.CentralPanel\n    (-&gt;\n     \"https://docs.fragcolor.com\"\n     (UI.Hyperlink\n      :Label \"Fragcolor documentation\"\n      :Style {:italics true}))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/UI/Image/","title":"UI.Image","text":"Name - Description Default Type <code>&lt;input&gt;</code> The image to display. <code>Image</code><code>GFX.Texture2D</code> <code>&lt;output&gt;</code> The output of this shard will be its input. <code>Image</code><code>GFX.Texture2D</code> <code>Scale</code> Scaling to apply to the source image. <code>@f2(1 1)</code> <code>Float2</code><code>Var(Float2)</code> <code>Size</code> The size to render the image at. <code>none</code> <code>Float2</code><code>Var(Float2)</code> <code>ScalingAware</code> When set to true, this image's pixels will be rendered 1:1 regardless of UI context point size. <code>none</code> <code>Bool</code><code>Var(Bool)</code> <p>Display an image in the UI.</p>"},{"location":"reference/shards/shards/UI/Image/#examples","title":"Examples","text":"CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.CentralPanel\n    (-&gt;\n     (Setup\n      (LoadImage \"data/ShardsLogo.png\") = .image)\n     .image (UI.Image :Scale (float2 0.25)))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre> CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.CentralPanel\n    (-&gt;\n     (Setup\n      (LoadImage \"data/ShardsLogo.png\")  &gt;= .image\n      (GFX.Texture) &gt;= .texture)\n       ; Draw UI image by loading the image into graphics memory when needed\n     .image (UI.Image :Scale (float2 0.1))\n       ; Draw UI image directly from a texture\n     .texture (UI.Image :Scale (float2 0.1)))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre> CodeOutput <pre><code>;; this test script is meant to test the PremultiplyAlpha and DemultiplyAlpha shards as well as the :PremultiplyAlpha behaviour of LoadImage shrad\n;; however, this script uses GFX.Texture as well. Without GFX.Texture, the issues with non-premultiplied alpha may not appear for PNGs.\n\n(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.CentralPanel\n    (-&gt;\n     (Setup\n      (LoadImage \"data/Damaged_Effect_5.png\" :PremultiplyAlpha true) (GFX.Texture) = .premultiplied-alpha-image-1\n      (LoadImage \"data/Damaged_Effect_5.png\" :PremultiplyAlpha false) (PremultiplyAlpha) (GFX.Texture) = .premultiplied-alpha-image-2\n      (LoadImage \"data/Damaged_Effect_5.png\" :PremultiplyAlpha true) (DemultiplyAlpha) (PremultiplyAlpha) (GFX.Texture) = .premultiplied-alpha-image-3\n      (LoadImage \"data/Damaged_Effect_5.png\" :PremultiplyAlpha false) (DemultiplyAlpha) (PremultiplyAlpha) (PremultiplyAlpha) (GFX.Texture) = .premultiplied-alpha-image-4\n      (LoadImage \"data/Damaged_Effect_5.png\" :PremultiplyAlpha false) (GFX.Texture) = .non-premultiplied-alpha-image-1\n      (LoadImage \"data/Damaged_Effect_5.png\" :PremultiplyAlpha false) (PremultiplyAlpha) (DemultiplyAlpha) (GFX.Texture) = .non-premultiplied-alpha-image-2\n      (LoadImage \"data/Damaged_Effect_5.png\" :PremultiplyAlpha false) (PremultiplyAlpha) (DemultiplyAlpha) (DemultiplyAlpha) (GFX.Texture) = .non-premultiplied-alpha-image-3\n      (LoadImage \"data/Damaged_Effect_5.png\" :PremultiplyAlpha true) (PremultiplyAlpha) (DemultiplyAlpha) (GFX.Texture) = .non-premultiplied-alpha-image-4)\n     (UI.Horizontal\n      :Contents \n      (-&gt; \n       (UI.Vertical\n        :Contents\n        (-&gt;\n         .premultiplied-alpha-image-1 (UI.Image :Scale (float2 0.25))\n         .premultiplied-alpha-image-2 (UI.Image :Scale (float2 0.25))\n         .premultiplied-alpha-image-3 (UI.Image :Scale (float2 0.25))\n         .premultiplied-alpha-image-4 (UI.Image :Scale (float2 0.25))\n         ))\n       (UI.Vertical\n        :Contents\n        (-&gt;\n         .non-premultiplied-alpha-image-1 (UI.Image :Scale (float2 0.25))\n         .non-premultiplied-alpha-image-2 (UI.Image :Scale (float2 0.25))\n         .non-premultiplied-alpha-image-3 (UI.Image :Scale (float2 0.25))\n         .non-premultiplied-alpha-image-4 (UI.Image :Scale (float2 0.25))\n     )))))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/UI/ImageButton/","title":"UI.ImageButton","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value that will be passed to the Action shards of the button. <code>Image</code><code>GFX.Texture2D</code> <code>&lt;output&gt;</code> Indicates whether the button was clicked during this frame. <code>Bool</code> <code>Action</code> The shards to execute when the button is pressed. <code>none</code> <code>Shard</code><code>[Shard]</code> <code>Scale</code> Scaling to apply to the source image. <code>@f2(1 1)</code> <code>Float2</code><code>Var(Float2)</code> <code>Size</code> The size to render the image at. <code>none</code> <code>Float2</code><code>Var(Float2)</code> <code>ScalingAware</code> When set to true, this image's pixels will be rendered 1:1 regardless of UI context point size. <code>none</code> <code>Bool</code><code>Var(Bool)</code> <code>Selected</code> Indicates whether the button is selected. <code>none</code> <code>Bool</code><code>Var(Bool)</code> <p>Clickable button with image.</p>"},{"location":"reference/shards/shards/UI/ImageButton/#examples","title":"Examples","text":"CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.CentralPanel\n    (-&gt;\n     (Setup\n      (LoadImage \"../../assets/ShardsLogo.png\") = .image)\n     .image (UI.ImageButton :Scale (float2 0.1) :Action (Msg \"Clicked\")))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre> CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.CentralPanel\n    (-&gt;\n     (Setup\n      (LoadImage \"data/ShardsLogo.png\")  &gt;= .image\n      (GFX.Texture) &gt;= .texture)\n       ; Draw UI image by loading the image into graphics memory when needed\n     .image (UI.ImageButton :Scale (float2 0.1))\n       ; Draw UI image directly from a texture\n     .texture (UI.ImageButton :Scale (float2 0.1)))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/UI/Indent/","title":"UI.Indent","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value that will be passed to the Contents shards. <code>Any</code> <code>&lt;output&gt;</code> The output of this shard will be its input. <code>Any</code> <code>Contents</code> The UI contents. <code>none</code> <code>Shard</code><code>[Shard]</code> <p>Creates a child UI which is indented to the right.</p>"},{"location":"reference/shards/shards/UI/Indent/#examples","title":"Examples","text":"CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.CentralPanel\n    (-&gt;\n     \"Part A\" (UI.Label)\n     (UI.Indent\n      :Contents\n      (-&gt;\n       \"1.\" (UI.Label)\n       (UI.Indent\n        :Contents\n        (-&gt;\n         \"1.1.\" (UI.Label)\n         \"1.2.\" (UI.Label)))\n       \"2.\" (UI.Label)))\n     (UI.Separator)\n     \"Part B\" (UI.Label))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/UI/Inspection/","title":"UI.Inspection","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Any</code> <code>&lt;output&gt;</code> <code>Any</code> <p>Show inspection ui</p> <p> </p>"},{"location":"reference/shards/shards/UI/Int2Input/","title":"UI.Int2Input","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value is ignored. <code>&lt;output&gt;</code> The value produced. <code>Int2</code> <code>Variable</code> The variable that holds the input value. <code>none</code> <code>Int2</code><code>Var(Int2)</code> <p>A numeric input.</p>"},{"location":"reference/shards/shards/UI/Int2Input/#examples","title":"Examples","text":"CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.CentralPanel\n    (-&gt;\n     (UI.Int2Input\n      :Variable .int2)\n     (ExpectInt2))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/UI/Int2Slider/","title":"UI.Int2Slider","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value is ignored. <code>&lt;output&gt;</code> The value produced. <code>Int2</code> <code>Label</code> The label for this widget. <code>none</code> <code>String</code> <code>Style</code> The text style. <code>none</code> <code>{Any}</code><code>Var({Any})</code> <code>Variable</code> The variable that holds the input value. <code>none</code> <code>Int2</code><code>Var(Int2)</code> <code>Min</code> The minimum value. <code>none</code> <code>Int2</code><code>Var(Int2)</code> <code>Max</code> The maximum value. <code>none</code> <code>Int2</code><code>Var(Int2)</code> <p>A numeric slider.</p>"},{"location":"reference/shards/shards/UI/Int2Slider/#examples","title":"Examples","text":"CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.CentralPanel\n    (-&gt;\n     (UI.Int2Slider\n      :Variable .int2\n      :Min (int2 1) :Max (int2 100))\n     (ExpectInt2))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/UI/Int3Input/","title":"UI.Int3Input","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value is ignored. <code>&lt;output&gt;</code> The value produced. <code>Int3</code> <code>Variable</code> The variable that holds the input value. <code>none</code> <code>Int3</code><code>Var(Int3)</code> <p>A numeric input.</p>"},{"location":"reference/shards/shards/UI/Int3Input/#examples","title":"Examples","text":"CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.CentralPanel\n    (-&gt;\n     (UI.Int3Input\n      :Variable .int3)\n     (ExpectInt3))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/UI/Int3Slider/","title":"UI.Int3Slider","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value is ignored. <code>&lt;output&gt;</code> The value produced. <code>Int3</code> <code>Label</code> The label for this widget. <code>none</code> <code>String</code> <code>Style</code> The text style. <code>none</code> <code>{Any}</code><code>Var({Any})</code> <code>Variable</code> The variable that holds the input value. <code>none</code> <code>Int3</code><code>Var(Int3)</code> <code>Min</code> The minimum value. <code>none</code> <code>Int3</code><code>Var(Int3)</code> <code>Max</code> The maximum value. <code>none</code> <code>Int3</code><code>Var(Int3)</code> <p>A numeric slider.</p>"},{"location":"reference/shards/shards/UI/Int3Slider/#examples","title":"Examples","text":"CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.CentralPanel\n    (-&gt;\n     (UI.Int3Slider\n      :Variable .int3\n      :Min (int3 1) :Max (int3 100))\n     (ExpectInt3))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/UI/Int4Input/","title":"UI.Int4Input","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value is ignored. <code>&lt;output&gt;</code> The value produced. <code>Int4</code> <code>Variable</code> The variable that holds the input value. <code>none</code> <code>Int4</code><code>Var(Int4)</code> <p>A numeric input.</p>"},{"location":"reference/shards/shards/UI/Int4Input/#examples","title":"Examples","text":"CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.CentralPanel\n    (-&gt;\n     (UI.Int4Input\n      :Variable .int4)\n     (ExpectInt4))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/UI/Int4Slider/","title":"UI.Int4Slider","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value is ignored. <code>&lt;output&gt;</code> The value produced. <code>Int4</code> <code>Label</code> The label for this widget. <code>none</code> <code>String</code> <code>Style</code> The text style. <code>none</code> <code>{Any}</code><code>Var({Any})</code> <code>Variable</code> The variable that holds the input value. <code>none</code> <code>Int4</code><code>Var(Int4)</code> <code>Min</code> The minimum value. <code>none</code> <code>Int4</code><code>Var(Int4)</code> <code>Max</code> The maximum value. <code>none</code> <code>Int4</code><code>Var(Int4)</code> <p>A numeric slider.</p>"},{"location":"reference/shards/shards/UI/Int4Slider/#examples","title":"Examples","text":"CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.CentralPanel\n    (-&gt;\n     (UI.Int4Slider\n      :Variable .int4\n      :Min (int4 1) :Max (int4 100))\n     (ExpectInt4))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre> CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.CentralPanel\n    (-&gt;\n     (UI.Int4Slider\n      :Label \"My Label\"\n      :Style {:color (color 255 128 64) :italics true}\n      :Variable .int4\n      :Min (int4 1) :Max (int4 100))\n     (ExpectInt4))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/UI/IntInput/","title":"UI.IntInput","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value is ignored. <code>&lt;output&gt;</code> The value produced. <code>Int</code> <code>Variable</code> The variable that holds the input value. <code>none</code> <code>Int</code><code>Var(Int)</code> <code>Prefix</code> Display a prefix before the number. <code>none</code> <code>String</code> <p>A numeric input.</p>"},{"location":"reference/shards/shards/UI/IntInput/#examples","title":"Examples","text":"CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.CentralPanel\n    (-&gt;\n     (UI.IntInput\n      :Variable .int)\n     (ExpectInt))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/UI/IntSlider/","title":"UI.IntSlider","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value is ignored. <code>&lt;output&gt;</code> The value produced. <code>Int</code> <code>Label</code> The text label for this widget. <code>none</code> <code>String</code> <code>Style</code> The text style. <code>none</code> <code>{Any}</code><code>Var({Any})</code> <code>Variable</code> The variable that holds the input value. <code>none</code> <code>Int</code><code>Var(Int)</code> <code>Min</code> The minimum value. <code>none</code> <code>Int</code><code>Var(Int)</code> <code>Max</code> The maximum value. <code>none</code> <code>Int</code><code>Var(Int)</code> <p>A numeric slider.</p>"},{"location":"reference/shards/shards/UI/IntSlider/#examples","title":"Examples","text":"CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.CentralPanel\n    (-&gt;\n     (UI.IntSlider\n      :Variable .int\n      :Min 1 :Max 100)\n     (ExpectInt))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre> CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.CentralPanel\n    (-&gt;\n     (UI.IntSlider\n      :Label \"My Label\"\n      :Style {:color (color 255 128 64) :italics true}\n      :Variable .int\n      :Min 1 :Max 100)\n     (ExpectInt))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/UI/Label/","title":"UI.Label","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>String</code> <code>&lt;output&gt;</code> <code>String</code> <code>Wrap</code> The text wrapping mode. <code>TextWrap::Extend</code> <code>TextWrap</code><code>Bool</code> <code>Style</code> The text style. <code>none</code> <code>{Any}</code><code>Var({Any})</code> <p>Static text.</p>"},{"location":"reference/shards/shards/UI/Label/#examples","title":"Examples","text":"CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.CentralPanel\n    (-&gt;\n     \"Hello Shards!\" (UI.Label))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre> CodeOutput <pre><code>(def lorem_ipsum\n  \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\")\n\n(GFX.MainWindow\n :Width 480 :Height 360\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.CentralPanel\n    (UI.Columns\n     [(-&gt; lorem_ipsum (UI.Label :Wrap true))\n      nil\n      (-&gt; lorem_ipsum (UI.Label :Wrap false))])))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre> CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.CentralPanel\n    (-&gt;\n     \"Hello Shards!\" (UI.Label)\n     \"Hello Shards!\" (UI.Label :Style {:strikethrough true})\n     \"Hello Shards!\" (UI.Label :Style {:underline true})\n     \"Hello Shards!\" (UI.Label :Style {:italics true})\n     \"Hello Shards!\" (UI.Label :Style {:color (color 96 96 12)})\n     \"Hello Shards!\" (UI.Label :Style {:color (color 12 96 96) :italics true}))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/UI/Layout/","title":"UI.Layout","text":"Name - Description Default Type <code>&lt;input&gt;</code> Not used. <code>Any</code> <code>&lt;output&gt;</code> Passthrough the input. <code>Any</code> <code>Contents</code> The UI contents. <code>none</code> <code>Shard</code><code>[Shard]</code> <code>Class</code> The Layout class defining all layout options. <code>none</code> <code>Var(Object)</code> <code>MinSize</code> Minimum reserved space for the UI. Overridden by FillWidth and FillHeight. <code>none</code> <code>Float2</code><code>Var(Float2)</code> <code>MaxSize</code> Maximum reserved space for the UI. Overridden by FillWidth and FillHeight. <code>none</code> <code>Float2</code><code>Var(Float2)</code> <code>FillWidth</code> Whether the layout should occupy the full width. <code>none</code> <code>Bool</code><code>Var(Bool)</code> <code>FillHeight</code> Whether the layout should occupy the full height. <code>none</code> <code>Bool</code><code>Var(Bool)</code> <p>Versatile layout with numerous customization options.</p>"},{"location":"reference/shards/shards/UI/Layout/#examples","title":"Examples","text":""},{"location":"reference/shards/shards/UI/LayoutClass/","title":"UI.LayoutClass","text":"Name - Description Default Type <code>&lt;input&gt;</code> Not used. <code>Any</code> <code>&lt;output&gt;</code> A Layout class that can be used in other UI shards. <code>Object</code> <code>Parent</code> The parent Layout class to inherit parameters from. <code>none</code> <code>Var(Object)</code> <code>MainDirection</code> The primary direction of the UI element layout. <code>none</code> <code>LayoutDirection</code> <code>MainWrap</code> Should UI elements wrap when reaching the end of the main direction. <code>none</code> <code>Bool</code><code>Var(Bool)</code> <code>MainAlign</code> Alignment of UI elements along the main axis. <code>none</code> <code>LayoutAlign</code> <code>MainJustify</code> Justification of UI elements along the main axis. <code>none</code> <code>Bool</code><code>Var(Bool)</code> <code>CrossAlign</code> Alignment of UI elements along the cross axis. <code>none</code> <code>LayoutAlign</code> <code>CrossJustify</code> Justification of UI elements along the cross axis. <code>none</code> <code>Bool</code><code>Var(Bool)</code> <code>MinSize</code> Minimum space reserved for UI contents. Overridden by FillWidth and FillHeight. <code>none</code> <code>Float2</code><code>Var(Float2)</code> <code>MaxSize</code> Maximum space reserved for UI contents. Overridden by FillWidth and FillHeight. <code>none</code> <code>Float2</code><code>Var(Float2)</code> <code>FillWidth</code> Whether the layout should occupy the full width. <code>none</code> <code>Bool</code><code>Var(Bool)</code> <code>FillHeight</code> Whether the layout should occupy the full height. <code>none</code> <code>Bool</code><code>Var(Bool)</code> <code>Disabled</code> Whether the layout should be disabled. <code>none</code> <code>Bool</code><code>Var(Bool)</code> <code>Frame</code> Frame to be drawn around the layout. <code>none</code> <code>LayoutFrame</code> <code>EnableHorizontalScrollBar</code> Enable the horizontal scroll bar. Creates a ScrollArea if true. <code>none</code> <code>Bool</code><code>Var(Bool)</code> <code>EnableVerticalScrollBar</code> Enable the vertical scroll bar. Creates a ScrollArea if true. <code>none</code> <code>Bool</code><code>Var(Bool)</code> <code>ScrollBarVisibility</code> Visibility of the scroll bars: AlwaysVisible, VisibleWhenNeeded, or AlwaysHidden. Default: AlwaysVisible. <code>none</code> <code>ScrollVisibility</code> <code>ScrollAreaMinWidth</code> Minimum width of the scroll area. <code>none</code> <code>Float</code><code>Var(Float)</code> <code>ScrollAreaMinHeight</code> Minimum height of the scroll area. <code>none</code> <code>Float</code><code>Var(Float)</code> <code>ScrollAreaMaxWidth</code> Maximum width of the scroll area. <code>none</code> <code>Float</code><code>Var(Float)</code> <code>ScrollAreaMaxHeight</code> Maximum height of the scroll area. <code>none</code> <code>Float</code><code>Var(Float)</code> <code>ScrollAreaAutoShrinkWidth</code> Auto-shrink scroll area width to fit contents. <code>none</code> <code>Bool</code><code>Var(Bool)</code> <code>ScrollAreaAutoShrinkHeight</code> Auto-shrink scroll area height to fit contents. <code>none</code> <code>Bool</code><code>Var(Bool)</code> <code>ScrollAreaEnableScrolling</code> Enable scrolling in the scroll area. <code>none</code> <code>Bool</code><code>Var(Bool)</code> <p>This shard creates a Layout class that can be used in other UI shards.</p> <p> </p>"},{"location":"reference/shards/shards/UI/LeftPanel/","title":"UI.LeftPanel","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value that will be passed to the Contents shards of the panel. <code>Any</code> <code>&lt;output&gt;</code> The output of this shard will be its input. <code>Any</code> <code>Resizable</code> Whether the panel can be resized. <code>false</code> <code>Bool</code> <code>DefaultSize</code> The initial size of the panel. <code>none</code> <code>Float</code> <code>MinSize</code> The minimum allowable size of the panel. <code>none</code> <code>Float</code> <code>MaxSize</code> The maximum allowable size of the panel. <code>none</code> <code>Float</code> <code>Contents</code> The UI contents. <code>none</code> <code>Shard</code><code>[Shard]</code> <p>Layout UI elements into the panel.</p>"},{"location":"reference/shards/shards/UI/LeftPanel/#examples","title":"Examples","text":"CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.LeftPanel\n    :Contents\n    (-&gt;\n     \"Left Panel\" (UI.Label))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/UI/Link/","title":"UI.Link","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value that will be passed to the Action shards of the link. <code>Any</code> <code>&lt;output&gt;</code> Indicates whether the link was clicked during this frame. <code>Bool</code> <code>Label</code> Optional label for the link. <code>none</code> <code>String</code> <code>Action</code> The shards to execute when the link is clicked. <code>none</code> <code>Shard</code><code>[Shard]</code> <code>Style</code> The text style. <code>none</code> <code>{Any}</code><code>Var({Any})</code> <p>A clickable link.</p>"},{"location":"reference/shards/shards/UI/Link/#examples","title":"Examples","text":"CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.CentralPanel\n    (-&gt;\n     (UI.Link \"Click here\" (Msg \"Hello\")))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre> CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.CentralPanel\n    (-&gt;\n     (UI.Link\n      :Label \"Click here\"\n      :Style {:italics true}\n      :Action (Msg \"Hello\")))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/UI/ListBox/","title":"UI.ListBox","text":"Name - Description Default Type <code>&lt;input&gt;</code> A sequence of values. <code>Any</code> <code>&lt;output&gt;</code> The selected value. <code>Any</code> <code>Index</code> The index of the selected item. <code>none</code> <code>Int</code><code>Var(Int)</code> <code>IsSelected</code> Predicate that should return selection state of an item, receives the index in the list, should return true/false. <code>none</code> <code>Shard</code><code>[Shard]</code> <code>Clicked</code> Action to perform if an element of the list is being clicked. <code>none</code> <code>Shard</code><code>[Shard]</code> <code>Template</code> Custom rendering <code>none</code> <code>Shard</code><code>[Shard]</code> <p>A list selection.</p>"},{"location":"reference/shards/shards/UI/ListBox/#examples","title":"Examples","text":"CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.CentralPanel\n    (-&gt;\n     [\"\u03b1 \u0391\" \"\u03c9 \u03a9\"]\n     (UI.ListBox :Index .index)\n     (ExpectString) &gt;= .value\n\n     (UI.Horizontal\n      (-&gt; \"Selected index: \" (UI.Label)\n          .index (ToString) (UI.Label))))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre> CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.CentralPanel\n    (-&gt;\n     [1 2 3 4 5 6 7 8 9]\n     (UI.ListBox\n      :Index .index\n      :Template\n      (-&gt;\n       (ToString) (UI.Label)))\n     (ExpectInt) &gt;= .value\n\n     (UI.Horizontal\n      (-&gt; \"Selected index: \" (UI.Label)\n          .index (ToString) (UI.Label))))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre> CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n\n  (UI\n   (UI.CentralPanel\n    (-&gt;\n\n     (Setup\n      -1 &gt;= .clicked\n      [1 2 3 4 5 6 7 8 9] = .items)\n\n     .items\n     (UI.ListBox\n      :IsSelected (-&gt;\n                   = .i\n                   .clicked (If (IsLess 0) (-&gt; false)\n                                (-&gt; (IsLessEqual .i))))\n      :Clicked (-&gt; &gt; .clicked)\n      :Template\n      (-&gt;\n       (ToString) (UI.Label)))\n     (ExpectInt) &gt;= .value\n\n     (UI.Horizontal\n      (-&gt; \"Selected index: \" (UI.Label)\n          .clicked (ToString) (UI.Label))))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/UI/MarkdownViewer/","title":"UI.MarkdownViewer","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>String</code> <code>&lt;output&gt;</code> <code>String</code> <p>A markdown viewer.</p>"},{"location":"reference/shards/shards/UI/MarkdownViewer/#examples","title":"Examples","text":"CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.TopPanel\n    :Contents\n    (-&gt;\n     \"# Title\n\n## Sub-title\n**list:**\n- item 1\n- item 2\" (UI.MarkdownViewer))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre> CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.CentralPanel\n    :Contents\n    (-&gt;\n     (Setup\n      \"shards/UI/MarkdownViewer/sample.md\" (FS.Read) = .text)\n\n     (UI.ScrollArea\n      :Contents\n      (-&gt;\n       .text (UI.MarkdownViewer))))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/UI/Menu/","title":"UI.Menu","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value that will be passed to the Contents shards of the menu. <code>Any</code> <code>&lt;output&gt;</code> A boolean value indicating whether the menu is active. <code>Bool</code> <code>Title</code> The title of the menu. <code>none</code> <code>String</code> <code>Contents</code> The UI contents. <code>none</code> <code>Shard</code><code>[Shard]</code> <p>Creates a menu button that when clicked will show the given menu. If called from within a menu this will instead create a button for a sub-menu.</p>"},{"location":"reference/shards/shards/UI/Menu/#examples","title":"Examples","text":"CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.TopPanel\n    :Contents\n    (UI.MenuBar\n     (UI.Menu\n      :Title \"File\"\n      :Contents\n      (UI.Button \"Exit\")))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/UI/MenuBar/","title":"UI.MenuBar","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value that will be passed to the Contents shards of the menu bar. <code>Any</code> <code>&lt;output&gt;</code> A boolean value indicating whether the menu bar is active. <code>Bool</code> <code>Contents</code> The UI contents. <code>none</code> <code>Shard</code><code>[Shard]</code> <p>The menu bar goes well in a <code>UI.TopPanel</code>.</p>"},{"location":"reference/shards/shards/UI/MenuBar/#examples","title":"Examples","text":"CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.TopPanel\n    :Contents\n    (UI.MenuBar\n     :Contents\n     (UI.Menu\n      \"Menu\"\n      (-&gt; \"Some Text\" (UI.Label))))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/UI/NextRow/","title":"UI.NextRow","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value is ignored. <code>Any</code> <code>&lt;output&gt;</code> The output of this shard will be its input. <code>Any</code> <p>Moves to the next row in a grid layout.</p>"},{"location":"reference/shards/shards/UI/NextRow/#examples","title":"Examples","text":"CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.CentralPanel\n    (UI.Grid\n     :Striped true\n     :Contents\n     (-&gt;\n      \"Col 1\" (UI.Label)\n      \"Col 2\" (UI.Label)\n      \"Col 3\" (UI.Label)\n      (UI.NextRow)\n      \"Hello\" (UI.Label)\n      \"shards\" (UI.Label)\n      \"!\" (UI.Label)\n      (UI.NextRow)\n      \"Lorem ipsum dolor sit amet\" (UI.Label)\n      \"consectetur adipiscing elit\" (UI.Label)\n      \"sed do eiusmod tempor\" (UI.Label)))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/UI/Overlay/","title":"UI.Overlay","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Any</code> <code>&lt;output&gt;</code> <code>Any</code> <code>Items</code> A list of UI's to overlay on top of each other in order <code>none</code> <code>[[None Shard [Shard]]]</code> <p>Overlays multiple UI's on top of each other.</p> <p> </p>"},{"location":"reference/shards/shards/UI/PaintCircle/","title":"UI.PaintCircle","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value is ignored. <code>Any</code> <code>&lt;output&gt;</code> <code>Any</code> <code>Center</code> Center of the circle <code>none</code> <code>Float2</code><code>Var(Float2)</code> <code>Radius</code> Radius of the circle <code>none</code> <code>Float</code><code>Var(Float)</code> <code>StrokeWidth</code> Width of circle outline <code>none</code> <code>Float</code><code>Var(Float)</code> <code>StrokeColor</code> Color of circle outline <code>none</code> <code>Color</code><code>Var(Color)</code> <p>Draw a circle on the canvas</p> <p> </p>"},{"location":"reference/shards/shards/UI/Plot/","title":"UI.Plot","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value that will be passed to the Contents shards of the plot. <code>Any</code> <code>&lt;output&gt;</code> The output of this shard will be its input. <code>Any</code> <code>Contents</code> The UI contents. <code>none</code> <code>Shard</code><code>[Shard]</code> <code>ViewAspect</code> Width / height ratio of the plot region. <code>none</code> <code>Float</code><code>Var(Float)</code> <code>DataAspect</code> Width / height ratio of the data. <code>none</code> <code>Float</code><code>Var(Float)</code> <code>Legend</code> Whether to display the legend. <code>none</code> <code>Bool</code> <p>A 2D plot area.</p>"},{"location":"reference/shards/shards/UI/Plot/#examples","title":"Examples","text":"CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.CentralPanel\n    (UI.Plot\n     (-&gt;\n      [(float2 -1) (float2 0) (float2 1)] (UI.PlotLine)))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre> CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (-&gt;\n    (UI.TopPanel\n     :Contents\n     (UI.Checkbox \"Horizontal\" .horizontal))\n    (UI.CentralPanel\n     (UI.Plot\n      (-&gt;\n       [] &gt;= .hist\n       (ForRange\n        -40 39\n        (-&gt;\n         (Setup\n          0.02 (Math.Multiply 3.1415926535) (Math.Sqrt) = .f)\n         (ToFloat) (Math.Divide 10.0) (Math.Add 0.05) &gt;= .x\n         .x (Math.Multiply .x) (Math.Divide -2.0) (Math.Exp) (Math.Divide .f) &gt;= .y\n         [.x .y] (ToFloat2) &gt;&gt; .hist))\n\n       .hist (ExpectLike [(float2 0)])\n       (UI.PlotBar\n        :Horizontal .horizontal\n        :Width 0.095\n        :Color (color 173 216 230)))))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre> CodeOutput <pre><code>(def N 32)\n(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.CentralPanel\n    (UI.Plot\n     :Legend true\n     :Contents\n     (-&gt;\n      [] &gt;= .sin\n      (ForRange\n       (- N) N\n       (-&gt;\n        (ToFloat) (Math.Divide  (/ N 3.1415926535)) &gt;= .x\n        .x (Math.Sin) &gt;= .y\n        [.x .y] (ToFloat2) &gt;&gt; .sin))\n      .sin (ExpectLike [(float2 0)])\n      (UI.PlotPoints\n       :Color (color 200 100 100)\n       :Name \"sin\")))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/UI/PlotBar/","title":"UI.PlotBar","text":"Name - Description Default Type <code>&lt;input&gt;</code> A sequence of point coordinates. <code>[Float2]</code> <code>&lt;output&gt;</code> The output of this shard will be its input. <code>[Float2]</code> <code>Color</code> Stroke color. <code>none</code> <code>Color</code><code>Var(Color)</code> <code>Width</code> Width of a bar. <code>none</code> <code>Float</code> <code>Horizontal</code> Display the bars horizontally. <code>none</code> <code>Bool</code><code>Var(Bool)</code> <code>Name</code> Name of this chart, displayed in the plot legend. <code>none</code> <code>String</code> <p>Points represented as vertical or horizontal bars on a plot.</p>"},{"location":"reference/shards/shards/UI/PlotBar/#examples","title":"Examples","text":"CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (-&gt;\n    (UI.TopPanel\n     :Contents\n     (UI.Checkbox \"Horizontal\" .horizontal))\n    (UI.CentralPanel\n     (UI.Plot\n      (-&gt;\n       [] &gt;= .hist\n       (ForRange\n        -40 39\n        (-&gt;\n         (Setup\n          0.02 (Math.Multiply 3.1415926535) (Math.Sqrt) = .f)\n         (ToFloat) (Math.Divide 10.0) (Math.Add 0.05) &gt;= .x\n         .x (Math.Multiply .x) (Math.Divide -2.0) (Math.Exp) (Math.Divide .f) &gt;= .y\n         [.x .y] (ToFloat2) &gt;&gt; .hist))\n\n       .hist (ExpectLike [(float2 0)])\n       (UI.PlotBar\n        :Horizontal .horizontal\n        :Width 0.095\n        :Color (color 173 216 230)))))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/UI/PlotLine/","title":"UI.PlotLine","text":"Name - Description Default Type <code>&lt;input&gt;</code> A sequence of point coordinates. <code>[Float2]</code> <code>&lt;output&gt;</code> The output of this shard will be its input. <code>[Float2]</code> <code>Color</code> Stroke color. <code>none</code> <code>Color</code><code>Var(Color)</code> <code>Name</code> Name of this chart, displayed in the plot legend. <code>none</code> <code>String</code> <p>Line-connected points on a plot.</p>"},{"location":"reference/shards/shards/UI/PlotLine/#examples","title":"Examples","text":"CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.CentralPanel\n    (UI.Plot\n     (-&gt;\n      [(float2 -1) (float2 0) (float2 1)] (UI.PlotLine)))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/UI/PlotPoints/","title":"UI.PlotPoints","text":"Name - Description Default Type <code>&lt;input&gt;</code> A sequence of point coordinates. <code>[Float2]</code> <code>&lt;output&gt;</code> The output of this shard will be its input. <code>[Float2]</code> <code>Name</code> Name of this chart, displayed in the plot legend. <code>none</code> <code>String</code> <code>Color</code> Stroke color. <code>none</code> <code>Color</code><code>Var(Color)</code> <code>Shape</code> Shape of the marker. <code>none</code> <code>MarkerShape</code> <code>Radius</code> Radius of the marker. <code>none</code> <code>Float</code> <p>Scattered points on a plot.</p>"},{"location":"reference/shards/shards/UI/PlotPoints/#examples","title":"Examples","text":"CodeOutput <pre><code>(def N 32)\n(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.CentralPanel\n    (UI.Plot\n     :Legend true\n     :Contents\n     (-&gt;\n      [] &gt;= .sin\n      (ForRange\n       (- N) N\n       (-&gt;\n        (ToFloat) (Math.Divide  (/ N 3.1415926535)) &gt;= .x\n        .x (Math.Sin) &gt;= .y\n        [.x .y] (ToFloat2) &gt;&gt; .sin))\n      .sin (ExpectLike [(float2 0)])\n      (UI.PlotPoints\n       :Color (color 200 100 100)\n       :Name \"sin\")))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/UI/PopupWrapper/","title":"UI.PopupWrapper","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value that will be passed to the Widget shard(s) of the popup. <code>Any</code> <code>&lt;output&gt;</code> The output of this shard will be its input. <code>Any</code> <code>MinWidth</code> The minimum width of the popup that should appear below or above the button. By default, it is always at least as wide as the button. <code>none</code> <code>Float</code> <code>AboveOrBelow</code> Whether the location of the popup should be above or below the button. <code>none</code> <code>PopupLocation</code> <code>ID</code> An optional ID value to make the popup unique if the label text collides. <code>none</code> <code>String</code><code>Var(String)</code> <code>Widget</code> The shard(s) to execute that should contain a widget that supports having this popup generated for it upon being clicked. <code>none</code> <code>Shard</code><code>[Shard]</code> <code>Contents</code> The shards to execute and render inside the popup ui when the button is pressed. <code>none</code> <code>Shard</code><code>[Shard]</code> <p>Wraps a button with a popup that can act as a drop-down menu or suggestion menu.</p>"},{"location":"reference/shards/shards/UI/PopupWrapper/#examples","title":"Examples","text":""},{"location":"reference/shards/shards/UI/ProgressBar/","title":"UI.ProgressBar","text":"Name - Description Default Type <code>&lt;input&gt;</code> The progress amount ranging from 0.0 (no progress) to 1.0 (completed). <code>Float</code> <code>&lt;output&gt;</code> The output of this shard will be its input. <code>Float</code> <code>Overlay</code> The text displayed inside the progress bar. <code>none</code> <code>String</code><code>Var(String)</code> <code>Width</code> The desired width of the progress bar. Will use all horizontal space if not set. <code>none</code> <code>Float</code><code>Var(Float)</code> <p>A progress bar with an optional overlay text.</p>"},{"location":"reference/shards/shards/UI/ProgressBar/#examples","title":"Examples","text":"CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.CentralPanel\n    (-&gt;\n     (Setup\n      0.0 &gt;= .progress)\n     .progress (UI.ProgressBar :Overlay \"Progress\")\n     (Math.Add 0.01) &gt; .progress)))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/UI/Property/","title":"UI.Property","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>&lt;output&gt;</code> <code>Float4</code><code>Float2</code><code>Float</code><code>Bool</code> <code>Property</code> The property to retrieve from the UI context <code>none</code> <code>UIProperty</code> <p>Retrieves values from the current state of the UI.</p>"},{"location":"reference/shards/shards/UI/Property/#examples","title":"Examples","text":"CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.CentralPanel\n    :Contents\n    (-&gt;\n     (UI.Property UIProperty.RemainingSpace)\n     (Once (Log)))))))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/UI/RadioButton/","title":"UI.RadioButton","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value is ignored. <code>&lt;output&gt;</code> Indicates whether the radio button was clicked during this frame. <code>Bool</code> <code>Label</code> The text label of this radio button. <code>none</code> <code>String</code> <code>Variable</code> The variable that holds the input value. <code>none</code> <code>Any</code><code>Var(Any)</code> <code>Value</code> The value to compare with. <code>none</code> <code>Any</code> <code>Style</code> The text style. <code>none</code> <code>{Any}</code><code>Var({Any})</code> <p>A radio button for selecting a value amongst multiple choices.</p>"},{"location":"reference/shards/shards/UI/RadioButton/#examples","title":"Examples","text":"CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.CentralPanel\n    (-&gt;\n     (Setup 2 &gt;= .choice)\n     (UI.RadioButton\n      :Label \"Choice 1\"\n      :Variable .choice\n      :Value 1)\n     (UI.RadioButton \"Choice 2\" .choice 2)\n     (UI.RadioButton \"Choice 3\" .choice 3))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre> CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.CentralPanel\n    (-&gt;\n     (Setup 2 &gt;= .choice)\n     (UI.RadioButton :Label \"Choice 1\" :Style {} :Variable .choice :Value 1)\n     (UI.RadioButton\n      :Label \"Choice 2\"\n      :Style {:underline true}\n      :Variable .choice\n      :Value 2)\n     (UI.RadioButton :Label \"Choice 3\" :Style {} :Variable .choice :Value 3))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/UI/Render/","title":"UI.Render","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>[Object]</code><code>Object</code> <code>&lt;output&gt;</code> <code>[Object]</code><code>Object</code> <code>Queue</code> The draw queue. <code>none</code> <code>Var(GFX.DrawQueue)</code> <p>Render given UI</p> <p> </p>"},{"location":"reference/shards/shards/UI/RenderTarget/","title":"UI.RenderTarget","text":"Name - Description Default Type <code>&lt;input&gt;</code> The image to display. <code>GFX.Texture2D</code> <code>&lt;output&gt;</code> The output of this shard will be its input. <code>GFX.Texture2D</code> <code>Scale</code> Scaling to apply to the source texture. <code>@f2(1 1)</code> <code>Float2</code><code>Var(Float2)</code> <p>Display the contents of a render target. Consumes input on the region.</p> <p> </p>"},{"location":"reference/shards/shards/UI/Reset/","title":"UI.Reset","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value is ignored. <code>Any</code> <code>&lt;output&gt;</code> The output of this shard will be its input. <code>Any</code> <p>Forgets UI scroll, position, size changes, etc.</p>"},{"location":"reference/shards/shards/UI/Reset/#examples","title":"Examples","text":"CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (-&gt;\n    (UI.TopPanel\n     :Contents\n     (UI.MenuBar\n      (UI.Menu\n       :Title \"File\"\n       :Contents\n       (UI.Tooltip\n        :Contents\n        (UI.Button \"Reset UI memory\" (UI.Reset))\n        :OnHover\n        (-&gt;\n         \"Forget scroll, positions, sizes, etc.\" (UI.Label))))))\n\n    (UI.Window\n     :Title \"My Window\"\n     :Position (float2 10 100)\n     :Contents\n     (-&gt; \"Lorem ipsum\" (UI.Label)\n         (UI.Separator)))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/UI/RestoreState/","title":"UI.RestoreState","text":"Name - Description Default Type <code>&lt;input&gt;</code> The UI state to restore to represented as a byte array. <code>Bytes</code> <code>&lt;output&gt;</code> The output of this shard will be its input passed through unchanged. <code>Bytes</code> <p>This shard restores the UI to a previously saved state (provided as input as a byte array).</p> <p> </p>"},{"location":"reference/shards/shards/UI/RightPanel/","title":"UI.RightPanel","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value that will be passed to the Contents shards of the panel. <code>Any</code> <code>&lt;output&gt;</code> The output of this shard will be its input. <code>Any</code> <code>Resizable</code> Whether the panel can be resized. <code>false</code> <code>Bool</code> <code>DefaultSize</code> The initial size of the panel. <code>none</code> <code>Float</code> <code>MinSize</code> The minimum allowable size of the panel. <code>none</code> <code>Float</code> <code>MaxSize</code> The maximum allowable size of the panel. <code>none</code> <code>Float</code> <code>Contents</code> The UI contents. <code>none</code> <code>Shard</code><code>[Shard]</code> <p>Layout UI elements into the panel.</p>"},{"location":"reference/shards/shards/UI/RightPanel/#examples","title":"Examples","text":"CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.RightPanel\n    :Contents\n    (-&gt;\n     \"Right Panel\" (UI.Label))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/UI/SaveState/","title":"UI.SaveState","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value is ignored. <code>&lt;output&gt;</code> Returns the current state of the UI as a byte array. <code>Bytes</code> <p>This shard saves the current state of the UI as a byte array. It saves UI information such as the position of windows, the state of checkboxes, the state of sliders, etc.</p> <p> </p>"},{"location":"reference/shards/shards/UI/Scope/","title":"UI.Scope","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value that will be passed to the Contents shards of the scope. <code>Any</code> <code>&lt;output&gt;</code> The output of this shard will be its input. <code>Any</code> <code>Contents</code> The UI contents. <code>none</code> <code>Shard</code><code>[Shard]</code> <p>Creates a scoped child UI.</p>"},{"location":"reference/shards/shards/UI/Scope/#examples","title":"Examples","text":"CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.CentralPanel\n    (UI.Scope\n     :Contents\n     (-&gt;\n        ;; UI here\n      nil))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/UI/ScrollArea/","title":"UI.ScrollArea","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value that will be passed to the Contents shards of the scroll area. <code>Any</code> <code>&lt;output&gt;</code> The output of this shard will be its input. <code>Any</code> <code>Contents</code> The UI contents. <code>none</code> <code>Shard</code><code>[Shard]</code> <code>Horizontal</code> Enable horizontal scrolling. <code>false</code> <code>Bool</code> <code>Vertical</code> Enable vertical scrolling. <code>true</code> <code>Bool</code> <code>AlwaysShow</code> Always show the enabled scroll bars even if not needed. <code>false</code> <code>Bool</code> <p>Add vertical and/or horizontal scrolling to a contained UI.</p>"},{"location":"reference/shards/shards/UI/ScrollArea/#examples","title":"Examples","text":"CodeOutput <pre><code>(def lorem_ipsum\n  \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\")\n\n(GFX.MainWindow\n :Width 480 :Height 320\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.CentralPanel\n    (UI.ScrollArea\n     :Horizontal true\n     :Contents\n     (-&gt;\n      lorem_ipsum (UI.Label :Wrap false)))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/UI/Selectable/","title":"UI.Selectable","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Any</code> <code>&lt;output&gt;</code> <code>Bool</code> <code>Contents</code> The UI contents to wrap, contain, and detect for selection. <code>none</code> <code>Shard</code><code>[Shard]</code> <code>IsSelected</code> Callback function for checking if the contents are currently selected. <code>none</code> <code>Shard</code><code>[Shard]</code> <code>Clicked</code> Callback function for the contents of this shard is clicked. <code>none</code> <code>Shard</code><code>[Shard]</code> <code>DoubleClicked</code> Callback function for the contents of this shard is clicked. <code>none</code> <code>Shard</code><code>[Shard]</code> <code>ContextMenu</code> Callback function for the right-click context menu. <code>none</code> <code>Shard</code><code>[Shard]</code> <code>DragData</code> Enables dragging and sets the data for drag operations <code>none</code> <code>Any</code> <code>ID</code> An optional ID value in case of ID conflicts. <code>none</code> <code>String</code><code>Var(String)</code> <p>A wrapper that detects selection over the provided contents.</p>"},{"location":"reference/shards/shards/UI/Selectable/#examples","title":"Examples","text":""},{"location":"reference/shards/shards/UI/Separator/","title":"UI.Separator","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value is ignored. <code>Any</code> <code>&lt;output&gt;</code> The output of this shard will be its input. <code>Any</code> <p>A visual separator. A horizontal or vertical line (depending on the layout).</p>"},{"location":"reference/shards/shards/UI/Separator/#examples","title":"Examples","text":"CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.CentralPanel\n    (-&gt;\n     \"Hello\" (UI.Label)\n     (UI.Separator)\n     \"World\" (UI.Label))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/UI/SetClipboard/","title":"UI.SetClipboard","text":"Name - Description Default Type <code>&lt;input&gt;</code> The string to set as the clipboard contents. <code>String</code> <code>&lt;output&gt;</code> Outputs the input value, passed through unchanged. <code>String</code> <p>This shard sets the input string to the system clipboard.</p> <p> </p>"},{"location":"reference/shards/shards/UI/Settings/","title":"UI.Settings","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Any</code> <code>&lt;output&gt;</code> <code>Any</code> <p>Show settings ui</p> <p> </p>"},{"location":"reference/shards/shards/UI/Shards/","title":"UI.Shards","text":"Name - Description Default Type <code>&lt;input&gt;</code> No input required, the AST is manipulated in place. <code>&lt;output&gt;</code> True if the AST has been modified, false otherwise. <code>Bool</code> <code>AST</code> The Shards AST object to edit in real time, this shard will manipulate and edit this variable in place. <code>none</code> <code>Var(Object)</code> <p>A Shards program AST visual editor.</p> <p> </p>"},{"location":"reference/shards/shards/UI/Sized/","title":"UI.Sized","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value that will be passed to the Contents shards of the layout. <code>Any</code> <code>&lt;output&gt;</code> The output of this shard will be its input. <code>Any</code> <code>Contents</code> The UI contents. <code>none</code> <code>Shard</code><code>[Shard]</code> <code>Width</code> <code>0</code> <code>Float</code> <code>Height</code> <code>0</code> <code>Float</code> <code>FillWidth</code> <code>false</code> <code>Bool</code> <code>FillHeight</code> <code>false</code> <code>Bool</code> <p>Layout the contents sizedly.</p> <p> </p>"},{"location":"reference/shards/shards/UI/Space/","title":"UI.Space","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value is ignored. <code>Any</code> <code>&lt;output&gt;</code> The output of this shard will be its input. <code>Any</code> <code>Amount</code> The amount of space to insert. <code>none</code> <code>Float</code><code>Var(Float)</code> <p>Inserts an empty space before the next widget. The direction will depend on the layout.</p> <p> </p>"},{"location":"reference/shards/shards/UI/Spinner/","title":"UI.Spinner","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value is ignored. <code>Any</code> <code>&lt;output&gt;</code> The output of this shard will be its input. <code>Any</code> <code>Size</code> Overrides the size of the spinner. This sets both the height and width, as the spinner is always square. <code>none</code> <code>Float</code><code>Var(Float)</code> <p>A spinner widget used to indicate loading.</p>"},{"location":"reference/shards/shards/UI/Spinner/#examples","title":"Examples","text":"CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n\n  (UI\n   (UI.CentralPanel\n    (UI.Spinner)))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/UI/Style/","title":"UI.Style","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Any</code> <code>&lt;output&gt;</code> <code>Any</code> <code>InheritDefault</code> Inherit default style instead of current style. <code>false</code> <code>Bool</code> <code>OverrideTextStyle</code> If set this will change the default TextStyle for all widgets. <code>none</code> <code>TextStyle</code><code>Var(TextStyle)</code><code>String</code><code>Var(String)</code> <code>FontId</code> If set this will change the font family and size for all widgets. <code>none</code> <code>{Any}</code><code>Var({Any})</code> <code>TextStyles</code> The FontFamily and size you want to use for a specific TextStyle. <code>none</code> <code>{Any}</code><code>Var({Any})</code> <code>DragValueTextStyle</code> The style to use for DragValue text. <code>none</code> <code>TextStyle</code><code>Var(TextStyle)</code><code>String</code><code>Var(String)</code> <code>Wrap</code> If set, labels, buttons, etc will use this to determine wrap behavior of the text at the right edge of the Ui they are in. <code>none</code> <code>Bool</code><code>TextWrap</code> <code>AnimationTime</code> How many seconds a typical animation should last. <code>none</code> <code>Float</code><code>Var(Float)</code> <code>ExplanationTooltips</code> Show tooltips explaining DragValues etc when hovered. <code>none</code> <code>Bool</code> <code>ResizeGrabRadiusSide</code> Mouse must be this close to the side of a window to resize <code>none</code> <code>Float</code><code>Var(Float)</code> <code>ResizeGrabRadiusCorner</code> Mouse must be this close to the corner of a window to resize <code>none</code> <code>Float</code><code>Var(Float)</code> <code>ShowTooltipsOnlyWhenStill</code> If <code>false</code>, tooltips will show up anytime you hover anything, even is mouse is still moving <code>none</code> <code>Bool</code> <code>ItemSpacing</code> Horizontal and vertical spacing between widgets. <code>none</code> <code>Float2</code><code>Var(Float2)</code> <code>WindowMargin</code> Horizontal and vertical margins within a window frame. <code>none</code> <code>Float4</code><code>Var(Float4)</code> <code>ButtonPadding</code> Button size is text size plus this on each side <code>none</code> <code>Float2</code><code>Var(Float2)</code> <code>MenuMargin</code> Horizontal and vertical margins within a menu frame. <code>none</code> <code>Float4</code><code>Var(Float4)</code> <code>Indent</code> Indent collapsing regions etc by this much. <code>none</code> <code>Float</code><code>Var(Float)</code> <code>InteractSize</code> Minimum size of a DragValue, color picker button, and other small widgets. interact_size.y is the default height of button, slider, etc. Anything clickable should be (at least) this size. <code>none</code> <code>Float2</code><code>Var(Float2)</code> <code>SliderWidth</code> Default width of a Slider. <code>none</code> <code>Float</code><code>Var(Float)</code> <code>ComboWidth</code> Default (minimum) width of a ComboBox. <code>none</code> <code>Float</code><code>Var(Float)</code> <code>TextEditWidth</code> Default width of a TextEdit. <code>none</code> <code>Float</code><code>Var(Float)</code> <code>IconWidth</code> Checkboxes, radio button and collapsing headers have an icon at the start. This is the width/height of the outer part of this icon (e.g. the BOX of the checkbox). <code>none</code> <code>Float</code><code>Var(Float)</code> <code>IconWidthInner</code> Checkboxes, radio button and collapsing headers have an icon at the start. This is the width/height of the inner part of this icon (e.g. the check of the checkbox). <code>none</code> <code>Float</code><code>Var(Float)</code> <code>IconSpacing</code> Checkboxes, radio button and collapsing headers have an icon at the start. This is the spacing between the icon and the text <code>none</code> <code>Float</code><code>Var(Float)</code> <code>DefaultAreaSize</code> The size used for the [<code>Ui::max_rect</code>] the first frame. Text will wrap at this width, and images that expand to fill the available space will expand to this size. <code>none</code> <code>Float2</code><code>Var(Float2)</code> <code>TooltipWidth</code> Width of a tooltip (on_hover_ui, on_hover_text etc). <code>none</code> <code>Float</code><code>Var(Float)</code> <code>IndentEndsWithHorizontalLine</code> End indented regions with a horizontal line <code>none</code> <code>Bool</code> <code>ComboHeight</code> Height of a combo-box before showing scroll bars. <code>none</code> <code>Float</code><code>Var(Float)</code> <code>ScrollBarFloating</code> Use floating scroll bar. <code>none</code> <code>Bool</code><code>Var(Bool)</code> <code>ScrollBarWidth</code> Width of a scroll bar. <code>none</code> <code>Float</code><code>Var(Float)</code> <code>ScrollBarFloatingWidth</code> Width of a floating scroll bar (not hovering). <code>none</code> <code>Float</code><code>Var(Float)</code> <code>ScrollBarFloatingAllocatedWidth</code> Allocated width of a floating scroll bar (not hovering). <code>none</code> <code>Float</code><code>Var(Float)</code> <code>ScrollHandleMinLength</code> Make sure the scroll handle is at least this big <code>none</code> <code>Float</code><code>Var(Float)</code> <code>ScrollBarInnerMargin</code> Margin between contents and scroll bar. <code>none</code> <code>Float</code><code>Var(Float)</code> <code>ScrollBarOuterMargin</code> Margin between scroll bar and the outer container (e.g. right of a vertical scroll bar). <code>none</code> <code>Float</code><code>Var(Float)</code> <code>ScrollBarDormantOpacity</code> Opacity of the scroll bar when dormant. <code>none</code> <code>Float</code><code>Var(Float)</code> <code>DarkMode</code> If true, the visuals are overall dark with light text. If false, the visuals are overall light with dark text. <code>none</code> <code>Bool</code><code>Var(Bool)</code> <code>OverrideTextColor</code> Override default text color for all text. <code>none</code> <code>Color</code><code>Var(Color)</code> <code>Selection</code> <code>none</code> <code>{Any}</code><code>Var({Any})</code> <code>HyperlinkColor</code> The color used for Hyperlink <code>none</code> <code>Color</code><code>Var(Color)</code> <code>FaintBgColor</code> Something just barely different from the background color. Used for Grid::striped. <code>none</code> <code>Color</code><code>Var(Color)</code> <code>ExtremeBgColor</code> Very dark or light color (for corresponding theme). Used as the background of text edits, scroll bars and others things that needs to look different from other interactive stuff. <code>none</code> <code>Color</code><code>Var(Color)</code> <code>CodeBgColor</code> Background color behind code-styled monospaced labels. <code>none</code> <code>Color</code><code>Var(Color)</code> <code>WarnFgColor</code> A good color for warning text (e.g. orange). <code>none</code> <code>Color</code><code>Var(Color)</code> <code>ErrorFgColor</code> A good color for error text (e.g. red). <code>none</code> <code>Color</code><code>Var(Color)</code> <code>WindowRounding</code> Window corner rounding. <code>none</code> <code>Float4</code><code>Var(Float4)</code> <code>WindowShadow</code> Window shadow size. <code>none</code> <code>{Any}</code><code>Var({Any})</code> <code>WindowFill</code> Window background color. <code>none</code> <code>Color</code><code>Var(Color)</code> <code>WindowStroke</code> Window stroke (border) color and thickness. <code>none</code> <code>{Any}</code><code>Var({Any})</code> <code>MenuRounding</code> Menu corner rounding. <code>none</code> <code>Float4</code><code>Var(Float4)</code> <code>PanelFill</code> Panel background color. <code>none</code> <code>Color</code><code>Var(Color)</code> <code>PopupShadow</code> Popup shadow size. <code>none</code> <code>{Any}</code><code>Var({Any})</code> <code>ResizeCornerSize</code> Corner rounding for resize handle rects. <code>none</code> <code>Float</code><code>Var(Float)</code> <code>TextCursorWidth</code> Width of the line cursor when hovering over InputText etc. <code>none</code> <code>Float</code><code>Var(Float)</code> <code>TextCursorPreview</code> Show where the text cursor would be if you clicked. <code>none</code> <code>Bool</code><code>Var(Bool)</code> <code>ClipRectMargin</code> Allow child widgets to be just on the border and still have a stroke with some thickness <code>none</code> <code>Float</code><code>Var(Float)</code> <code>ButtonFrame</code> Show a background behind buttons. <code>none</code> <code>Bool</code><code>Var(Bool)</code> <code>CollapsingHeaderFrame</code> Show a background behind collapsing headers. <code>none</code> <code>Bool</code><code>Var(Bool)</code> <code>IndentHasLeftVLine</code> Draw a vertical lien left of indented region, in e.g. CollapsingHeader. <code>none</code> <code>Bool</code><code>Var(Bool)</code> <code>Striped</code> Whether or not Grids and Tables should be striped by default (have alternating rows differently colored). <code>none</code> <code>Bool</code><code>Var(Bool)</code> <code>SliderTrailingFill</code> Show trailing color behind the circle of a Slider. Default is OFF. Enabling this will affect ALL sliders, and can be enabled/disabled per slider with Slider::trailing_fill. <code>none</code> <code>Bool</code><code>Var(Bool)</code> <p>Apply style changes to the current UI scope.</p>"},{"location":"reference/shards/shards/UI/Style/#examples","title":"Examples","text":"CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.CentralPanel\n    :Contents\n    (-&gt;\n     (UI.Style\n      :OverrideTextStyle \"MyStyle\"\n      :TextStyles {:MyStyle {:Size 36.0\n                             :Family FontFamily.Monospace}})\n     \"Hello Shards!\" (UI.Label)\n\n     (UI.Style :TextStyles {:MyStyle {:Size 16.0 :Family FontFamily.Monospace}})\n     \"Hello Shards!\" (UI.Label)\n\n     (UI.Style :TextStyles {:MyStyle {:Size 20.0 :Family FontFamily.Proportional}})\n     \"Hello Shards!\" (UI.Label)\n\n    ;;  (UI.Style :TextStyles {:MyStyle {:Size 24.0 :Family FontFamily.Monospace}})\n    ;;  (UI.Button \"Button\")\n     ;\n     )))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre> CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.CentralPanel\n    (-&gt;\n     (Setup\n      64 &gt;= .hue\n      0 &gt;= .r &gt;= .g\n      (color 0 0 0 0) &gt;= .color\n      16.0 &gt;= .size)\n\n     255 (Math.Subtract .hue) (Math.Multiply 2) (Min 255) &gt; .r\n     .hue (Math.Multiply 2) (Min 255) &gt; .g\n     [.r .g 0 255] (ToColor) &gt; .color\n\n     (UI.Scope\n      (-&gt;\n       (UI.Style\n        :OverrideTextStyle \"MyStyle\"\n        :TextStyles {:MyStyle {:Size .size\n                               :Family FontFamily.Monospace}}\n        :OverrideTextColor .color)\n       (UI.IntSlider\n        :Variable .hue\n        :Min 0 :Max 255)\n       (UI.FloatSlider\n        :Variable .size\n        :Min 8.0 :Max 96.0)\n       \"Hello Shards!\" (UI.Label)))\n\n     \"This text is not affected\" (UI.Label))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/UI/SubArea/","title":"UI.SubArea","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Any</code> <code>&lt;output&gt;</code> <code>Any</code> <code>Contents</code> The UI contents. <code>none</code> <code>Shard</code><code>[Shard]</code> <code>Offset</code> Relative offset. (X/Y) <code>none</code> <code>Float2</code><code>Var(Float2)</code> <code>Anchor</code> The anchor for the inner UI, relative to the available space <code>none</code> <code>Anchor</code><code>Var(Anchor)</code> <code>Pivot</code> The pivot for the inner UI <code>none</code> <code>Anchor</code><code>Var(Anchor)</code> <p>Places UI element at a specific position.</p> <p> </p>"},{"location":"reference/shards/shards/UI/Tab/","title":"UI.Tab","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value that will be passed to the Contents shards of the tab. <code>Any</code> <code>&lt;output&gt;</code> The output of this shard will be its input. <code>Any</code> <code>Title</code> The title of the tab. <code>none</code> <code>String</code> <code>Contents</code> The UI contents. <code>none</code> <code>Shard</code><code>[Shard]</code> <p>Experimental/unstable</p> <p>This API is experimental and might produce unexpected results or crash.</p> <p>Represents a tab inside a DockArea.</p>"},{"location":"reference/shards/shards/UI/Tab/#examples","title":"Examples","text":"CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.DockArea\n    :Contents\n    (-&gt;\n     (UI.Tab\n      :Title \"Tab 1\"\n      :Contents\n      (-&gt; \"Tab 1 contents\" (UI.Label)))\n     (UI.Tab\n      :Title \"Tab 2\"\n      :Contents\n      (-&gt; \"Tab 2 contents\" (UI.Label))))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/UI/Table/","title":"UI.Table","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value that will be passed to the Columns and Rows shards of the table. <code>[Any]</code> <code>&lt;output&gt;</code> The output of this shard will be its input. <code>[Any]</code> <code>Builder</code> Sequence of shards to build each column, repeated for each row. <code>[]</code> <code>[None Shard [Shard]]</code> <code>Columns</code> Configuration of the columns. <code>none</code> <code>[{Any}]</code> <code>Striped</code> Whether to alternate a subtle background color to every other row. <code>none</code> <code>Bool</code><code>Var(Bool)</code> <code>Resizable</code> Whether columns can be resized within their specified range. <code>none</code> <code>Bool</code><code>Var(Bool)</code> <code>RowIndex</code> Variable to hold the row index, to be used within Rows. <code>Var: Table.RowIndex</code> <code>Int</code><code>Var(Int)</code> <p>Table layout.</p>"},{"location":"reference/shards/shards/UI/Table/#examples","title":"Examples","text":"CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.CentralPanel\n    :Contents\n    (-&gt;\n     [{:Name \"Doe\" :Surname \"John\"}\n      {:Name \"Dough\" :Surname \"Jane\"}\n      {:Name \"Smith\" :Surname \"Dick\"}]\n     (UI.Table\n      :Resizable true\n      :Striped true\n      :RowIndex .index\n      :Columns\n      [{:Initial (float 20)}\n       {:Header \"Surname\"\n        :Initial (float 100) :AtLeast (float 60) :AtMost (float 160)}\n       {:Header \"Name\"\n        :Initial (float 80) :AtLeast (float 60) :AtMost (float 160)}]\n      :Builder\n      [(-&gt; .index (ToString) (UI.Label))\n       (-&gt; (Take \"Surname\") (UI.Label))\n       (-&gt; (Take \"Name\") (UI.Label))]))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre> CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.CentralPanel\n    :Contents\n    (-&gt;\n     [(int2 0) (int2 0 1) (int2 1) (int2 1 0)]\n     (UI.Table\n      :Columns\n      [{:Header \"A\"}\n       {:Header \"B\"}\n       {:Header \"A xor B\"}]\n      :Builder\n      [(-&gt; (Take 0) (ToString) (UI.Label))\n       (-&gt; (Take 1) (ToString) (UI.Label))\n       (-&gt; (| (Take 0) &gt;= .a)\n           (| (Take 1) &gt;= .b)\n           .a (Math.Xor .b) (ToString) (UI.Label))]))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre> CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.CentralPanel\n    :Contents\n    (-&gt;\n     [{:Name \"Doe\" :Surname \"John\"}\n      {:Name \"Dough\" :Surname \"Jane\"}\n      {:Name \"Smith\" :Surname \"Dick\"}]\n     (UI.Table\n      :Resizable true\n      :Striped true\n      :RowIndex .index\n      :Columns\n      [{:Initial (float 20)}\n       {:Header \"Surname\"\n        :Initial (float 100) :AtLeast (float 60) :AtMost (float 160)}\n       {:Header\n        (-&gt; \"Name\" (UI.Label :Style {:text_style \"Heading\"})\n            (UI.Button \"Up\" (Msg \"Clicked Up\") :Style {:text_style \"Small\"})\n            (UI.Button \"Down\" (Msg \"Clicked Down\") :Style {:text_style \"Small\"}))\n        :Initial (float 120) :AtLeast (float 100) :AtMost (float 160)}]\n      :Builder\n      [(-&gt; .index (ToString) (UI.Label))\n       (-&gt; (Take \"Surname\") (UI.Label))\n       (-&gt; (Take \"Name\") (UI.Label))]))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/UI/TextField/","title":"UI.TextField","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value is ignored. <code>&lt;output&gt;</code> The value produced when changed. <code>Any</code> <code>Variable</code> The variable that holds the input value. <code>none</code> <code>String</code><code>Var(String)</code> <code>JustifyWidth</code> Whether to take up all available space for its desired width. Takes priority over Desired Width. <code>false</code> <code>Bool</code> <code>DesiredWidth</code> The desired width of the text field. <code>none</code> <code>Float</code><code>Var(Float)</code> <code>ClipText</code> Whether to clip the text if it exceeds the width of the text field. Or expand the text field to fit the text. <code>true</code> <code>Bool</code> <code>Multiline</code> Support multiple lines. <code>false</code> <code>Bool</code> <code>Password</code> Support multiple lines. <code>false</code> <code>Bool</code> <code>Hint</code> Hint to show in the text field. <code>none</code> <code>String</code><code>Var(String)</code> <p>A widget where text can be entered.</p>"},{"location":"reference/shards/shards/UI/TextField/#examples","title":"Examples","text":"CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.CentralPanel\n    (-&gt;\n     (Setup \"Lorem ipsum dolor sit amet\" &gt;= .text)\n     (UI.TextField :Variable .text :Multiline false))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre> CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.CentralPanel\n    (-&gt;\n       ;; read-only\n     (UI.TextField \"Lorem ipsum dolor sit amet\"))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre> CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.CentralPanel\n    (-&gt;\n     ;; exposing a new variable\n     (UI.TextField .text))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/UI/Tooltip/","title":"UI.Tooltip","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value that will be passed to both the Contents and OnHover shards of the tooltip. <code>Any</code> <code>&lt;output&gt;</code> The output of this shard will be its input. <code>Any</code> <code>Contents</code> The UI contents. <code>none</code> <code>Shard</code><code>[Shard]</code> <code>OnHover</code> The tooltip contents. <code>none</code> <code>String</code><code>Var(String)</code><code>Shard</code><code>[Shard]</code> <p>Display a tooltip when the Contents is hovered over.</p>"},{"location":"reference/shards/shards/UI/Tooltip/#examples","title":"Examples","text":"CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.CentralPanel\n    (UI.Tooltip\n     :Contents\n     (-&gt;\n      \"Lorem ipsum\" (UI.Label))\n     :OnHover\n     (-&gt;\n      \"Tooltip\" (UI.Label)))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/UI/TopPanel/","title":"UI.TopPanel","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value that will be passed to the Contents shards of the panel. <code>Any</code> <code>&lt;output&gt;</code> The output of this shard will be its input. <code>Any</code> <code>Resizable</code> Whether the panel can be resized. <code>false</code> <code>Bool</code> <code>DefaultSize</code> The initial size of the panel. <code>none</code> <code>Float</code> <code>MinSize</code> The minimum allowable size of the panel. <code>none</code> <code>Float</code> <code>MaxSize</code> The maximum allowable size of the panel. <code>none</code> <code>Float</code> <code>Contents</code> The UI contents. <code>none</code> <code>Shard</code><code>[Shard]</code> <p>Layout UI elements into the panel.</p>"},{"location":"reference/shards/shards/UI/TopPanel/#examples","title":"Examples","text":"CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.TopPanel\n    :Contents\n    (-&gt;\n     \"Top Panel\" (UI.Label))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/UI/Variable/","title":"UI.Variable","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value is ignored. <code>Any</code> <code>&lt;output&gt;</code> The output of this shard will be its input passed through unchanged. <code>Any</code> <code>Variable</code> The variable that holds the value. <code>none</code> <code>Var(Any)</code> <code>Labeled</code> If the name of the variable should be visible as a label. <code>none</code> <code>Bool</code> <p>This shard creates a UI element that displays and allows interaction with the variable specified in the Variable parameter.</p>"},{"location":"reference/shards/shards/UI/Variable/#examples","title":"Examples","text":"CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (Setup\n   (float4 -1 0 0 1) &gt;= .my-var)\n  (UI\n   (UI.CentralPanel\n    (UI.Variable .my-var)))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/UI/Vertical/","title":"UI.Vertical","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value that will be passed to the Contents shards of the layout. <code>Any</code> <code>&lt;output&gt;</code> The output of this shard will be its input. <code>Any</code> <code>Contents</code> The UI contents. <code>none</code> <code>Shard</code><code>[Shard]</code> <code>Centered</code> Center the contents horizontally. <code>false</code> <code>Bool</code> <p>Layout the contents vertically.</p>"},{"location":"reference/shards/shards/UI/Vertical/#examples","title":"Examples","text":"CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.CentralPanel\n    (UI.Vertical\n     :Contents\n     (-&gt;\n      \"Hello\" (UI.Label)\n      (UI.Separator)\n      \"World\" (UI.Label)))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre> CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  .ui-draw-queue (GFX.ClearQueue)\n\n  (UI\n   (UI.CentralPanel\n    (UI.Vertical\n     :Centered true\n     :Contents\n     (-&gt;\n      \"Hello\" (UI.Label)\n      (UI.Separator)\n      \"World\" (UI.Label)))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/UI/WidgetStyle/","title":"UI.WidgetStyle","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Any</code> <code>&lt;output&gt;</code> <code>Any</code> <code>NonInteractive</code> The style of a widget that you cannot interact with. <code>none</code> <code>{Any}</code><code>Var({Any})</code> <code>Inactive</code> The style of an interactive widget, such as a button, at rest. <code>none</code> <code>{Any}</code><code>Var({Any})</code> <code>Hovered</code> The style of an interactive widget while you hover it, or when it is highlighted. <code>none</code> <code>{Any}</code><code>Var({Any})</code> <code>Active</code> The style of an interactive widget as you are clicking or dragging it. <code>none</code> <code>{Any}</code><code>Var({Any})</code> <code>Open</code> The style of a button that has an open menu beneath it (e.g. a combo-box) <code>none</code> <code>{Any}</code><code>Var({Any})</code> <p>Apply style changes to the current UI scope.</p> <p> </p>"},{"location":"reference/shards/shards/UI/Window/","title":"UI.Window","text":"Name - Description Default Type <code>&lt;input&gt;</code> The value that will be passed to the Contents shards of the rendered window. <code>Any</code> <code>&lt;output&gt;</code> The output of this shard will be its input. <code>Any</code> <code>Title</code> The window title displayed on the title bar. <code>none</code> <code>String</code><code>Var(String)</code> <code>Contents</code> The UI contents. <code>none</code> <code>Shard</code><code>[Shard]</code> <code>Position</code> Absolute position; or when anchor is set, relative offset. <code>none</code> <code>Float2</code><code>Var(Float2)</code> <code>Anchor</code> Corner or center of the screen. <code>none</code> <code>Anchor</code> <code>MinWidth</code> The minimum width of the window. <code>none</code> <code>Float</code><code>Var(Float)</code> <code>MinHeight</code> The minimum height of the window. <code>none</code> <code>Float</code><code>Var(Float)</code> <code>MaxWidth</code> The maximum width of the window. <code>none</code> <code>Float</code><code>Var(Float)</code> <code>MaxHeight</code> The maximum height of the window. <code>none</code> <code>Float</code><code>Var(Float)</code> <code>FixedWidth</code> The fixed size of the window. overrides all other min/max sizes. <code>none</code> <code>Float</code><code>Var(Float)</code> <code>FixedHeight</code> The fixed size of the window. overrides all other min/max sizes. <code>none</code> <code>Float</code><code>Var(Float)</code> <code>Closed</code> When provided with a callback, this window will have a close button and call this when pressed. <code>none</code> <code>Shard</code><code>[Shard]</code> <code>Flags</code> Window flags. <code>none</code> <code>WindowFlags</code><code>[WindowFlags]</code> <code>ID</code> An optional ID value to make the window unique if the title name collides. <code>none</code> <code>String</code><code>Var(String)</code> <code>Transparency</code> If not None, it sets the window's transparency level based on the alpha value. <code>false</code> <code>Float</code> <p>Creates a floating window which can be dragged, closed, collapsed, and resized.</p>"},{"location":"reference/shards/shards/UI/Window/#examples","title":"Examples","text":"CodeOutput <pre><code>(GFX.MainWindow\n :Contents\n (-&gt;\n  (Setup\n   (GFX.DrawQueue) &gt;= .ui-draw-queue\n   (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n  (UI\n   (UI.Window\n    :Title \"Greetings\" :Flags WindowFlags.NoCollapse\n    :Contents\n    (-&gt;\n     \"Hello shards!\" (UI.Label))))\n\n  (GFX.Render :Steps .render-steps)))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"reference/shards/shards/UUID/Convert/","title":"UUID.Convert","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Bytes</code><code>String</code> <code>&lt;output&gt;</code> <code>Int16</code> <p>Outputs a UUID (Universally Unique Identifier) as Int16.</p> <p> </p>"},{"location":"reference/shards/shards/UUID/ToBytes/","title":"UUID.ToBytes","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Int16</code> <code>&lt;output&gt;</code> <code>Bytes</code> <p>Reads an UUID and formats it into bytes.</p> <p> </p>"},{"location":"reference/shards/shards/UUID/ToString/","title":"UUID.ToString","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Int16</code> <code>&lt;output&gt;</code> <code>String</code> <code>Hyphenated</code> Whether to use hyphens in the output. <code>false</code> <code>Bool</code> <p>Reads an UUID and formats it into a readable string.</p> <p> </p>"},{"location":"reference/shards/shards/Wasm/Run/","title":"Wasm.Run","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>String</code> <code>&lt;output&gt;</code> <code>String</code> <code>Module</code> The wasm module to run. <code>\"\"</code> <code>Path</code><code>String</code> <code>Arguments</code> The arguments to pass to the module entrypoint function. <code>none</code> <code>[String]</code><code>Var([String])</code> <code>EntryPoint</code> The entry point function to call when activating. <code>\"_start\"</code> <code>String</code> <code>StackSize</code> The stack size in kilobytes to use. <code>1024</code> <code>Int</code> <code>ResetRuntime</code> If the runtime should be reset every activation, altho slow this might be useful if certain modules fail to execute properly or leak on multiple activations. <code>true</code> <code>Bool</code> <code>CallConstructors</code> Use if it might be necessary to force a call to <code>__wasm_call_dtors</code>, modules generated with WASI rust might need this. <code>false</code> <code>Bool</code>"},{"location":"reference/shards/shards/Yaml/FromJson/","title":"Yaml.FromJson","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>String</code> <code>&lt;output&gt;</code> <code>String</code> <p>A shard that converts JSON to YAML.</p> <p> </p>"},{"location":"reference/shards/shards/Yaml/ToJson/","title":"Yaml.ToJson","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>String</code> <code>&lt;output&gt;</code> <code>String</code> <p>A shard that converts YAML to JSON.</p> <p> </p>"},{"location":"reference/shards/shards/_Callgrind/Start/","title":"_Callgrind.Start","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input can be of any type. <code>Any</code> <code>&lt;output&gt;</code> The output will be the input (passthrough). <code>Any</code>"},{"location":"reference/shards/shards/_Callgrind/Stop/","title":"_Callgrind.Stop","text":"Name - Description Default Type <code>&lt;input&gt;</code> The input can be of any type. <code>Any</code> <code>&lt;output&gt;</code> The output will be the input (passthrough). <code>Any</code>"},{"location":"reference/shards/shards/_Inputs/DiscardTempFiles/","title":"_Inputs.DiscardTempFiles","text":"Name - Description Default Type <code>&lt;input&gt;</code> <code>Any</code> <code>&lt;output&gt;</code> <code>Any</code> <p>Discard temporary files created by open &amp; drag-drop operations</p> <p> </p>"}]}