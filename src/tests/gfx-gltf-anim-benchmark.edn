(def timestep (/ 1.0 120.0))
(defmesh root)

(defshards get-view-transform [time]
  (Float4 0.0 1.0 -5.0 1.0) >= .arm-pos
  time (Math.AxisAngleY) (Math.Rotation) (Math.MatMul .arm-pos) (ToFloat3) >= .arm-pos-3
  {:Position .arm-pos-3 :Target (Float3 0 0.025 0)} (Math.LookAt))

(defloop character
  (Take "Position") = .position
  .position (Math.Translation)
  (GFX.glTF :Copy .gltf-template
            :AnimationController
            (->
             (| (Setup
                 (ForEach (-> (Take 0) >> .animation-names))
                 .animation-names
                 (RandomFloat 5.0) = .animation-offset)
                .animation-names (Take .animation-index) >= .animation-name)
             (Take .animation-name) = .animation

             (Animation.Timer .animation :Rate 1.3 :Offset .animation-offset
                              :Action (->
                                       (Count .animation-names) >= .num-animations
                                       (Math.Inc .animation-index)
                                       .animation-index (Math.Mod .num-animations) > .animation-index))
             (Animation.Play .animation);
             ))(GFX.Draw .queue))

(defwire spawn-benchmark
  (Log "Spawning models")
  16 >= .num-x (ToFloat) (Math.Divide 2.0) >= .sub-x
  16 >= .num-y (ToFloat) (Math.Divide 2.0) >= .sub-y

  (ForRange 1 .num-y
            (->
             (ToFloat) (Math.Subtract .sub-y) >= .y
             (ForRange 1 .num-x
                       (->
                        (ToFloat) (Math.Subtract .sub-x) >= .x
                        (Float3 .x 0.0 .y) >= .position
                        {:Position .position} (Spawn character))))))

(defshards lighting-feature []
  (Float3 -0.2 -2 -1) (Math.Normalize) = .light-direction
  (Float3 1 1 1) (Math.Multiply 0.5) = .light-color
  {:Shaders [{:Name "lighting"
              :Stage ProgrammableGraphicsStage.Fragment
              :EntryPoint (->
                           (Shader.ReadInput :Name "worldNormal") >= .normal
                           (Shader.ReadBuffer :Name "lightDirection") >= .light-dir
                           (Float3 0 0 0) (Math.Subtract .light-dir) >= .inv-light-dir
                           .normal (Math.Normalize) (Math.Dot .inv-light-dir) (Max 0.0) >= .n-dot-l
                           (Shader.ReadBuffer :Name "lightColor") (Math.Multiply .n-dot-l)
                           (Shader.WriteGlobal "lighting"))}
             {:Name "mainColor"
              :Stage ProgrammableGraphicsStage.Fragment
              :EntryPoint (->
                           (Shader.ReadGlobal "lighting") (ToFloat4) >= .lighting-4
                           (Shader.ReadGlobal "color") (Math.Add .lighting-4)
                           (Shader.WriteGlobal "color"))
              :After ["readColor"]
              :Before ["writeColor"]}]
   :Params {:lightDirection {:Default .light-direction}
            :lightColor {:Default .light-color}}}
  (GFX.Feature))

(defloop test-basic-anim
  (Setup
   (Float3 0 0 0) (Math.Translation) >= .t1

   "" >> .animation-names
   (Clear .animation-names)
   1 >= .animation-index

   (GFX.DrawQueue) >= .queue

   (Math.MatIdentity) (GFX.glTF :Path "data/mascot.glb") = .gltf-template

   ;; Render steps
   (GFX.BuiltinFeature :Id BuiltinFeatureId.Transform) >> .features
   (GFX.BuiltinFeature :Id BuiltinFeatureId.BaseColor) >> .features
   (lighting-feature) >> .features
   {:Features .features :Queue .queue} (GFX.DrawablePass) >> .render-steps

   ;; Create view
   (get-view-transform 0.0) >= .view-transform
   (GFX.View :View .view-transform) >= .view)

  (GFX.MainWindow
   :Title "glTF" :Width 1280 :Height 720 :Debug false
   :Contents
   (->
    (Animation.Timer :Rate 0.2 :Offset -0.75) >= .time
    (get-view-transform .time) > .view-transform
    .queue (GFX.ClearQueue)
    (Branch [spawn-benchmark])

    (GFX.Render :Steps .render-steps :View .view))))
(schedule root test-basic-anim)
(if (run root timestep 400) nil (throw "Root tick failed"))
