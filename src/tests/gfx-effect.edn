(def timestep (/ 1.0 120.0))

(defshards spin-transform [t location]
  t
  (| (Math.Multiply 0.2) (Math.AxisAngleX) (Math.Rotation) >= .rotX)
  (| (Math.Multiply 0.7) (Math.AxisAngleY) (Math.Rotation) >= .rotY)
  (| (Math.Multiply 0.9) (Math.AxisAngleZ) (Math.Rotation) >= .rotZ)
  location (Math.Translation) (Math.MatMul .rotX) (Math.MatMul .rotY) (Math.MatMul .rotZ))

(defloop gfx
  (Setup
   0.0 >= .time

   (GFX.BuiltinMesh :Type BuiltinMeshType.Cube) >= .mesh
   (Float3 0 0 0) (Math.Translation) >= .transform-0
   {:Mesh .mesh :Params {:baseColor (Float4 1 1 1 1)}} (GFX.Drawable :Transform .transform-0) >> .drawables

   ; The first pass that just renders the spinning cube
   (GFX.BuiltinFeature BuiltinFeatureId.Transform) >> .features
   (GFX.BuiltinFeature  BuiltinFeatureId.BaseColor) >> .features
   {:Features .features} (GFX.DrawablePass) >> .render-steps1

   ; The effect pass that modifies the rendered cube image
   ; It also uses the depth buffer from the rendered cube
   {;
    ; This indicates that the outputs from previous passes named "color" & "depth" are used within the pass
    ; EffectPass will automatically expose them as shader bindings
    :Inputs ["color" "depth"]
    :EntryPoint (-> ; Begin shader
                 ; Texture coordinates are named texCoord0/1/2/etc. by convention
                 (Shader.ReadInput "texCoord0" :Dimension 2) >= .uv
                 .uv (Take 0) >= .u
                 .uv (Take 1) >= .v

                 ; Manipulate coordinates
                 .v (Math.Multiply 300.0) (Math.Cos) (Math.Multiply 0.001) (Math.Add .u) > .u
                 (MakeFloat2 .u .v) (Math.Multiply 2.0) (Math.FMod (Float2 1.0 1.0)) > .uv

                 ; Sample the previous pass color output
                 .uv (Shader.SampleTextureUV "color") (ToFloat4) >= .color

                 ; Sample the previous pass depth output
                 ; Linearize and scale the result to display it, since depth is stored as normalized 1/z 
                 .uv (Shader.SampleTextureUV "depth") (Take [0])
                 (Shader.LinearizeDepth) (Math.Subtract 6.0) (Math.Divide 4.0) >= .depth

                 ; Write output to "color"
                 (MakeFloat4 .depth .depth 1.0 1.0) (Math.Multiply .color)
                 (Shader.WriteOutput "color")
                 ; End shader
                 )}(GFX.EffectPass) >> .render-steps1

   {:Position (Float3 0 0 8) :Target (Float3 0 0 0)} (Math.LookAt) >= .view-transform
   (GFX.View :View .view-transform) >= .view)

  .view-transform (FreeCamera) > .view-transform

  .time (Math.Add timestep) > .time
  (spin-transform .time (Float3 0.0 0 0)) > .transform-0

  .drawables (GFX.Draw)
  (GFX.Render :Steps .render-steps1 :View .view))

(defmesh root)
(schedule root (Wire "test-wire" :Looped :LStack
                     (GFX.MainWindow :Title "SDL Window" :Width 1280 :Height 720 :Debug false :Contents
                                     (Step gfx))))
(run root timestep 100)
