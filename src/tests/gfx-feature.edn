(def timestep (/ 1.0 120.0))
(defmesh root)
(def BlendAdd {:Operation BlendOperation.Add :Src BlendFactor.One :Dst BlendFactor.One})
(def BlendAlpha {:Operation BlendOperation.Add :Src BlendFactor.SrcAlpha :Dst BlendFactor.OneMinusSrcAlpha})
(def BlendOne {:Operation BlendOperation.Add :Src BlendFactor.One :Dst BlendFactor.One})

(defshards spin-transform [t location]
  t
  (| (Math.Multiply 0.2) (Math.AxisAngleX) (Math.Rotation) >= .rotX)
  (| (Math.Multiply 0.7) (Math.AxisAngleY) (Math.Rotation) >= .rotY)
  (| (Math.Multiply 0.9) (Math.AxisAngleZ) (Math.Rotation) >= .rotZ)
  location (Math.Translation) (Math.MatMul .rotX) (Math.MatMul .rotY) (Math.MatMul .rotZ))

(defloop test-wire
  (Setup
   0.0 >= .time
   (GFX.BuiltinMesh :Type BuiltinMeshType.Cube) >= .mesh
   (Float3 -1 0 0) (Math.Translation) >= .transform-0
   (Float3 1 0 0) (Math.Translation) >= .transform-1
   (Float3 0 0 -1) (Math.Normalize) >= .light-direction

   0.0 >= .time
   .time (Broadcast "time")

    ; Create render steps
   (GFX.BuiltinFeature BuiltinFeatureId.Transform) >> .features
   {:Shaders [{:Name "lighting"
               :Stage ProgrammableGraphicsStage.Fragment
               :EntryPoint (->
                            (Shader.ReadInput :Name "worldNormal") >= .normal
                            (Shader.ReadBuffer :Name "lightDirection") >= .light-dir
                            (Float3 0 0 0) (Math.Subtract .light-dir) >= .inv-light-dir
                            .normal (Math.Normalize) (Math.Dot .inv-light-dir) (Max 0.0) >= .n-dot-l
                            (Shader.ReadBuffer :Name "lightColor") (Math.Multiply .n-dot-l)
                            (Shader.WriteGlobal "lighting"))}
              {:Name "mainColor"
               :Stage ProgrammableGraphicsStage.Fragment
               :EntryPoint (->
                            (Shader.ReadBuffer :Name "time" :BufferName "view") >= .time
                            .time (Math.Multiply 2.0) (Math.Cos) (Math.Divide 2.0) (Math.Add 0.5) >= .wave
                            (Shader.ReadGlobal :Name "lighting") (ToFloat4) >= .lighting-4
                            .wave (Math.Multiply (Float4 0 0 0 1)) (Math.Add .lighting-4)
                            (Shader.WriteOutput "color"))}]
    :Params {:lightDirection .light-direction
             :lightColor (Float3 1.0)}
    :State {:DepthCompare CompareFunction.Less
            :Blend {:Color BlendAlpha :Alpha BlendOne}}}
   (GFX.Feature :ViewGenerators
                (->
                 (Listen "time") >= .time
                 {:time .time})) >> .features
   (GFX.DrawQueue) >= .queue
   {:Features .features :Queue .queue} (GFX.DrawablePass) >> .render-steps

    ;; Create view
   {:Position (Float3 0 0 8) :Target (Float3 0 0 0)} (Math.LookAt) >= .view-transform
   (GFX.View :View .view-transform) >= .view)
  (GFX.MainWindow
   :Title "SDL Window" :Width 1280 :Height 720 :Debug false
   :Contents
   (->
    .time (Math.Add timestep) > .time
    .time (Broadcast "time")

    (spin-transform .time (Float3 -0.6 0 0))
    (GFX.Drawable :Mesh .mesh) (GFX.Draw .queue)

    (spin-transform (-> .time (Math.Multiply 0.5)) (Float3 0.6 0 0))
    (GFX.Drawable :Mesh .mesh) (GFX.Draw .queue)

    (GFX.Render :Steps .render-steps :View .view))))

(schedule root test-wire)
(if (run root timestep) nil (throw "Root tick failed"))
